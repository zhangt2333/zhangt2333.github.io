<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>计算机视觉-学习笔记 - Zhang T&#39;s Blog</title><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-212316117-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-212316117-1")</script><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/">TTTT&#39;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i> </a><a class="navbar-item" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-image"><span class="image is-7by1"><img class="thumbnail" src="/thumbnails/Computer-Vision-Study-Notes.png" alt="计算机视觉-学习笔记"></span></div><div class="card-content article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>计算机视觉-学习笔记</h1><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2019-09-05T13:00:00.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-09-05</time> <time class="level-item has-text-grey is-hidden-mobile" datetime="2022-01-05T12:15:22.453Z"><i class="far fa-calendar-check">&nbsp;</i>2022-01-05</time><div class="level-item"><i class="far fa-folder-open has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/categories/CS/">CS</a></div><span class="level-item has-text-grey"><i class="far fa-clock"></i>&nbsp; 29 分钟 读完 (大约 4414 个字) </span><span class="level-item has-text-grey" id="busuanzi_container_page_pv"><i class="far fa-eye"></i> <span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p><code>自学笔记，单词翻译可能出错</code></p><h2 id="第-1-章-绪论"><a href="#第-1-章-绪论" class="headerlink" title="第 1 章 绪论"></a>第 1 章 绪论</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>图像：对客观世界视觉属性的描述</p><p>视觉：图像获取、基于图像的感知</p><p>计算机视觉的目标：让机器“理解”图像和视频</p><a id="more"></a><h3 id="计算机视觉的应用"><a href="#计算机视觉的应用" class="headerlink" title="计算机视觉的应用"></a>计算机视觉的应用</h3><ul><li>智能监控</li><li>无人车</li><li>医学影像分析</li><li>机器人（定位、导航）</li><li>增强/混合现实</li><li>图像检索</li><li>智能图像管理/编辑</li><li>刷脸</li><li>面孔和数码相机，笑容检测</li><li>图像拼接</li><li>体感游戏</li><li>视觉特效</li></ul><h3 id="计算机视觉的难点-挑战"><a href="#计算机视觉的难点-挑战" class="headerlink" title="计算机视觉的难点/挑战"></a>计算机视觉的难点/挑战</h3><ul><li>光照 Illumination</li><li>物体姿势 Object pose</li><li>噪声 Clutter</li><li>遮蔽 Occlusions</li><li>外观识别 Intra-class appearance</li><li>视点 Viewpoint</li><li>类内差异 Intra-Category Variation，比如沙发有很多种</li><li>复杂度 Complexity</li></ul><h3 id="成像"><a href="#成像" class="headerlink" title="成像"></a>成像</h3><p>人眼的成像：</p><ul><li>物体在视网膜上的成像为倒影、视网膜位于球面上</li><li>人眼对光线有很强的环境适应能力</li><li>人眼对亮度的感受与光线强度成对数关系</li><li>马赫带</li><li>人对亮度的感觉：亮度的相对性</li><li>对比引起的相对性</li><li>前景与背景的相对性</li><li>整体性：主观轮廓</li></ul><p>图像获取方式的变化 Camera Obscura：</p><ul><li>暗箱，点投影</li><li>绘画</li><li>针孔相机 Pinhole Camera</li></ul><p>相机：</p><ul><li>光圈 Aperture，或者说孔径 Pinhole Size：进光量</li><li>镜头作用：保持图像清晰对焦，同时收集大面积的光线</li><li>薄透镜：</li><li>景深：可以容忍模糊的图像平面之间的距离</li><li>视野：取决于焦距</li></ul><p>数字相片：</p><ul><li>底片被传感器阵列替代</li><li>电荷耦合器件阵列 (Charge-Coupled device，CCD)</li><li>图片离散成像素</li><li>光强量化为像素值</li><li>颜色传感器：将进光用不同的过滤层转换为传感阵列，ceil 的颜色缺失可从相邻 ceil 中获取</li></ul><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>图像 -&gt; 采样 -&gt; 量化：</p><ul><li><p>采样</p><ul><li>分辨率，采样间隔</li><li>粗采样 Coarse Sampling</li><li>细采样 Finer Sampling<br><img src="1567929933434.png" alt="1567929933434"></li></ul></li><li><p>量化</p><ul><li><p>信号量化 $K=2^n $<br><img src="1567930024199.png" alt="1567930024199"></p></li><li><p>影响图像灰度<br><img src="1567930104056.png" alt="1567930104056"></p></li></ul></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>文件格式：</p><ul><li><p>矢量图 vector images，<code>.ai .eps .ps ...</code></p><ul><li>优点：缩放无混叠 aliasing 和 模糊 blur</li><li>缺点：难以获取，应用有限</li></ul></li><li><p>位图 bitmap <code>.bmp .jpg .pmg .gif</code></p><ul><li><p>存储像素色彩。优缺点与矢量图相反。将矢量图进行光栅化 rasterize 可得到位图<br><img src="1567932299904.png" alt="1567932299904"></p></li><li><p>GIF —— Graphics Interchange Format</p><ul><li>8 位真彩</li><li>可进行融色 dither</li><li>优点：生动 animated、易懂 transparent</li></ul></li><li><p>JPEG —— Joint Photographic Experts Group</p><ul><li>16 bit，一次性不融色 dither 地展示上百万像素</li><li>约 60% 的压缩比是质量与文件大小的合适比例<br><img src="1567932310616.png" alt="1567932310616"></li></ul></li><li><p>PNG —— Portable Network Graphics</p><ul><li>基于 ZIP 的无损压缩</li><li>4-channel image，4通道图，第4个参数控制透明</li></ul></li><li><p>BMP —— Windows Bitmap</p><ul><li>简单、未压缩 uncompressed</li><li>设备独立位图 Device Independent Bitmap, DIB，设备依赖位图 Device Dependent Bitmap, DDB</li></ul></li><li><p>位图的存储结构：<br><img src="1567932598246.png" alt="1567932598246"></p><ul><li><p>size (resolution, dpi, width*height, numOfPixels)</p></li><li><p>Color Space (RGB, CMYK, YUV, Lab, …)</p></li><li><p>Channels (1,2,3,4, gray&amp;color)，通道</p></li><li><p>Depth (8bits, 12bits, …, LDR&amp;HDR)</p></li><li><p>Coordinate system<br><img src="1567932705517.png" alt="1567932705517"></p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyImage</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> width, height;</span><br><span class="line">    <span class="hljs-keyword">int</span> type; <span class="hljs-comment">// 类型(通道数、位深度)</span></span><br><span class="line">    <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">    CV_8UC3: unsigned char[3]</span></span><br><span class="line"><span class="hljs-comment">    CV_32SC1: int[1]</span></span><br><span class="line"><span class="hljs-comment">    CV_32UC1: uint[1]</span></span><br><span class="line"><span class="hljs-comment">    CV_32FC4: float[4]</span></span><br><span class="line"><span class="hljs-comment">    */</span></span><br><span class="line">    <span class="hljs-keyword">void</span>* data; <span class="hljs-comment">// 图像数据</span></span><br><span class="line">    <span class="hljs-keyword">int</span> step;   <span class="hljs-comment">// 步长 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span>* <span class="hljs-title">getPixel</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyImage &amp;img, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123; <span class="hljs-comment">// img.type=CV_32SC3:  32位带符号，3通道数据</span></span><br><span class="line">    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>*)((<span class="hljs-keyword">char</span>*)img.data+y*img.step+x*<span class="hljs-number">3</span>*<span class="hljs-number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scanPixels</span><span class="hljs-params">(uchar *data, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> step, <span class="hljs-keyword">int</span> nc)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123; <span class="hljs-comment">// step步长 nc通道数numOfChannel</span></span><br><span class="line">    uchar *row=data;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> yi=<span class="hljs-number">0</span>; yi&lt;height; yi++, row+=step)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar *px=row;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> xi=<span class="hljs-number">0</span>; xi&lt;width; xi++, px+=nc)</span><br><span class="line">        	<span class="hljs-comment">// px now address the pixel (xi,yi)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scan_roi_pixels</span><span class="hljs-params">(MyImage &amp;img, <span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, <span class="hljs-keyword">int</span> roi_width, <span class="hljs-keyword">int</span> roi_height)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 通道数nc=img.nc();</span></span><br><span class="line">    scan_pixels( get_pixel(img, x, y),  roi_width, roi_height, img.step, img.nc());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="第-2-章-图像处理"><a href="#第-2-章-图像处理" class="headerlink" title="第 2 章 图像处理"></a>第 2 章 图像处理</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>像素描述 <code>(x, y, R, G, B)</code>：</p><ul><li>空间坐标 Spatial coordinate —— x, y</li><li>像素颜色 —— RGB, YUV, …</li></ul><p>基本图像处理：</p><ul><li>基于空间坐标 —— 几何变换（CG 课程中有所关注）</li><li>基于像素颜色 —— 代数运算（CV 中着重）</li></ul><h3 id="代数运算"><a href="#代数运算" class="headerlink" title="代数运算"></a>代数运算</h3><h4 id="像素灰度变换"><a href="#像素灰度变换" class="headerlink" title="像素灰度变换"></a>像素灰度变换</h4><ul><li><p>灰度变换 Gray Level Transformation，通过代数运算</p></li><li><p>最简单的图像处理任务</p></li><li><p>逐个像素转换：亮度 Intensity、对比度 Contrast</p></li></ul><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 逐个像素扫描处理的通用过程 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">scanPixels</span><span class="hljs-params">(uchar *data, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> step, <span class="hljs-keyword">int</span> nc)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123; <span class="hljs-comment">// step步长 nc通道数numOfChannel</span></span><br><span class="line">    uchar *row=data;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> yi=<span class="hljs-number">0</span>; yi&lt;height; yi++, row+=step)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar *px=row;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> xi=<span class="hljs-number">0</span>; xi&lt;width; xi++, px+=nc)</span><br><span class="line">        	<span class="hljs-comment">// px now address the pixel (xi,yi)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 灰度处理 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">grayTransform</span><span class="hljs-params">(uchar *data, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> step, <span class="hljs-keyword">const</span> uchar T[<span class="hljs-number">256</span>])</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    uchar *row=data;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> yi=<span class="hljs-number">0</span>; yi&lt;height; ++yi, row+=step)</span><br><span class="line">    &#123;</span><br><span class="line">        uchar *px=row;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> xi=<span class="hljs-number">0</span>; xi&lt;width; ++xi, px++)</span><br><span class="line">            *px = Transform(*px);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="亮度调整函数"><a href="#亮度调整函数" class="headerlink" title="亮度调整函数"></a>亮度调整函数</h5><ul><li>亮度调整：整体变亮或变暗</li></ul><p><img src="1567942133518.png" alt="1567942133518"></p><ul><li>线性函数</li></ul><p><img src="1567941380554.png" alt="1567941380554"></p><ul><li>非线性函数<br><img src="1567941418454.png" alt="1567941418454"><ul><li>log 函数 $s = c·log(1+r)$</li><li>幂次函数 $s = c·r^\gamma $</li></ul></li></ul><p><img src="1567941744801.png" alt="1567941744801"></p><p><img src="1567941808279.png" alt="1567941808279"></p><ul><li>伽马矫正<ul><li>对图像的伽马曲线进行编辑，图像进行非线性色调编辑的方法,检出图像信号中的深色部分和浅色部分，并使两者比例增大，从而提高图像对比度效果</li></ul></li></ul><p><img src="1567942037668.png" alt="1567942037668"></p><h5 id="对比度调整函数"><a href="#对比度调整函数" class="headerlink" title="对比度调整函数"></a>对比度调整函数</h5><p>对比度调整：亮的更亮，暗的更暗</p><p><img src="1567942163355.png" alt="1567942163355"></p><p><img src="1567942259148.png" alt="1567942259148"></p><ul><li>增加图像处理中被处理的灰度等级范围</li></ul><p><img src="1567942410847.png" alt="1567942410847"></p><ul><li>分层量化 Quantize、固定阈值二值化 Threshold</li></ul><p><img src="1567942533313.png" alt="1567942533313"></p><ul><li>分段线性 Piecewise</li></ul><p><img src="1567942728010.png" alt="1567942728010"></p><ul><li>Sigmoid 函数<ul><li>优美 S 形曲线的数学函数，连续，光滑，严格单调，以(0,0.5)中心对称，是一个非常良好的阈值函数</li></ul></li></ul><p><img src="1567942920789.png" alt="1567942920789"></p><h4 id="多图像处理"><a href="#多图像处理" class="headerlink" title="多图像处理"></a>多图像处理</h4><p>输入多幅大小相同的图像，基于对应像素进行计算，输出图像。</p><p>$O(x, y) = f[I^1(x,y), I^2(x,y), \cdots , I^N(x,y)] $</p><ul><li>Multiply</li></ul><p><img src="1567943284160.png" alt="1567943284160"></p><ul><li>XOR</li></ul><p><img src="1567943335793.png" alt="1567943335793"></p><ul><li>OR</li></ul><p><img src="1567943373629.png" alt="1567943373629"></p><ul><li><p>Alpha Blending，阿尔法混合</p><ul><li>$C = \alpha F + (1-\alpha) B$<br><img src="1567943476132.png" alt="1567943476132"></li><li>给定 C，如何分离 $\alpha、F、B $ 。C 去掉 B 的纯色得到 $\alpha$</li></ul></li><li><p>Image Matting (masking, 抠图)</p><ul><li><p>从图像中提取特殊的物体或区域，得到 alpha map</p></li><li><p>对于细微区域或头发等物体的抠图需要解决</p></li></ul></li><li><p>前景恢复 foreground restoration</p><p><img src="1567943849071.png" alt="1567943849071"></p></li><li><p>背景相减</p><ul><li>当前帧 $I(x, y)=(r,g,b)$，背景 $B(x,y) = (r,g,b) $，阈值 $T $</li><li>$Diff(x, y) = ||I(x,y)-B(x,y)||^2 ，当 Diff(x,y)&gt;T 则认为是前景$</li></ul></li></ul><p><img src="1567944111315.png" alt="1567944111315"></p><h3 id="几何处理"><a href="#几何处理" class="headerlink" title="几何处理"></a>几何处理</h3><ul><li>翻转 flip</li><li>缩放 resize / zoom in / zoom out / scale</li><li>旋转 rotation</li><li>仿射变换 Affine Transform</li><li>透视变换 Perspective Transform</li><li>图形变形 Image Warping</li></ul><h4 id="翻转"><a href="#翻转" class="headerlink" title="翻转"></a>翻转</h4><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">vflip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *in, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> istep,  <span class="hljs-keyword">int</span> pix_size, <span class="hljs-keyword">void</span> *out, <span class="hljs-keyword">int</span> ostep)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 竖直翻转</span></span><br><span class="line">    out = (<span class="hljs-keyword">char</span>*)out+(height<span class="hljs-number">-1</span>)*ostep;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> yi=<span class="hljs-number">0</span>; yi&lt;height; ++yi, in=(<span class="hljs-keyword">char</span>*)in+istep, out=(<span class="hljs-keyword">char</span>*)out-ostep)&#123;</span><br><span class="line">        <span class="hljs-built_in">memcpy</span>(out, in, width*pix_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">hflip</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *in, <span class="hljs-keyword">int</span> width, <span class="hljs-keyword">int</span> height, <span class="hljs-keyword">int</span> istep, <span class="hljs-keyword">int</span> pix_size, <span class="hljs-keyword">void</span> *out, <span class="hljs-keyword">int</span> ostep)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 水平翻转 / 镜像翻转</span></span><br><span class="line">    <span class="hljs-keyword">char</span> * _in=(<span class="hljs-keyword">char</span>*)in;</span><br><span class="line">    <span class="hljs-keyword">char</span> *_out=(<span class="hljs-keyword">char</span>*)out+(width<span class="hljs-number">-1</span>)*pix_size;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> yi=<span class="hljs-number">0</span>; yi&lt;height; ++yi, _in+=istep, _out+=ostep)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">char</span> *in_x=_in, <span class="hljs-keyword">char</span> *out_x=_out;</span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> xi=<span class="hljs-number">0</span>; xi&lt;width; ++xi, in_x+=px_size, out_x-=px_size)</span><br><span class="line">            <span class="hljs-built_in">memcpy</span>(out_x, in_x, pix_size) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="放大-Zoom-in"><a href="#放大-Zoom-in" class="headerlink" title="放大 Zoom in"></a>放大 Zoom in</h4><p><img src="1567944827831.png" alt="1567944827831"></p><p>如何填充新增的像素点：</p><ul><li><p>方案 1，投影 projection，对小图中的每个像素，计算其在大图中对应的像素。会遗漏像素<br><img src="1567944935486.png" alt="1567944935486"></p></li><li><p>方案 2，查找 Lookup，对大图中的每个像素，计算其在小图中对应的像素</p></li><li><p>方案 3，重采样 Resampling</p><ul><li><p>基于邻近像素的值，计算非整数位置上的颜色值。有三种策略</p></li><li><p>最近邻 （Nearest Neighbor)<br><img src="1567945144443.png" alt="1567945144443"></p></li><li><p>线性插值 (Bilinear Interpolation)<br><img src="1567945170678.png" alt="1567945170678"></p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">float</span> <span class="hljs-title">bilinear</span><span class="hljs-params">(<span class="hljs-keyword">float</span> a, <span class="hljs-keyword">float</span> b, <span class="hljs-keyword">float</span> c, <span class="hljs-keyword">float</span> d, <span class="hljs-keyword">float</span> dx, <span class="hljs-keyword">float</span> dy)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">float</span>  h1=a+dx*(b-a); <span class="hljs-comment">// =(1-dx)*a+dx*b  </span></span><br><span class="line">    <span class="hljs-keyword">float</span>  h2=c+dx*(d-c); </span><br><span class="line">    <span class="hljs-keyword">return</span> h1+dy*(h2-h1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="1567945304908.png" alt="1567945304908"></p></li><li><p>双三次插值 (Bicubic Interpolation)<br><img src="1567945324611.png" alt="1567945324611"></p><ul><li>怎么解是 $\begin{cases} f(0) = d \ f(1)=a+b+c+d \ f(2) =8a+4b+2c+d \ f(3)=27a+9b+3c+d \end{cases} \Rightarrow [a,b,c,d] $ 吗？ 不是正确解法，等式过多。</li><li>正确解法 $\begin{cases}f(0) = d \ f(1) = a+b+c+d \ y’ = 3ax^2 +2bx + c \ f’(0)=c \ f’(1)=3a+2b+c \end{cases} \Rightarrow [a,b,c,d]$</li><li>补充：离散函数的导数 $f’(x) = \frac{[f(x+1)-f(x)]+[f(x)-f(x-1)]}{2}=\frac{f(x+1)-f(x-1)}{2} $</li></ul></li></ul></li></ul><p><img src="1567948185690.png" alt="1567948185690"></p><p>Super-Resolution (超分辨率)</p><p><code>以下引入 CG 的笔记，有所更改</code></p><h3 id="二维变换原理"><a href="#二维变换原理" class="headerlink" title="二维变换原理"></a>二维变换原理</h3><p>变换：比例、旋转、镜像、错切、平移</p><p>对于一个图形，可用顶点表描述图形的几何关系，用连边表来描述图形的拓扑关系。故对图形的变换，只变换图形的顶点表</p><h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><ul><li>Affine Transformation</li><li>平直性：直线变换后仍是直线</li><li>平行性：平行线变换后仍平行</li><li>二维仿射变换： $\begin{cases} x’ = a_1x+b_1y+c_1 \ y’=a_2x+b_2y+c_2 \end{cases}$</li><li>二维仿射变换，矩阵形式：$\left[ \begin{matrix} x^* &amp; y^* \end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} a_1 &amp; a_2\ b_1 &amp; b_2 \ c_1 &amp; c_2 \end{matrix} \right] $</li></ul><p>特殊的仿射变换：</p><ul><li>刚性变换 Rigid Transformation<ul><li>只包含平移和旋转</li><li>保持物体的形状、尺寸</li><li>相当于正交变换</li></ul></li><li>相似变换 Similar Transformation<ul><li>只包含平移、旋转和等比缩放</li><li>保持物体的形状</li></ul></li></ul><p>仿射变换 Affine Transformation： 在同一平面内部的变换</p><p>视角变换 Perspective Transform： 可表示不同视角观察到的同一平面，或同一视角观察到的不同平面之间的变换</p><h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><ul><li>二维平面中用(x, y)表示一个点，不妨说是一个向量(x, y)表示一个点。所以可以用第3维为常数的(x, y, 1)表示二维平面上的向量</li><li>这种n+1维表示n维的方法称为——齐次坐标表示法，n维向量 $(p_1,p_2,\cdots,p_n)$ 表示为 $(hp_1,hp_2,\cdots,hp_n, h)$，其中 $h $ 称为哑坐标，特别的 h=1 时称齐次坐标为规格化坐标。</li><li>二维仿射变换，齐次坐标表示：$\left[ \begin{matrix} x^* &amp; y^*&amp;1 \end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} a_1 &amp; a_2 &amp;0\ b_1 &amp; b_2&amp;0 \ c_1 &amp; c_2 &amp;1\end{matrix} \right] $</li><li>不使用齐次坐标可以做比例、对称、旋转变换，但做不到平移变化，无法增加常数项。</li></ul><h4 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h4><ul><li>不产生变形而移动物体的<strong>刚体变换</strong>，即物体上的每个点移动相同数量的坐标</li><li>坐标形式：$\begin{cases} x^* = x+T_x \ y^*=y + T_y \end{cases} $</li><li>齐次坐标形式：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} 1 &amp; 0 &amp;0 \0&amp;1&amp;0\T_x&amp;T_y&amp;1 \end{matrix} \right] $</li></ul><h4 id="比例变换"><a href="#比例变换" class="headerlink" title="比例变换"></a>比例变换</h4><ul><li>相对于坐标原点沿x方向放缩$S_x$倍，沿y方向放缩$S_y$倍。S &gt; 1放大，S &lt; 1 缩小。</li><li>坐标形式：$\begin{cases} x^* = x·S_x \ y^*=y·S_y \end{cases} $</li><li>齐次坐标形式：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} S_x &amp; 0 &amp;0 \0&amp;S_y&amp;0\0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x·S_x &amp; y·S_y &amp;1\end{matrix}\right] $</li><li>当 $S_x =S_y $ 时，为整体比例变换，$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} 1 &amp; 0 &amp;0 \0&amp;1&amp;0\0&amp;0&amp;S \end{matrix} \right] =\left[ \begin{matrix} \frac{x}{S} &amp; \frac{y}{S} &amp;1\end{matrix}\right] $，S&gt;1缩小，0&lt;S&lt;1缩小，S&lt;0发生关于原点的对称等比变换</li></ul><h4 id="对称变换"><a href="#对称变换" class="headerlink" title="对称变换"></a>对称变换</h4><ul><li>也称镜像变换。有关于x轴、y轴、原点、某条直线的对称变换</li><li>关于 x 轴对称：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} 1 &amp; 0 &amp;0 \0&amp;-1&amp;0\0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x&amp;-y&amp;1\end{matrix}\right] $</li><li>关于 y 轴对称：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} -1 &amp; 0 &amp;0 \0&amp;1&amp;0\0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} -x&amp;y&amp;1\end{matrix}\right] $</li><li>关于原点对称：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} -1 &amp; 0 &amp;0 \0&amp;-1&amp;0\0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} -x&amp;-y&amp;1\end{matrix}\right] $</li></ul><h4 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h4><ul><li>将点绕原点旋转角度 $\theta$ ，逆时针为正，顺时针为负</li><li>坐标形式（逆时针）：$\begin{cases} x^* =r·cos(\alpha+\theta)=r·cos\alpha ·cos\theta-r·sin\alpha ·sin\theta \ y^* =r·sin(\alpha+\theta)=r·cos\alpha ·sin\theta + r·sin\alpha ·cos\theta\end{cases} \Rightarrow \begin{cases} x^* =x ·cos\theta-y ·sin\theta \ y^* =x ·sin\theta + y ·cos\theta\end{cases} $</li><li>齐次坐标形式（逆时针）：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} cos\theta &amp; sin\theta &amp;0\-sin\theta&amp;cos\theta &amp; 0\0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x ·cos\theta-y ·sin\theta &amp; x ·sin\theta + y ·cos &amp;1\end{matrix}\right] $</li><li>顺时针只要将 $\theta = -\theta $ 即可。</li></ul><p><img src="1567949364388.png" alt="1567949364388"></p><p>基于中心点的旋转</p><ul><li>先把坐标系以到中心点 $(c_x,c_y)$ ，再以进行旋转</li></ul><h4 id="错切变换"><a href="#错切变换" class="headerlink" title="错切变换"></a>错切变换</h4><ul><li>弹性物体的变形处理</li></ul><p><img src="1559033084287.png" alt="1559033084287"></p><ul><li>变换矩阵中的非对角元素起着把图形沿x或y方向错切的作用</li><li>齐次坐标形式：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} 1 &amp; b &amp; 0\ c &amp;1 &amp;0\0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix}c+cy&amp;bx+y &amp;1\end{matrix}\right] $</li><li>沿 x 方向错切，即 b=0 ：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} 1 &amp; 0 &amp; 0\ c &amp;1 &amp;0\0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix}c+cy&amp;y &amp;1\end{matrix}\right] $</li></ul><h4 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h4><ul><li>图形作大于一次的变换，$P^* = P · T = P·(T_1·T_2·\cdots ·T_n) ，n\gt 1$，<strong>矩阵相乘</strong>不可交换！</li><li>二维复合平移：$T = T_{t1}·T_{t2} = \left[ \begin{matrix} 1 &amp; 0 &amp;0 \0&amp;1&amp;0\T_{x1}&amp;T_{y1}&amp;1 \end{matrix} \right] · \left[ \begin{matrix} 1 &amp; 0 &amp;0 \0&amp;1&amp;0\T_{x1}&amp;T_{y1}&amp;1 \end{matrix} \right] =\left[ \begin{matrix} 1 &amp; 0 &amp;0 \0&amp;1&amp;0\T_{x1}+T_{x2}&amp;T_{y1}+T_{y2}&amp;1 \end{matrix} \right] $</li><li>二维复合比例：$T = T_{s1}·T_{s2} = \left[ \begin{matrix} S_{x1} &amp; 0 &amp;0 \0&amp;S_{y1}&amp;0\0&amp;0&amp;1 \end{matrix} \right] · \left[ \begin{matrix} S_{x2} &amp; 0 &amp;0 \0&amp;S_{y2}&amp;0\0&amp;0&amp;1 \end{matrix} \right]= \left[ \begin{matrix} S_{x1}·S_{x2} &amp; 0 &amp;0 \0&amp;S_{y1}·S_{y2}&amp;0\0&amp;0&amp;1 \end{matrix} \right]$</li><li>二维复合旋转：$T = T_{r1}·T_{r2} = \left[ \begin{matrix} cos\theta_1 &amp; sin\theta_1 &amp;0\-sin\theta_1&amp;cos\theta_1 &amp; 0\0&amp;0&amp;1 \end{matrix} \right] · \left[ \begin{matrix} cos\theta_2 &amp; sin\theta_2 &amp;0\-sin\theta_2&amp;cos\theta_2 &amp; 0\0&amp;0&amp;1 \end{matrix} \right]=\left[ \begin{matrix} cos(\theta_1+\theta_2) &amp; sin(\theta_1+\theta_2) &amp;0\-sin(\theta_1+\theta_2)&amp;cos(\theta_1+\theta_2) &amp; 0\0&amp;0&amp;1 \end{matrix} \right] $</li></ul><h4 id="坐标系变换"><a href="#坐标系变换" class="headerlink" title="坐标系变换"></a>坐标系变换</h4><ul><li>图形变换经常需要从一个坐标系变换到另一个坐标系，如下图从x0y变换到x’0’y’</li></ul><p><img src="1559034067979.png" alt="1559034067979"></p><ul><li>上图可以拆分成，$x’0’y’ \xrightarrow{平移} x’0y’ \xrightarrow{旋转} x0y $，注意是从目标到源</li><li>$T = T_{t}·T_{r} = \left[ \begin{matrix} 1 &amp; 0 &amp;0 \0&amp;1&amp;0\-x_0&amp;-y_0&amp;1 \end{matrix} \right] · \left[ \begin{matrix} cos(-\theta) &amp; sin(-\theta) &amp;0\-sin(-\theta)&amp;cos(-\theta) &amp; 0\0&amp;0&amp;1 \end{matrix} \right] $</li></ul><h4 id="任意参考点的几何变换"><a href="#任意参考点的几何变换" class="headerlink" title="任意参考点的几何变换"></a>任意参考点的几何变换</h4><ul><li>在以往的变换中，以 (0, 0) 为参考点，倘若以任意点为参考点，则：<ul><li>将参考点移到原点（平移）</li><li>针对原点进行二维几何变换（变换）</li><li>将原点移到参考点（反平移）</li></ul></li></ul><h4 id="二维变换矩阵"><a href="#二维变换矩阵" class="headerlink" title="二维变换矩阵"></a>二维变换矩阵</h4><ul><li><p>二维空间中某点的变化可以表示成点的齐次坐标与 3 阶的二维变换矩阵 $T_{2d} $ 相乘</p><p>$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} a&amp;b&amp;p\c&amp;d&amp;q\l&amp;m&amp;s \end{matrix} \right] $</p></li><li><p><img src="1559035081804.png" alt="1559035081804"></p></li></ul><h4 id="二维图形几何变换的计算"><a href="#二维图形几何变换的计算" class="headerlink" title="二维图形几何变换的计算"></a>二维图形几何变换的计算</h4><ul><li>点的变换：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· T $</li><li>直线的变换（两端点的变换）：$\left[ \begin{matrix} x_1^* &amp; y_1^* &amp;1\ x_2^* &amp; y_2^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x_1 &amp; y_1 &amp;1\ x_2 &amp; y_2 &amp;1\end{matrix}\right] ·T $</li><li>多边形的变换（每个顶点的变换）：$p =\left[ \begin{matrix} x_1^* &amp; y_1^* &amp;1\ x_2^* &amp; y_2^* &amp;1 \ \cdots&amp;\cdots&amp;\cdots\x_n^* &amp;y_n^*&amp;1\end{matrix}\right] $</li></ul><h4 id="代码接口设计"><a href="#代码接口设计" class="headerlink" title="代码接口设计"></a>代码接口设计</h4><p>由于都是经过仿射矩阵进行变换，更好的形式是输入算好的矩阵，进行仿射变换。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyImage &amp;input, MyImage &amp;output, <span class="hljs-keyword">float</span> angle)</span></span>;</span><br><span class="line"><span class="hljs-comment">// ↓ 更好的设计</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">warpAffine</span><span class="hljs-params">(<span class="hljs-keyword">const</span> MyImage&amp; input, MyImage &amp;output, <span class="hljs-keyword">const</span> Matrix23 &amp;mat)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">calcRotationMatrix</span><span class="hljs-params">(Matrix23 &amp;matrix, <span class="hljs-keyword">float</span> angle)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="应用：图像匹配"><a href="#应用：图像匹配" class="headerlink" title="应用：图像匹配"></a>应用：图像匹配</h4><ul><li><p>基于仿射变换的图像匹配</p><ul><li><p>在第 t 帧检测特征点 (特征检测)</p></li><li><p>计算特征点在第 t+1 帧的对应 (特征跟踪)。”t, t+1” 两个特征点记位<strong>特征点对</strong></p></li><li><p>根据<strong>特征点对</strong>，估计第 t 帧到第 t+1 帧的仿射变换 A</p></li><li><p>利用 A 对第 t 帧的图像进行变换，将变换的结果作为与第 t+1 帧配准的图像： $Ap_t\leftrightarrow p_{t+1} $</p><p><img src="1567950518581.png" alt="1567950518581"></p></li></ul></li><li><p>如何估计两个图像之间的仿射变换 $A$？<br><img src="1567950596612.png" alt="1567950596612"></p><ul><li>不共线的 3 个平面点对决定一个二维仿射变换<br>$\left[ \begin{matrix} x^* &amp; y^* \end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} a_1 &amp; a_2\ b_1 &amp; b_2 \ c_1 &amp; c_2 \end{matrix} \right] = [a_1 x +b_1 y + c_1, a_2 x + b_2 y + c_2] $</li><li>不共线的多于 3 个平面点对决定一个二维仿射变换$ A = arg_Amin \sum\limits_i ||Ap_i - p_i’||^2 $</li></ul></li></ul><h4 id="应用：图像变形-Image-Warping"><a href="#应用：图像变形-Image-Warping" class="headerlink" title="应用：图像变形 Image Warping"></a>应用：图像变形 Image Warping</h4><p><img src="1568177963373.png" alt="1568177963373"></p><ul><li><p>记 $[x’ , y’] = f([x, y])$ 为像素坐标的一个映射，实现 $f$ 所表示的图像形变。</p></li><li><p>$f$ 的逆映射为： $[x, y] = f^{-1}([x’, y’]) = \begin{cases} [x’,y’] , &amp; r&gt;1 \ [cos\theta·x’-sin\theta ·y’ , sin\theta ·x’+ cos\theta ·y’ ], &amp; otherwise \end{cases}$</p><ul><li>$r = \sqrt{x’^2+y’^2} ,\theta = (1-r)^2 $</li><li>$[x, y], [x’, y’]$ 都是中心归一化坐标<br><img src="1568178333301.png" alt="1568178333301"></li></ul></li><li><p>正向查找、逆向查找的优缺点 / 局限性</p></li><li></li></ul><h2 id="第-3-章-空间过滤-Spatial-Filtering"><a href="#第-3-章-空间过滤-Spatial-Filtering" class="headerlink" title="第 3 章 空间过滤 Spatial Filtering"></a>第 3 章 空间过滤 Spatial Filtering</h2><h2 id="第-4-章-统计特征-Statistics"><a href="#第-4-章-统计特征-Statistics" class="headerlink" title="第 4 章 统计特征 Statistics"></a>第 4 章 统计特征 Statistics</h2><h3 id="直方图-Histogram"><a href="#直方图-Histogram" class="headerlink" title="直方图 Histogram"></a>直方图 Histogram</h3><p>描述<strong>一个像素</strong>的信息：</p><ul><li>空间坐标 <code>(x, y)</code></li><li>颜色值 <code>(RGB, YUV, ...)</code></li><li><code>(x, y, R, G, B)</code></li></ul><p>描述多个像素的信息：</p><ul><li>空间坐标 -&gt; 图像的结果</li><li>颜色值 -&gt; 像素颜色的分布</li></ul><p>直方图：</p><ul><li><p>$h(r_k) = n_k $，其中 $r_k$ 是第 $k^{th} $ 灰度级，$n_k $ 是图像中对应灰度级的像素数点数目。</p></li><li><p>令 $n$ 为图像中像素总数，归一化直方图 $p(r_k) = \frac{n_k}{n}$</p></li><li><p>图像的直方图提供了关于<strong>对比度增强的可能性</strong>的信息</p></li></ul><img src="image-20191219092832591.png" alt="image-20191219092832591" style="zoom:50%"><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void calc_hist(uchar *data, int width, int height, int step, int H[256]) </span><br><span class="line">&#123;</span><br><span class="line">	memset(H, 0, sizeof(H[0])*256);</span><br><span class="line">	uchar *row = data;</span><br><span class="line">	for(int yi=0; yi&lt;height; ++yi, row+=step)</span><br><span class="line">		for(int xi=0; xi&lt;width; ++xi)</span><br><span class="line">			H[row[xi]]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="image-20191219093728675.png" alt="image-20191219093728675"></p><h3 id="直方图均衡化-Equalization"><a href="#直方图均衡化-Equalization" class="headerlink" title="直方图均衡化 Equalization"></a>直方图均衡化 Equalization</h3><p>更”好看”的图像，其像素的灰度级可能有哪些特征：</p><ul><li>覆盖了所有可能的灰度级</li><li>均匀分布</li></ul><p>直方图均等化的工作：</p><img src="image-20191219094309618.png" alt="image-20191219094309618" style="zoom:67%"><ul><li>设计一个转换函数使其转换为满足”好看”的图像的灰度级要求</li></ul><p>HK 转换函数：</p><ul><li><p>归一化 $r \rightarrow [0, 1]$</p></li><li><p>用于直方图均等化的灰度级转换函数（可以类比前缀和）：<br>$\large s_k = T(r_k) = \sum\limits_{j=0}^{k} \frac{n_j}{n}= \sum\limits_{j=0}^{k} p_r (r_j)$，其中 $p_r(r)$ 为原始图像灰度分布的概率密度函数</p></li><li><p>例子：下图中灰度级 0、64、255 的像素分别转为了 85、170、255，使得对比度增强</p></li></ul><p><img src="image-20191219095530092.png" alt="image-20191219095530092"></p><ul><li><p>证明不是均匀分布：</p><ul><li>令 $s = T(r) $，其中 $r$ 是原灰度值， $T ()$ 是转换函数，$s=T(r)$ 是转换后的灰度值。该函数是连续的。在 $r\in [0,1]$ 是单调递增的。</li><li>$s$ 的概率密度函数：$\large p_s(s) = p_r(r)|\frac{dr}{ds}|$</li><li>$\large s = T(r) = \int_0^r p_r(w)dw$<br>其满足 $\large \frac{ds}{dr}=\frac{dT(r)}{dr} = \frac{d}{dr}[\int_0^rp_r(w)dw] = p_r(r)$<br>所以 $\large p_s(s) =p_r(r)|\frac{dr}{ds}| = p_r(r)\frac{1}{p_r(r)}=1$</li><li><img src="image-20191219101736171.png" alt="image-20191219101736171"></li></ul></li><li><p>总结：</p><ul><li>转换 $\large s_k = T(r_k) = \sum\limits_{j=0}^{k} \frac{n_j}{n}= \sum\limits_{j=0}^{k} p_r (r_j)$ 不能产生均匀的直方图，其趋向于去扩散输入图像的直方图，使得图像的灰度值覆盖整个区间（对比度增强）。</li><li>该转换有固定的公式、算法，可以实现完全的自动化，故也利于硬件实现。</li></ul></li></ul><img src="image-20191219102026089.png" alt="image-20191219102026089" style="zoom:67%"><h3 id="直方图匹配-Matching"><a href="#直方图匹配-Matching" class="headerlink" title="直方图匹配 Matching"></a>直方图匹配 Matching</h3><p>直方图匹配的产生缘由：</p><ul><li>直方图均衡化并不能<strong>交互式</strong>地图像增强，而是只能产生唯一一种结果 —— 一个近似均匀的直方图。</li><li>对于增强图像的直方图，有时会有特殊要求，即对其灰度值范围有定制的要求。</li></ul><p>指定所需密度函数，可以得到如下转换函数 $G(z)$：</p><ul><li><p>$\large v = G(z) = \sum\limits_0^z p_z(w)\approx \sum\limits_{i=0}^z\frac{n_i}{n} $</p></li><li><p>将<strong>转换函数的输入</strong>设为<strong>直方图均等化后的灰度值</strong><br>$\Rightarrow z=G^{-1}(s) \Rightarrow z=G^{-1}[T(r)] $</p></li></ul><p>应用特殊的方法去做图像增强能构造出有特殊意义的直方图：</p><ul><li>生成符合指定概率密度函数的直方图（比如高斯函数密度）</li><li>或在图形设备上指定直方图形状（交互式），然后将其馈入处理器去执行直方图指定算法</li></ul><h3 id="局部增强-Local-Enhancement"><a href="#局部增强-Local-Enhancement" class="headerlink" title="局部增强 Local Enhancement"></a>局部增强 Local Enhancement</h3><ul><li><p>先前的方法是全局性的，当需要增强细节的时候，需要使用一些局部增强的方法<br>即根据每个像素附近的灰度分布来设计变换函数</p></li><li><p>在邻域进行像素平移时有两种方案</p><ul><li>一种是进行逐像素平移，此时邻域中仅一行/列改变，每一步移动中以新数据更新前一个位置得到的直方图。</li><li>另一种减少计算量的方法是使用非重叠区域。</li></ul></li></ul><img src="image-20191219151637209.png" alt="image-20191219151637209" style="zoom:50%"><h3 id="在图像增强中使用直方图"><a href="#在图像增强中使用直方图" class="headerlink" title="在图像增强中使用直方图"></a>在图像增强中使用直方图</h3><h2 id="第-5-章-结构"><a href="#第-5-章-结构" class="headerlink" title="第 5 章 结构"></a>第 5 章 结构</h2><h2 id="第-6-章-匹配"><a href="#第-6-章-匹配" class="headerlink" title="第 6 章 匹配"></a>第 6 章 匹配</h2><p>图像匹配：同一场景点在不同图像间像素的对应关系</p><ul><li>同一视频中的两帧</li><li>不同人拍摄的同一场景</li><li>同一场景的不同角度</li><li>同一物体，不同场景</li></ul><p>图像匹配的意义：</p><ul><li>视频处理与分析的基础</li><li>视觉三维重建的基础</li><li>早起物体识别、图像检索技术的基础</li><li>计算机视觉半壁江山的基础</li></ul><p>图像匹配关注的重点：<strong>局部特征</strong></p><ul><li>因为全局特征面临难以克服的困难：遮挡、形变、环境变化</li></ul><p><img src="1568258283775.png" alt="1568258283775"></p><h3 id="特征检测"><a href="#特征检测" class="headerlink" title="特征检测"></a>特征检测</h3><p><img src="1568258350026.png" alt="1568258350026"></p><p>特征检测与匹配的挑战：</p><ul><li><p>对图像几何变换的稳定性。Robust or covariant to out-of-plane (≈affine) transformations<br><img src="1568258553663.png" alt="1568258553663"></p></li><li><p>对光照、噪声、模糊、分层变化的稳定性 Robust to lighting variations, noise, blur, quantization<br><img src="1568258577236.png" alt="1568258577236"></p></li></ul><p><strong>特征点</strong>的特质：稳定检测、易于匹配</p><ul><li>局部性 Locality：因此对于阻塞和杂乱是鲁棒的。Features are local, therefore robust to occlusion and clutter.</li><li>大量的 Quantity：We need a sufficient number of regions to cover the object.</li><li>独特性 Distinctiveness: The regions should contain “interesting” structure.</li><li>高效性 Efficiency: Close to real-time performance.</li></ul><p>现成可行的检测器 / 方法 （已成为 CV 领域中许多最新应用的基本构件）：</p><ul><li>Hessian &amp; Harris</li><li>Laplacian, DoG</li><li>Harris-/Hessian-Laplace</li><li>Harris-/Hessian-Affine</li><li>EBR and IBR</li><li>MSER</li><li>Salient Regions</li></ul><h3 id="角点检测"><a href="#角点检测" class="headerlink" title="角点检测"></a>角点检测</h3><p>​ 角点是图像很重要的特征,对图像图形的理解和分析有很重要的作用。角点在保留图像图形重要特征的同时,可以有效地减少信息的数据量,使其信息的含量很高,有效地提高了计算的速度,有利于图像的可靠匹配,使得实时处理成为可能。</p><p>​ 角点在三维场景重建运动估计，目标跟踪、目标识别、图像配准与匹配等计算机视觉领域起着非常重要的作用。在现实世界中，角点对应于物体的拐角，道路的十字路口、丁字路口等。从图像分析的角度来定义角点可以有以下两种定义：</p><p>​ a. 角点可以是两个边缘的角点；</p><p>​ b. 角点是邻域内具有两个主方向的特征点；</p><p>前者往往需要对图像边缘进行编码，这在很大程度上依赖于图像的分割与边缘提取，具有相当大的难度和计算量，且一旦待检测目标局部发生变化，很可能导致操作的失败。早期主要有Rosenfeld 和 Freeman 等人的方法，后期有 CSS 等方法。</p><p>​ 基于图像灰度的方法通过计算点的曲率及梯度来检测角点，避免了第一类方法存在的缺陷，此类方法主要有 Moravec 算子、Forstner 算子、Harris 算子、SUSAN 算子等。</p><p>下图中表明了三种点中哪个是角点：</p><ul><li>平摊 flat：每个方向都没变化</li><li>边 edge：边方向没有变化</li><li>角 corner：角点处沿着任何方向移动都会引起像素颜色的明显变化</li></ul><img src="image-20191219154209784.png" alt="image-20191219154209784" style="zoom:50%"><h3 id="Harris-角点检测"><a href="#Harris-角点检测" class="headerlink" title="Harris 角点检测"></a>Harris 角点检测</h3><ul><li>将像素点看作<strong>滑动窗口</strong>，滑动窗口在角点处沿着任何方向移动都会引起像素颜色的明显变化</li></ul><h4 id="Moravec-算子"><a href="#Moravec-算子" class="headerlink" title="Moravec 算子"></a>Moravec 算子</h4><p>Moravec 算子是 Harris 算子的前身。</p><p>思想（个人理解）：定准一个小窗口，小窗口向各个方向移动（造成竖直/水平方向的偏移），窗口区域内的灰度值的变化程度加权到 $E$ 上，这个值越大，窗口内的点越可能是角点。</p><img src="image-20191219185354461.png" alt="image-20191219185354461" style="zoom:67%"><ul><li><p>公式：$\Large E(u,v) = \sum\limits_{x, y}(w(x,y) [I(x+u,y+v) - I(x,y)]^2)$<br>其中 $(u, v)$ 是滑动窗口竖直和水平方向的偏移，$w(x,y)$ 是窗口函数，$(x,y)$ 是窗口中心，$I(x+u,y+v)$ 是移动后的亮度，$I(x,y)$ 是移动前的亮度。</p></li><li><p>$E(u,v)$ 越大越可能是角点。</p></li><li><p>窗口函数 $w(x,y)$ 是一种滤波，高斯滤波或均值滤波均可。<img src="image-20191219154847776.png" alt="image-20191219154847776"></p></li></ul><p>Moravec 算子存在的问题：</p><ul><li><p>只考虑了 4 个方向，所以不存在图像旋转不变性。</p></li><li><p>理应考虑多个方向，但是这个“多”，并不是数量上的，应该是用全微分，涉及到泰勒展开。<br>Harris 算子就是在 Moravec 算子上优化得到。</p></li></ul><h4 id="引入-Sobel-梯度算子"><a href="#引入-Sobel-梯度算子" class="headerlink" title="引入 Sobel 梯度算子"></a>引入 Sobel 梯度算子</h4><p>图像边缘一般都是通过对图像进行梯度运算来实现的。图像梯度的最重要性质是，梯度的方向在图像灰度最大变化率上，它恰好可以反映出图像边缘上的灰度变化 。</p><p>Sobel 算子</p><p>主要用作边缘检测，在技术上，它是一离散性差分算子，用来运算图像亮度函数的灰度之近似值。在图像的任何一点使用此算子，将会产生对应的灰度矢量或是其法矢量。</p><p>Sobel 卷积因子为：$G_x = \left[ \begin{matrix} -1 &amp; 0 &amp;+1 \-2&amp;0&amp;+2\-1&amp;0&amp;+1 \end{matrix} \right] \ \ \ G_y= \left[ \begin{matrix} +1 &amp; +2 &amp;+1 \0&amp;0&amp;0\-1&amp;-2&amp;+1 \end{matrix} \right] $</p><p>水平方向梯度幅值计算过程可以简易理解如下：</p><p><img src="image-20191219191026525.png" alt="image-20191219191026525"></p><h4 id="Harris-算子"><a href="#Harris-算子" class="headerlink" title="Harris 算子"></a>Harris 算子</h4><ul><li><p>对 Moravec 算子的公式利用泰勒展开（原理是 $f(x+u, y+v)\approx f(x,y)+uf_x(x,y)+vf_y(x,y) $），到：$\large E(u,v) = \sum\limits_{x, y}(w(x,y) [u^2I_x^2+2uvI_xI_y+v^2I_y^2])$<br>其中，$I_x$ 是图像水平梯度，$I_y$ 是图像竖直梯度</p></li><li><p>上式可以化为 $\large E(u,v) \approx [u, v](\sum w(x,y) \left[ \begin{matrix} I_x^2 &amp; I_xI_y \ I_xI_y &amp; I_y^2 \end{matrix}\right] ) \left[ \begin{matrix} u \ v\end{matrix}\right]$</p></li><li><p>$\Rightarrow \large E(u,v) \approx [u \ v] · M·\left[ \begin{matrix} u \ v\end{matrix}\right]$ ，其中 $\large M =\sum\limits_{x, y} w(x,y) \left[ \begin{matrix} I_x^2 &amp; I_xI_y \ I_xI_y &amp; I_y^2 \end{matrix}\right] $</p></li><li><p>这个 $E(u,v) $ 的形式是一个二项式函数，本质上是一个椭圆函数</p></li></ul><img src="image-20191219194758869.png" alt="image-20191219194758869" style="zoom:67%"><ul><li>而平坦、边、角点的梯度分布如下，可以看到椭圆长短半径都较大的话可以断定是角点。</li></ul><img src="image-20191219194430764.png" alt="image-20191219194430764" style="zoom:50%"><ul><li><p>角点响应 $R= det(M)-k(trace(M))^2 $，其中 $det(M) = I_x^2I_y^2-I_xI_y\times I_xI_y，trace(M)=I_x^2+I_y^2$<br>$R \begin{cases}&lt;0 &amp; 边缘点\ \approx 0 &amp; 平坦点 \ &gt; 0 &amp; 角点\end{cases}$</p></li><li><p>代码 demo 框架</p></li></ul><img src="image-20191219195644267.png" alt="image-20191219195644267" style="zoom:50%"><ul><li>总结：<ul><li>Harris 对图像旋转有稳定性，对缩放没有稳定性</li><li>Harris 对光照变化有稳定性，因为它用的是图像梯度</li></ul></li></ul><h3 id="斑点检测-Blob-Detection"><a href="#斑点检测-Blob-Detection" class="headerlink" title="斑点检测 Blob Detection"></a>斑点检测 Blob Detection</h3><p>​ 斑点通常是指与周围有着颜色和灰度差别的区域。在实际地图中，往往存在着大量这样的斑点，如一颗树是一个斑点，一块草地是一个斑点，一栋房子也可以是一个斑点。由于斑点代表的是一个区域，”一坨东西”，相比单纯的角点，它的稳定性要好，抗噪声能力要强，所以它在图像配准上扮演了很重要的角色。</p><img src="image-20191220083207371.png" alt="image-20191220083207371" style="zoom:50%"><h4 id="Hessian-检测器"><a href="#Hessian-检测器" class="headerlink" title="Hessian 检测器"></a>Hessian 检测器</h4><p>在两个正交方向上搜索强导数。<strong>主要响应角点和很强的纹理区域。</strong></p><p>Hessian 矩阵是一个多元函数的二阶偏导数构成的方阵，描述了函数的局部曲率。对一个图像 f(x,y)，其 Hessian 矩阵如下：<br>$$<br>\large H(f(x, y))=\left[\begin{array}{cc}{\frac{\partial^{2} f}{\partial x^{2}}} &amp; {\frac{\partial^{2} f}{\partial x \partial y}} \ {\frac{\partial^{2} f}{\partial x \partial y}} &amp; {\frac{\partial^{2} f}{\partial y^{2}}}\end{array}\right]<br>$$<br>在构造Hessian矩阵前需要对图像进行高斯滤波，去除噪声引起的像素突变，经过滤波后的Hessian矩阵表述为：<br>$$<br>H(\mathbf{x}, \sigma)=\left[\begin{array}{cc}{I_{x x}(\mathbf{x}, \sigma)} &amp; {I_{x y}(\mathbf{x}, \sigma)} \ {I_{x y}(\mathbf{x}, \sigma)} &amp; {I_{y y}(\mathbf{x}, \sigma)}\end{array}\right]<br>$$<br>当Hessian矩阵的判别式取得局部极值（极大值或极小值）时，判定当前点是比周围邻域内其他点更亮或更暗的点，由此来定位关键点的位置。<br>$$<br>\operatorname{det}(H)=I_{x x} I_{y y}-I_{x y}^{2}=\lambda_{1} \lambda_{2}<br>$$<br>对每个像素点计算图像在 X 方向 Y 方向的二阶偏导数，计算图像的 XY 方向的导数代入上式，</p><h3 id="高斯金字塔"><a href="#高斯金字塔" class="headerlink" title="高斯金字塔"></a>高斯金字塔</h3><h3 id="SIFT-尺度不变特征转换"><a href="#SIFT-尺度不变特征转换" class="headerlink" title="SIFT 尺度不变特征转换"></a>SIFT 尺度不变特征转换</h3><p>尺度不变特征转换 (Scale-invariant feature transform 或 SIFT)是一种电脑视觉的算法用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变量，此算法由 David Lowe 在 1999 年所发表，2004 年完善总结。</p><p>数学上，高斯和是唯一一个能模拟近处清晰远处模糊的一个线性和。</p><h3 id="ORB-特征检测"><a href="#ORB-特征检测" class="headerlink" title="ORB 特征检测"></a>ORB 特征检测</h3><h2 id="第-7-章-重建"><a href="#第-7-章-重建" class="headerlink" title="第 7 章 重建"></a>第 7 章 重建</h2></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://zhangt.top/CS/Computer-Vision-Study-Notes/">计算机视觉-学习笔记</a></li><li><strong>本文作者：</strong><a href="https://zhangt.top">ZhangT</a></li><li><strong>本文链接：</strong><a href="https://zhangt.top/CS/Computer-Vision-Study-Notes/">https://zhangt.top/CS/Computer-Vision-Study-Notes/</a></li><li><strong>发布时间：</strong>2019-09-05</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><hr style="height:1px;margin:1rem 0"><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><i class="fas fa-tags has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/tags/ComputerVision/">ComputerVision</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？投喂一下吧！ヾ(●´∀｀●)</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i> </span><span>支付宝</span><div class="qrcode"><img src="/images/alipay.jpg" alt="支付宝"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/CS/Operating-System-Study-Notes/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">操作系统-学习笔记</span></a></div><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/CS/Computer-Graphics-Study-Notes/"><span class="level-item">计算机图形学-学习笔记</span> <i class="level-item fas fa-chevron-right"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"91f36240e98756fc091e",clientSecret:"20de2f4dadd54bc04ad8db6c1090fb00a9477ac4",id:"028b0c43cb01f9cc50a83e20155d4358",repo:"zhangt2333.github.io",owner:"zhangt2333",admin:"zhangt2333",createIssueManually:!1,distractionFreeMode:!1});gitalk.render("comment-container")</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered"><div><img class="image is-96x96 has-mb-6" src="/images/avatar.png" alt="Zhang T"><p class="is-size-4 is-block">Zhang T</p><p class="is-size-6 is-block">感受我的感受</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Nanjing &lt;- Qingdao, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><div class="level-item has-text-centered is-marginless"><a href="/archives/"><p class="heading">文章</p><p class="title has-text-weight-normal">21</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/categories/"><p class="heading">分类</p><p class="title has-text-weight-normal">5</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/tags/"><p class="heading">标签</p><p class="title has-text-weight-normal">23</p></a></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/zhangt2333" target="_blank"><i class="fab fa-github"></i>&nbsp;&nbsp;关注我</a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu" style="max-height:750px;overflow:auto"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#第-1-章-绪论"><span class="has-mr-6">1</span> <span>第 1 章 绪论</span></a><ul class="menu-list"><li><a class="is-flex" href="#概述"><span class="has-mr-6">1.1</span> <span>概述</span></a></li><li><a class="is-flex" href="#计算机视觉的应用"><span class="has-mr-6">1.2</span> <span>计算机视觉的应用</span></a></li><li><a class="is-flex" href="#计算机视觉的难点-挑战"><span class="has-mr-6">1.3</span> <span>计算机视觉的难点/挑战</span></a></li><li><a class="is-flex" href="#成像"><span class="has-mr-6">1.4</span> <span>成像</span></a></li><li><a class="is-flex" href="#处理"><span class="has-mr-6">1.5</span> <span>处理</span></a></li><li><a class="is-flex" href="#结构"><span class="has-mr-6">1.6</span> <span>结构</span></a></li></ul></li><li><a class="is-flex" href="#第-2-章-图像处理"><span class="has-mr-6">2</span> <span>第 2 章 图像处理</span></a><ul class="menu-list"><li><a class="is-flex" href="#概述-1"><span class="has-mr-6">2.1</span> <span>概述</span></a></li><li><a class="is-flex" href="#代数运算"><span class="has-mr-6">2.2</span> <span>代数运算</span></a><ul class="menu-list"><li><a class="is-flex" href="#像素灰度变换"><span class="has-mr-6">2.2.1</span> <span>像素灰度变换</span></a></li><li><a class="is-flex" href="#多图像处理"><span class="has-mr-6">2.2.2</span> <span>多图像处理</span></a></li></ul></li><li><a class="is-flex" href="#几何处理"><span class="has-mr-6">2.3</span> <span>几何处理</span></a><ul class="menu-list"><li><a class="is-flex" href="#翻转"><span class="has-mr-6">2.3.1</span> <span>翻转</span></a></li><li><a class="is-flex" href="#放大-Zoom-in"><span class="has-mr-6">2.3.2</span> <span>放大 Zoom in</span></a></li></ul></li><li><a class="is-flex" href="#二维变换原理"><span class="has-mr-6">2.4</span> <span>二维变换原理</span></a><ul class="menu-list"><li><a class="is-flex" href="#仿射变换"><span class="has-mr-6">2.4.1</span> <span>仿射变换</span></a></li><li><a class="is-flex" href="#齐次坐标"><span class="has-mr-6">2.4.2</span> <span>齐次坐标</span></a></li><li><a class="is-flex" href="#平移变换"><span class="has-mr-6">2.4.3</span> <span>平移变换</span></a></li><li><a class="is-flex" href="#比例变换"><span class="has-mr-6">2.4.4</span> <span>比例变换</span></a></li><li><a class="is-flex" href="#对称变换"><span class="has-mr-6">2.4.5</span> <span>对称变换</span></a></li><li><a class="is-flex" href="#旋转变换"><span class="has-mr-6">2.4.6</span> <span>旋转变换</span></a></li><li><a class="is-flex" href="#错切变换"><span class="has-mr-6">2.4.7</span> <span>错切变换</span></a></li><li><a class="is-flex" href="#复合变换"><span class="has-mr-6">2.4.8</span> <span>复合变换</span></a></li><li><a class="is-flex" href="#坐标系变换"><span class="has-mr-6">2.4.9</span> <span>坐标系变换</span></a></li><li><a class="is-flex" href="#任意参考点的几何变换"><span class="has-mr-6">2.4.10</span> <span>任意参考点的几何变换</span></a></li><li><a class="is-flex" href="#二维变换矩阵"><span class="has-mr-6">2.4.11</span> <span>二维变换矩阵</span></a></li><li><a class="is-flex" href="#二维图形几何变换的计算"><span class="has-mr-6">2.4.12</span> <span>二维图形几何变换的计算</span></a></li><li><a class="is-flex" href="#代码接口设计"><span class="has-mr-6">2.4.13</span> <span>代码接口设计</span></a></li><li><a class="is-flex" href="#应用：图像匹配"><span class="has-mr-6">2.4.14</span> <span>应用：图像匹配</span></a></li><li><a class="is-flex" href="#应用：图像变形-Image-Warping"><span class="has-mr-6">2.4.15</span> <span>应用：图像变形 Image Warping</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第-3-章-空间过滤-Spatial-Filtering"><span class="has-mr-6">3</span> <span>第 3 章 空间过滤 Spatial Filtering</span></a></li><li><a class="is-flex" href="#第-4-章-统计特征-Statistics"><span class="has-mr-6">4</span> <span>第 4 章 统计特征 Statistics</span></a><ul class="menu-list"><li><a class="is-flex" href="#直方图-Histogram"><span class="has-mr-6">4.1</span> <span>直方图 Histogram</span></a></li><li><a class="is-flex" href="#直方图均衡化-Equalization"><span class="has-mr-6">4.2</span> <span>直方图均衡化 Equalization</span></a></li><li><a class="is-flex" href="#直方图匹配-Matching"><span class="has-mr-6">4.3</span> <span>直方图匹配 Matching</span></a></li><li><a class="is-flex" href="#局部增强-Local-Enhancement"><span class="has-mr-6">4.4</span> <span>局部增强 Local Enhancement</span></a></li><li><a class="is-flex" href="#在图像增强中使用直方图"><span class="has-mr-6">4.5</span> <span>在图像增强中使用直方图</span></a></li></ul></li><li><a class="is-flex" href="#第-5-章-结构"><span class="has-mr-6">5</span> <span>第 5 章 结构</span></a></li><li><a class="is-flex" href="#第-6-章-匹配"><span class="has-mr-6">6</span> <span>第 6 章 匹配</span></a><ul class="menu-list"><li><a class="is-flex" href="#特征检测"><span class="has-mr-6">6.1</span> <span>特征检测</span></a></li><li><a class="is-flex" href="#角点检测"><span class="has-mr-6">6.2</span> <span>角点检测</span></a></li><li><a class="is-flex" href="#Harris-角点检测"><span class="has-mr-6">6.3</span> <span>Harris 角点检测</span></a><ul class="menu-list"><li><a class="is-flex" href="#Moravec-算子"><span class="has-mr-6">6.3.1</span> <span>Moravec 算子</span></a></li><li><a class="is-flex" href="#引入-Sobel-梯度算子"><span class="has-mr-6">6.3.2</span> <span>引入 Sobel 梯度算子</span></a></li><li><a class="is-flex" href="#Harris-算子"><span class="has-mr-6">6.3.3</span> <span>Harris 算子</span></a></li></ul></li><li><a class="is-flex" href="#斑点检测-Blob-Detection"><span class="has-mr-6">6.4</span> <span>斑点检测 Blob Detection</span></a><ul class="menu-list"><li><a class="is-flex" href="#Hessian-检测器"><span class="has-mr-6">6.4.1</span> <span>Hessian 检测器</span></a></li></ul></li><li><a class="is-flex" href="#高斯金字塔"><span class="has-mr-6">6.5</span> <span>高斯金字塔</span></a></li><li><a class="is-flex" href="#SIFT-尺度不变特征转换"><span class="has-mr-6">6.6</span> <span>SIFT 尺度不变特征转换</span></a></li><li><a class="is-flex" href="#ORB-特征检测"><span class="has-mr-6">6.7</span> <span>ORB 特征检测</span></a></li></ul></li><li><a class="is-flex" href="#第-7-章-重建"><span class="has-mr-6">7</span> <span>第 7 章 重建</span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/">TTTT&#39;s Blog</a><p class="is-size-7">&copy; 2022 ZhangT&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},skipTags:["script","noscript","style","textarea","pre","code"],processEscapes:!0,tex2jax:{inlineMath:[["$","$"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>