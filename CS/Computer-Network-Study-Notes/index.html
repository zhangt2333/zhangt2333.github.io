<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>计算机网络-学习笔记 - Zhang T&#39;s Blog</title><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-212316117-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-212316117-1")</script><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/">TTTT&#39;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i> </a><a class="navbar-item" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-image"><span class="image is-7by1"><img class="thumbnail" src="/thumbnails/Computer-Network-Study-Notes.png" alt="计算机网络-学习笔记"></span></div><div class="card-content article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>计算机网络-学习笔记</h1><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2019-05-02T13:00:00.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-05-02</time> <time class="level-item has-text-grey is-hidden-mobile" datetime="2022-01-05T12:15:22.353Z"><i class="far fa-calendar-check">&nbsp;</i>2022-01-05</time><div class="level-item"><i class="far fa-folder-open has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/categories/CS/">CS</a></div><span class="level-item has-text-grey"><i class="far fa-clock"></i>&nbsp; 3 小时 读完 (大约 29034 个字) </span><span class="level-item has-text-grey" id="busuanzi_container_page_pv"><i class="far fa-eye"></i> <span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p>两个设备如何通信？</p><h2 id="第1章-引言"><a href="#第1章-引言" class="headerlink" title="第1章 引言"></a>第1章 引言</h2><a id="more"></a><p><img src="1553603452046.png" alt="1553603452046"></p><h3 id="网络硬件"><a href="#网络硬件" class="headerlink" title="网络硬件"></a>网络硬件</h3><ul><li><p>PAN</p><ul><li>Personal Area Network 个域网</li><li>蓝牙</li></ul></li><li><p>LAN</p><ul><li>Local Area Network 局域网</li><li>WiFi、路由AP、以太网</li></ul></li><li><p>MAN</p><ul><li>Metropolitan Area Network 城域网</li><li>卫星、基于有线电视得城域网</li></ul></li><li><p>WAN</p><ul><li>Wide Area Network 广域网</li><li>VPN</li></ul></li><li><p>Intenet</p><ul><li>互联网</li></ul></li></ul><h3 id="网络软件"><a href="#网络软件" class="headerlink" title="网络软件"></a>网络软件</h3><h4 id="协议层次结构"><a href="#协议层次结构" class="headerlink" title="协议层次结构"></a>协议层次结构</h4><p><img src="1553059885303.png" alt="1553059885303"></p><p><img src="1552889290151.png" alt="1552889290151"></p><ul><li>特点<ul><li>每一层都将数据和控制信息传递给它的下一层，传递到最底层后，再往上传，第一层下面是物理介质</li><li>每一对相邻层次之间的是接口</li></ul></li></ul><h4 id="面向连接与无连接服务"><a href="#面向连接与无连接服务" class="headerlink" title="面向连接与无连接服务"></a>面向连接与无连接服务</h4><ul><li>面向连接服务：按电话系统建模</li><li>无连接服务：按照邮政系统建模</li></ul><h4 id="服务原语"><a href="#服务原语" class="headerlink" title="服务原语"></a>服务原语</h4><ul><li><p>原语：一个服务由一组原语正式说明，用户进程通过这些原语来访问该服务。</p></li><li><p>原子性</p></li><li><p><img src="1553059984198.png" alt="1553059984198"></p></li></ul><h3 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h3><h4 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h4><p><img src="1553060007309.png" alt="1553060007309"></p><h4 id="TCP-IP模型"><a href="#TCP-IP模型" class="headerlink" title="TCP/IP模型"></a>TCP/IP模型</h4><p><img src="1553060025150.png" alt="1553060025150"></p><h4 id="本书模型"><a href="#本书模型" class="headerlink" title="本书模型"></a>本书模型</h4><p><img src="1553060042033.png" alt="1553060042033"></p><h3 id="常用术语"><a href="#常用术语" class="headerlink" title="常用术语"></a>常用术语</h3><ul><li>层次栈/分级栈：网络组织的一种形式，每一层都建立在其下一层的基础上，层的个数、每一层的名字、每一层的内容和功能各个网络都不尽相同。每一层的目的是向上一层提供特定的服务，而把服务实现的细节对上层屏蔽。</li></ul><ul><li>协议：通信双方就如何进行通信的一种约定。</li><li>对等体：不同机器上构成相应层次的实体。</li><li>网络体系结构：层和协议的集合。网络体系结果的规范必须包含足够的信息，以便实现者为每一层编写的程序或设计的硬件能遵守有关协议。</li><li>协议栈：一个特定的系统所使用的一组协议，即每一层一个协议。</li><li>服务：某一层向其上一层提供的一组原语。</li><li>统计复用：许多网络设计根据主机的短期需求变化动态共享网络带宽，而不是给每个主机分配可能用也可能不会用的固定比例带宽。</li><li>拥塞：太多的计算机要发送太多的流量，而网络没有能力传递所有的数据包。</li><li>存储-转发交换：中间节点只能在收到报文的全部内容后再将该报文发送给下一个节点。</li><li>直通式交换：报文还未全部接受完毕之前就向下一个节点传输。</li><li>请求-应答服务：发送方传输一个包含了每个请求的数据报，接收方以一个包含了请求结果的应答数据报作为反馈。</li></ul><ul><li>ISP：互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务和增值业务的电信运营商。</li><li>P2P：对等计算机网络，是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构，是对等计算模型在应用层形成的一种组网或网络形式。</li><li>router：路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。</li><li>Cable：有线电视电缆</li><li>FTTH：光纤到户是一种光纤通信的传输方法。是直接把光纤接到用户的家中（用户所需的地方）。</li><li>DSL：数字用户线路，是以电话线为传输介质的传输技术组合。</li></ul><h2 id="第2章-物理层"><a href="#第2章-物理层" class="headerlink" title="第2章 物理层"></a>第2章 物理层</h2><p><img src="1553603405024.png" alt="1553603405024"></p><ul><li><p>主要功能：提供透明的比特流传输</p></li><li><p>注意</p><ul><li>封装好的数据以“0、1”比特流形式传输</li><li>物理层上的传输不关心比特流里携带的信息，只关心其正确搬运</li></ul></li><li><p>物理层四大特性</p><ul><li>机械特性：指明接口所有接线器的形状、尺寸、引脚数和排列等，如RJ45</li><li>电气特性：指明在接口电缆的各条线上出现的电压范围</li><li>功能特性：指明某条线上出现的某一电平的电压表示何种意义</li><li>规程特性：指明对于不同功能的各种可能事件的出现顺序规程的概念类似协议</li></ul></li><li><p>概念</p><ul><li>物理层上数据的传输：信号</li><li>信号：数据的电气或电磁表现</li><li>模拟信号：对应时域的信号取值是连续的</li><li>数字信号：对应时域的信号取值是离散的</li><li>码元：不同离散值的基本波形</li><li>物理带宽：传输过程中振幅不会明显衰减的频率范围（单位Hz），物理特性，通常取决于介质材料的构成、厚度、长度</li><li>数字带宽：单位时间内流经的信息总量。<strong>尼奎斯特定理和香农定理描述了物理带宽和数字带宽的关系。</strong></li></ul></li></ul><h3 id="数据通信的理论基础"><a href="#数据通信的理论基础" class="headerlink" title="数据通信的理论基础"></a>数据通信的理论基础</h3><h4 id="调制解调"><a href="#调制解调" class="headerlink" title="调制解调"></a>调制解调</h4><ul><li>调制：将模拟信号转换成数字比特</li><li>解调：将数字比特转换为模拟信号</li></ul><h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><ul><li>傅里叶变换<ul><li>任何行为周期为T的函数$g(t)$可表示为正余弦函数组合的无穷级数$g(t) = \frac{1}{2}c + \sum_{n=1}^{\infty}a_nsin(2 \pi n ft) + \sum_{n=1}^{\infty}b_ncos(2 \pi nft)$</li></ul></li><li><strong>尼奎斯特定理</strong><ul><li>在<strong>无噪声信道</strong>中，当物理带宽为$B$ Hz，信号离散度等级为$V$级，则该信道最大数据速率 （数字带宽）$ = 2B \ log_2V \ \ bps$，计算后还要乘每秒采样数。</li><li>任意一个信号的通过一个物理带宽为B的低通滤波器只要进行每秒2B次的采样就可完全重构出被滤掉的信号</li><li>信道一定，物理带宽确定时，要提高数字带宽只有<strong>增加离散等级</strong></li></ul></li><li><strong>香农定理</strong><ul><li>在<strong>有噪声信道</strong>中，如果物理带宽为$B$ Hz，信噪比为S/N，则该信道最大数据速率 （数字带宽）$ = B \ log_2(1+\frac{S}{N}) \ \ bps$</li><li>$分贝值=10log_{10}\frac{S}{N} \ \ db$</li><li>信道一定，物理带宽确定时，要提高数字带宽只有<strong>增加信噪比</strong></li></ul></li></ul><h3 id="引导性传输介质"><a href="#引导性传输介质" class="headerlink" title="引导性传输介质"></a>引导性传输介质</h3><p>物理层的功能是搬运比特，承载比特的就是传输介质</p><p>传输介质按是否有形分为引导性（有线）和非引导性（无线）两种</p><h4 id="同轴线缆"><a href="#同轴线缆" class="headerlink" title="同轴线缆"></a>同轴线缆</h4><ul><li>优点：比非屏蔽双绞线有更好屏蔽特性和更大的带宽，而且有很好的抗噪性</li><li>典型：中心导体（铜芯） - 绝缘材料 - 网状导体 - 外部绝缘层</li><li>分类：基带同轴电缆（50Ω，用于数字传输，屏蔽层为铜）、宽带同轴电缆（75Ω，用于模拟传输，屏蔽层为铝），还分为粗缆和细缆</li></ul><p><img src="1551782982958.png" alt="1551782982958"></p><h4 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h4><ul><li><p>两根具有绝缘层的铜导线按一定密度，逆时针绞在一起</p><ul><li>两根平行的线构成一个很好的天线，当两根线在一起后，不同电线产生的干扰波会相互抵消，从而能显著降低电线的辐射。</li><li>对外部噪声有更好的免疫力，因为噪声对两根电线的干扰是相同的，而它们的电压却不会改变。</li></ul></li><li><p>典型——5类线/猫5</p><ul><li><p>非屏蔽双绞线（UnshieldedTwisted Pair，缩写<strong>UTP</strong>）</p><p><img src="1551783450881.png" alt="1551783450881"></p><ul><li><p>提供10M、100M的数字带宽使用了其中的2对线（12、36）分别用于收、发</p></li><li><p>1000M以太网中，用到了全部的4对线</p></li><li><p>最大传输距离100米，广泛用于局域网中</p></li><li><p>优点：成本低、尺寸小、易于安装</p></li><li><p>缺点：易受干扰、传输距离和性能受到绞距影响</p></li><li><p>568B标准排线：白橙-橙-白绿-蓝-白蓝-绿-白棕-棕</p></li><li><p>直通线和交叉线：连接两台相同设备用交叉线（线顺不同），但现在设备都可以自适应，故标准排线即可。</p></li></ul></li><li><p>屏蔽双绞线（Shielded Twisted Pair，<strong>STP</strong>），在双绞线和外层绝缘封套之间有一个金属屏蔽层（多了2层）。</p><p><img src="1552301173320.png" alt="1552301173320"></p><ul><li>优点：抗EMI/RFI干扰</li><li>缺点：成本高、安装不易</li></ul></li></ul></li><li><p>链路</p><ul><li>全双工链路：双向可同时使用</li><li>半双工链路：可以双向使用，一次只能用一个方向</li><li>单工链路：只允许一个方向上传输</li></ul></li></ul><h4 id="电力线"><a href="#电力线" class="headerlink" title="电力线"></a>电力线</h4><ul><li><p>特点：非常方便，但是传输数据较为困难，因为分发电能和分发数据信号是两项完全不同的工作，需要考虑到电噪声等影响。</p><p><img src="1552301703978.png" alt="1552301703978"></p></li></ul><h4 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h4><ul><li><p>光纤——光导纤维，极细的玻璃纤维构成，把光封闭在其中并沿轴向进行传播</p></li><li><p>横截面：极细的玻璃芯 - 玻璃覆盖层 - 塑料封套，玻璃覆盖层的折射率比玻璃芯低以保证光都被限制在玻璃芯内<br><img src="1551785158250.png" alt="1551785158250"></p></li><li><p>优点：重量轻、损耗低、不受电磁辐射干扰、传输带宽和通信容量非常大</p></li><li><p>缺点：昂贵、易断裂</p></li><li><p>多模光纤</p><ul><li>玻璃芯直径$50\mu m$</li><li>光源：LED</li><li>许多不同光束以不同角度来回反射着向前传播，每一束光有不同模式（入射角度大于临界值的光束会在内部反射，多个角度所以叫做“多模”）。</li><li><img src="1552302045462.png" alt="1552302045462"></li><li>常用规格：$62.5/125 \mu m$</li></ul></li><li><p>单模光纤</p><ul><li>玻璃芯直径$10\mu m$</li><li>光源：激光</li><li>光纤直径减少到几个光波波长时，光只按直线传播而不会反射。</li><li>$100Gbps$</li><li><img src="1552302063813.png" alt="1552302063813"></li><li>常用规格：$8.3/125 \mu m$</li></ul></li><li><p>光源</p><ul><li>光传输系统组成：光源、传输介质、探测器</li><li>光源：LED（距离较短）和激光（成本较高）</li></ul></li></ul><p><img src="1551782285281.png" alt="1551782285281"></p><ul><li>光通过玻璃的衰减<ul><li><img src="1551783693635.png" alt="1551783693635"></li><li>现今光纤通信最常用的三个波段集中在：0.85、1.30、1.55微米</li></ul></li><li>三种拼接方式（光纤断了续接）<ul><li>连接器（10%~20%光损失，但使重配工作较易）</li><li>机械手段拼接：两端切口放入特殊的套管，夹紧（10%光损失）</li><li>熔合：两端切口熔合为一个新的连接</li></ul></li><li>与铜线的比较<ul><li>细、轻</li><li>安装费用低</li><li>不受电源浪涌、电磁干扰或电源故障等影响，不易化学腐蚀</li><li>难被搭线窃听（光纤不漏光）</li><li>光传输基本是单向</li><li>光纤接口成本原高于电子接口</li></ul></li></ul><h3 id="无线传输"><a href="#无线传输" class="headerlink" title="无线传输"></a>无线传输</h3><h4 id="无线电传输"><a href="#无线电传输" class="headerlink" title="无线电传输"></a>无线电传输</h4><p><img src="1551786594849.png" alt="1551786594849"></p><h4 id="光通信"><a href="#光通信" class="headerlink" title="光通信"></a>光通信</h4><p><img src="1551786745989.png" alt="1551786745989"></p><h3 id="复用技术★"><a href="#复用技术★" class="headerlink" title="复用技术★"></a>复用技术★</h3><p>多个用户共享同一根信道，是在干线上的技术，主要解决干线起点如何复用，干线终点如何分离的问题</p><h4 id="频分多路复用FDM"><a href="#频分多路复用FDM" class="headerlink" title="频分多路复用FDM"></a>频分多路复用FDM</h4><ul><li>分割频段<ul><li>利用基带传输的优势使多个用户共享一个信道</li><li>一个信道多个不同频段，实现信道的复用</li></ul></li></ul><p><img src="1551851307672.png" alt="1551851307672"></p><ul><li>正交FDM（Orthogonal FDM，简称OFDM）<ul><li>一种更好地利用带宽的FDM，没有了保护带，并且子带之间相互重叠，同样的干线承载更多的用户</li><li>被广泛用于802.11、有线电视网</li><li><img src="1552303572757.png" alt="1552303572757"></li></ul></li></ul><h4 id="波分多路复用WDM"><a href="#波分多路复用WDM" class="headerlink" title="波分多路复用WDM"></a>波分多路复用WDM</h4><ul><li>WDM，Wavelength Division Multiplexing</li><li>波长$\lambda$，$c=\lambda f$</li><li>按照波长分成若干份，承载不同用户的光信号</li></ul><p><img src="1552286357909.png" alt="1552286357909"></p><ul><li>DWDM（Dense WDM），密集波分多路复用。WDM在相邻波长间隔非常接近，子信道数目非常大时，WDM变成了DWDM。</li></ul><h4 id="时分多路复用TDM"><a href="#时分多路复用TDM" class="headerlink" title="时分多路复用TDM"></a>时分多路复用TDM</h4><ul><li><p>分割时间，Time Division Multiplexing</p></li><li><p>每个用户周期性获得整个带宽非常短的一个时间</p></li><li><p>要求时间上必须同步，各用户需要的带宽不均衡，而TDW用户时间片的使用却是一样的，将造成信道的浪费，不高效</p></li></ul><p><img src="1551851738754.png" alt="1551851738754"></p><ul><li>STDM（TDMStatistic），统计时分多路复用<ul><li>动态分配信道，按需分配</li><li>实现技术复杂，通常只在高速远程通信中使用，如ATM，用户使用情况较为平均的情况下不适合使用</li></ul></li></ul><h4 id="码分多路复用CDMA"><a href="#码分多路复用CDMA" class="headerlink" title="*码分多路复用CDMA"></a>*码分多路复用CDMA</h4><ul><li>Code Division Multiple Access，扩展频谱技术，1942年海蒂拉玛受钢琴启发发明。高通开发用于3G</li><li>CDMA允许每个站利用整个频段发送信号，没有时间限制</li><li>可以将TDM看作许多人按顺序交谈，将FDM看作不用人按不同语调交谈，CDMA则是每对交谈者使用不用的语言</li><li>CDMA关键在于能够提取出需要的信号，同时拒绝所有其他的信号并把这些信号当作噪声</li></ul><h3 id="调制技术★"><a href="#调制技术★" class="headerlink" title="调制技术★"></a>调制技术★</h3><h4 id="基带传输"><a href="#基带传输" class="headerlink" title="基带传输"></a>基带传输</h4><ul><li>定义：基带传输是按照数字信号原有的波形（以脉冲形式）在信道上直接传输，它要求信道具有较宽的通频带。基带传输不需要调制、解调，设备花费少，适用于较小范围的数据传输。 信号需要编码。</li><li>信号的传输占据传输介质从0到最大值之间的全部频率</li><li>是有线传输介质普遍采用的传输方法，比如以太网</li></ul><ul><li><strong>数据比特直接转换为信号</strong>的一些方案，不经过调制。</li></ul><ul><li>线路编码（Line codes），发送一个样本可传输一或多个比特<ul><li><img src="1551788326268.png" alt="1551788326268"></li><li>不归零NRZ：高电平表示”1”，低电平表示“0”。（没有电压跳变。随时间累计，接收方可能无法分辨出连续几个“1”或“0”）</li><li>不归零逆转NRZI：在比特时间中间做电压跳变表示“1“，无跳变表示”0”。（解决了连续1问题，但连续0问题仍存在），USB里采用这种编码</li><li>曼彻斯特编码：在比特时间中间，电压从高跳变到低表示“1“，反之从低跳变到高表示”0“。（解决了连续0和连续1的问题，在10Base<strong>以太网中使用</strong>，但因为在比特时间中跳变故编码效率只有50%）</li><li>双极编码：两级电压的交替出现表示“1“，不出现表示”0”。（实现了信号的平衡）</li><li>4B/5B：4比特数据被映射为1个5比特模式（抛开连续0的组合，解决连续0问题），相比曼彻斯特编码效率提高80%</li><li>差分曼彻斯特编码：在每个时钟周期的中间必有一次电平跳变（这个跳变做同步之用）。 在每个时钟周期的起始处：跳变则说明该比特是0，不跳变则说明该比特是1。<br><img src="1559973780005.png" alt="1559973780005"></li></ul></li></ul><ul><li>时钟恢复：将数据、时钟信号异或混合在一起</li></ul><h4 id="通带传输"><a href="#通带传输" class="headerlink" title="通带传输"></a>通带传输</h4><ul><li>定义：通带传输是一种采用调制、解调技术的传输形式。在发送端，采用调制手段，对数字信号进行某种变换，将代表数据的二进制“1”和“0”，变换成具有一定频带范围的模拟信号，以适应在模拟信道上传输。在接收端，通过解调手段进行相反变换，把模拟的调制信号复原为“1”或“0”。</li></ul><ul><li>调节载波信号的<strong>幅值</strong>、<strong>相位</strong>或<strong>频率</strong>来运载比特的调制方案。</li><li>信号占据了以载波信号频率为中心的一段频带</li></ul><p><img src="1551788461012.png" alt="1551788461012"></p><ul><li><p>信号星座图——表示某种调制方式中信号的呈现模式（调制的级别）</p><ul><li><p>QAM-16（正交调幅调制Quadrature Amplitude Modulation），16表示调制方式中有$2^4=16$种不同振幅和相位的信号组合模式，意味着一个符号可传输4个比特</p></li><li><p>QPSK（正交相移键控）中，使用了4个相位角度，每次采样（码元、样本）可表达的级别有4个，每个码元可传输2 bits</p></li><li><p>QAM-64中，允许64个不同的信号组合，即64个信号级别，每个码元可传输6 bits</p></li><li><p>下图中，一个点的相位是以它为起点到原点的线与x正轴之间的角度；一个点的振幅则是该点到原点的距离</p><p><img src="1552353471530.png" alt="1552353471530"></p></li></ul></li><li><p>码元：承载信息量的基本信号单位。</p><ul><li>数字通信中常用时间间隔相同的符号来表示一个二进制数字，该符号即称为（二进制）码元。</li><li>在使用时间域的波形表示数字信号时，不同离散值的基本波形，也即是码元。</li><li>波特率B（码率）：1s能发送码元的个数。（每秒钟信号变化的次数）</li><li>比特率C：位传输率、数据传输速率、数字带宽</li><li><strong>波特率与比特率关系</strong>：$C = B\times log_2n$，n为信号呈现的个数，一般为2的倍数</li></ul></li><li><p>格子架编码调制TCM（Trellis Coded Modulation）</p><ul><li>提高数字带宽，要提高信号级别，即星座图上的星点，密密分布下容易导致出错率的提升。为了降低高速调制错误，在每个样本中采用一些额外的位用作纠错，剩下的位采用来传输数据。</li><li>比如，在V.32调制标准中，波特率2400，使用QAM-32，即每个码元传输5个比特，其中1个比特用来做奇偶校验，4个比特用来传输数据，则数据传输率只有$2400\times4=9600bps=9.6kbps$</li></ul></li></ul><h3 id="公共电话交换网络PSTN★"><a href="#公共电话交换网络PSTN★" class="headerlink" title="公共电话交换网络PSTN★"></a>公共电话交换网络PSTN★</h3><ul><li><p>PSTN低速传输原因：最后一英里</p></li><li><p>PSTN发展</p><ul><li>全连通网-&gt;中心交换网-&gt;层次交换网</li><li>人工交换-&gt;全自动交换</li></ul></li></ul><h4 id="电话系统结构"><a href="#电话系统结构" class="headerlink" title="电话系统结构"></a>电话系统结构</h4><p>电话系统由主要三部分构成：</p><ul><li>本地回路(Local loops)：模拟线路，连接端局和千家万户，通常用三类双绞线承担</li><li>干线、中继线(Trunks)：数字光纤，连接交换局</li><li>交换局(Switching offices)：语音接驳干线的场所，包括端局</li></ul><p><img src="1551852770906.png" alt="1551852770906"></p><h4 id="本地回路——调制解调器、ADSL和光纤"><a href="#本地回路——调制解调器、ADSL和光纤" class="headerlink" title="本地回路——调制解调器、ADSL和光纤"></a>本地回路——调制解调器、ADSL和光纤</h4><p><img src="1551854484530.png" alt="1551854484530"></p><ul><li><p>调制解调器：将计算机产生的数字比特流转变为载波输出（模拟信号-&gt;数字信号）</p><ul><li>56k（64k）的调制解调器：V.90标准电话线路频率为4kHz，采样率$=2\times 4000=8000 sample/sec$，每个码元传输8bit，其中1个比特控制错误，故传输数据速率$=8000 \times 7=56000kbps$，若算上控制错误的比特，毛速率为$64kbps$</li><li>连接调制解调器的本地回路带宽，被限制为4k，因为电话占频为4k；xDSL取消了电话系统里的滤波器后，可使用本地回路的全部（1.1兆）物理带宽</li></ul></li><li><p>ADSL：“Asymmetric Digital Subscriber Lines(DSL)” ，非平衡数字用户线路</p><ul><li>1999年颁布的标准G.dmt中，允许下行带宽（8Mbps，目前为24Mbps）上行带宽（1Mbps），课本$P_{116}$</li><li>1.1M的频宽，分为256根信道，每根4k。第1根用于简单的老式电话服务（POTS），再空闲5根， 剩下250根用于上下行控制和数据传输<img src="1551854905703.png" alt="1551854905703"></li></ul></li><li><p>光纤</p><ul><li>由于本地回路通常用3类UTP来承载信号，3类UTP的物理特性限制了带宽的增长上限，故用户对带宽的需求导致了光纤的替换。</li><li>FttH，Fiber to the Home，光纤到户</li><li>采用的光纤传输网络通常是无源的，这带来了更多的可靠性和安全性——光进铜退，最后一英里革命</li></ul></li><li><p>DSLAM：数字用户线路接入复用器</p></li><li><p>NID：网络接口设备</p></li></ul><p><img src="1551854603354.png" alt="1551854603354"></p><ul><li>PON：无源光网络<ul><li><img src="1552284967361.png" alt="1552284967361"></li></ul></li></ul><h4 id="中继线（干线）和多路复用★"><a href="#中继线（干线）和多路复用★" class="headerlink" title="中继线（干线）和多路复用★"></a>中继线（干线）和多路复用★</h4><p>干线是用来连接交换局，通常用光纤，要用到复用技术。</p><p>端局里特殊的设备——编解码器（codec）：$模拟信号 \rightleftharpoons 数字信号$，其中用到的技术为PCM。</p><ul><li><p>脉冲编码调制，PCM，Pulse Code Modulation</p><ul><li>模拟信号数字化的技术。构成了现代PSTN的核心。</li><li>采样、量化、编码、传输</li><li>每125微秒发送一个语音样值，该采样率足以捕捉4kHz电话信道带宽上的信息</li></ul></li><li><p>时分多路复用TDM</p><ul><li><p>T1载波（北美和日本），24路<img src="1551855497728.png" alt="1551855497728"></p><p>每帧24<em>8=192个比特，加上控制用的 帧码，则每125微秒产生193个比特，即*</em>数据传输率为$193bits / 0.000125 s = 1.544Mbps$**</p><p>一通电话带宽为$64kb$，那么100G光缆可同时用于163万通电话</p></li><li><p>E1载波（中国），32路语音的复用</p><p>每125微秒传递32<em>8=256个比特，即*</em>数据传输率为$256bits / 0.000125 s = 2.048Mbps$**</p></li><li><p>TDM允许更高级别的复用，比如4条T1流复用为1条T2流，7条T2流复用为1条T3流（每一步复用有少量开销用于同步控制、成帧）<img src="1552292395427.png" alt="1552292395427"></p></li></ul></li><li><p>SONET/SDH，光介质上进行同步数据传输的标准</p><ul><li>SONET（同步光网络），美国ANSIS制定；SDH（同步数字序列），国际标准组织ITU制定。</li><li>每隔125微秒发送810字节数据块，SONET是同步系统故不管是否有用该帧都被发送出去，<strong>总的传输速率为51.84Mbps</strong></li><li>9行，90列，有效载荷为87列，共$87 \times 9 \times 8bit \times 8000sample/sec = 50.112Mbps$</li><li>每帧前三列，保留用作传输系统管理信息<ul><li>其中前三列的前三行包括section开销</li><li>前三列的后六行包含line开销，其中前两个字节包含了指向信息首地址的指针</li></ul></li><li>源端正在构造SONET空帧时来了一个有效载荷数据，它可直接半途插入到当前构造的帧中，比如下图，SPE就从第1个帧的半途开始，横跨了两个帧。</li><li>对应于STS-n的光纤载波称为OC-n，其复用也是按比特进行的</li><li>如果一个载波（比如OC-3）没有被复用，而是仅承载了来自单个源的数据，则在线路名称后面加一个字母c（表示级联），因此OC-3表示由三条独立的OC-1载波构成的一条155.52Mbps载波，而OC-3c则表示来自于单个源的155.52Mbps数据流。</li></ul></li></ul><p><img src="1551856353272.png" alt="1551856353272"></p><p><img src="1551856722967.png" alt="1551856722967"></p><h4 id="交换局"><a href="#交换局" class="headerlink" title="交换局"></a>交换局</h4><ul><li><p>电路交换</p><ul><li>传统的电话系统，要求通话之前建立一条端到端的通路（物理），即”<strong>建立连接</strong>“，之后话音沿通道按顺序送达。<strong>数据传输</strong>完后<strong>拆除连接</strong></li><li>提前分配</li><li><img src="1552287698661.png" alt="1552287698661"></li></ul></li><li><p>数据包交换（分组交换）</p><ul><li>IP电话数据业务。允许包存储在交换局的内存里；每个包携带目的地址、信息（便于独立寻径）；乱序送达</li><li>按需分配，更好的容错能力和抗毁性</li><li><img src="1552293649031.png" alt="1552293649031"></li></ul></li><li><p><img src="1552287773099.png" alt="1552287773099"></p></li><li><p><img src="1552288674392.png" alt="1552288674392"></p></li></ul><h3 id="移动电话系统"><a href="#移动电话系统" class="headerlink" title="移动电话系统"></a>移动电话系统</h3><h4 id="常用术语-1"><a href="#常用术语-1" class="headerlink" title="常用术语"></a>常用术语</h4><ul><li>按钮电话系统：push-to-talk system，使用一个被安置在高大建筑物顶上的大型发射器，并且只有一个信道用于发送和接收。为了通话用户必须按一下按钮以便打开发送功能并关闭接收功能。</li><li>改进型移动电话系统：IMST，较按钮电话系统有两个频率，一个用于发送一个用于接收。</li><li>高级移动电话系统：AMPS</li><li>全球移动通信系统：GSM</li></ul><h4 id="1G：模拟语音"><a href="#1G：模拟语音" class="headerlink" title="1G：模拟语音"></a>1G：模拟语音</h4><ul><li>高级移动电话系统AMPS</li></ul><h4 id="2G：数字语音"><a href="#2G：数字语音" class="headerlink" title="2G：数字语音"></a>2G：数字语音</h4><ul><li><p>GSM——Global System for Mobile Communications</p><ul><li><img src="1552387809592.png" alt="1552387809592"></li></ul></li></ul><h4 id="3G：数字语音和数据"><a href="#3G：数字语音和数据" class="headerlink" title="3G：数字语音和数据"></a>3G：数字语音和数据</h4><h3 id="有线电视"><a href="#有线电视" class="headerlink" title="有线电视"></a>有线电视</h3><h4 id="频谱分配"><a href="#频谱分配" class="headerlink" title="频谱分配"></a>频谱分配</h4><p><img src="1552388683013.png" alt="1552388683013"></p><h2 id="第3章-数据链路层DLL"><a href="#第3章-数据链路层DLL" class="headerlink" title="第3章 数据链路层DLL"></a>第3章 数据链路层DLL</h2><p><img src="1553603346203.png" alt="1553603346203"></p><h3 id="DLL概述"><a href="#DLL概述" class="headerlink" title="DLL概述"></a>DLL概述</h3><p>相比物理层关注单个<strong>比特</strong>的传输，数据链路层更关注完整信息块（<strong>帧</strong>）的可靠有效的通信。</p><h4 id="DLL功能"><a href="#DLL功能" class="headerlink" title="DLL功能"></a>DLL功能</h4><ul><li>向网络层提供一个定义良好的服务接口<ul><li>无确认的无连接服务，广告。事先不需建立逻辑连接，事后也不用释放，若由于线路噪声造成了某一帧的丢失，数据链路层并不试图去检测这样的丢帧情况，更不会去试图恢复。</li><li>有确认的无连接服务，WiFi。发送方需要知道帧是否已经正确到达目的地</li><li>有确认的有连接服务</li></ul></li><li>保证数据传输的<strong>有效、可靠</strong><ul><li>处理传输错误：差错检测和控制</li><li>流量控制（基于速率/反馈），接收方反馈给发送方，使其调节数据流，确保慢速的接收方不会被快速的发送方淹没</li></ul></li></ul><h4 id="成帧——使接收方很容易发现一个新帧的开始★"><a href="#成帧——使接收方很容易发现一个新帧的开始★" class="headerlink" title="成帧——使接收方很容易发现一个新帧的开始★"></a>成帧——使接收方很容易发现一个新帧的开始★</h4><ul><li>帧PDU<ul><li>数据处理单元Protocol Data Unit</li><li>帧 = 帧头(控制) + 载荷 + 帧尾(校验)</li></ul></li></ul><p><img src="1552390990066.png" alt="1552390990066"></p><ul><li><p>成帧：将原始的位流分散到离散的帧中</p></li><li><p>字节计数法——Byte count</p><ul><li>每帧开始使以一个计数字段表示该帧的总字符数。</li><li>简单，但很少被使用</li><li>缺点：一旦出错，无法同步</li></ul><p><img src="1552392192252.png" alt="1552392192252"></p></li><li><p>字节填充的标志字节法——Byte stuffing</p><ul><li>以某些特殊字符作帧的开始/结束标志，同时增加转义环节以免该字符无法表达。</li><li>缺点：容易造成帧界混淆（故增加转义字节）、<strong>依赖8位字符</strong></li></ul></li></ul><p><img src="1552392360255.png" alt="1552392360255"></p><ul><li><p>比特填充的标志比特法——Bit stuffing</p><ul><li>用特殊的位模式<code>01111110</code>作为帧标志，即一个帧的开始（前一个帧的结束）</li><li>且为了处理帧内容中出现一个和帧标志相同的位串<code>01111110</code>。发送方一般在5个1后插入1个0，变为<code>01111101</code>。接收方自动删除第5个1后的0。</li><li>优点：可传输任意比特数的帧、传输速率更高</li></ul></li><li><p>物理层编码违例法</p><ul><li>在物理层的线路编码方法里头，有一些冗余信号是不会出现在传输数据里的，以其作帧界</li><li>比如，在4B/5B编码中，4B被映射成5B传输，32个模式，只用到16个，剩下的可以用作帧界</li><li>比如，曼彻斯特编码，高电位跳变到低电位表示”1”，相反表”0”。所以有两个跳变（高-&gt;高，低-&gt;低），两个冗余的跳变是没有使用的，也可拿作帧界。好处是使用冗余信号，不会混淆也不需要填充，故传输速率高</li></ul></li></ul><h3 id="差错处理概述"><a href="#差错处理概述" class="headerlink" title="差错处理概述"></a>差错处理概述</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li><p>处理错误的手段</p><ul><li>纠错码：恢复出正确的来（前项纠错技术）。需要纠错，需要更多的冗余位，所以在有线网较少采用主要用于无线网</li><li>检错：仅检出错误，不恢复，通常伴随着重传。局域网中主要采用</li></ul></li><li><p>错误的类型</p><ul><li>单个错误：分散在各块中</li><li>突发错误：集中在某个块中</li><li>突发错误比单个错误更难处理，通常利用单个处理的方法来应对突发错误</li></ul></li><li><p>码字：包含数据位和校验位的n位单元。</p></li></ul><h4 id="海明距离、海明码"><a href="#海明距离、海明码" class="headerlink" title="海明距离、海明码"></a>海明距离、海明码</h4><ul><li>海明距离：两个码字(codeword)的海明距离，是两个码字之间不同位的数，即异或结果中1的个数</li><li>全部码字的海明距离：全部码字中任意两个码字之间海明距离的最小值。</li><li>海明距离的意义在于：如果海明距离为d，则一个码字需要发生d个1位错误才能变成另外一个码字</li><li>海明距离=2d+1的编码，能纠正d位差错。<ul><li>比如，一个系统有4个合法码字：0000000000, 0000011111, 1111100000 和 1111111111。海明距离5，d=2，所以可以纠正两位错误</li><li>发送了0000011111，若接收到0000000111，它离0000011111的海明距离最近（为2），故恢复成功；发送了0000000000，若接收到0000000111，纠正后就是0000011111，错误了3位所以无法纠错</li><li>海明距离越大，纠错能力越强，同时合法码字就减少了，传输效率降低</li></ul></li><li>海明码：在数字逻辑，略</li></ul><h4 id="Internet-互联网-校验和"><a href="#Internet-互联网-校验和" class="headerlink" title="Internet(互联网)校验和"></a>Internet(互联网)校验和</h4><ul><li><p>校验和通常是按照N位码字，来进行模2加运算。发方将运算结果附加在数据报文的尾部作为校验位</p><ul><li>比如4位字的Internet校验和，就将信息每隔4位相加起来，高于4位的溢出被放回低序位相加，最终和为全0或全1则正确。</li></ul></li><li><p>常用：16位互联网补码校验和</p></li><li><p>特点</p><ul><li>比奇偶校验更好的检错性能</li><li>能检出高至N位的突发错误</li><li>检错随机错误率$1-2^N$</li><li>易受系统错误干扰，比如，增加的”0”</li></ul></li></ul><h4 id="循环冗余校验码CRC"><a href="#循环冗余校验码CRC" class="headerlink" title="循环冗余校验码CRC"></a>循环冗余校验码CRC</h4><ul><li><p>CRC工作原理</p><ul><li><p>任何一个k位的帧，可以看做一个k-1次的多项式。如1011001，看做$x^6+x^4+x^3+x^0$（6阶7项多项式）</p></li><li><p>约定一个<strong>生成多项式</strong>（Generator Polynomial）：$G(x)$，阶数为$r$，项数为 $r+1$。</p></li><li><p>现在有一个要计算CRC的m位帧的多项式$M(x)$，$m \gt r$，即$M(x)$比$G(x)$长</p></li><li><p>在 $M(x) $ 后附上 r 个0，成为 $x^rM(x) $。</p></li><li><p>$x^r M(x)/G(x) = Q(x)+R(x)$，其中$Q(x)$为商、$R(x)$为余数，则$x^rM(x)-R(x)$一定能被$G(x)$整除。</p><p><img src="1552910014655.png" alt="1552910014655"></p></li><li><p>接收方，将收到的码字，除生成多项式，余数为0则无误。</p></li><li><p>一个著名的CRC标准：CRC32，用于以太网计算循环冗余校验$G(x)=x^{32}+x^{26}+x^{23}+x^{22}+x^{16} +x^{12}+x^{11} \+x^{10}+x^{8} +x^{7}+x^{5}+x^{4}+x^{3}+x^{1}+0$</p></li></ul></li></ul><h3 id="基本数据链路协议1-3"><a href="#基本数据链路协议1-3" class="headerlink" title="基本数据链路协议1~3"></a>基本数据链路协议1~3</h3><p>网络接口卡NIC（Network InterFace Cards），能以帧到达的速度来处理帧</p><p>单工：数据的传输是单向的</p><ul><li><p>假设</p><ul><li><p>物理层、数据链路层、网络层，在工程中可能有不同的存在形式，在此作为三个独立进程</p></li><li><p>机器A希望向B发送的一个可靠的、面向连接的长数据流</p></li><li><p>假设机器不会崩溃</p></li><li><p>从网络拿到的数据是纯数据</p></li><li><p>三个层的数据传输传送接口：</p><p>$网络层 \xrightarrow{\text{from_network_layer}} 数据链路层 \xrightarrow{\text{to_physical_layer}} 物理层$</p><p>$网络层 \xleftarrow{\text{to_network_layer}} 数据链路层 \xleftarrow{\text{from_physical_layer}} 物理层$</p></li><li><p>Wait_for_event函数，等待帧到达事件frame_arrival、校验和出错事件cksum_err、定时器超时事件timeout</p></li><li><p>定时器，重传定时器、捎带确认定时器</p></li></ul></li></ul><p>protocol.h文件</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_PKT 1024  <span class="hljs-comment">/*数据包最大大小*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>&#125; boolean; <span class="hljs-comment">/*布尔类型枚举变量*/</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> seq_nr; <span class="hljs-comment">/*seq(序列号)、ack(确认号), nr(number缩写)*/</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> data[MAX_PKT];&#125; packet; <span class="hljs-comment">/* packet结构体定义*/</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;data, ack, nak&#125; frame_kind; <span class="hljs-comment">/*帧类型定义*/</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span>                <span class="hljs-comment">/* 帧结构体定理 */</span></span><br><span class="line">    frame_kind kind;</span><br><span class="line">    seq_nr seq;</span><br><span class="line">    seq_nr ack;</span><br><span class="line">    packet info;</span><br><span class="line">&#125; frame; </span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wait_for_event</span><span class="hljs-params">(event_type *event)</span></span>;<span class="hljs-comment">/*阻塞等待某事件*/</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">from_network_layer</span><span class="hljs-params">(packet *p)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">to_network_layer</span><span class="hljs-params">(packet *p)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">from_physical_layer</span><span class="hljs-params">(frame *f)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">to_physical_layer</span><span class="hljs-params">(frame *s)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_timer</span><span class="hljs-params">(seq_nr k)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop_timer</span><span class="hljs-params">(seq_nr k)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">start_ack_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">stop_ack_timer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enable_network_layer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">disable_network_layer</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> inc(k) <span class="hljs-meta-keyword">if</span>(k &lt; MAX_SEQ) k = k + 1; <span class="hljs-meta-keyword">else</span> k = 0; <span class="hljs-comment">/* 序列号、确认号自增 */</span></span></span><br></pre></td></tr></table></figure><h4 id="无限制的单工协议——乌托邦式"><a href="#无限制的单工协议——乌托邦式" class="headerlink" title="无限制的单工协议——乌托邦式"></a>无限制的单工协议——乌托邦式</h4><ul><li><p>假设</p><ul><li>数据单向传输</li><li>收发双方的网络层都处于就绪状态（随时待命）</li><li>帧处理时间忽略不计</li><li>可用缓存空间无穷大</li><li>数据通道不损坏、不丢帧（完美通道）</li></ul></li><li><p>Sender</p><p>不断从网络层拿数据，组帧，传输给物理层</p></li><li><p>Receiver</p><p>不断从物理层收帧，处理，提取载荷packet，传输给网络层</p></li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;frame_arrival&#125; event_type;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sender1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    frame s;</span><br><span class="line">    packet buffer;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span><br><span class="line">        from_network_layer(&amp;buffer);</span><br><span class="line">        s.info = buffer;</span><br><span class="line">        to_physical_layer(&amp;s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiver1</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    frame r;</span><br><span class="line">    event_type event;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span><br><span class="line">        wait_for_event(&amp;event);</span><br><span class="line">        from_physical_layer(&amp;r);</span><br><span class="line">        to_network_layer(&amp;r.info);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其他的协议是逐步取消乌托邦中的假设形成的。</li></ul><h4 id="单工停-等协议"><a href="#单工停-等协议" class="headerlink" title="单工停-等协议"></a>单工停-等协议</h4><ul><li>取消了乌托邦中允许无限量接受的假设 -&gt; 接收方可能被大量数据淹没</li><li>解决<ul><li>若接收方有能力处理的话回反馈给发送方一个哑帧</li><li>发送方收到哑帧，发下一帧数据。此时数据流向为双向（半双工）。</li></ul></li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;frame_arrival&#125; event_type;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sender2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    frame s;</span><br><span class="line">    packet buffer;</span><br><span class="line">    event_type event;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span><br><span class="line">        from_network_layer(&amp;buffer);</span><br><span class="line">        s.info = buffer;</span><br><span class="line">        to_physical_layer(&amp;s);</span><br><span class="line">        wait_for_event(&amp;event);   <span class="hljs-comment">// 等待哑帧，阻塞循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiver2</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    frame r, s;</span><br><span class="line">    event_type event;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span><br><span class="line">        wait_for_event(&amp;event);</span><br><span class="line">        from_physical_layer(&amp;r);</span><br><span class="line">        to_network_layer(&amp;r.info);</span><br><span class="line">        to_physical_layer(&amp;s);   <span class="hljs-comment">// 发送哑帧后进入下一循环</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="有噪声信道的单工协议"><a href="#有噪声信道的单工协议" class="headerlink" title="有噪声信道的单工协议"></a>有噪声信道的单工协议</h4><ul><li><p>取消了完美信道的假设，信道可能有错误、有噪声 -&gt; 接收方可能发现接收的帧不能通过校验。</p></li><li><p>解决</p><ul><li><p>肯定确认重传（PAR：Positive Acknowledgement with Retransmissioin）</p><p>自动重传请求（ARQ：Automatic Repeat ReQuest）</p></li><li><p>接收方接收的帧通过校验后才向发送方发送确认</p></li><li><p>只有发送方收到确认后才会发送下一帧</p></li><li><p>倘若发送帧丢失或确认帧丢失，则发送方发送前启动的定时器会引发重传。</p></li><li><p>定时器时间设置不恰当会发送多于的重传帧，区别新帧与重传帧的方法——给每帧一个独一无二序列号，同时该序号可用作重排、重组。</p></li></ul></li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_SEQ 1</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span>&#123;frame_arrival,cksum_err,timeout&#125; event_type;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sender3</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    seq_nr next_frame_to_send;</span><br><span class="line">    frame s;</span><br><span class="line">    packet buffer;</span><br><span class="line">    event_type event;</span><br><span class="line">    next_frame_to_send = <span class="hljs-number">0</span>;</span><br><span class="line">    from_network_layer(&amp;buffer);  <span class="hljs-comment">// 准备下一个包</span></span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span><br><span class="line">        s.info = buffer;</span><br><span class="line">        s.seq = next_frame_to_send; <span class="hljs-comment">// 下一帧序列号</span></span><br><span class="line">        to_physical_layer(&amp;s);</span><br><span class="line">        start_timer(s.seq);       <span class="hljs-comment">// 启动定时器</span></span><br><span class="line">        wait_for_event(&amp;event);   <span class="hljs-comment">// 等待确认帧</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(event == frame_arrival) &#123;</span><br><span class="line">            from_physical_layer(&amp;s);  <span class="hljs-comment">// 读入确认帧</span></span><br><span class="line">            <span class="hljs-keyword">if</span>(s.ack == next_frame_to_send) &#123;<span class="hljs-comment">// 确认号与序列号匹配</span></span><br><span class="line">                stop_timer(s.ack);   <span class="hljs-comment">// 拆除定时器</span></span><br><span class="line">                from_network_layer(&amp;buffer); <span class="hljs-comment">// 准备下一个包</span></span><br><span class="line">                inc(next_frame_to_send); <span class="hljs-comment">// 序列号自增</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">receiver3</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    seq_nr frame_expected; <span class="hljs-comment">// 确认号</span></span><br><span class="line">    frame r, s;</span><br><span class="line">    event_type event;</span><br><span class="line">    frame_expected = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span><br><span class="line">        wait_for_event(&amp;event);</span><br><span class="line">        <span class="hljs-keyword">if</span>(event == frame_arrival) &#123;</span><br><span class="line">            from_physical_layer(&amp;r);</span><br><span class="line">            <span class="hljs-keyword">if</span>(r.seq == frame_expected) &#123;<span class="hljs-comment">//序列号=确认号</span></span><br><span class="line">                to_network_layer(&amp;r.info);</span><br><span class="line">                inc(frame_expected); <span class="hljs-comment">// 确认号自增</span></span><br><span class="line">            &#125;</span><br><span class="line">            s.ack = <span class="hljs-number">1</span>-frame_expected; <span class="hljs-comment">// 模2加</span></span><br><span class="line">            to_physical_layer(&amp;s);  <span class="hljs-comment">// 回发确认帧</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提高传输效率：全双工、捎带确认（不单独发确认帧，搭”顺风车”过去）、批发数据 （管道化技术）</p><h3 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h3><p>之前3个模拟协议，为单工协议，信道利用率特别低，可在等待对方确认的时候继续发数据，这叫批量发送（管道化技术，一次性若干个数据，即一个窗口的数据）</p><p>接下来要介绍的3个协议，协议4对应着w=1的滑窗协议，协议5~6分别对应着批量传输数据出错后采用的两种策略。</p><ul><li>滑动窗口<ul><li>发送窗口：已经发送，未被确认</li><li>接受窗口：期望接收</li></ul></li></ul><h4 id="1位滑动窗口协议"><a href="#1位滑动窗口协议" class="headerlink" title="1位滑动窗口协议"></a>1位滑动窗口协议</h4><p>w=1的滑窗协议，引出滑动窗口的基本概念。</p><p><img src="1553598312610.png" alt="1553598312610"></p><ul><li><p>基本工作原理</p><ul><li><p>设置滑动窗口最大值：MAX_SEQ = 1</p></li><li><p>通信双方初始值：seq=0, ack=1(期望接收seq=0)</p><p><img src="1553598470417.png" alt="1553598470417"></p></li></ul></li><li><p>特点</p><ul><li>序列号seq和确认号ack，01交替</li><li>滑动窗口长度w=1，收到确认才移动窗口</li><li>保证按序将接收到的正确帧只一次上交网络层</li></ul></li></ul><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_SEQ 1</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;frame_arrival, cksum_err, timeout&#125; event_type;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">protocol4</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>  <span class="hljs-comment">// 双工的函数，即处理发送又处理接收</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-comment">// 声明</span></span><br><span class="line">    seq_nr next_frame_to_send;</span><br><span class="line">    seq_nr frame_expected;</span><br><span class="line">    frame r, s;</span><br><span class="line">    packet buffer;</span><br><span class="line">    event_type event;</span><br><span class="line">    <span class="hljs-comment">// 初始化</span></span><br><span class="line">    next_frame_to_send = <span class="hljs-number">0</span>; </span><br><span class="line">    frame_expected = <span class="hljs-number">0</span>;</span><br><span class="line">    from_network_layer(&amp;buffer);</span><br><span class="line">   </span><br><span class="line">    <span class="hljs-keyword">do</span> &#123;</span><br><span class="line">        <span class="hljs-comment">// 新发/重发一个包</span></span><br><span class="line">        s.info = buffer;</span><br><span class="line">        s.seq = next_frame_to_send;</span><br><span class="line">        s.ack = <span class="hljs-number">1</span> - frame_expected;<span class="hljs-comment">// 接收信道的捎带确认号</span></span><br><span class="line">        to_physical_layer(&amp;s);     </span><br><span class="line">        start_timer(s.seq);</span><br><span class="line">        </span><br><span class="line">        wait_for_event(&amp;event);</span><br><span class="line">        <span class="hljs-keyword">if</span>(event == frame_arrival) &#123; </span><br><span class="line">            from_physical_layer(&amp;r);</span><br><span class="line">            <span class="hljs-keyword">if</span>(r.seq == frame_expected) &#123; <span class="hljs-comment">// 接收包带的序列号</span></span><br><span class="line">            	to_network_layer(&amp;r.info);</span><br><span class="line">            	inc(frame_expected); <span class="hljs-comment">// 更新接收窗口     </span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="hljs-keyword">if</span>(r.ack == next_frame_to_send) &#123; <span class="hljs-comment">// 捎带确认号，跟发包没关系，可能是上一次的确认号</span></span><br><span class="line">            	stop_timer(r.ack);</span><br><span class="line">              from_network_layer(&amp;buffer);</span><br><span class="line">              inc(next_frame_to_send);<span class="hljs-comment">// 更新发送窗口</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>协议4的异常</p><ul><li>异常一：对重复帧的差错控制<br><img src="1553598863394.png" alt="1553598863394"></li><li>异常二：同步开始发送过程的差错控制<br><img src="1553598931008.png" alt="1553598931008"></li></ul></li><li><p>协议4的信道利用率如何</p><ul><li>假设了<strong>忽略</strong>接收方处理到达帧的时间。事实上在低速信道，来回时间RTT（Round Trip TIme）可能会非常大</li><li>-&gt;想到提高信道利用率要批量发送-&gt;即增大W</li></ul></li><li><p>如何找到合适的W值</p><ul><li>信道容量：一帧从发出到目的期间，信道上能够容纳的帧数量</li><li>带宽-延迟积：$B \times D $</li><li>窗口值：$W = 2\times B\times D +1$，这是信道利用率100%情况，实际上$W \le 2\times B D +1$<ul><li>2倍带宽-延迟积，是指发送帧和接收确认帧的时间</li><li>+1，是指接收窗口要留多一个帧位接收该发送帧。</li></ul></li></ul></li><li><p>异常处理：批量发送了一些帧，但中间某个帧出错了</p><ul><li>重传出错帧后的所有帧——Go Back n协议</li><li>缓存出错帧后面的正确帧，重传出错帧——Select Repeat</li></ul></li></ul><h4 id="回退N协议——Go-Back-n"><a href="#回退N协议——Go-Back-n" class="headerlink" title="回退N协议——Go Back n"></a>回退N协议——Go Back n</h4><ul><li><p>基本概念</p><ul><li>定义序列号seq的取值范围、滑动窗口W</li><li>发送方连续发送，直至发送窗口满</li><li>接收窗口为1，对出错帧不确认（-&gt;引发超时）</li><li>发送方超时重传，<strong>从未被</strong>确认帧开始</li></ul><p><img src="1553602362779.png" alt="1553602362779"></p></li><li><p>工作原理</p><ul><li>发送方<ul><li>正常发送：对帧编号，待确认帧缓存</li><li>收到确认：释放确认帧所占缓冲区，滑动发送窗口</li><li>差错帧超时事件到：回退到超时帧，顺序重传最后被确认帧以后的缓冲区中缓存的帧</li></ul></li><li>接收方<ul><li>收到每一个期望的正确帧：上交网络层、回送确认</li><li>收到出错帧或非期望帧：丢弃，回送对接收的最后正确帧的确认</li></ul></li><li>采用累计确认。</li><li>需要发送方付出更多的缓存代价，适合出错率较少的高速信道。</li></ul></li></ul><p>数据链路层采用后退N帧（GBN）协议，发送方已经发送了编号为0~9的帧。当计时器超时时，若发送方只收到0.2.3号帧的确认，则发送方需要重发的帧数是6——因为累计确认！</p><ul><li>滑动窗口长度W的选择<ul><li>发送窗口：$W \le \text{MAX_SEQ}$</li><li>接收窗口：$W = 1$</li><li>倘若头铁，W=MAX_SEQ+1，比如三位的MAX_SEQ=7，取W=8，那么在发送方接收到一个ack=7时候，无法知道是对上一个窗口最后一个帧的确认（即对当前窗口全部出错的肯定），或者是当前窗口全部帧的累计确认。<img src="1553603140801.png" alt="1553603140801"></li></ul></li></ul><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_SEQ 7</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;frame_arrival, cksum_err, timeout, network_layer_ready&#125; event_type;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> boolean <span class="hljs-title">between</span><span class="hljs-params">(seq_nr a, seq_nr, seq_nr c)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 判断 环式a&lt;=b&lt;c成立</span></span><br><span class="line">    <span class="hljs-keyword">return</span> (a&lt;=b &amp;&amp; b&lt;c) || (c&lt;a &amp;&amp; a&lt;=b) || (b&lt;c &amp;&amp; c&lt;a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send_data</span><span class="hljs-params">(seq_nr frame_nr, seq_nr frame_expected, packet buffer[])</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 构造并传输一个数据帧</span></span><br><span class="line">    frame s;</span><br><span class="line">    s.info = buffer[frame_nr];</span><br><span class="line">    s.seq = frame_nr;</span><br><span class="line">    s.ack = (frame_expected + MAX_SEQ)%(MAX_SEQ+<span class="hljs-number">1</span>); <span class="hljs-comment">// 上一到达帧，做捎带确认</span></span><br><span class="line">    to_physical_layer(&amp;s);</span><br><span class="line">    start_timer(frame_nr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">protocol5</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">	seq_nr next_frame_to_send, ack_expected, frame_expected;</span><br><span class="line">    next_frame_to_send = ack_expected = frame_expected = <span class="hljs-number">0</span>;</span><br><span class="line">    frame r;</span><br><span class="line">    packet buffer[MAX_SEQ + <span class="hljs-number">1</span>];</span><br><span class="line">    seq_nr nbuffered, i;</span><br><span class="line">    nbuffered = <span class="hljs-number">0</span>;</span><br><span class="line">    event_type event;</span><br><span class="line">    enable_network_layer();</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span><br><span class="line">        wait_for_event(&amp;event);</span><br><span class="line">        <span class="hljs-keyword">switch</span>(event) &#123;</span><br><span class="line">            <span class="hljs-keyword">case</span> network_layer_ready:          <span class="hljs-comment">// 网络层下传，放到发方缓冲区</span></span><br><span class="line">                from_network_layer(&amp;buffer[next_frame_to_send]);</span><br><span class="line">                nbuffered = nbuffered + <span class="hljs-number">1</span>;</span><br><span class="line">                send_data(next_frame_to_send, frame_expected, buffer);</span><br><span class="line">                inc(next_frame_to_send);</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            <span class="hljs-keyword">case</span> frame_arrival:</span><br><span class="line">                from_physical_layer(&amp;r);</span><br><span class="line">                <span class="hljs-keyword">if</span>(r.seq == frame_expected) &#123;</span><br><span class="line">                    to_network_layer(&amp;r.info); <span class="hljs-comment">// 接收窗口=1，直接传网络层</span></span><br><span class="line">                	inc(frame_expected);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">while</span>(between(ack_expected, r.ack, next_frame_to_send)) &#123; <span class="hljs-comment">// 累计确认处理</span></span><br><span class="line">                    nbuffered = nbuffered - <span class="hljs-number">1</span>; <span class="hljs-comment">// 缓冲区清刷</span></span><br><span class="line">                    stop_timer(ack_expected);</span><br><span class="line">                    inc(ack_expected);</span><br><span class="line">                &#125; <span class="hljs-comment">// 第三个参数在出错时会起到中止循环的作用</span></span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            <span class="hljs-keyword">case</span> cksum_err: <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 校验和出错，不确认，让发方自动超时</span></span><br><span class="line">            <span class="hljs-keyword">case</span> timeout:</span><br><span class="line">                next_frame_to_send = ack_expected; <span class="hljs-comment">// 直接重传出错帧后的所有</span></span><br><span class="line">                <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>;i &lt;= nbuffered; i++) &#123;</span><br><span class="line">                    send_data(next_frame_to_send, frame_expected, buffer);</span><br><span class="line">                    inc(next_frame_to_send);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span>(nbuffered &lt; MAX_SEQ) enable_network_layer();</span><br><span class="line">        <span class="hljs-keyword">else</span> disable_network_layer(); <span class="hljs-comment">// 缓冲区满，不接收网络层下传包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="选择性重传协议——Select-Repeat"><a href="#选择性重传协议——Select-Repeat" class="headerlink" title="选择性重传协议——Select Repeat"></a>选择性重传协议——Select Repeat</h4><ul><li><p>工作原理</p><ul><li>发送方<ul><li>正常发送：对帧编号，待确认帧缓存</li><li>收到确认：释放确认帧所占缓冲区，滑动发送窗口</li><li>差错帧超时事件到：<strong>重传缓存的最后被确认帧以后的那一帧</strong></li></ul></li><li>接收方<ul><li>正常接收：上交网络层、回送确认，滑动接收窗口</li><li>收到非期望的正确帧：缓存，回送对接收的最后正确帧的确认</li><li>收到重传帧：将缓存帧排序上交，回送确认，滑动接收窗口</li></ul></li><li>超时重传的优化 -&gt; <strong>否定确认NAK机制</strong>，收到某帧的错帧，明确的回馈接收方NAK=出错帧序号。</li></ul></li><li><p>与回退N帧协议的比较</p><ul><li>缓冲区：回退N帧对发送方要求，选择性重传对接收方要求</li><li>适用网络：回退N帧适用存信道出错率小，选择性重传适用信道出错率高</li></ul></li><li><p>滑动窗口长度W的选择</p><ul><li>发送窗口：$$\text{SWnd} \le 接收窗口大小$$</li><li>接收窗口：$\text{RWnd} = (\text{MAX_SEQ + 1})/2 $</li><li>如果不能保证新老窗口不重叠，那么重传帧可能被当为下一窗口的新帧</li></ul></li></ul><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_SEQ 7          <span class="hljs-comment">// 协议6必要奇数</span></span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NR_BUFS ((MAX_seq + 1)/2)</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span> &#123;frame_arrival, cksum_err, timeout, network_layer_ready&#125; event_type;</span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"protocol.h"</span></span></span><br><span class="line">boolean no_nak = <span class="hljs-literal">true</span>;</span><br><span class="line">seq_nr oldest_frame = MAX_SEQ + <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> boolean <span class="hljs-title">between</span><span class="hljs-params">(seq_nr a, seq_nr, seq_nr c)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 判断 环式a&lt;=b&lt;c成立</span></span><br><span class="line">    <span class="hljs-keyword">return</span> (a&lt;=b &amp;&amp; b&lt;c) || (c&lt;a &amp;&amp; a&lt;=b) || (b&lt;c &amp;&amp; c&lt;a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send_frame</span><span class="hljs-params">(frame_kind fk, seq_nr frame_nr, seq_nr frame_expected, packet buffer[])</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123; <span class="hljs-comment">// 构造并传输一个帧/否定帧</span></span><br><span class="line">    frame s;</span><br><span class="line">    s.kind = fk;</span><br><span class="line">    <span class="hljs-keyword">if</span>(fk == data) s.info = buffer[frame_nr % NR_BUFS];</span><br><span class="line">    s.seq = frame_nr;</span><br><span class="line">    s.ack = (frame_expected + MAX_SEQ)%(MAX_SEQ+<span class="hljs-number">1</span>); <span class="hljs-comment">// 上一到达帧，做捎带确认</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(fk == nak) no_nak = <span class="hljs-literal">false</span>;</span><br><span class="line">    to_physical_layer(&amp;s);</span><br><span class="line">    <span class="hljs-keyword">if</span>(fk == data) start_timer(frame_nr % NR_BUFS);</span><br><span class="line">    stop_ack_timer();                  <span class="hljs-comment">// 不需要单独的确认帧</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">protocol6</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">	seq_nr ack_expected,          <span class="hljs-comment">// 发送窗口下界</span></span><br><span class="line">           next_frame_to_send,    <span class="hljs-comment">// 发送窗口上界 + 1 </span></span><br><span class="line">           frame_expected,        <span class="hljs-comment">// 接收窗口下界</span></span><br><span class="line">           too_far;               <span class="hljs-comment">// 接收窗口上界 + 1</span></span><br><span class="line">    <span class="hljs-keyword">int</span> i;</span><br><span class="line">    frame r;</span><br><span class="line">    packet out_buf[NR_BUFS], in_buf[NR_BUFS];</span><br><span class="line">    boolean arrived[NR_BUFS];</span><br><span class="line">    seq_nr nbuffered;</span><br><span class="line">    event_type event;</span><br><span class="line">    enable_network_layer();</span><br><span class="line">    ack_expected = next_frame_to_send = frame_expected = <span class="hljs-number">0</span>;</span><br><span class="line">    too_far = NR_BUFS;</span><br><span class="line">    nbuffered = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; NR_BUFS; i++) arrived[i] = <span class="hljs-literal">false</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;</span><br><span class="line">        wait_for_evnet(&amp;event);</span><br><span class="line">        <span class="hljs-keyword">switch</span>(event) &#123;</span><br><span class="line">            <span class="hljs-keyword">case</span> network_layer_ready:</span><br><span class="line">                nbuffered = nubuffered + <span class="hljs-number">1</span>;</span><br><span class="line">                from_network_layer(&amp;out_buf[next_frame_to_send % NR_BUFS]);</span><br><span class="line">                send_frame(data, next_frame_to_send, frame_expected, out_buf);</span><br><span class="line">                inc(next_frame_to_send);</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            <span class="hljs-keyword">case</span> frame_arrival:</span><br><span class="line">                from_physical_layer(&amp;r);</span><br><span class="line">                <span class="hljs-keyword">if</span>(r.kind == data) &#123;</span><br><span class="line">                    <span class="hljs-keyword">if</span>(r.seq != frame_expected &amp;&amp; no_nak) <span class="hljs-comment">// 发送否定确认</span></span><br><span class="line">                        send_frame(nak, <span class="hljs-number">0</span>, frame_expected， out_buf);</span><br><span class="line">                    <span class="hljs-keyword">else</span> </span><br><span class="line">                        start_ack_timer(); <span class="hljs-comment">// 收方发送确认帧的计时器</span></span><br><span class="line">                    <span class="hljs-keyword">if</span>(between(frame_expected, r.seq, too_far) &amp;&amp; !arrived[r.seq%NR_BUFS]) &#123; <span class="hljs-comment">// 按序收帧</span></span><br><span class="line">                        arrived[r.seq % NR_BUFS] = <span class="hljs-literal">true</span>;</span><br><span class="line">                        in_buf[r.seq % NR_BUFS] = r.info;</span><br><span class="line">                        <span class="hljs-keyword">while</span>(arrived[frame_expected % NR_BUFS]) &#123;</span><br><span class="line">                            to_network_layer(&amp;in_buf[frame_expected % NR_BUFS]);</span><br><span class="line">                            no_nak = <span class="hljs-literal">true</span>;</span><br><span class="line">                            arrived[frame_expected % NR_BUFS] = <span class="hljs-literal">false</span>;</span><br><span class="line">                            inc(frame_expected);</span><br><span class="line">                            inc(too_far);</span><br><span class="line">                            start_ack_timer();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="hljs-keyword">if</span>(r.kind==nak &amp;&amp; between(ack_expected, (r.ack+<span class="hljs-number">1</span>)%(MAX_SEQ+<span class="hljs-number">1</span>), next_frame_to_send)) <span class="hljs-comment">// 收到否定确认帧，选择重传该帧</span></span><br><span class="line">                    send_frame(data, (r.ack+<span class="hljs-number">1</span>)%(MAX_SEQ+<span class="hljs-number">1</span>), frame_expected, out_buf);</span><br><span class="line">                <span class="hljs-keyword">while</span>(between(ack_expected, r.ack, next_frame_to_send)) &#123; <span class="hljs-comment">// 累计确认处理</span></span><br><span class="line">                    nbuffered = nbuffered - <span class="hljs-number">1</span>; <span class="hljs-comment">// 缓冲区清刷</span></span><br><span class="line">                    stop_timer(ack_expected % NR_BUFS);</span><br><span class="line">                    inc(ack_expected);</span><br><span class="line">                &#125; <span class="hljs-comment">// 第三个参数在出错时会起到中止循环的作用</span></span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            <span class="hljs-keyword">case</span> cksum_err:</span><br><span class="line">                <span class="hljs-keyword">if</span>(no_nak) send_frame(nak, <span class="hljs-number">0</span>, frame_expected, out_buf); <span class="hljs-comment">// 否定确认</span></span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            <span class="hljs-keyword">case</span> timeout:</span><br><span class="line">                send_frame(data, oldest_frame, frame_expected, out_buf);</span><br><span class="line">                <span class="hljs-keyword">break</span>;</span><br><span class="line">            <span class="hljs-keyword">case</span> ack_timeout:</span><br><span class="line">                send_frame(ack, <span class="hljs-number">0</span>, frame_expected, out_buf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">if</span>(nbuffered &lt; MAX_SEQ) enable_network_layer();</span><br><span class="line">        <span class="hljs-keyword">else</span> disable_network_layer(); <span class="hljs-comment">// 缓冲区满，不接收网络层下传包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PPP协议"><a href="#PPP协议" class="headerlink" title="PPP协议"></a>PPP协议</h3><ul><li>PPP协议是为在同等单元之间传输数据包的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。</li><li>主要区别：<ul><li>成帧：使用了字节填充的标志字节法</li><li>采用“无编号模式”来提供无连接无确认的服务</li><li>使用校验和字段来检错</li></ul></li><li>PPP无需支持的功能<ul><li>无需差错纠正/恢复</li><li>无需流量控制</li><li>不存在乱序交付</li><li>无需支持多点链路</li></ul></li><li>链路控制协议：LCP，它可用于启动线路、测试线路、协商参数，以及当线路不再需要时温和地关闭线路。</li><li>网络控制协议：NCP，一种协商网络层选项的方式。协商方式独立于网络层协议。所选择的方法是针对每一种支持的网络层都有一个不同网络控制协议。</li></ul><h3 id="常用术语-2"><a href="#常用术语-2" class="headerlink" title="常用术语"></a>常用术语</h3><ul><li>ATM：异步传输模式，是一种链路层，它的传输基于固定长度的信息信元。</li></ul><h2 id="第4章-介质访问控制层"><a href="#第4章-介质访问控制层" class="headerlink" title="第4章 介质访问控制层"></a>第4章 介质访问控制层</h2><p><img src="1559910495325.png" alt="1559910495325"></p><p>数据链路层分为：逻辑链路控制（LLC，Logical Link Control）、介质访问控制（MAC，Media AccessControl）</p><h3 id="MAC子层概述"><a href="#MAC子层概述" class="headerlink" title="MAC子层概述"></a>MAC子层概述</h3><p><img src="1554118899722.png" alt="1554118899722"></p><ul><li><p>数据通信的三种方式</p><ul><li>单播unicast：一对一</li><li>广播broadcast：一对所有</li><li>组播multicast：一对一组</li></ul></li><li><p>局域网里采用的传输方式：共享传输介质 -&gt; 降低成本，在共享传输介质上通常采用广播。</p></li><li><p>广播网络面临的问题：同时会有多个站点请求占用广播信道（多路访问信道）</p><ul><li>故我们要解决的是在多路访问信道上<strong>确定下一个使用者、及信道的分配</strong>，即介质的多路访问控制（MAC）</li></ul></li><li><p>分配信道（介质访问控制）</p><ul><li><p>静态分配：预先分配给各用户。PSTN中的干线用到了复用技术FDM、TDM。</p><ul><li>问题：资源分配不合理。提前分配会造成资源浪费，效率低。延迟时间增大N倍。</li><li>适用：用户数量少且较固定的情况、通信量大且流量稳定的情况、不适合突发性业务。</li></ul></li><li><p>动态分配：信道开放临时分配。通过多路访问协议（Multiple Access Protocol），提高信道利用率。</p></li></ul></li><li><p>多路访问协议</p><ul><li>随机访问协议：站点/用户争用信道 -&gt; 冲突<ul><li>典型的随机访问协议：ALOHA协议、CSMA协议、CSMA/CDX协议（以太网采用）</li></ul></li><li>受控访问协议：站点明确地被分配、占用始信道 -&gt; 不会产生冲突</li></ul></li></ul><h3 id="ALOHA协议"><a href="#ALOHA协议" class="headerlink" title="ALOHA协议"></a>ALOHA协议</h3><p>ALOHA协议是上世纪70年代诞生于夏威夷大学的一个随机访问协议，为解决夏威夷群岛和檀香山之间无线通信而提出。夏威夷打招呼的方式即ALOHA。</p><p>无线信道是典型的广播/共享信道。</p><ul><li><p>ALOHA协议的两个版本</p><ul><li>纯ALOHA协议</li><li>分隙ALOHA协议，隙是时隙、时槽的意思</li></ul></li></ul><h4 id="纯ALOHA工作原理"><a href="#纯ALOHA工作原理" class="headerlink" title="纯ALOHA工作原理"></a>纯ALOHA工作原理</h4><ul><li><p>任何一个工作站都可以在帧生成后立即发送，并通过信号的反馈检测信道以判断是否发送成功。冲突则随机等待后重发。</p></li><li><p>即任性，想发就发。</p><p><img src="1554119540885.png" alt="1554119540885"></p></li><li><p>性能分析</p><ul><li>吞吐率S：发送时间T内（一个帧时内）发送成功的平均帧数（$0&lt;S&lt;1$），S越大信道利用率越高</li><li>运载负载G：一个帧时T内所有通信站总共发送的帧平均值（包括原发和重发的帧），$G \ge S$。无冲突时，$G=S$，有冲突时，$G &gt; S$，冲突频繁时，$G &gt; 1$。</li><li>$P_0$：$P_0$是一帧发送成功（未冲突）的概率$S = G \times P_0 $</li><li>冲突危险期：时间长度2t（要保证在该帧发送之前t内没有帧发送，并且该帧开始发送后t内没有帧发送）<img src="1554120520775.png" alt="1554120520775"></li><li>在冲突危险期内，生成帧均值为$2G$。</li><li>生成k帧的概率服从泊松分布：$\text{Pr[k]} = \frac{G^k e^{-G}}{k !}$。例如生成0帧的概率是$\text{Pr[0]} = e^{-G}$</li><li>在2t时间内，发送成功的概率应为，2t内都不才产生新帧的概率：$P_0 = Pr[0] \times Pr[0] = e^{-2G}$</li></ul></li><li><p>纯ALOHA协议的性能</p><ul><li>将$P_0 = e^{-2G} $代入$S = G\times P_0$，得$S = G \times e^{-2G}$</li><li>求导求吞吐率S的极大值：$S’ = e^{-2G} - 2G \times e^{-2G} = 0$，故当 $G = 0.5 $时， $S \approx 0.184$</li><li>即，纯ALOHA信道的利用率最高为18.4%。</li></ul><p><img src="1554709882592.png" alt="1554709882592"></p></li></ul><p>因为ALOHA协议的利用率极低，所以改进为分隙ALOHA协议。</p><h4 id="分隙ALOHA协议（Slotted-ALOHA）工作原理"><a href="#分隙ALOHA协议（Slotted-ALOHA）工作原理" class="headerlink" title="分隙ALOHA协议（Slotted ALOHA）工作原理"></a>分隙ALOHA协议（Slotted ALOHA）工作原理</h4><ul><li><p>把时间分成时隙（时间片），时隙 = 帧时T（较纯ALOHA降低一半）</p></li><li><p>发送帧必须在时隙的起点，所以冲突值发生在时隙的起点</p></li><li><p>冲突危险期缩短为T，一旦某个站占用某个时隙并发送成功，则在该时隙内不会出现冲突</p><p><img src="1554710217846.png" alt="1554710217846"></p></li><li><p>性能分析</p><ul><li>$P_0 = P[0] = e^{-G}$，$S = G\times e^{-G}$</li><li>在G=1时取得最大吞吐率：$S_{max} = \frac{1}{e} \approx 0.368$</li><li>即，分隙ALOHA信道的利用率最高为36.8%。</li></ul></li></ul><h3 id="CSMA协议"><a href="#CSMA协议" class="headerlink" title="CSMA协议"></a>CSMA协议</h3><p>载波侦听多路访问协议（CSMA，Carrier Sense Multiple Access），改进的ALOHA协议。特点：先听后发。</p><h4 id="非持续式CSMA"><a href="#非持续式CSMA" class="headerlink" title="非持续式CSMA"></a>非持续式CSMA</h4><ul><li><p>概念：经过侦听，若介质空闲，则发送帧；若介质忙碌，则随机等待再侦听。</p></li><li><p>缺点：随机等待时间内介质上没有数据传送，这段时间被浪费。</p></li></ul><h4 id="持续式CSMA"><a href="#持续式CSMA" class="headerlink" title="持续式CSMA"></a>持续式CSMA</h4><ul><li>分为：1-持续CSMA、P-持续CSMA</li><li>概念：经过侦听，若介质空闲，则发送帧；若介质忙碌，则持续侦听直至空闲；若发送帧发生冲突，则随机等待后再侦听</li><li>P-持续CSMA<ul><li>侦听得到介质空闲，则以P的概率发送，以1-P的概率延迟一个时间发送</li></ul></li><li>1-持续CSMA<ul><li>是P-持续的特例，此时P=1，即侦听到介质空闲就发送，而不会延迟等待后再发送。</li></ul></li></ul><p>CSMA仍然会冲突的原因</p><ul><li>同时侦听同时传送。</li><li>传播延迟。信号在介质传播速度是光速的65%（每微秒200米），在信号未到达接收方的时候，接收方监听信道发现空闲，随后发帧，两帧碰撞冲突。</li></ul><p><img src="1554712915087.png" alt="1554712915087"></p><h4 id="冲突窗口"><a href="#冲突窗口" class="headerlink" title="冲突窗口"></a>冲突窗口</h4><ul><li>冲突危险期。一个工作站能够检测到冲突的时间最大值</li></ul><p><img src="1554713005393.png" alt="1554713005393"></p><ul><li>冲突窗口定义为上限：来回时间（RTT，Round Trip Time），2个帧时。</li><li>信号在信道传播速度：V = 200m/us</li><li>网卡处理帧的时间：网卡延时$\text{t}_{\text{PHY}}$</li><li>最远的两个工作站相距：S</li><li>计算得到：$冲突窗口 = 2t + 2t_{\text{PHY}}$，其中$ t = \frac{S}{V}$</li><li>倘若最远两个工作站间还有中继器，则$冲突窗口 = 2（t + t_{\text{PHY}} + N \times t_{\text{中继器}} ）$，其中$ t = \frac{S}{V}$</li><li>如果冲突发生在最远两个工作站的正中间，那么此时检测到冲突的时间等于最远两个工作站之间的传播延迟。</li></ul><h4 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h4><p>带冲突检测的载波侦听多路访问协议——CSMA with Collision Detection，也是1-持续的CSMA。半双工以太网中使用。</p><ul><li><p>工作原理</p><ul><li>先听后发、边发边听</li><li>经侦听，若介质空闲，则发送；若介质忙碌，持续侦听至空闲；发送之后，持续侦听是否碰撞冲突，若不冲突则发送成功，若冲突则随机等待后再重复侦听。</li><li>发送站感知冲突后，中断发送，之后发送一个非常简短的拥塞信号（Jam信号，是一个强化信号，广播出去通知各工作组该地方发生了碰撞）。</li></ul></li><li><p>各协议性能比较</p></li></ul><p><img src="1554716840246.png" alt="1554716840246"></p><ul><li>冲突检测和处理<ul><li>冲突检测的方法：比较发出和收到的两个信号的能量与脉冲宽度变化</li><li>冲突检测的要求<ul><li>时隙宽度 = 冲突窗口(最大冲突检测时间) -&gt; 保证在一个时隙内能够检测到最远距离的冲突。</li><li>发送有效帧的时间 &gt;= 冲突窗口 -&gt; 防止因为在发生冲突时，已完成短帧发送而无法知道实际上已发送失败。</li></ul></li></ul></li></ul><h3 id="以太网概述"><a href="#以太网概述" class="headerlink" title="以太网概述"></a>以太网概述</h3><p>以太网位于OSI参考模型的下两层——物理层、数据链路层。</p><p><img src="1554717577144.png" alt="1554717577144"></p><ul><li><p>两种以太网</p><ul><li>经典以太网：3M-10Mbps，不太常用</li><li>交换式以太网：10M、100M、1G，广泛使用</li></ul></li><li><p>IEEE以太网命名规则</p><ul><li>10Base2：10——10Mbps、Base——线路编码这种基带传输方式、2——传输距离（百米）</li><li>10Base-TX：T——传输介质，铜制非屏蔽双绞线</li><li>10Base-F：F——传输介质，光缆</li></ul></li><li><p>三种以太网线缆参数对比</p></li></ul><table><thead><tr><th align="center">名称</th><th align="center">电缆</th><th align="center">最大区间长度</th><th align="center">节点数/段</th><th align="center">优点</th><th align="center">接口</th><th align="center">拓扑</th></tr></thead><tbody><tr><td align="center">10Base5</td><td align="center">粗缆</td><td align="center">500m</td><td align="center">100</td><td align="center">用于主干</td><td align="center">AUI</td><td align="center">总线拓扑</td></tr><tr><td align="center">10Base2</td><td align="center">细缆</td><td align="center">200m(185m)</td><td align="center">30</td><td align="center">廉价</td><td align="center">BNC</td><td align="center">总线拓扑</td></tr><tr><td align="center">10Base-T</td><td align="center">双绞线</td><td align="center">100m</td><td align="center">1024</td><td align="center">易于维护</td><td align="center">RJ-45</td><td align="center">星型/拓展星型</td></tr></tbody></table><ul><li>10Base-T<ul><li>相比于10Base5、10Base2，优点<ul><li>安装成本大大降低</li><li>即插即用组网灵活</li><li>星型结构，故障隔离</li><li>适用于大批量制造</li><li>具有开放式标准的互操作能力</li></ul></li><li>缺点：多用户共享10Mbps信道的上行信道</li></ul></li></ul><p><img src="1554718815127.png" alt="1554718815127"></p><p>IEEE802.3协议描述了运行在各种介质上1兆到10兆速度的1-持续CSMA/CD协议的局域网标准。IEEE802.3与Ethernet在帧格式、涵盖参考模型的层数等方面有区别。DIX以太网是一种事实上的以太网标准。</p><h4 id="二进制指数回退算法"><a href="#二进制指数回退算法" class="headerlink" title="二进制指数回退算法"></a>二进制指数回退算法</h4><p>在CSMA/CD中，发送冲突后随机等待时长的算法，比如二进制指数回退算法。</p><p>冲突检测到后，时间被分成离散的时隙，时隙长度等于信号在介质上来回传输时间($51.2 \mu s$)，一般地，i次冲突后，等待的时间将从$\begin{cases} (0 \thicksim 2^i-1) \times 2\tau &amp; 0 &lt; i \le 10 \ (0 \thicksim 1023) \times 2\tau &amp; 10 &lt; i \le 16 \ 放弃发送 &amp; 16 &lt; i \end{cases} $中随机选择。</p><h4 id="经典以太网、快速以太网"><a href="#经典以太网、快速以太网" class="headerlink" title="经典以太网、快速以太网"></a>经典以太网、快速以太网</h4><p>10Base经典以太网，越来越不能满足人们对速度的需求</p><ul><li><p>提高负载的方法</p><ul><li>提速到100M</li><li>全双工</li><li>交换式网络，改集线器Hub为交换机Switch</li></ul></li><li><p>快速以太网（100M以太网——IEEE802.3u）</p><ul><li>要求：跟10M以太网兼容</li><li>基本思想：保留原有的帧格式、接口和过程规则</li><li>比特时间：100ns -&gt; 10ns</li><li>电缆最大长度：2500m - &gt; 250m</li></ul></li><li><p>编码方式</p><ul><li>10M以太网：曼彻斯特编码</li><li>快速以太网：4B/5B（4bits数据被编码成5bits信号，易实现、电压平衡、效率80%）</li></ul></li><li><p>千兆以太网（G比特以太网，GE）：IEEE802.3z</p><ul><li>兼容10/100M以太网（同时期的两个技术FDDI、ATM不兼容）</li><li>主要工作在全双工模式，若半双工，则需要CSMA/CD技术，可能带来传输距离过短的问题 -&gt; 可使用帧串、帧扩充等方法解决</li></ul></li><li><p>以太网为什么延用至今</p><ul><li>简单性和灵活性</li><li>易于维护</li><li>支持TCP/IP，互联容易</li><li>善于借鉴：4B/5B，8B/10B</li></ul></li></ul><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>以太网是多路访问协议的实现：CSMA/CD</li><li>二进制指数回退算法，降低了再次冲突的可能性</li><li>以太网类型：经典以太网、交换式以太网</li><li>以太网信道利用率</li></ul><p><img src="1554777979182.png" alt="1554777979182"></p><h3 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h3><p>以太网位于OSI参考模型的下两层， IEEE802.3位于OSI参考模型的下一层半，二者有些许差别，以太网处理的PDU是帧，DIX以太帧和IEEE802.3帧有小小差别。</p><p><img src="1554776809222.png" alt="1554776809222"></p><h4 id="IEEE802-3帧结构"><a href="#IEEE802-3帧结构" class="headerlink" title="IEEE802.3帧结构"></a>IEEE802.3帧结构</h4><ul><li>前导码+帧起始字段：8个Bytes，前7个Bytes都是10101010，最后一个字节10101011（最后一位是1表明帧的开始）。前导码的作用——表明一个帧的开始<ul><li>而在DIX以太网帧中，帧起始字段最后一位是0</li></ul></li><li>目的地址：6个Bytes（MAC地址，前24位为OUI表示某公司，后24位表序号）</li><li>源地址：6个Bytes（MAC地址，全球唯一，表示方法是’-‘、’:’、’.’配合16进制）</li><li>长度字段：表明帧长度（不包括前导码、但包括帧头帧尾），帧长度最小64字节最大1518字节<ul><li>而在DIX以太网帧中，该字段是类型字段，表明上层网络层是什么协议</li><li>如何区分是长度字段还是类型字段：判断大小，$\begin{cases} 长度字段 &amp; 大小&lt;1536(\text{0x600}) \ 类型字段 &amp; 大小 &gt; 1536(\text{0x600})\end{cases} $</li></ul></li><li>数据字段：搭载了LLC的数据，长度最小是46字节，实际内容小于46则要填充到46，如此加上帧头帧尾的18字节再能保证整个帧至少64字节。</li><li>校验字段：4个Bytes，CRC循环冗余校验，除了前导码+帧起始字段都被校验。</li></ul><h4 id="有效帧长度至少64Bytes-★"><a href="#有效帧长度至少64Bytes-★" class="headerlink" title="有效帧长度至少64Bytes ★"></a>有效帧长度至少64Bytes ★</h4><ul><li>CDMA/CD的要求：最短帧发送时间 &gt;= 冲突窗口 $2\tau$</li><li>以太网(802.3)规定，在10Mbps局域网中<ul><li>时隙$2\tau = 51.2 \mu s$</li><li>最短帧长度：$10Mbps \times 2 \tau /8 = 64\text{Bytes}$或$(51200/100ns) /8 = 64\text{Bytes}$</li></ul></li><li>为了更加容易区分有效帧和垃圾数据，以太网要求有效帧必须至少64字节</li></ul><h3 id="二层交换的基本原理"><a href="#二层交换的基本原理" class="headerlink" title="二层交换的基本原理"></a>二层交换的基本原理</h3><p>不同建筑、单位，有着许多LAN，想要将它们连接起来，可用网桥/交换机。</p><h4 id="网桥与交换机"><a href="#网桥与交换机" class="headerlink" title="网桥与交换机"></a>网桥与交换机</h4><ul><li><p>网桥</p><ul><li>工作在数据链路层，通过检查MAC地址做出转发帧的举措。</li><li>不会检查网络层（二层交换不关系三层协议），所以IPv4、IPv6、AppleTalk、ATM、IPX、OSI分组可以穿越网桥。</li></ul></li><li><p>交换器</p><ul><li>网桥的现代名称，二者不做严格的区分，交换机等同于网桥。</li></ul></li><li><p>二层交换</p><ul><li>使用网桥/交换机将LAN连接起来。</li></ul><p><img src="1555937205907.png" alt="1555937205907"></p><ul><li>网桥可将不同类型的网络，如802.11、802.3连在一起。</li></ul></li><li><p>从802.X到802.Y的网桥</p><ul><li>不用的帧格式 -&gt; 重新封装</li><li>不用的数据传输速率 -&gt; 缓存</li><li>不同的最大帧长度 -&gt; 切割<ul><li>802.3帧最长1526字节，802.11帧最长2346</li></ul></li><li>不同的安全策略</li><li>不同的服务质量要求</li></ul></li></ul><h4 id="透明的网桥（Transparent-Bridges）"><a href="#透明的网桥（Transparent-Bridges）" class="headerlink" title="透明的网桥（Transparent Bridges）"></a>透明的网桥（Transparent Bridges）</h4><ul><li>通过透明网桥将多个LAN连接起来，硬件和软件不需做任何变化。</li><li>透明网桥工作在<strong>混杂模式</strong>（Promiscuous Mode），它接收所有的帧。</li><li>当一个帧到达网桥时，他必须做出丢弃（Discard）或转发（Forward）的决策。</li><li>决策是通过在网桥内部的地址表（Hash Table）中查找目的MAC地址而作出的。</li></ul><h4 id="MAC地址表的逆向学习"><a href="#MAC地址表的逆向学习" class="headerlink" title="MAC地址表的逆向学习"></a>MAC地址表的逆向学习</h4><ul><li><p>当一个帧到达网桥/交换机的时候，若不在表中，则将大量广播该表（向除发送端口外的所有其他端口转发）。</p></li><li><p>同时做<strong>逆向学习</strong>（Backward Learning），即从到达帧的源地址认识源地址对应的主机在帧发送端口上，将这对信息写入MAC地址表。</p></li><li><p>MAC地址表的变化。因为拓扑是变化的，网桥需要适应这种变化。规则：</p><ul><li>往表中加入记录的同时，打上时间戳</li><li>到达帧的源地址在表中已有记录，更新时间戳</li><li>周期性扫描表，删除超时记录</li></ul></li></ul><h4 id="网桥工作原理"><a href="#网桥工作原理" class="headerlink" title="网桥工作原理"></a>网桥工作原理</h4><p>网桥接收到一个帧，则在MAC地址表中查找该端口。执行下述三个操作（专用的VLSL芯片可在几微秒内完成操作）：</p><ul><li>若目的端口与源端口相同，则丢弃该帧</li><li>若目的端口与源端口不同，则转发该帧</li><li>若目的端口位置（MAC地址查找不到），则广播该帧</li><li>上述三个操作也叫：过滤、泛洪/扩散、转发，是二层交换的基本原理。</li></ul><p>不同部分可以同时通信互不影响 -&gt; 网桥/交换机分割了冲突域，提高了性能</p><h3 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h3><ul><li>在网络中经常采用冗余结构，来获取可靠性（比如在两个节点建两条信道，其中一条信道损坏时也可保证通信）。</li></ul><p><img src="1555938855593.png" alt="1555938855593"></p><ul><li><p>但是环结构（回路），可能会造成一些问题</p><ul><li>多帧传送：有帧的副本到达。</li><li>广播风暴：局域网内发送的广播帧在两个Switch来回泛洪。</li><li>MAC地址库不稳定：同样帧从同一个交换机的不同端口到达，导致交换机的逆向学习结果不稳定。</li></ul></li><li><p>于是Radiation Perlman提出的生成树算法——既无“环路”又提高可靠性</p><ul><li>STP，Spanning Tree Protocol，IEEE802.1D</li><li>每一个网络有一个根网桥；每一个网桥有一个根端口；每一个网段有一个指定端口；剩下的非指定端口不被使用</li><li>生成树算法，可在有物理回路的网络中，生成逻辑无回路的生成树，但并不能保证其中的路径最优。</li></ul><p><img src="1556107611926.png" alt="1556107611926"></p><ul><li>非指定端口虽不参与数据帧的转发，但它会侦听树的工作报文。当树上某些端口失效后，非指定端口将重新启用，形成新的生成树。</li></ul></li></ul><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><ul><li><p>经典LAN：物理LAN，地理位置靠近的工作站构成。</p></li><li><p>VLAN：一组逻辑上的设备或用户，不考虑地理位置。</p></li><li><p>VLAN的实现：</p><ul><li>基于MAC地址</li><li>基于三层协议</li><li>基于端口（大多数）：在交换机内部有一张VLAN成员配置表</li></ul></li><li><p>VLAN成员跨越不同交换机（帧标记法）：</p><ul><li>帧在通过Trunk干线起点时打上标签，干线终点拆除标签（把这个帧涂上它所在VLAN的颜色）</li></ul><p><img src="1556108203186.png" alt="1556108203186"></p></li><li><p>总结</p><ul><li>VLAN是一组逻辑上的用户</li><li>一个VLAN特性等同于一个物理LAN</li><li>一个VLAN就是一个广播帧</li><li>VLAN，可使用二层交换机实现广播域的分割</li><li>帧标记法可以让帧穿过交换机的干线</li></ul></li></ul><h3 id="二层设备"><a href="#二层设备" class="headerlink" title="二层设备"></a>二层设备</h3><p>二层（数据链路层）的设备：网卡、网桥、交换机</p><h4 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h4><ul><li><p>网卡，NIC，Network Interface Card</p></li><li><p>功能</p><ul><li>Logical Link Control：网卡提供和上层通信</li><li>Naming：提供一个独特的MAC地址标识符（MAC地址烧在网卡的ROM）</li><li>Framing：封装过程的一部分，为传输比特流打包</li><li>Media Access Control：为访问共享介质提供访问策略</li><li>Signaling：创建信号和与介质的接口</li><li>网卡本身还是第一层设备，故，还有第一层的功能（内建转发器等）</li></ul></li><li><p>分类</p><ul><li>适用PC/Notebook的分类： 标准以太网卡 / pcmcia网卡</li><li>用于以太网/令牌环的分类：Ethernet NIC / TOKEN Ring NIC</li></ul></li><li><p>以太网卡</p><ul><li><p>分为Tx、Rx</p><p><img src="1556108977024.png" alt="1556108977024"></p></li></ul></li></ul><h4 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h4><ul><li>网桥，用来连接不同的LAN端</li><li>通过过滤部分交通流量（基于MAC地址，将LAN端分流），减少冲突，改善网络性能</li></ul><h4 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h4><ul><li><p>一种多端口的网桥。交换机具有比网桥更高的交换速度，支持新的功能如VLAN</p></li><li><p>交换机常被替换集线器用作以太网星型拓扑的中心，以改善现有网络的性能</p></li><li><p>交换机中地址表的维护</p><ul><li>除了直接读取数据帧中的源地址信息去更新CAM。</li><li>还有动态更新：利用时戳（每增加/引用/找到一条记录，为它打上新的时间标记），再周期性扫描时戳，过期删除</li></ul></li><li><p>交换机会利用微分段技术来创建无冲突域：LAN被交换机分割开的网段在一个大的冲突域中产生无冲突域。</p></li><li><p>交换机内虚拟的线路，就像一些拨接开关一样，端口之间的交换会建立线路，故交换机的内部，帧交换非常的快。</p></li><li><p>交换机在交换帧时的三种方式</p><ul><li>存储转发：交换机把整个帧接收下来，计算校验和并检查该帧无错再做策略。（延迟大、出错率小）</li><li>直通交换（贯穿）：在接收时即读入目的端口转发出去。（延迟小、出错率高）</li><li>无分片交换：交换时，读满64字节后才转发，不会转发碎片帧，而冲突碎片往往是小于64字节的非法短帧runt。（延迟不大、出错率不高）</li></ul></li><li><p>交换机和集线器的比较</p></li></ul><table><thead><tr><th align="center">功能</th><th align="center">网桥（二层设备）</th><th align="center">中继器（一层设备）</th></tr></thead><tbody><tr><td align="center">再生信号</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">连接采用不用MAC协议的网段</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">隔离冲突域</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">根据帧头的物理地址转发帧</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">丢弃损坏帧</td><td align="center">√</td><td align="center">×</td></tr></tbody></table><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><p>无线传输信号的性质决定了无线信道接收与发送信号时，无法采用CSMA/CD通过电压变化检测冲突的方法（Near/Far现象），同时无线网络中存在隐蔽站与暴露站的问题，因此设计了CSMA/CA来完成无线局域网下的冲突检测和避免，进行介质访问控制。</p><p>CSMA/CA利用ACK信号来避免冲突的发生，也就是说，只有当客户端收到网络上返回的ACK信号后才确认送出的数据已经正确到达目的地址。</p><p>CSMA/CA原理：</p><ul><li><p>带<strong>冲突避免</strong>的载波侦听多路访问协议。</p></li><li><p>首先检测信道是否有使用，如果检测出信道空闲，则等待一段随机时间后，才送出数据。</p></li><li><p>接收端如果正确收到此帧，则经过一段时间间隔后，向发送端发送确认帧ACK。</p></li><li><p>发送端收到ACK帧，确定数据正确传输，在经历一段时间间隔后，会出现一段空闲时间。</p></li></ul><p>隐藏站问题：</p><ul><li><p>假设有3无线通信站ABC如下所示：</p><p>A —&gt; (B &lt;— C)</p><p>其中B在C的无线电波范围内，但A不在C的无线电波范围内。此时C正在向B传送数据，而A也试图向B传送数据。此时，A不能够监听到B正在忙，而错误的认为此时可以向B传送数据了。如果A向B传送数据，则将导致错误。此即隐藏站问题。其中C是A的隐藏站。</p></li></ul><p>暴露站问题：</p><ul><li><p>假设有3无线通信站ABC如下所示：</p><p>&lt;—–(A B) —&gt; C</p><p>其中B在A的无线电波范围内，但C不在A的无线电波范围内。此时A正在传送数据（向除B以外的某通信站），而B希望给C发送数据，但是错误地认为该传送过程将会失败（因为B会监听到一次传输，所以它会错误地认为此时不能向C发送数据）。此即暴露站问题。其中A是B的暴露站。</p></li></ul><p>物理层：repeater中继器、hub</p><p>数据链路层：Bridge、switch</p><p>网络层：Router</p><p>传输层：Transport gateway</p><p>应用层：Application gateway</p><h2 id="第5章-网络层"><a href="#第5章-网络层" class="headerlink" title="第5章 网络层"></a>第5章 网络层</h2><p><img src="1559910757948.png" alt="1559910757948"></p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>网络层主要功能：将源端产生的数据包（或数据分组）送至目的机</p></li><li><p>过程中其中涉及：信息的封装、目的机识别、找源端到目的机的路由。</p></li><li><p>可能会遭遇的问题：地址不够用、丢包、拥塞</p></li><li><p>网络层内容分三大块：</p><ul><li>被路由协议——IP协议<ul><li>IP地址（用来定位目的机）</li><li>IP分组（用来解决信息的封装）</li><li>IPV6（新一代IP协议）</li></ul></li><li>路由选择协议，用来找到源机和目的机之间的最优的路径<ul><li>距离适量路由选择协议，实例RIP</li><li>链路状态路由协议，实例OSPF</li></ul></li><li>其他：ARP、ICMP、CIDR、NAT</li></ul></li><li><p>源和目的间的网络分成两大类：</p><ul><li>数据报网络：无连接的服务，携带目的机地址，一路查路由表。<ul><li>抗毁性：感知拥塞</li></ul></li><li>虚电路网络：面向连接的服务，不携带目的机地址，携带路径的标号，沿途路由器有带路径标号的路由表。</li></ul></li></ul><p><img src="1557924460893.png" alt="1557924460893"></p><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>Internet Protocol，互联网协议，TCP/IP协议栈的核心之一，其提供一种尽力而为的把数据从源送达到接收方的方法。</p><p>IP为路由提供路由所需要的信息，所以它也被称作被路由的协议，其主要包括两方面内容：</p><ul><li>IP地址（用来标识收发数据主机）</li><li>IP分组或IP数据报（信息封装的格式）</li></ul><p>IP地址32位，有二进制表示、点分十进制表示。IP地址有层次结构，比如130.1.1.1属于130.1.1.0，130.1.1.0属于130.1.0.0。</p><p>IP地址有两层结构，网络部分和主机部分，IP地址分为5大类：</p><p><img src="1557924959890.png" alt="1557924959890"></p><ul><li><p>A类地址——大型</p><ul><li>前1×8位是网络部分，后3×8位是主机部分</li><li>第一字节的最高位固定为0，故第一字节取值范围为 $0 \sim 127 $</li><li>全世界的A类地址总共只有128个</li><li>每一个A类网络可容纳 $2^{24}-2 $ 个主机</li></ul></li><li><p>B类地址——中型</p><ul><li>前2×8位是网络部分，后2×8位是主机部分</li><li>第一字节的最高位固定为10，故第一字节取值范围为 $128 \sim 191 $</li><li>全世界的B类地址总共只有 $2^{14} $ 个</li><li>每一个B类网络可容纳 $2^{16}-2 $ 个主机</li></ul></li><li><p>C类地址——小型</p><ul><li>前3×8位是网络部分，后1×8位是主机部分</li><li>第一字节的最高位固定为110，故第一字节取值范围为 $192 \sim 223 $</li><li>全世界的C类地址总共只有 $2^{21} $ 个</li><li>每一个C类网络可容纳 254 个主机</li></ul></li><li><p>区分ABC——看第一字节值的</p></li><li><p>D类：用作组播</p></li><li><p>E类：用作一些科研</p></li></ul><p>特殊的保留地址（不分配给特定主机）：</p><ul><li>网络地址：主机部分全0的地址</li><li>广播地址：主机部分全1的地址</li><li>0.0.0.0：指该主机、该网络，路由表中默认路由的目的地址</li><li>255.255.255.255：泛洪广播地址，为防广播风暴，又退化成本地广播地址</li><li>127.0.0.0：环回地址(Lookback Network)，如127.0.0.1表示本机</li><li>169.254.0.0：非正常地址，不能与外部正常通信</li></ul><p>IP地址的分配——ICANN机构：</p><p><img src="1557926123879.png" alt="1557926123879"></p><h3 id="子网规划"><a href="#子网规划" class="headerlink" title="子网规划"></a>子网规划</h3><p>IP分组如何送达子网：路由器使用子网掩码来决定分组往哪个子网转发</p><p>主路由器（边界路由器）：负责和外部联系</p><p>子网掩码：了解内部网络结构的机制</p><ul><li>点分十进制：如255.255.255.224</li><li>/网络位数+子网位数：如/27</li><li>目的网络地址 = 目的IP地址 &amp; 子网掩码</li><li>举例：131.108.2.2目的IP地址 &amp; 255.255.255.0子网掩码 = 131.108.2.0子网络地址</li><li>ABC类IP地址的子网掩码分别是：/8、/16、/24</li></ul><p>子网位由主机位借位而来，剩下的主机位中全0为网络地址、全1为广播地址，不能标识主机。</p><p><img src="1557969138343.png" alt="1557969138343"></p><p>子网位借位原则：从主机域的高位开始、借位剩下的主机部分至少为两位（网络地址和广播地址）</p><p>子网让两层IP地址结构变成了三层：网络、子网、主机。</p><h3 id="IP寻址"><a href="#IP寻址" class="headerlink" title="IP寻址"></a>IP寻址</h3><p>IP寻址</p><ul><li>根据目的IP地址找到目的网络的过程（大网络-&gt;中网络-&gt;小网络-&gt;目的机所在网络）</li><li>在中间网络，IP寻址，执行者：路由器，一个路由器称为 1 hop。</li><li>步骤<ul><li>打开分组-&gt;提取目的IP地址</li><li>定网络，查路由（将目的IP地址与子网掩码按位与运算）</li><li>重新封装，转发</li></ul></li></ul><p>MAC寻址</p><ul><li>在最后一个网络进行主机的对应，执行者：交换机。</li><li>解封装：比特流 -&gt; 帧 -&gt; 分组 -&gt; 数据段 -&gt; 数据流 -&gt; 信息</li></ul><p><img src="1557969990436.png" alt="1557969990436"></p><h3 id="IP分组"><a href="#IP分组" class="headerlink" title="IP分组"></a>IP分组</h3><p><img src="1557970498329.png" alt="1557970498329"></p><p>字段：</p><ul><li>协议版本：4位，IPv4为0100，IPv6为0110</li><li><strong>报头长度</strong>：4位，表示IP分组的头部有多长，数据范围为0101~1111，单位是 4 Byte，即最小 20 Byte，最大 60 Byte</li><li>区分服务（ds，Differentiated Service）：8位，表示分组的重要程度优先级等，可提供一定的服务质量保证、拥塞控制</li><li><strong>总长度</strong>：16位，表示包括头部和数据的数据报总长度，单位是 1 Byte，最大为 65535 Byte</li><li>分组标识号：16位，标识当前的数据分组的序列号（由发送者来分配，接收方可通过该号码来进行重组）</li><li>标志位：3位，决定分组是否要进行分片</li><li>分段偏移量：13位，分片后接收方可通过分片偏移进行重组<ul><li>为什么要分片？分组穿越的网络 MTU (载重力)不同。</li></ul></li><li><strong>生存时间（TTL）</strong>：8位，单位 hop，每经过一个路由器，重新封装时把TTL生存时间减1，当TTL=0时，分组被丢弃，向源发回一个超时消息。该字段可防止分组在网络中无限循环。</li><li><strong>用户协议</strong>：8位，指明它的上层传输层采用的协议，UDP (17)、TCP (6)</li><li>报头校验和：16位，头部计算来的互联网校验和</li><li>源IP地址</li><li>目的IP地址</li><li>数据报选项：可选、可变长的选项，长度不等，该字段允许主机支持不同的选项，比如安全、源路由、时戳等</li><li>填充：将数据报选项字段填充到32位的整数倍</li></ul><p><img src="1560167822708.png" alt="1560167822708"></p><h3 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h3><p>IPv4 的先天不足：</p><ul><li>地址危机</li><li>端到端业务模式</li><li>QoS和性能问题</li><li>配置复杂</li><li>移动性支持不够</li><li>路由表的膨胀</li><li>安全问题</li></ul><p>IPv4地址不够用，使用私人地址，端 -&gt; 端 变为 端 -&gt; 转换器 -&gt; 端</p><p>IPv6 的目标：</p><ul><li><p>支持几十亿台主机</p></li><li><p>缩减路由表的规模</p></li><li><p>简化协议，让路由器可以更快地处理分组</p></li><li><p>提供比IPv4好的安全性</p></li><li><p>更加关注服务类型 （尤其是实时数据）</p></li><li><p>允许通过指定范围来支持组播传输</p></li><li><p>允许主机在不改变地址的情况下能够漫游（移动性支持）</p></li><li><p>允许协议具有扩展性</p></li><li><p>允许新老协议共存多年</p></li></ul><p>IPv6 地址表示——冒分十进制</p><ul><li>每16位以4位十六进制表示</li><li>地址前缀长度用 “/xx” 的形式放到地址后</li><li>例如，2001:0410:0000:0001:0000:0000:0000:45ff</li><li>简化规则1，省略前导零，变为 2001:410:0:1:<strong>0:0:0</strong>:45ff</li><li>简化规则2，忽略全零，变为双冒号，变为 2001:410:0:1::45ff</li><li>注意：一个IPv6地址最多一个双冒号</li></ul><p>IPv6地址 分类：</p><p><img src="1558175988308.png" alt="1558175988308"></p><p>单播地址：</p><ul><li><p>链路本地地址（FE80::/64 + EUI-64）：FE80:: + MAC地址一分为二中间拼上 “11111111 11111110”</p></li><li><p>可聚合全球单播地址，可用来标识主机的接口，等于64位网络位+64位主机位</p><ul><li>3位，固定的001，表示只用到了全球IPv6地址的八分之一</li><li>13位，TLA顶级聚类地址，分给各大地区的网络中心</li><li>8位，保留位</li><li>24位，NLA次级聚类</li><li>16位，SLA站点级聚类</li></ul><p><img src="1558176415864.png" alt="1558176415864"></p></li></ul><p>IPv6的快速配置：</p><ul><li>IPv6主机启动时，首先生成链路本地地址，有该地址主机可和本地其他节点通信</li><li>最主要是和默认网关(内部子网路由器)的通信，获得全球IPv6地址的前缀</li><li>前缀 + InterfaceID -&gt; 全球单播地址</li><li>InterfaceID的三种生成方式：手动配、EUI-64（有安全隐患）、DHCPv6</li></ul><p>IPv6 子网规划：根据路由器数量及其支持网络，来构建寻址的分层结构，不需要精打细算</p><h3 id="IPv6分组"><a href="#IPv6分组" class="headerlink" title="IPv6分组"></a>IPv6分组</h3><p>IPv6分组由基本头部、拓展头部、载荷三部分构成，Next Header描述了三者间的关系。</p><p>IPv6分组字段：</p><ul><li><p>基本头部</p><ul><li>协议版本，4位</li><li>区分服务，8位，数据分组的服务类型，这些分组有不同的实时传输要求，表明该分组它的重要程度、优先级等</li><li>字段流标签，20位，为源端和接收端提供了一种建立伪连接的方式，即源端和接收方把一组具有同样需求并希望得到网络同等对待的数据分组打上同样一个标签或者标记</li><li>有效载荷长度，16位，指明了搭载数据的长度</li><li><strong>Next Header</strong>，8位，指明了紧跟的拓展头类型，最后一个拓展头或无拓展头则表示”用户协议”，6表示TCP，17表示UDP</li><li>跳数限制（HP），8位，同 IPv4 中TTL</li><li>源IPv6地址，128位</li><li>目的IPv6地址，128位</li><li>删除了分段功能，所以IPv6源端必须一开始就知道全部路径网络的最小MTU，以便分成合适大小的数据报文发送（PMTU算法）</li><li>删除了校验和字段，数据链路层、传输层有自己的校验和</li></ul><p><img src="1558177707706.png" alt="1558177707706"></p></li><li><p>扩展头部，可以有0…6个，用于那些省略的IPv4字段偶尔使用</p><p><img src="1558178048921.png" alt="1558178048921"></p></li><li><p>数据</p></li></ul><h3 id="IPv6过渡技术"><a href="#IPv6过渡技术" class="headerlink" title="IPv6过渡技术"></a>IPv6过渡技术</h3><p>IPv6 过程过程：</p><p><img src="1558178221468.png" alt="1558178221468"></p><p>三类基本过渡技术 (RFC-1933)：</p><ul><li>双协议栈 (Dual Stack)：服务器必须支持双栈，主机端优先用IPv6</li><li>隧道 (Tunnel)：IPv4分组可以作为无结构无意义的数据被封装在IPv6数据报中，或者反之。</li><li>翻译/转换技术：从IPv4转换到IPv6，或反过来，不仅发生在网络层，还有传输层和应用层。</li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>路由器收到IP分组后：</p><ul><li><p>解封装到L3，提取目的IP地址</p></li><li><p>目的IP地址与子网掩码进行与运算，查路由表</p></li><li><p>重封装，转发</p><ul><li>TTL -= 1</li><li>置换源和目的MAC地址</li><li>重算校验和</li><li>分片(可选)</li></ul></li></ul><p>路由表表头：目的网络/子网掩码、路径代价、下一跳、转出接口</p><p>路由信息的三种：</p><ul><li><p>直连路由：学习感知直连路由</p></li><li><p>静态路由：人工配置</p><ul><li>默认/缺省路由，找不到路可以从这转发，能避免错丢包、缩减路由表规模、减少路由器负担</li></ul><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">在小型网络中容易实施</td><td align="center">仅适用于简单网络或特殊用途（比如默认路由）</td></tr><tr><td align="center">非常安全，不会发送通告</td><td align="center">随着网络增大，配置复杂性显著增长</td></tr><tr><td align="center">总是通过同一路径到达同一目的网络</td><td align="center">需要人工更新和维护</td></tr><tr><td align="center">不需要CPU、RAM、带宽等开销</td><td align="center"></td></tr></tbody></table></li><li><p>动态路由：由路由选择协议动态生成、更新、维护</p><table><thead><tr><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">适用于有多个路由器的网络</td><td align="center">可能会使实施更加复杂</td></tr><tr><td align="center">通常不受网络规模的限制</td><td align="center">有安全隐患</td></tr><tr><td align="center">自动更新和维护路由信息</td><td align="center">需要CPU、RAM、带宽等开销来维护</td></tr></tbody></table></li></ul><p>路径优劣的量度：</p><ul><li>路径长度：由网络管理员定义每条网络链路的代价(cost)，从源到宿的代价总和为路径长度，hop (跳数)</li><li>可靠性：链路数据传输的可靠性（误码率）</li><li>延迟：数据包从源到宿需要花费的传输时间</li><li>带宽：链路的最大传输能力以及网络流量</li><li>负载：网络资源（例如路由器的CPU）的使用率</li><li>通信代价：占用通信线路的费用</li></ul><p>最优化原理：</p><ul><li><p>如果一个路由器 J 处在路由器I到路由器K的最优路径上，那么，从路由器J到路由器K的最优路径也在同样的这条路径上。</p></li><li><p>汇聚树（Sink Tree）：从所有的源到一个给定的目的地的最优路径形成的一棵树，树根是目的地。汇聚树不唯一。路由算法的目的，为所有的路由器发现和使用汇聚树。</p></li></ul><p>路由选择协议：</p><ul><li>距离矢量路由选择（Distance Vector，DV）</li><li>链路状态路由选择（Link State，LS）</li></ul><h3 id="距离矢量路由选择算法"><a href="#距离矢量路由选择算法" class="headerlink" title="距离矢量路由选择算法"></a>距离矢量路由选择算法</h3><p>DV是分布式Bellman-Ford路由算法，常被用于小型网络，RIP是一个典型的DV</p><p>工作原理：</p><ul><li>维护：每个路由器维护两个向量，$D_i、S_i$</li><li>交换：在邻居路由器之间交换路由信息（矢量）</li><li>更新：每个路由器根据收到的矢量信息更新自己的路由表</li></ul><p><img src="1558181640209.png" alt="1558181640209"></p><p><img src="1558181865453.png" alt="1558181865453"></p><p><img src="1558182101311.png" alt="1558182101311"></p><p>D-V 算法的特点：</p><ul><li>优点<ul><li>简单</li></ul></li><li>缺点<ul><li>交换的信息太大</li><li>路由信息传播慢，可能导致路径信息不一致</li><li>收敛慢</li><li>度量计数到无穷、路径环</li><li>不适合大型的网络</li></ul></li></ul><h4 id="路由选择信息协议RIP"><a href="#路由选择信息协议RIP" class="headerlink" title="路由选择信息协议RIP"></a>路由选择信息协议RIP</h4><p>RIP：Routing information protocol，路由选择信息协议。</p><p>版本：</p><ul><li>RIPv1：有类的路由选择协议</li><li>RIPv2：无类的路由选择协议，支持CIDR、VLSM等</li><li>RIPng：支持IPv6</li></ul><p>尽管在现代网络中极少使用 RIP，但是作为了解基本网络路由的基础则十分有用。</p><p>特点：</p><ul><li>RIP 是一种典型的D-V 路由选择协议</li><li>RIP 采用了跳数（hop）作为量度（metric），不能真正反映网络的状况</li><li>当量度超过15 跳，目的被认为不可达<ul><li>以防无穷计数，路由环</li></ul></li><li>默认地，每30秒钟交换一次矢量/向量信息（全部路由表）</li></ul><p>可能的问题：</p><ul><li><p>路由环路</p></li><li><p>无穷计数</p><ul><li>“好事传千里，坏事传得慢”</li><li>解决办法：定义最大跳数、加快收敛</li></ul></li><li><p>收敛慢</p><ul><li>收敛：网络查找最佳路径的过程</li><li>收敛的加快：水平分割、毒性逆转、抑制定时器、触发更新</li></ul></li><li><p>因为站得不够高看得不够远，每个路由只从近邻拿信息，无法判断正确与否，可能学习、传播过时信息。全网不断传播错误、过时信息，无法稳定、收敛</p></li></ul><h3 id="链路状态路由选择算法"><a href="#链路状态路由选择算法" class="headerlink" title="链路状态路由选择算法"></a>链路状态路由选择算法</h3><p>为解决DV站得不够高看得不够远的问题。</p><p>算法思想：</p><ul><li>发现：向邻居发Hello包，等待回复了解它们的全球唯一名字</li><li>设置：到它的每个邻居的成本度量<ul><li>链路带宽的反比</li><li>延迟：发送ECHO包，等待回复，通过测量往返时间RTT，获得合理的延迟估计值</li></ul></li><li>构造：Link State Packet，一个分组，包含发送方标识、序列号（防序列号回转问题，用32bits表示）、年龄（解决路由器崩溃和序列号损坏，每过1s，age-1，age=0则丢弃LSP）、邻居列表、到邻居的成本/度量。基于事件/时钟去触发构造。</li><li>发送：这个分组给所有其他的路由器<ul><li><strong>逆向路径转发</strong>：新的分组到达，若该分组是新的，被从除了来线路外的其他线路转发/泛洪出去；重复分组丢弃，过时分组拒绝。</li><li>保留区：到达的分组不先处理，而是每时钟时间处理一次，期间保留区的相同分组就会被丢弃</li></ul></li><li>计算：dijkstra到每个路由器的最短路径，最短路树</li></ul><p>LS路由算法特点：</p><table><thead><tr><th align="center">优点</th><th align="center">缺电</th></tr></thead><tbody><tr><td align="center">每个路由器的认识一致</td><td align="center">每个路由器需要较大的存储空间</td></tr><tr><td align="center">收敛快</td><td align="center">计算负担很大</td></tr><tr><td align="center">适合在大型网络里使用</td><td align="center"></td></tr></tbody></table><h4 id="开放的最短路径优先-OSPF"><a href="#开放的最短路径优先-OSPF" class="headerlink" title="开放的最短路径优先(OSPF)"></a>开放的最短路径优先(OSPF)</h4><p>OSPF，Open Shortest Path First。内部网关协议（IGP）中应用最广、性能最优的一个协议。</p><p>特点：</p><ul><li>可在大型网络中使用</li><li>无路由自环</li><li>OSPF支持VLSM、CIDR等</li><li>使用带宽作为度量值（$10^8 \div BW$），比如10M网络代价是 $10^8 / (10 \times 10^6) = 10 $</li><li>收敛速度快</li><li>通过分区实现高效的网络管理<ul><li>所有区域都要连到骨干区域（区域0）上</li></ul></li></ul><p>术语：</p><ul><li><p>RouterID：32位，自治系统内路由的位置标识</p></li><li><p>协议号：89</p></li><li><p>TTL=1，只被传递一跳</p></li><li><p>LSP：Link State Packet</p></li></ul><p>OSPF分组类型：</p><table><thead><tr><th align="center">OSPF数据包类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">Type 1－Hello</td><td align="center">与邻居建立和维护毗邻关系。</td></tr><tr><td align="center">Type 2－数据库描述包（DD）</td><td align="center">描述一个OSPF路由器的链路状态数据库内容（概况）</td></tr><tr><td align="center">Type 3－链路状态请求（LSR）</td><td align="center">请求相邻路由器发送其链路状态数据库中的具体条目（请求详情）</td></tr><tr><td align="center">Type 4－链路状态更新（LSU）</td><td align="center">向邻居路由器发送链路状态通告（发送详情）、事件触发</td></tr><tr><td align="center">Type 5－链路状态确认（LSAck）</td><td align="center">确认收到了邻居路由器的LSU</td></tr></tbody></table><p>全网进行同步，同步次数为 n*(n-1)/2</p><p>找到一台特别的路由器（Designated Router，指定路由器）进行同步，同步次数为 n-1</p><p>DR的选举：</p><ul><li>登记：本网段内的OSPF路由器</li><li>登记候选人：本网段内的priority&gt;0的OSPF路由器</li><li>所有的priority&gt;0的OSPF路由器都认为自己是DR</li><li>取大：选priority值最大的，若priority值相等，选Router ID最大的</li></ul><p>DR的特点：</p><ul><li>选举制：DR是路由器选出来的，而非人工指定</li><li>终身制：一旦当选，除非路由器故障，否则不会更换</li><li>世袭制：DR选出的同时，也选出BDR，DR故障后，由BDR接替DR成为新的DR</li></ul><p>OSPF维护路由信息的措施：</p><ul><li>触发更新，LSU通告</li><li>Hello分组发送的时间间隔：缺省10秒</li><li>Hello分组的失效间隔：缺省40秒</li><li>即使没有拓扑变化，LSA在条目过期（缺省30分钟）后，发送LSU，通告链路存活</li></ul><p>为什么说OSPF克服了路由自环：</p><ul><li>每一条LSA都标记了生成者（用生成该LSA的路由器的RouterID标记），其他路由器只负责传输，不会对该信息改变或错误理解</li><li>路由计算的算法是SPF，计算的结果是一棵树，路由是树上的叶子节点，从根节点到叶子节点是单向不可回复的路径。</li><li>区域之间通过规定骨干区域避免</li></ul><h3 id="无类域间路由CIDR"><a href="#无类域间路由CIDR" class="headerlink" title="无类域间路由CIDR"></a>无类域间路由CIDR</h3><p>IP 面临的两大问题：</p><ul><li>分类造成了数百万个地址浪费<ul><li>A类地址网络：16 M 个地址（太大）</li><li>C类地址网络：256个地址（太小）</li><li>B类地址网络：65,536个地址（够用）</li></ul></li><li>路由表膨胀</li></ul><p>CIDR技术的提出：</p><ul><li>Classless Inter Domain Routing</li><li>缓解了B类地址的枯竭</li><li>缩减了路由表的规模</li></ul><p>CIDR基本思想：</p><ul><li><p>分配地址方法：按需分配</p><ul><li>比如用户需要2000个IP地址，C类不足，B类太大，则分配一个块地址x.x.x.x/21</li></ul></li><li><p>如果路由表中有多个表项匹配 (这些表项有不同的子网掩码) ，使用子网掩码最长（子网最小）的那个表项</p></li><li><p>路由聚合（子网规划的相反行为）</p><ul><li>如 $\begin{cases} 200.199.48.0/24 \ 200.199.49.0/24 \200.199.50.0/24 \200.199.51.0/24 \ \end{cases} $ ，聚合成 200.199.48.0/22</li><li>聚合结果——超网（SuperNet）</li><li>聚合的前提：子网构成地址空间连续、下一跳相同</li><li>聚合的另一个好处：隔离了路由翻动（RTA下某条具体路由的Down/Up状态，不会影响到上游路由器RTZ汇总后的路由状态）</li></ul></li></ul><h3 id="网络地址翻译NAT"><a href="#网络地址翻译NAT" class="headerlink" title="网络地址翻译NAT"></a>网络地址翻译NAT</h3><p>IPv4 总地址池已枯竭，私人地址（不可路由的地址）的提出，NAT技术为私人地址而服务。</p><table><thead><tr><th align="center">Class</th><th align="center">Address Range</th><th align="center">CIDR Prefix</th></tr></thead><tbody><tr><td align="center">A</td><td align="center">10.0.0.0 - 10.255.255.255</td><td align="center">10.0.0.0/8</td></tr><tr><td align="center">B</td><td align="center">172.16.0.0 - 172.31.255.255</td><td align="center">172.16.0.0/12</td></tr><tr><td align="center">C</td><td align="center">192.168.0.0 – 192.168.255.255</td><td align="center">192.168.0.0/16</td></tr></tbody></table><p><img src="1558265511908.png" alt="1558265511908"></p><p>NAT思想：</p><ul><li>内网使用私人地址，当内网需与外网通信，私人地址转换为合法的global的IP地址</li><li>NAT转换器（NAT Box），维护地址转换表</li></ul><p>NAT优点：</p><ul><li>节省了公有IP地址</li><li>提供了内部网访问外网的灵活性</li><li>有一定的保密性</li></ul><p>NAT缺点：</p><ul><li>违背了IP的结构模型——每个IP地址唯一地标识了一台机器</li><li>将互联网改变成了“面向连接”的网络，NAT转换器维护着连接的状态，一旦它崩溃，连接也没有了</li><li>违背了最基本的协议分层原则，IP是网络层，Port是传输层，跨层工作了</li><li>如果传输层不是采用TCP或UDP，而是采用了其它的协议，NAT将不再工作</li><li>有些应用会在payload中插入IP地址，然后接收方会提取出该IP地址并使用，但是NAT转换器对此一无所知，导致该类应用不再有效</li><li>NAT让一个IP地址可以承载61,440 （65536-4096）个私人地址（超载，PAT）</li></ul><h3 id="互联网控制消息协议ICMP"><a href="#互联网控制消息协议ICMP" class="headerlink" title="互联网控制消息协议ICMP"></a>互联网控制消息协议ICMP</h3><p>ICMP（IP的姊妹协议）的诞生：</p><ul><li>IP提供的是境内传送的服务，分组可能会遭遇拥塞、丢弃<br>找不到目的机等问题</li><li>有时我们也想知道到某个目标机的路是否通达，以及延时是多少等</li><li>ICMP消息封装在IP分组中</li></ul><p>ICMP作用：</p><ul><li>向源报告差错</li><li>测试网络：ping、tracert</li></ul><p>ICMP应用——Ping：</p><ul><li>源站点发出<strong>ICMP回声请求报文</strong></li><li>目的站点接收后必须回复<strong>ICMP回声应答报文</strong></li><li>源站点接收到应答报文后决定可达不可达</li><li>应用<ul><li>测试TCP/IP是否正常工作<code>ping 127.0.0.1</code></li><li>网络设备是否正确<code>ping 本机IP地址</code></li><li>检查对外连接的路由器<code>ping 默认网关IP</code></li><li>检查与某台设备的畅通情况<code>ping IP</code></li><li>检查DNS设置<code>ping 域名</code></li><li>执行DNS反向查询<code>ping –a IP</code></li></ul></li></ul><p>ICMP应用——tracert：</p><ul><li>通过ICMP超时报文得到途径的路由器列表</li><li>源机向源机逐步发送 TTL = 1,2,…,n 的报文，得到各层超时报文</li></ul><p>ICMP应用——PMTU：</p><ul><li>求从源到目标中间穿过网络的最小MTU</li><li>发数据包，分段标记DF=1，根据反馈尝试各种长度的报文，直到到达目的机</li></ul><p>ICMP消息仅送给源机，规定ICMP消息不生成自己的差错报告（拥塞而发出的ICMP源抑制消息，该消息可能同样拥塞发出ICMP源抑制消息，以此类推）</p><h3 id="地址解析协议ARP"><a href="#地址解析协议ARP" class="headerlink" title="地址解析协议ARP"></a>地址解析协议ARP</h3><p>封装的任务：添加寻址所需的信息，比如IP地址、MAC地址</p><p>用 Address Resolution Protocol 解决只知道IP地址不知道MAC地址的问题</p><p>ARP思想：</p><ul><li>将IP地址映射到MAC地址</li><li>向周围广播：”我是128.1.2.7，谁知道128.1.2.15的MAC地址”</li><li>128.1.2.15收到询问自己的ARP请求，才回复</li></ul><p>远程主机的MAC地址解析（跨LAN进行ARP）：</p><ul><li>源将目的MAC地址填上默认网关的MAC</li><li>默认网关解封装后重封装时将源、目的MAC分别变为默认网关MAC、目的机MAC</li></ul><p>ARP的优化——ARP表：</p><ul><li>动态建立、更新、维护ARP表</li><li>机器上线/配置改变时，向周围广播免费ARP（srcIP=trgtIP），告知周边的MAC地址，不期望收到应答，若意外收到应答则表明自己的IP冲突</li><li>收到源的ARP请求非目标机虽不应答，但默默记下源的MAC地址到自己的ARP表</li><li>定时删除超时ARP信息</li><li>静态配置ARP可以解决动态更新的病毒隐患</li></ul><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞（Congestion）：子网或其一部分出现太多分组，网络性能急剧下降</p><p><img src="1558268470149.png" alt="1558268470149"></p><p>拥塞控制的两类措施：</p><ul><li>开环<ul><li>试图用良好的设计来解决问题，本质是从一开始就保证问题不会发生</li><li>很难精准估计需求</li></ul></li><li>闭环：建立在反馈环路的概念上，分三个步骤：<ul><li>监视系统，检测何时何地发生了拥塞</li><li>把这些信息传递到能够采取行动的地方</li><li>调整系统的运行，以改正问题</li></ul></li></ul><p>拥塞量度——如何得知拥塞：</p><ul><li>因为缺乏缓存空间而丢弃的分组百分比</li><li>平均队列长度</li><li>超时和重传的分组数</li><li>平均分组延迟</li><li>分组延迟的标准方差（standard deviation）</li></ul><p>拥塞处理：</p><ul><li>检测到拥塞的路由器发送一个警告分组给流量源，但是这个分组可能无法到达</li><li>每个分组可以保留一位或一个域，当拥塞度量超过阈值的时候，路由器填充该位或域，以此警告它的邻居。</li><li>主机或路由器周期性地向外显式探询</li></ul><p>拥塞（负载 &gt; 资源）的解决：</p><ul><li>增加资源<ul><li>在某些点之间使用更多的通道增加带宽（增加通路）</li><li>把流量分散到多条路径</li><li>启用空闲或备份的路由器</li></ul></li><li>降低负载<ul><li>拒绝为某些用户提供服务</li><li>给某些用户的服务降低等级</li><li>让用户更有预见性地安排他们的需求</li></ul></li></ul><p><img src="1558269223557.png" alt="1558269223557"></p><p>数据报子网中的拥塞控制：</p><ul><li>路由器监视它的输出线路和其它资源的使用情况，用 实变量 u 关联，u 介于 0.0~1.0</li><li>u 超出了阈值，对应的线路就进入到警告“warning”状态</li><li>每个新到达的分组都将被检查，看它的输出线路是否处于“警告状态”，</li><li>警告位：在分组头部中设置一个特殊的位，分组被传回源后源调整发送速度</li><li>抑制分组：路由器给源机发回一个抑制分组，并在抑制分组中指明原分组的目标地址；当源机收到抑制分组后，它会以某种百分比减少它发向该目标的流量；这段时间过后恢复原速</li><li>逐跳抑制分组：让抑制分组路径的每个路由器都采取相应的措施；代价是上游路由器的缓存空间</li></ul><p>负载脱落：</p><ul><li>分组超载后的丢弃</li><li>随机丢弃</li><li>丢弃新到达的(葡萄酒策略，适合文件传输类)</li><li>丢弃早到达的分组(牛奶策略，适合多媒体类)</li><li>丢弃不太重要的（less important）分组，需要发送方在它们的分组中标明优先级</li></ul><p>随机早期检测RED：</p><ul><li>在情况恶化之前RED，Random Early Detection</li><li>路由器检测维护队列的平均长度</li><li>为了确定何时开始丢弃数据包，路由器需要维护一个运行队列长度的平均值。当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随机丢弃一小部分数据包，随机选择丢弃的数据包使发送方发现丢包的可能性更大；因为在数据报网络中，路由器不能分辩出那个源引起了网络的最大麻烦，因此随机选择丢弃的数据包或许是最佳选择。</li></ul><h3 id="流量整形"><a href="#流量整形" class="headerlink" title="流量整形"></a>流量整形</h3><p>用户产生的流量忽大忽小，流量整形就是调节数据传输的平均速率和突发数据流，以减少突发而带来的拥塞、缓存溢出、丢包等问题。</p><p>算法：</p><ul><li>漏桶，Leaky Bucket</li><li>令牌桶，Token Bucket</li><li>其他：资源预留、准入控制、分组调度等</li></ul><p>漏桶：</p><ul><li>每个主机连接到网络的接口中都有一个漏桶，即一个优先长度的内部队列</li><li>当桶中有分组的时候，输出速率是恒定的，当桶空的时候，输出速率是0</li><li>当一个分组到达满的桶的时候，分组将被丢弃（满则溢）</li><li>每个时钟周期tick，仅允许一个分组或固定数量的分组发送出去</li></ul><p><img src="1558270014689.png" alt="1558270014689"></p><p>令牌桶：</p><ul><li>改进了漏桶中桶满溢出的问题，桶满丢令牌而不丢分组</li><li>允许有上限的数据输出突发</li><li>令牌桶拥有令牌（tokens），且以每△T秒产生一个令牌的速度往桶中输入令牌</li><li>一个分组要发送的时候，它必要从桶中取出和获取到一个令牌</li><li>令牌桶算法允许累积令牌，但最多可以累积 n（令牌桶的容量）个令牌</li></ul><p><img src="1558270247599.png" alt="1558270247599"></p><p>最大突发时间的计算：</p><ul><li>设突发时间：S 秒</li><li>已知，令牌桶容量 B 字节，令牌到达速率 R 字节/秒，最大输出速率 M 字节/秒</li><li>得到 B+ RS = MS，即 S = B/(M-R)</li></ul><p><img src="1558270547098.png" alt="1558270547098"></p><h2 id="第6章-传输层"><a href="#第6章-传输层" class="headerlink" title="第6章 传输层"></a>第6章 传输层</h2><p><img src="1559910777475.png" alt="1559910777475"></p><h3 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h3><p>传输层：整个协议栈(TCP/IP)的核心</p><p>任务：提供可靠、高效、性价比高的数据传输</p><p>传输实体：</p><ul><li>是任务完成的硬件或软件</li><li>可以存在操作系统的内核</li><li>可以以一个链接库的形式绑定到网络应用中</li><li>可以以一个独立的用户进程运行</li><li>可以实现在网卡上</li></ul><p>传输层用网络层的接口，为上层应用层提供服务，也分面向连接/无连接两种</p><p><img src="1559873590366.png" alt="1559873590366"></p><p>传输层、网络层分层原因：</p><ul><li>网络层运行在由承运商操作的路由器上，用户无法真正控制到网络层，只能眼睁睁看着丢包、延迟</li><li>把另一层放在网络层之上，可让用户能够控制道服务质量</li><li>传输层原语独立于网络层原语，而网络层原语会因网络的不同而不同</li><li>两层的作用范围不同<ul><li>网络层负责把数据从源机送达目的机，hostToHost</li><li>传输层负责把数据送到具体的应用进程，endToEnd</li></ul></li></ul><p>传输层、数据链路层对比：</p><ul><li>功能相似<ul><li>流控制、差错控制、数据(报文/帧)排序</li></ul></li><li>传输环境不同<ul><li>一个是通信子网，一个是物理信道<br><img src="1559873974316.png" alt="1559873974316"></li></ul></li></ul><p>数据段：</p><ul><li>TPDU（Transport Protocol Data Unit），传输层协议数据单元。是从传输实体发到对端传输实体的信息</li><li>TPDUs 被封装在分组（packet）中，由网络层交换</li><li>分组被封装在帧（frames）中，由数据链路层交换</li></ul><p><img src="1559874068764.png" alt="1559874068764"></p><p>传输层两大协议：</p><ul><li>用户数据报协议，UDP，User Datagram Protocol</li><li>传输控制协议，TCP，Transport Control Protocol</li></ul><h3 id="用户数据报协议UDP"><a href="#用户数据报协议UDP" class="headerlink" title="用户数据报协议UDP"></a>用户数据报协议UDP</h3><p>UDP 是一个无连接的（connectionless）的传输层协议。</p><p>UDP传输数据段，无须建立连接，不提供数据的可靠传输。与IP数据分组类似，但不可用IP分组替代UDP，因为UDP有使用源端口、目的端口。</p><p>UDP数据段头——头部+数据：</p><ul><li>头部第1字段，源端口，16bits</li><li>头部第2字段，目的端口，16bits</li><li>头部第3字段，长度字段，表示包括头部和数据共多少字节，16bits</li><li>头部第4字段，校验和，可选(不选择填0)，16bits<br><img src="1559874530918.png" alt="1559874530918"></li></ul><p>端口Port：</p><ul><li>16位，0~65535</li><li>&lt; 1023，知名端口，用于公共应用（保留，全局分配，用于标准服务器），IANA分配</li><li>1024-49151，非特权用户端口，注册端口，比如BT使用6881-6887</li><li>$\ge$ 49152，动态端口，私人端口</li><li>自由端口 free port<ul><li>本地分配、动态随机端口</li></ul></li></ul><p>校验和的计算：</p><ul><li><p>IP伪头部、UDP头部、数据按16位列好，按列反码求和，结果取反<br><img src="1559875419126.png" alt="1559875419126"></p></li><li><p>其中用到的IP伪头部：<br><img src="1559875455920.png" alt="1559875455920"></p></li><li><p>接收方计算结果为全1，则传输无错。</p></li><li><p>CRC校验和纠错能力较弱。</p></li><li><p>校验和计算中使用了IP地址，这破坏了分层原则</p></li></ul><p>UDP特点：</p><ul><li><p>提供端点标识，端到端的数据传输</p></li><li><p>不提供差错控制和可靠传输，但简洁高效</p></li></ul><h3 id="通信模型"><a href="#通信模型" class="headerlink" title="通信模型"></a>通信模型</h3><p>端到端，端点即套接字(Socket)，Socket包括(IP, Port)</p><p>通信五元组：(源IP, 源Port, 目的IP, 目的Port, TCP/UDP协议)</p><p>已分配的知名端口号：<br><img src="1559875906061.png" alt="1559875906061"></p><h3 id="TCP数据段"><a href="#TCP数据段" class="headerlink" title="TCP数据段"></a>TCP数据段</h3><p>TCP协议：</p><ul><li><p>是为在不可靠的互联网上提供可靠的端到端的字节流而设计</p></li><li><p>TCP必须动态适应不同拓扑、带宽、延迟、分组大小、其他网络参数，在出错时要求足够健壮</p></li><li><p>支持TCP的机器都有一个TCP 实体，或者是用户进程或者是操作系统内核，都可以管理TCP流和跟IP层的接口</p></li><li><p>发方：封装。</p><ul><li>TCP实体接收本地进程的用户数据流，将其分割成不超过64kB的分片（实践中，通常分割成1460字节，以通过以太网传输）</li></ul></li><li><p>收方：解封装</p><ul><li>当包含TCP数据段的报文到达某台机器的时候，被提交给传输实体，传输实体将其重构出原始的字节流</li></ul></li><li><p>TCP连接上每个字节都有一个32位序列号</p></li><li><p>收发方不以字节而是以数据段的形式交换数据</p></li></ul><p>TCP数据段大小的确定——限制其的两个因素：</p><ul><li>IP分组的载荷限制<ul><li>TCP数据段必须适合IP的65515的载荷限制，65515=65535-IP头的20</li></ul></li><li>下层网络的MTU<ul><li>比如以太网载荷大小，1500字节</li></ul></li></ul><p>TCP数据段（TPDU）格式：</p><p><img src="1559876462155.png" alt="1559876462155"></p><ul><li>head，20字节的头部（去掉可选项<br>Options，变长的数据字段/域（可是0个或更多字节<br>Data</li><li>头部第1字段，源端口，16bits</li><li>头部第2字段，目的端口，16bits</li><li>头部第3字段，序列号，表示一个字节的编号，32bits<ul><li>ISNs(initial sequence numbers)：初始序列号，是随机产生的</li><li>SYN：携带了ISNs 和SYN 控制位的数据段</li></ul></li><li>头部第4字段，确认号，表示期望对方发来的字节的编号，32bits<ul><li>TCP的可靠传输保证，采用肯定确认机制和累计确认技术。</li><li>如确认号是500，表示收到了发方发送的499、498…等字节。下次我就可以发500序列号的字节过去了。</li></ul></li><li>头部第5字段，TCP段头长度，单位是4字节，4bits</li><li>下一字段是保留字段，现在逐步启用做拥塞控制</li><li>头部第6、7、8、9、10、11字段，控制比特，URG、ACK、PSH、RST、SYN、FIN，各1bit<ul><li>URG：当紧急指针使用的时候，URG 被置为1，表明有紧急数据，必须先处理。</li><li>ACK：等于1表示确认号有效，启用了捎带确认，等于0表示确认号无效</li><li>PSH：表示这是带有PUSH标志的数据，接收方收到这样的数据，应该立刻送到上层，而不需要缓存它</li><li>RST：被用来重置一个已经混乱的连接。如果在连接建立阶段，就直接拒绝建立连接</li><li>SYN：用在连接建立过程中。与ACK配合使用可以表示连接请求(SYN=1,ACK=0)或连接接收(SYN=1,ACK=1)</li><li>FIN：被用来释放连接，表示发送方已经没有数据要传输，但可继续接收数据</li></ul></li><li>头部第12字段，窗口尺寸，告诉对方可以发送的数据字节数，即从确认字节号开始，连续发送的字节总数，16bits<ul><li>为避免接收方被大量涌入的数据所淹没，TCP实体进行了流量控制，用可变长的滑动窗口来完成，这个窗口尺寸的大小取决于接收方</li></ul></li><li>头部第13字段，校验和，16bits</li><li>头部第14字段，紧急指针，与URG控制位配合使用，16bits<ul><li>紧急指针是一个对于当前序列号的字节偏移量，标明紧急数据从哪里开始。</li></ul></li><li>Options，选项域，提供了一种增加基本头没有包含内容的方法</li></ul><h3 id="TCP三次握手建立连接"><a href="#TCP三次握手建立连接" class="headerlink" title="TCP三次握手建立连接"></a>TCP三次握手建立连接</h3><p>TCP，提供面向连接的服务，其连接通过三次握手来建立。</p><p>TCP连接的建立：</p><ul><li>Host1发送连接请求，控制位SYN=1, ACK=0。SEQ=x，x是随机产生的初始序列号</li><li>Host2接收后，回答，控制位SYN=1, ACK=1。SEQ=y，y是初始序列号，ACK Number=x+1，表示对x之前的字节都确认收到</li><li>Host1接收应答，回发最后的确认，控制位SYN=0, ACK=1。SEQ=x+1，ACk Number=y+1，表示对y之前的字节确认收到</li></ul><p><img src="1559877835005.png" alt="1559877835005"></p><ul><li>三次握手也称为同步，在这个过程中双方交换了初始序列号x、y，用来跟踪后续交换的每一个字节</li><li>TCP双方没有主从之分，是全双工的</li></ul><p>DoS攻击：</p><ul><li>利用三次握手，SYN泛洪，导致DoS攻击。</li><li>控制一些主机向Server发送很多第一次握手信息，SYN里伪造并不存在的源IP地址</li><li>服务器会这些信息回发第二次握手信息，并且等待第三次握手信息，第二次握手信息无法到达发送者，第三次握手信息等待不来，这让服务器挂起很多资源等待，资源耗尽而瘫痪，无法提供正常服务</li></ul><h3 id="TCP连接释放"><a href="#TCP连接释放" class="headerlink" title="TCP连接释放"></a>TCP连接释放</h3><p>TCP连接释放：</p><ul><li>任何一方没数据要发送时，都可发送一个FIN置位的TCP数据段</li><li>当FIN被确认时，该方式的连接被关闭</li><li>当双向连接都关闭后，连接释放</li></ul><p>TCP连接的释放是对称，要求两方的释放请求都被确认，而一次只能确认一个，这有一些问题，解决方案是把释放连接的决定权交给请求者：</p><ul><li>一方发送 连接释放请求DR（Disconnect Request），并期待对方的确认ACK</li><li>DR到达接收端，它回发ACK，并且也发送一个DR</li><li>ACK到达发送端，连接释放；同时回发确认ACK，当这个ACK到达接收端，反方向的连接也释放。</li></ul><p>采用定时器：</p><ul><li>避免DR、ACK丢失而引发的问题，在任何时候发出DR的同时，都启动一个定时器</li><li>如果一方发送了FIN置位的DR数据段出去，若在定时器超时都没收到应答，释放连接</li><li>另一方最终也会注意到连接的对方已不在，即定时器超时后连接释放</li></ul><p>杀死半开放连接：</p><ul><li>半开放连接：最初的DR及其重传都丢失了的话，发送者因超时放弃继续发送且释放连接，但另一端却不知道这些情况仍处于活跃的状态。</li><li>杀死方式：在一定时间内没有TPDUs到达则单方面自动释放；同时利用定时器，超时时自动发一个哑TPDU（dummy TPDU），避免被对方释放。</li></ul><p><img src="1559890733795.png" alt="1559890733795"></p><h3 id="TCP传输策略"><a href="#TCP传输策略" class="headerlink" title="TCP传输策略"></a>TCP传输策略</h3><p>TCP传输策略：</p><ul><li><p>类似LLC，TCP链路传输，采用了基本的肯定确认重传机制。</p></li><li><p>使用Window Size字段进行流量控制：</p><ul><li>TCP是以数据段的形式传输数据的，一个数据段包含很多个字节，相当于批量传输。为避免大量数据淹没接收方，采用流量控制技术。</li><li>下图中，Sender先发送了一个2k的数据，Receiver接收到时缓存窗口还是空的，回复确认接收到2k数据并且告诉对方窗口大小还剩2k；<br>然后对方收到后就满打满算发了2k过来，此时Receiver窗口已满，回复的信息中win=0，告诉对方不要再发过来；<br>待Receiver的应用读取了缓冲中的数据后，又空出2k的缓存，此时Receiver发送一条win=2048的信息告诉对方更新可发送大小；<br>然后对方发了1k的数据过来….<img src="1559891157804.png" alt="1559891157804"></li></ul></li><li><p>当窗口数为0时，发送者不能正常发送数据段，除非：</p><ul><li>Urgent紧急数据。比如用户想杀掉远端机器上的进程时</li><li>发送者可发送一个字节的数据段，以便让接受者再次发送(期待接收的字节号或ACK, WIN)，以免死锁</li></ul></li><li><p>优化接收端，不要急着回复确认</p><ul><li>接收端推迟500ms发送确认分组和窗口更新，以便可免费搭载在处理后的回显分组内（free ride便车）</li></ul></li><li><p>优化发送端——Nagle’s Algorithm</p><ul><li>当数据以一次一字节的速度到达的时候，只发送第一个字节，然后将后续的字节缓存起来，直到发出的字节得到确认；<br>将缓存起来的字节在一个数据段中发出，再继续缓存，直到发出的数据得到确认。<br><img src="1559891840768.png" alt="1559891840768"></li><li>Nagle算法在很多TCP上实现，但是有些时候最好禁用，比如：当一个X-Windows应用在互联网运行的时候，鼠标的移动事件必须发送给远程计算机，把这些移动事件收集起来一批一批发送出去，使得鼠标的移动极不连贯</li></ul></li></ul><p>傻瓜窗口综合征：</p><ul><li>silly window syndrome problem</li><li>当有大块数据被传递给发送端TCP实体，但接收端的交互式应用每次只读取一个字节的时候，往返发送的有效信息大小与代价相差甚远。</li></ul><p><img src="1559892080424.png" alt="1559892080424"></p><ul><li><p>解决方案——Clark解决方案</p><ul><li>阻止接收方发送只有1个字节的窗口更新，相反，它必须等待一段时间，当有了一定数量的空间之后再告诉发送方</li><li>接收方可以可以维护一个内部缓冲，且阻塞上层应用的READ 请求，直到它有大块的数据提供</li></ul><p><img src="1559892170877.png" alt="1559892170877"></p></li></ul><p>发送方和接收方的优化：</p><ul><li>发送方，Nagle’s Algorithm。尽量不发送数据含量小的数据段；缓存应用层数据到一定量才发送</li><li>接收方，Clark’s Solution。不请求对方发送短数据段(Window Size)；延迟窗口变更信息，使接收缓冲区足够大</li></ul><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>虽然网络层也管理拥塞，但大多数管理任务由TCP完成。</p><p>因为针对拥塞的真正解决方案是减慢数据率，所以TCP拥塞控制遵循分组守恒原则，即老分组离开后新分组才注入网络。</p><p>拥塞检测：</p><ul><li>Congestion Detection</li><li>所有的互联网TCP算法都假定超时是由于拥塞引起的，并通过监视超时的情况来判断是否出现问题</li></ul><p>拥塞控制：</p><ul><li>Congestion Control</li><li>当一个连接建立的时候，双方选择一个合适的窗口大小，接收方根据自己的缓冲区大小来指定窗口的大小</li><li>若发送者遵循这窗口大小的限制，则接收端不会出现缓冲区溢出的问题，但可能由于网络内部的拥塞而发生问题</li></ul><p>拥塞的两种情形：</p><ul><li>接收方容量不足，比如快速的网络向小容量接收方传输数据</li><li>网络容量瓶颈，比如慢速的网络向大容量的接收方传输数据</li></ul><p>拥塞控制：</p><ul><li>针对拥塞的两种情形，单独解决问题</li><li>发送者维护两个窗口：<ul><li>接受者窗口，反映了目前接受者的处理能力（容易获取）</li><li>拥塞窗口cwnd，反映了目前网络容量（难以获取）</li><li>发送数据大小 = 上述两个窗口的较小值</li></ul></li></ul><p>慢启动算法Slow Start：</p><ul><li><p>获取拥塞窗口大小。</p></li><li><p>指数的增长：连接建立时，发送者用当前使用的最大数据段长度MaxSeqL初始化拥塞窗口，然后发送一个最大的数据段，若在定时器超时前得到确认，则将拥塞窗口翻倍，发送两个数据段，直到超时。</p></li><li><p>线性的增长：采用阈值参数，初始为64K，拥塞窗口增长到阈值时，就停止指数增长，按照线性增长，即每次成功的传输让拥塞窗口增加一个最大的数据段长度。<br>当超时发生时，阈值降为当前拥塞窗口的一半，同时将拥塞窗口重设为一个最大的数据段的长度，重新开启新一次的慢启动。</p></li><li><p>下图，一开始阈值Threshold=32k，当指数增长到阈值时改为线性增长，在第14次发送时超时，阈值设为拥塞窗口的一半20k，且发送窗口重置为一个数据段大小，重新开启新一次的慢启动。</p></li></ul><p><img src="1559893660399.png" alt="1559893660399"></p><ul><li>线性增长，可将窗口尝试粒度变小，以获得更准确的拥塞窗口值</li><li>TCP慢启动算法就是这样不断超时、不断重启，尝试出的拥塞窗口值也随之网络状况变化而变化，达到拥塞控制的目的</li><li>快速恢复：重新慢启动时，拥塞窗口值可以不重置为一个数据段大小，而是设置为阈值大小，从这里开始直接线性增长<br><img src="1559893983058.png" alt="1559893983058"></li></ul><p>任何时候，若TCP传输实体接收到一个ICMP抑制分组，则这个事件被当作超时对待。</p><h3 id="TCP定时器等"><a href="#TCP定时器等" class="headerlink" title="TCP定时器等"></a>TCP定时器等</h3><p>TCP采用肯定确认重传技术，保证每一个字节的可靠传输。</p><p>重传定时器：</p><ul><li>retransmission timer</li><li>为了解决数据段丢失的问题，每发一个数据段都会启动一个重传定时器</li><li>其时间设置需要良好的考量，设置过长则等待过长，设置过短引发频繁超时重传</li></ul><p>持续定时器：</p><ul><li><p>persistence timer</p></li><li><p>用来避免以下死锁deadlock发生</p><ul><li>接收方发送了一个窗口数为零的确认（窗口更新），告诉发送方等待。<br>稍后，接收方空出了缓冲，发送更新窗口的数据段，但是该分组丢失啦！<br>现在，收发双方都在等待对方发送数据段过来，但永远等不到，死锁产生。</li></ul></li><li><p>发送方在收到win=0时，启动一个持续定时器，如果定时器超时没有收到更新窗口，则发送一个探测数据段，引发对方重新发出更新窗口。</p></li></ul><p>保活定时器：</p><ul><li>keep-alive timer</li><li>用来检查连接是否存活，当一个连接空闲的时间超过保活定时器的时间，该连接将被杀掉。</li></ul><p>在关闭时刻处于TIMED WAIT状态中使用的定时器：</p><ul><li>运行两倍的最大分组生存时间，以确保连接关闭之后，该连接上的所有分组都完全消失。</li></ul><h2 id="第7章-应用层"><a href="#第7章-应用层" class="headerlink" title="第7章 应用层"></a>第7章 应用层</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>工作原理：</p><ol><li>应用程序以域名作为参数调用解析器</li><li>解析器发送UDP分组给本地DNS服务器</li><li>如果待查询域名在该DNS服务器的管辖范围内或存在缓存则返回资源记录给解析器</li><li>反之则本地DNS服务器向根域名服务器发送一条查询此域的迭代查询请求。</li><li>根域名服务器会返回所查询域的IP地址或者本地DNS服务器下一步应该向之查询的域名服务器地址。</li><li>本地域名服务器向正确的域名服务器查询到IP后返回给解析器。同时缓存查询过的域名服务器地址。</li></ol></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://zhangt.top/CS/Computer-Network-Study-Notes/">计算机网络-学习笔记</a></li><li><strong>本文作者：</strong><a href="https://zhangt.top">ZhangT</a></li><li><strong>本文链接：</strong><a href="https://zhangt.top/CS/Computer-Network-Study-Notes/">https://zhangt.top/CS/Computer-Network-Study-Notes/</a></li><li><strong>发布时间：</strong>2019-05-02</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><hr style="height:1px;margin:1rem 0"><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><i class="fas fa-tags has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/tags/ComputerNetwork/">ComputerNetwork</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？投喂一下吧！ヾ(●´∀｀●)</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i> </span><span>支付宝</span><div class="qrcode"><img src="/images/alipay.jpg" alt="支付宝"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/CS/Computer-Graphics-Study-Notes/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">计算机图形学-学习笔记</span></a></div><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/ACM/ACMLife-0_2-Java-Summarize/"><span class="level-item">ACMLife-0_2-Java总结</span> <i class="level-item fas fa-chevron-right"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"91f36240e98756fc091e",clientSecret:"20de2f4dadd54bc04ad8db6c1090fb00a9477ac4",id:"5ba9f42ea9bf25160a737a3fc7428b2c",repo:"zhangt2333.github.io",owner:"zhangt2333",admin:"zhangt2333",createIssueManually:!1,distractionFreeMode:!1});gitalk.render("comment-container")</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered"><div><img class="image is-96x96 has-mb-6" src="/images/avatar.png" alt="Zhang T"><p class="is-size-4 is-block">Zhang T</p><p class="is-size-6 is-block">感受我的感受</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Nanjing &lt;- Qingdao, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><div class="level-item has-text-centered is-marginless"><a href="/archives/"><p class="heading">文章</p><p class="title has-text-weight-normal">21</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/categories/"><p class="heading">分类</p><p class="title has-text-weight-normal">5</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/tags/"><p class="heading">标签</p><p class="title has-text-weight-normal">23</p></a></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/zhangt2333" target="_blank"><i class="fab fa-github"></i>&nbsp;&nbsp;关注我</a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu" style="max-height:750px;overflow:auto"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#第1章-引言"><span class="has-mr-6">1</span> <span>第1章 引言</span></a><ul class="menu-list"><li><a class="is-flex" href="#网络硬件"><span class="has-mr-6">1.1</span> <span>网络硬件</span></a></li><li><a class="is-flex" href="#网络软件"><span class="has-mr-6">1.2</span> <span>网络软件</span></a><ul class="menu-list"><li><a class="is-flex" href="#协议层次结构"><span class="has-mr-6">1.2.1</span> <span>协议层次结构</span></a></li><li><a class="is-flex" href="#面向连接与无连接服务"><span class="has-mr-6">1.2.2</span> <span>面向连接与无连接服务</span></a></li><li><a class="is-flex" href="#服务原语"><span class="has-mr-6">1.2.3</span> <span>服务原语</span></a></li></ul></li><li><a class="is-flex" href="#参考模型"><span class="has-mr-6">1.3</span> <span>参考模型</span></a><ul class="menu-list"><li><a class="is-flex" href="#OSI模型"><span class="has-mr-6">1.3.1</span> <span>OSI模型</span></a></li><li><a class="is-flex" href="#TCP-IP模型"><span class="has-mr-6">1.3.2</span> <span>TCP/IP模型</span></a></li><li><a class="is-flex" href="#本书模型"><span class="has-mr-6">1.3.3</span> <span>本书模型</span></a></li></ul></li><li><a class="is-flex" href="#常用术语"><span class="has-mr-6">1.4</span> <span>常用术语</span></a></li></ul></li><li><a class="is-flex" href="#第2章-物理层"><span class="has-mr-6">2</span> <span>第2章 物理层</span></a><ul class="menu-list"><li><a class="is-flex" href="#数据通信的理论基础"><span class="has-mr-6">2.1</span> <span>数据通信的理论基础</span></a><ul class="menu-list"><li><a class="is-flex" href="#调制解调"><span class="has-mr-6">2.1.1</span> <span>调制解调</span></a></li><li><a class="is-flex" href="#理论基础"><span class="has-mr-6">2.1.2</span> <span>理论基础</span></a></li></ul></li><li><a class="is-flex" href="#引导性传输介质"><span class="has-mr-6">2.2</span> <span>引导性传输介质</span></a><ul class="menu-list"><li><a class="is-flex" href="#同轴线缆"><span class="has-mr-6">2.2.1</span> <span>同轴线缆</span></a></li><li><a class="is-flex" href="#双绞线"><span class="has-mr-6">2.2.2</span> <span>双绞线</span></a></li><li><a class="is-flex" href="#电力线"><span class="has-mr-6">2.2.3</span> <span>电力线</span></a></li><li><a class="is-flex" href="#光纤"><span class="has-mr-6">2.2.4</span> <span>光纤</span></a></li></ul></li><li><a class="is-flex" href="#无线传输"><span class="has-mr-6">2.3</span> <span>无线传输</span></a><ul class="menu-list"><li><a class="is-flex" href="#无线电传输"><span class="has-mr-6">2.3.1</span> <span>无线电传输</span></a></li><li><a class="is-flex" href="#光通信"><span class="has-mr-6">2.3.2</span> <span>光通信</span></a></li></ul></li><li><a class="is-flex" href="#复用技术★"><span class="has-mr-6">2.4</span> <span>复用技术★</span></a><ul class="menu-list"><li><a class="is-flex" href="#频分多路复用FDM"><span class="has-mr-6">2.4.1</span> <span>频分多路复用FDM</span></a></li><li><a class="is-flex" href="#波分多路复用WDM"><span class="has-mr-6">2.4.2</span> <span>波分多路复用WDM</span></a></li><li><a class="is-flex" href="#时分多路复用TDM"><span class="has-mr-6">2.4.3</span> <span>时分多路复用TDM</span></a></li><li><a class="is-flex" href="#码分多路复用CDMA"><span class="has-mr-6">2.4.4</span> <span>*码分多路复用CDMA</span></a></li></ul></li><li><a class="is-flex" href="#调制技术★"><span class="has-mr-6">2.5</span> <span>调制技术★</span></a><ul class="menu-list"><li><a class="is-flex" href="#基带传输"><span class="has-mr-6">2.5.1</span> <span>基带传输</span></a></li><li><a class="is-flex" href="#通带传输"><span class="has-mr-6">2.5.2</span> <span>通带传输</span></a></li></ul></li><li><a class="is-flex" href="#公共电话交换网络PSTN★"><span class="has-mr-6">2.6</span> <span>公共电话交换网络PSTN★</span></a><ul class="menu-list"><li><a class="is-flex" href="#电话系统结构"><span class="has-mr-6">2.6.1</span> <span>电话系统结构</span></a></li><li><a class="is-flex" href="#本地回路——调制解调器、ADSL和光纤"><span class="has-mr-6">2.6.2</span> <span>本地回路——调制解调器、ADSL和光纤</span></a></li><li><a class="is-flex" href="#中继线（干线）和多路复用★"><span class="has-mr-6">2.6.3</span> <span>中继线（干线）和多路复用★</span></a></li><li><a class="is-flex" href="#交换局"><span class="has-mr-6">2.6.4</span> <span>交换局</span></a></li></ul></li><li><a class="is-flex" href="#移动电话系统"><span class="has-mr-6">2.7</span> <span>移动电话系统</span></a><ul class="menu-list"><li><a class="is-flex" href="#常用术语-1"><span class="has-mr-6">2.7.1</span> <span>常用术语</span></a></li><li><a class="is-flex" href="#1G：模拟语音"><span class="has-mr-6">2.7.2</span> <span>1G：模拟语音</span></a></li><li><a class="is-flex" href="#2G：数字语音"><span class="has-mr-6">2.7.3</span> <span>2G：数字语音</span></a></li><li><a class="is-flex" href="#3G：数字语音和数据"><span class="has-mr-6">2.7.4</span> <span>3G：数字语音和数据</span></a></li></ul></li><li><a class="is-flex" href="#有线电视"><span class="has-mr-6">2.8</span> <span>有线电视</span></a><ul class="menu-list"><li><a class="is-flex" href="#频谱分配"><span class="has-mr-6">2.8.1</span> <span>频谱分配</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第3章-数据链路层DLL"><span class="has-mr-6">3</span> <span>第3章 数据链路层DLL</span></a><ul class="menu-list"><li><a class="is-flex" href="#DLL概述"><span class="has-mr-6">3.1</span> <span>DLL概述</span></a><ul class="menu-list"><li><a class="is-flex" href="#DLL功能"><span class="has-mr-6">3.1.1</span> <span>DLL功能</span></a></li><li><a class="is-flex" href="#成帧——使接收方很容易发现一个新帧的开始★"><span class="has-mr-6">3.1.2</span> <span>成帧——使接收方很容易发现一个新帧的开始★</span></a></li></ul></li><li><a class="is-flex" href="#差错处理概述"><span class="has-mr-6">3.2</span> <span>差错处理概述</span></a><ul class="menu-list"><li><a class="is-flex" href="#概念"><span class="has-mr-6">3.2.1</span> <span>概念</span></a></li><li><a class="is-flex" href="#海明距离、海明码"><span class="has-mr-6">3.2.2</span> <span>海明距离、海明码</span></a></li><li><a class="is-flex" href="#Internet-互联网-校验和"><span class="has-mr-6">3.2.3</span> <span>Internet(互联网)校验和</span></a></li><li><a class="is-flex" href="#循环冗余校验码CRC"><span class="has-mr-6">3.2.4</span> <span>循环冗余校验码CRC</span></a></li></ul></li><li><a class="is-flex" href="#基本数据链路协议1-3"><span class="has-mr-6">3.3</span> <span>基本数据链路协议1~3</span></a><ul class="menu-list"><li><a class="is-flex" href="#无限制的单工协议——乌托邦式"><span class="has-mr-6">3.3.1</span> <span>无限制的单工协议——乌托邦式</span></a></li><li><a class="is-flex" href="#单工停-等协议"><span class="has-mr-6">3.3.2</span> <span>单工停-等协议</span></a></li><li><a class="is-flex" href="#有噪声信道的单工协议"><span class="has-mr-6">3.3.3</span> <span>有噪声信道的单工协议</span></a></li></ul></li><li><a class="is-flex" href="#滑动窗口协议"><span class="has-mr-6">3.4</span> <span>滑动窗口协议</span></a><ul class="menu-list"><li><a class="is-flex" href="#1位滑动窗口协议"><span class="has-mr-6">3.4.1</span> <span>1位滑动窗口协议</span></a></li><li><a class="is-flex" href="#回退N协议——Go-Back-n"><span class="has-mr-6">3.4.2</span> <span>回退N协议——Go Back n</span></a></li><li><a class="is-flex" href="#选择性重传协议——Select-Repeat"><span class="has-mr-6">3.4.3</span> <span>选择性重传协议——Select Repeat</span></a></li></ul></li><li><a class="is-flex" href="#PPP协议"><span class="has-mr-6">3.5</span> <span>PPP协议</span></a></li><li><a class="is-flex" href="#常用术语-2"><span class="has-mr-6">3.6</span> <span>常用术语</span></a></li></ul></li><li><a class="is-flex" href="#第4章-介质访问控制层"><span class="has-mr-6">4</span> <span>第4章 介质访问控制层</span></a><ul class="menu-list"><li><a class="is-flex" href="#MAC子层概述"><span class="has-mr-6">4.1</span> <span>MAC子层概述</span></a></li><li><a class="is-flex" href="#ALOHA协议"><span class="has-mr-6">4.2</span> <span>ALOHA协议</span></a><ul class="menu-list"><li><a class="is-flex" href="#纯ALOHA工作原理"><span class="has-mr-6">4.2.1</span> <span>纯ALOHA工作原理</span></a></li><li><a class="is-flex" href="#分隙ALOHA协议（Slotted-ALOHA）工作原理"><span class="has-mr-6">4.2.2</span> <span>分隙ALOHA协议（Slotted ALOHA）工作原理</span></a></li></ul></li><li><a class="is-flex" href="#CSMA协议"><span class="has-mr-6">4.3</span> <span>CSMA协议</span></a><ul class="menu-list"><li><a class="is-flex" href="#非持续式CSMA"><span class="has-mr-6">4.3.1</span> <span>非持续式CSMA</span></a></li><li><a class="is-flex" href="#持续式CSMA"><span class="has-mr-6">4.3.2</span> <span>持续式CSMA</span></a></li><li><a class="is-flex" href="#冲突窗口"><span class="has-mr-6">4.3.3</span> <span>冲突窗口</span></a></li><li><a class="is-flex" href="#CSMA-CD"><span class="has-mr-6">4.3.4</span> <span>CSMA/CD</span></a></li></ul></li><li><a class="is-flex" href="#以太网概述"><span class="has-mr-6">4.4</span> <span>以太网概述</span></a><ul class="menu-list"><li><a class="is-flex" href="#二进制指数回退算法"><span class="has-mr-6">4.4.1</span> <span>二进制指数回退算法</span></a></li><li><a class="is-flex" href="#经典以太网、快速以太网"><span class="has-mr-6">4.4.2</span> <span>经典以太网、快速以太网</span></a></li><li><a class="is-flex" href="#小结"><span class="has-mr-6">4.4.3</span> <span>小结</span></a></li></ul></li><li><a class="is-flex" href="#以太网帧"><span class="has-mr-6">4.5</span> <span>以太网帧</span></a><ul class="menu-list"><li><a class="is-flex" href="#IEEE802-3帧结构"><span class="has-mr-6">4.5.1</span> <span>IEEE802.3帧结构</span></a></li><li><a class="is-flex" href="#有效帧长度至少64Bytes-★"><span class="has-mr-6">4.5.2</span> <span>有效帧长度至少64Bytes ★</span></a></li></ul></li><li><a class="is-flex" href="#二层交换的基本原理"><span class="has-mr-6">4.6</span> <span>二层交换的基本原理</span></a><ul class="menu-list"><li><a class="is-flex" href="#网桥与交换机"><span class="has-mr-6">4.6.1</span> <span>网桥与交换机</span></a></li><li><a class="is-flex" href="#透明的网桥（Transparent-Bridges）"><span class="has-mr-6">4.6.2</span> <span>透明的网桥（Transparent Bridges）</span></a></li><li><a class="is-flex" href="#MAC地址表的逆向学习"><span class="has-mr-6">4.6.3</span> <span>MAC地址表的逆向学习</span></a></li><li><a class="is-flex" href="#网桥工作原理"><span class="has-mr-6">4.6.4</span> <span>网桥工作原理</span></a></li></ul></li><li><a class="is-flex" href="#生成树协议"><span class="has-mr-6">4.7</span> <span>生成树协议</span></a></li><li><a class="is-flex" href="#虚拟局域网"><span class="has-mr-6">4.8</span> <span>虚拟局域网</span></a></li><li><a class="is-flex" href="#二层设备"><span class="has-mr-6">4.9</span> <span>二层设备</span></a><ul class="menu-list"><li><a class="is-flex" href="#网卡"><span class="has-mr-6">4.9.1</span> <span>网卡</span></a></li><li><a class="is-flex" href="#网桥"><span class="has-mr-6">4.9.2</span> <span>网桥</span></a></li><li><a class="is-flex" href="#交换机"><span class="has-mr-6">4.9.3</span> <span>交换机</span></a></li></ul></li><li><a class="is-flex" href="#无线局域网"><span class="has-mr-6">4.10</span> <span>无线局域网</span></a></li></ul></li><li><a class="is-flex" href="#第5章-网络层"><span class="has-mr-6">5</span> <span>第5章 网络层</span></a><ul class="menu-list"><li><a class="is-flex" href="#概述"><span class="has-mr-6">5.1</span> <span>概述</span></a></li><li><a class="is-flex" href="#IP地址"><span class="has-mr-6">5.2</span> <span>IP地址</span></a></li><li><a class="is-flex" href="#子网规划"><span class="has-mr-6">5.3</span> <span>子网规划</span></a></li><li><a class="is-flex" href="#IP寻址"><span class="has-mr-6">5.4</span> <span>IP寻址</span></a></li><li><a class="is-flex" href="#IP分组"><span class="has-mr-6">5.5</span> <span>IP分组</span></a></li><li><a class="is-flex" href="#IPv6"><span class="has-mr-6">5.6</span> <span>IPv6</span></a></li><li><a class="is-flex" href="#IPv6分组"><span class="has-mr-6">5.7</span> <span>IPv6分组</span></a></li><li><a class="is-flex" href="#IPv6过渡技术"><span class="has-mr-6">5.8</span> <span>IPv6过渡技术</span></a></li><li><a class="is-flex" href="#路由"><span class="has-mr-6">5.9</span> <span>路由</span></a></li><li><a class="is-flex" href="#距离矢量路由选择算法"><span class="has-mr-6">5.10</span> <span>距离矢量路由选择算法</span></a><ul class="menu-list"><li><a class="is-flex" href="#路由选择信息协议RIP"><span class="has-mr-6">5.10.1</span> <span>路由选择信息协议RIP</span></a></li></ul></li><li><a class="is-flex" href="#链路状态路由选择算法"><span class="has-mr-6">5.11</span> <span>链路状态路由选择算法</span></a><ul class="menu-list"><li><a class="is-flex" href="#开放的最短路径优先-OSPF"><span class="has-mr-6">5.11.1</span> <span>开放的最短路径优先(OSPF)</span></a></li></ul></li><li><a class="is-flex" href="#无类域间路由CIDR"><span class="has-mr-6">5.12</span> <span>无类域间路由CIDR</span></a></li><li><a class="is-flex" href="#网络地址翻译NAT"><span class="has-mr-6">5.13</span> <span>网络地址翻译NAT</span></a></li><li><a class="is-flex" href="#互联网控制消息协议ICMP"><span class="has-mr-6">5.14</span> <span>互联网控制消息协议ICMP</span></a></li><li><a class="is-flex" href="#地址解析协议ARP"><span class="has-mr-6">5.15</span> <span>地址解析协议ARP</span></a></li><li><a class="is-flex" href="#拥塞控制"><span class="has-mr-6">5.16</span> <span>拥塞控制</span></a></li><li><a class="is-flex" href="#流量整形"><span class="has-mr-6">5.17</span> <span>流量整形</span></a></li></ul></li><li><a class="is-flex" href="#第6章-传输层"><span class="has-mr-6">6</span> <span>第6章 传输层</span></a><ul class="menu-list"><li><a class="is-flex" href="#传输层概述"><span class="has-mr-6">6.1</span> <span>传输层概述</span></a></li><li><a class="is-flex" href="#用户数据报协议UDP"><span class="has-mr-6">6.2</span> <span>用户数据报协议UDP</span></a></li><li><a class="is-flex" href="#通信模型"><span class="has-mr-6">6.3</span> <span>通信模型</span></a></li><li><a class="is-flex" href="#TCP数据段"><span class="has-mr-6">6.4</span> <span>TCP数据段</span></a></li><li><a class="is-flex" href="#TCP三次握手建立连接"><span class="has-mr-6">6.5</span> <span>TCP三次握手建立连接</span></a></li><li><a class="is-flex" href="#TCP连接释放"><span class="has-mr-6">6.6</span> <span>TCP连接释放</span></a></li><li><a class="is-flex" href="#TCP传输策略"><span class="has-mr-6">6.7</span> <span>TCP传输策略</span></a></li><li><a class="is-flex" href="#TCP拥塞控制"><span class="has-mr-6">6.8</span> <span>TCP拥塞控制</span></a></li><li><a class="is-flex" href="#TCP定时器等"><span class="has-mr-6">6.9</span> <span>TCP定时器等</span></a></li></ul></li><li><a class="is-flex" href="#第7章-应用层"><span class="has-mr-6">7</span> <span>第7章 应用层</span></a><ul class="menu-list"><li><a class="is-flex" href="#DNS"><span class="has-mr-6">7.1</span> <span>DNS</span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/">TTTT&#39;s Blog</a><p class="is-size-7">&copy; 2022 ZhangT&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},skipTags:["script","noscript","style","textarea","pre","code"],processEscapes:!0,tex2jax:{inlineMath:[["$","$"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>