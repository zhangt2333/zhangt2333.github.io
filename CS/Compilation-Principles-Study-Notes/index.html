<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>编译原理-学习笔记 - Zhang T&#39;s Blog</title><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-212316117-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-212316117-1")</script><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/">TTTT&#39;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i> </a><a class="navbar-item" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-content article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>编译原理-学习笔记</h1><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2020-02-16T16:00:00.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2020-02-17</time> <time class="level-item has-text-grey is-hidden-mobile" datetime="2020-06-23T15:00:00.000Z"><i class="far fa-calendar-check">&nbsp;</i>2020-06-23</time><div class="level-item"><i class="far fa-folder-open has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/categories/CS/">CS</a></div><span class="level-item has-text-grey"><i class="far fa-clock"></i>&nbsp; 3 小时 读完 (大约 27478 个字) </span><span class="level-item has-text-grey" id="busuanzi_container_page_pv"><i class="far fa-eye"></i> <span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p>编译原理…</p><a id="more"></a><p>国科大的 PPT 真好看… i 了 i 了</p><h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><p><img src="image-20200619122101408.png" alt></p><h3 id="什么是编译程序"><a href="#什么是编译程序" class="headerlink" title="什么是编译程序"></a>什么是编译程序</h3><ul><li>翻译程序(Translator)：把某一种语言程序(称为源语言程序)等价地转换成另一种语言程序(称为目标语言程序)的程序</li></ul><img src="image-20200224230231285.png" style="zoom:50%"><ul><li><p>编译程序(Compiler)：把某一种高级语言程序等价地转换成另一种低级语言程序(如汇编语言或机器语言程序)的程序</p><img src="image-20200224230240656.png" style="zoom:50%"> * 运行编译程序的计算机：宿主机 * 运行目标程序的计算机：目标机 * 根据用途和侧重，编译程序可分为： 诊断编译程序(Diagnostic Compiler) 优化编译程序(Optimizing Compiler) 交叉编译程序(Cross Compiler)：编译程序产生不同于其宿主机的目标代码 可变目标编译程序(Retargetable Compiler：不需要重写编译程序中与机器无关的部分。</li><li><p>解释程序(Interpreter)：</p><ul><li>把源语言写的源程序作为输入，但不产生目标程序，而是边解释边执行源程序</li></ul></li></ul><img src="image-20200228113729557.png" style="zoom:50%"><h3 id="为什么要学习编译原理"><a href="#为什么要学习编译原理" class="headerlink" title="为什么要学习编译原理"></a>为什么要学习编译原理</h3><ul><li><p>理解计算系统，注意不是计算机系统。</p></li><li><p>设计计算系统</p></li><li><p>计算思维 Computational Thinking)</p><ul><li>计算思维是运用计算机科学的基础概念去求解问题、设计系统和理解人类的行为，它包括了一系列广泛的计算机科学的思维方法</li><li>计算思维和阅读、写作和算术一样，是21世纪每个人的基本技能，而不仅仅属于计算机科学家</li><li>包括<br>抽象<br>自动化<br>问题分解<br>递归<br>权衡<br>保护、冗余、容错、纠错和恢复<br>利用启发式推理来寻求解答<br>在不确定情况下的规划、学习和调度</li></ul></li></ul><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><ul><li><p>词法分析</p><ul><li><p>输入源程序字符串，扫描哪些字符构成了标识符，哪些字符构成了常数</p></li><li><p>依循的原则：构词规则</p></li><li><p>描述工具：有限自动机</p></li><li><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for       i   :=     1     to     100   do</span><br><span class="line">基本字 标识符 赋值号 整常数 基本字 整常数 基本字</span><br></pre></td></tr></table></figure></li></ul></li><li><p>语法分析</p><ul><li>在词法分析的基础上，根据语法规则把单词符号串分解成各类 <strong>语法单位(语法范畴)</strong>，如下图得到了一棵语法树。</li><li>依循的原则：语法规则</li><li>描述工具：上下文无关文法</li></ul></li></ul><img src="image-20200228151145773.png" style="zoom:50%"><ul><li>中间代码产生<ul><li>对各类语法单位按语言的<strong>语义</strong>进行初步翻译</li><li>依循的原则：语义规则</li><li>描述工具：属性文法</li><li>中间代码：三元式、四元式，树，…</li></ul></li></ul><img src="image-20200228151540768.png" style="zoom:50%"><ul><li>优化<ul><li>对前阶段产生的中间代码进行加工变换，以期在最后阶段产生更高效的目标代码</li><li>依循的原则：程序的等价变换原则</li><li>比如下图的憨憨程序就可以被编译器优化得很优秀</li></ul></li></ul><img src="image-20200228152021412.png" style="zoom:50%"><ul><li>目标代码产生<ul><li>把中间代码变换成特定机器上的目标代码</li><li>依赖于硬件系统结构和机器指令的含义</li><li>目标代码三种形式<ul><li>汇编指令代码: 需要进行汇编</li><li>绝对指令代码: 可直接运行</li><li>可重新定位指令代码: 需要链接</li></ul></li></ul></li></ul><h3 id="编译程序的结构"><a href="#编译程序的结构" class="headerlink" title="编译程序的结构"></a>编译程序的结构</h3><ul><li>编译程序总框</li></ul><img src="image-20200228152816930.png" style="zoom:40%"><ul><li><p>出错处理</p><ul><li>发现源程序中的错误，把有关错误信息报告给用户</li><li>语法错误<ul><li>源程序中不符合语法（或词法）规则的错误</li><li>非法字符、括号不匹配、缺少；、…</li></ul></li><li>语义错误<ul><li>源程序中不符合语义规则的错误</li><li>说明错误、作用域错误、类型不一致、…</li></ul></li></ul></li><li><p>遍 (pass)</p><ul><li><p>所谓的 “遍”，就是对源程序或源程序的中间表示从头到尾扫描一遍</p></li><li><blockquote><p>编译程序的五个阶段，当然可以实现为五“遍”，也就是每个阶段都接受上一阶段的输出，然后完成本阶段的变换，生成本阶段完整的输出，每个阶段的输出都是源程序的一个完整表示，如一个完整的单词序列、一个完整的语法分析树、一个完整的中间代码表示、甚至是目标代码表示 等等</p></blockquote></li><li><p><strong>阶段与遍是不同的概念</strong></p><ul><li><p>一遍可以由若干段组成</p><blockquote><p>在实际工作中，从程序效率和软件设计的角度考虑，我们往往会把若干联系非常紧密的阶段，<strong>合成一遍处理</strong>，比如说我们通常把词法分析、语法分析、中间代码生成这三个阶段合成一遍处理。</p><p>把词法分析和中间代码产生实现为一些子程序，也就是词法分析子程序或者是语义子程序，这两类子程序由语法分析模块来驱动或者调用。</p><p>在这个过程中，语法分析起主导作用，在语法分析的驱动下，词法分析 语法分析和中间代码生成三个阶段穿插进行，当词法分析完成最后一个单词的识别的时候，整个分析树也就很快得到了，同时所有的语法单位的翻译也就完成了，三个阶段合成一遍完成</p></blockquote></li><li><p>一个阶段也可以分若干遍来完成</p><blockquote><p>有些情况下一个阶段也可以分若干遍来实现，优化就是这样的例子，通常来说优化这个阶段被分成了很多遍，比如说 可以先对中间代码扫描一遍识别程序的基本结构，再扫描一遍完成简单的优化，再扫描一遍完成循环的优化，有时循环优化还有可能分成很多遍</p></blockquote></li></ul></li></ul></li><li><p>编译前端和后端</p><img src="image-20200228155322477.png" style="zoom:50%"><ul><li>编译前端<ul><li>与源语言有关，如词法分析，语法分析，语义分析与中间代码产生，与机器无关的优化</li></ul></li><li>编译后端<ul><li>与目标机有关，与目标机有关的优化，目标代码产生</li></ul></li><li>带来的好处<ul><li>程序逻辑结构清晰</li><li>优化更充分，有利于移植</li></ul></li></ul></li></ul><h3 id="编译程序的生成"><a href="#编译程序的生成" class="headerlink" title="编译程序的生成"></a>编译程序的生成</h3><p>工具：</p><ul><li><p>以汇编语言和机器语言为工具</p><ul><li>优点: 可以针对具体的机器，充分发挥计算机的系统功能；生成的程序效率高</li><li>缺点: 程序难读、难写、易出错、难维护、生产的效率低</li></ul></li><li><p>以高级程序设计语言为工具</p><ul><li><p>程序易读、易理解、容易维护、生产的效率高</p><img src="image-20200228175720075.png" style="zoom:33%"> 上图表示已经有了 I 这种高级语言的实现和编译器，用 I 语言实现将 S 语言编译为 T 语言的编译器</li></ul></li></ul><p>高级语言书写：</p><ul><li><p>利用有的某种语言的编译程序实现另一种语言的编译程序</p><p>下图表示利用 P1 编译器，将 L1 语言写的 P2 编译器，编译成 A 代码写的 P2 编译器</p></li></ul><img src="image-20200228180026836.png" style="zoom:50%"><p>移植方法：</p><ul><li>把一种机器上的编译程序移植到另一种机器上，跨机器</li></ul><img src="image-20200228180440787.png" style="zoom:50%"><p>自编译方式</p><ul><li>你通过低级语言实现 L 语言的一部分 L1，然后拿 L1 和低级语言去实现 L1+L2，然后拿 L1+L2 去实现 L1+L2+L3，依次类推。</li></ul><img src="image-20200228180803482.png" style="zoom:50%"><p>编译程序自动产生：</p><ul><li>编译程序-编译程序，也叫编译程序产生器，也叫编译程序书写系统</li><li>LEX：词法分析程序产生器</li><li>YACC：语法分析程序产生器</li></ul><img src="image-20200228181044912.png" style="zoom:50%"><h2 id="第二章-高级程序设计语言定义与语法描述"><a href="#第二章-高级程序设计语言定义与语法描述" class="headerlink" title="第二章 高级程序设计语言定义与语法描述"></a>第二章 高级程序设计语言定义与语法描述</h2><p><img src="image-20200620000615982.png" alt></p><h3 id="程序设计语言的定义"><a href="#程序设计语言的定义" class="headerlink" title="程序设计语言的定义"></a>程序设计语言的定义</h3><p>语法：</p><ul><li><p>一组规则，用它可以形成和产生一个合式 (well-formed) 的程序</p></li><li><p>词法规则：<strong>单词符号</strong>的形成规则</p><ul><li>单词符号是语言中具有独立意义的最基本结构</li><li>一般包括：常数、标识符、基本字、算符、界符等</li><li>描述工具：有限自动机</li></ul></li><li><p>语法规则：<strong>语法单位</strong>的形成规则</p><ul><li>语法单位通常包括：表达式、语句、分程序、过程、函数、程序等;</li><li>描述工具：上下文无关文法</li></ul></li><li><p>例子：</p><ul><li>$E\rightarrow i$：一个算术表达式可以由一个标识符构成；</li><li>$E\rightarrow E+E$：一个算术表达式可由两个算术表达式（也叫子表达式）通过 ‘+’ 号连接构成；</li><li>$E\rightarrow E<em>E$：一个算术表达式可由两个算术表达式通过 ‘\</em>‘（星号，而不特指乘号）号连接构成；</li><li>$E\rightarrow (E)$：一个算术表达式外加括号，还是算术表达式；</li></ul></li><li><p><strong>语法规则</strong>和<strong>词法规则</strong>定义了程序的形式结构</p></li><li><p>定义语法单位的意义属于<strong>语义</strong>问题</p></li></ul><p>语义：</p><ul><li>一组规则，用它可以定义一个程序的<strong>意义</strong></li><li>描述方法<ul><li>自然语言描述<ul><li>二义性、隐藏错误和不完整性</li></ul></li><li>形式描述<ul><li>操作语义</li><li>指称语义</li><li>代数语义</li></ul></li></ul></li></ul><p>程序，本质上是描述一定数据的处理过程；</p><p>程序语言的基本功能：描述数据和对数据的运算；</p><p>程序的层次结构：</p><img src="image-20200228184632420.png" style="zoom:33%"><p>静态绑定：发生在程序编译过程中间的绑定，包括变量声明、类型定义、函数定义</p><p>动态绑定：发生在程序运行过程中间的绑定，包括 C++ 中的多态性虚函数</p><p>表达式：</p><ul><li>表达式由运算量（也称操作数，即数据引用或函数调用）和算符（运算符，操作符）组成</li><li>形式：中缀、前缀、后缀</li></ul><p>赋值语句</p><ul><li>A := B</li><li>名字的<strong>左</strong>值：该名字代表的存储单元的<strong>地址</strong></li><li>名字的<strong>右</strong>值：该名字代表的<strong>存贮单元的内容</strong></li><li>C 语言中，<code>a+5</code> 只有右值没有左值，因为该值只能用在赋值号右边</li></ul><h3 id="程序设计语言的描述"><a href="#程序设计语言的描述" class="headerlink" title="程序设计语言的描述"></a>程序设计语言的描述</h3><h4 id="上下文无关文法"><a href="#上下文无关文法" class="headerlink" title="上下文无关文法"></a>上下文无关文法</h4><p>文法：</p><ul><li>描述语言的语法结构的形成规则</li><li>如 <code>He gave me a book.</code> 这句自然语言的文法规则为：</li></ul><img src="image-20200228203556553.png" style="zoom:33%"> <img src="image-20200228203605324.png" style="zoom:48%"><p>相关概念：</p><ul><li><p>字母表：一个有穷字符集，记为 $\sum $</p></li><li><p>字母表中每个元素称为<font color="red">字符</font></p></li><li><p>$\sum$ 上的<font color="red">字</font>（也叫<font color="red">字符串</font>）是指由 $\sum$ 中的字符所构成的一个有穷序列</p></li><li><p>不包含任何字符的序列称为<font color="red">空字</font>，记为 $\varepsilon $</p></li><li><p>用 $\sum^※$ 表示 $\sum$ 上的所有<font color="red">字的全体</font>，包含空字 $ \varepsilon $</p><ul><li>例如：设 $\sum = {a, b}$，则 $\sum^※ = {\varepsilon, a, b,aa,ab,ba,bb,aaa,\cdots }$</li></ul></li><li><p>$\sum^※ $ 的子集 $U$ 和 $V$ 的<font color="red">连接</font>（<font color="red">积</font>）定义为 $UV = {\alpha \beta \ | \ \alpha \in U \and \beta \in V} $</p><ul><li>例如：设 $U={a,aa}, V={b,bb}$，则 $UV ={ab,abb,aab,aabb}$，并且此时 $UV \not = VU $</li></ul></li><li><p>$V$ 自身的 $n$ 次积记为 $V^n = \underbrace{V\cdots V}_{\text{n个}} $</p></li><li><p>$V^0={\varepsilon}$</p></li><li><p>$V^※ $ 是 $V$ 的<font color="red">闭包</font>：$V^※ = V^0 \cup V^1\cup V^2\cup V^3\cup \cdots $</p></li><li><p>$V^+ $ 是 $V$ 的<font color="red">正规闭包</font>： $V^+ = V V^※$</p><ul><li>正规闭包与闭包的区别：如果 V 中原来没有空字，那么闭包有空字，正规闭包没空字</li><li>例如：设 $U={a,aa}$，那么 $U^※ = {\varepsilon ,a,aa,aaa,aaaa,\cdots }, U^+ = {a,aa,aaa,aaaa,\cdots }$</li></ul></li></ul><p>上下文无关文法：</p><ul><li><p>上下文无关文法 $ G$ 是一个四元组 $G=(V_T,V_N,S,P) $，其中</p><ul><li>$V_T$：<font color="red">终结符</font> (Terminal) 集合 (非空)<ul><li>不能再分解的</li></ul></li><li>$V_N$：<font color="red">非终结符</font> (Noterminal) 集合(非空)，且$V_T ∩ V_N=∅$<ul><li>能再分解，比如上图中的 “主语”、”谓语”</li><li>非终结符可由终结符和非终结符构成</li></ul></li><li>$S$：文法的<font color="red">开始符号</font>，$S∈V_N$<ul><li>是一个特殊的非终结符，它代表所定义的语言最终感兴趣的语法单位</li><li>比如英语中的 “句子”，编程中的 “程序”</li></ul></li><li>$P$：<font color="red">产生式</font>集合(有限)，每个产生式形式为<ul><li>$P→α， P∈V_N， α ∈ (V_T ∪ V_N)^※$</li><li>上式读成 “P 定义为 α”，即左边的终结符 P，是被定义的句法单位，右边的 α 是构成这个句法单位的一种组合。</li><li>$(V_T ∪ V_N)$ 代表终结符和非终结符组成的字符集合，再打上 * 做闭包，代表该集合中的符号组成的字的全体</li></ul></li><li>开始符 $S$ 至少必须在某个产生式的左部出现一次</li><li>例如，定义只含 +, * 的算术表达式的文法：G=&lt; <font color="red">{i, +, *, (, )}</font>, <font color="green">{E}</font>, <font color="blue">E</font>, P &gt;，其中，P 由下列产生式组成：<ul><li>$E\rightarrow i$</li><li>$E\rightarrow E+E$</li><li>$E\rightarrow E*E$</li><li>$E\rightarrow (E)$</li></ul></li></ul></li><li><p>巴科斯范式：”-&gt;” 用 “::=” 来表示</p></li><li><p>上下文无关文法</p><ul><li>约定 $\begin{cases}P\rightarrow \alpha_1 \ P\rightarrow \alpha_2\\cdots \ P\rightarrow \alpha_n\end{cases} \overset{缩写为}{\rightarrow} P\rightarrow \alpha_1 | \alpha_2 |\cdots |\alpha_n$</li><li>其中 “|” 读成 “或”，称 $\alpha_1$ 为 $P$ 的一个候选式</li><li>表示一个文法时，通常只给出开始符号和产生式</li><li>例如，定义只含 +, * 的算术表达式的文法可以缩写为：<br>$G(E) : E\rightarrow i \ |\ E+E \ | \ E*E\ |\ (E) $</li></ul></li></ul><h4 id="文法与语言"><a href="#文法与语言" class="headerlink" title="文法与语言"></a>文法与语言</h4><p>推导：</p><ul><li><p>定义：称 $\alpha A\beta$ <font color="red">直接推出</font> $\alpha \gamma \beta$，即 $\alpha A\beta \Rightarrow \alpha \gamma \beta$ ，仅当 $A\rightarrow \gamma $ 是一个产生式，且 $\alpha, \beta \in (V_T\cup V_n)^※$</p></li><li><p>如果$α_1 \Rightarrow α_2 \Rightarrow … \Rightarrow α_n$，则我们称这个序列是从 $α_1$ 到 $α_n$ 的一个推导。若存在一个从 $α_1$ 到$α_n$ 的推导，则称 $α_1$ 可以推导出 $α_n $ 。</p></li><li><p>对文法 $G(E) : E\rightarrow i \ |\ E+E \ | \ E*E\ |\ (E) $，则 $E\Rightarrow (E)\Rightarrow (E+E)\Rightarrow (i+E)\Rightarrow (i+i)$</p></li><li><p>称 $\alpha_1 \overset{*}{\Rightarrow} \alpha_n$ 从 $\alpha_1$ 经过 0 步或若干步推出 $\alpha_n$</p></li><li><p>称 $\alpha_1 \overset{+}{\Rightarrow} \alpha_n$ 从 $\alpha_1$ 经过 1 步或若干步推出 $\alpha_n$</p></li><li><p>$\alpha_1 \overset{*}{\Rightarrow} \alpha_n$ 即 $\alpha=\beta$ 或 $ \alpha_1 \overset{+}{\Rightarrow} \alpha_n$</p></li></ul><p>句型：</p><ul><li>假定 G 是一个文法， S 是它的开始符号，如果 $S \overset{*}{\Rightarrow} \alpha_n$，则称 $\alpha$ 是一个句型</li><li>$S \overset{*}{\Rightarrow} S$，所以 S 也是句型</li></ul><p>句子：</p><ul><li>仅含终结符号的句型是一个句子。</li></ul><p>语言：</p><ul><li><p>文法 G 所产生的句子的全体是一个语言，记为 $L(G)$<br>$L(G)= {\alpha \ | \ S \overset{+}{\Rightarrow}\alpha, \alpha \in V_T^※ }$，即 $L(G)$ 是由 $\alpha$ 构成的集合， $\alpha$ 属于终结符的闭包，且能由 S 推导得来。</p></li><li><img src="image-20200229104118219.png" style="zoom:40%"></li><li><img src="image-20200229104345152.png" style="zoom:40%"></li><li><img src="image-20200229104632829.png" style="zoom:40%"></li><li><img src="image-20200229104915177.png" style="zoom:50%"></li><li><img src="image-20200229105135900.png" style="zoom:50%"></li></ul><h4 id="语法树与二义性"><a href="#语法树与二义性" class="headerlink" title="语法树与二义性"></a>语法树与二义性</h4><p>最左推导和最右推导：</p><ul><li><p>从一个句型到另一个句型的推导往往不唯一<br>$E+E \Rightarrow i+E \Rightarrow i+i \ E+E \Rightarrow E+i \Rightarrow i+i $</p></li><li><p>最左推导：任何一步 $\alpha\Rightarrow \beta$ 都是对 $\alpha $ 中的最左非终结符进行替换</p></li><li><p>最右推导：任何一步 $\alpha\Rightarrow \beta$ 都是对 $\alpha$ 中的最右非终结符进行替换</p></li></ul><p>语法树：</p><ul><li>用一张图表示一个句型的推导，称为语法树</li><li>一棵语法树是不同推导过程的共性抽象</li><li>最左推导所对应的语法树的生长顺序是从上往下、从左往右</li></ul><img src="image-20200229110330503.png" style="zoom:50%"><p>二义性 ambiguity：</p><ul><li><p>文法的二义性：如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义的<br>G(E)： E → i|E+E|E*E|(E) 是二义文法，对于 $i*i +i$ 可以画出两棵语法树</p><img src="image-20200229111904441.png" style="zoom:33%"></li><li><p>语言的二义性：一个<font color="red">语言是二义的</font>，如果对它不存在无二义的文法</p><ul><li>对于语言 L，可能存在 G 和 G’，使得 L(G)=L(G’)=L，有可能其中一个文法为二义的，<br>另一个为无二义的</li></ul></li><li><p>自然语言的二义性举例 <code>John saw Mary in a boat</code></p></li></ul><img src="image-20200229112549846.png" style="zoom:30%"><ul><li>二义问题是不可判定问题，即不存在一个算法，它能在有限步骤内，确切地判定一个文法是否是二义的</li><li>可以找到一组无二义文法的充分条件</li></ul><h4 id="形式语言鸟瞰"><a href="#形式语言鸟瞰" class="headerlink" title="形式语言鸟瞰"></a>形式语言鸟瞰</h4><ul><li>乔姆斯基于1956年建立形式语言体系，他把文法分成四种类型：0，1，2，3型</li><li>与上下文无关文法一样，它们都由四部分组成，<br>但对产生式的限制有所不同</li></ul><p>0 型（短语文法，图灵机）：</p><ul><li>产生式形如：$\alpha \rightarrow \beta$</li><li>其中：$\alpha \in (V_T \cup V_N)^※ $ 且至少含有一个非终结符；$\beta \in(V_T\cup V_N)^※$</li><li>乔姆斯基文法体系中，最通用，也是描述能力最强、最一般的文法，产生式的约束最弱</li></ul><p>1 型（上下文有关文法，线性界限自动机）:</p><ul><li>产生式形如：$\alpha \rightarrow \beta$</li><li>其中：$|\alpha| \le |\beta|$，仅 $S\rightarrow \varepsilon $ 例外</li><li>上下文有关文法非常复杂，等下会提到</li></ul><p>2 型(上下文无关文法，非确定下推自动机)：</p><ul><li>产生式形如： $A → β$</li><li>其中：$A∈ V_N$；$β∈ (V_T ∪ V_N)^※$</li></ul><p>3 型 (正规文法，有限自动机)</p><ul><li><p>产生式形如： $A → αB $ 或 $A → α $，终结符要么没有要么出现在右式最右边（右线性文法</p></li><li><p>其中： $α∈ V_T^※$；$A，B∈V_N^※$</p></li><li><p>产生式形如： $A → Bα$ 或 $A → α$ （左线性文法</p></li><li><p>其中： $α∈ V_T^※$；$A，B∈V_N$</p></li></ul><img src="image-20200229154446865.png" style="zoom:33%"><p>四种类型文法的描述能力：</p><ul><li><p>$L_5={a^nb^n\ |\ n≥1}$ 不能由正规文法产生，但可由上下文无关文法产生<br>$G_5(S): S\rightarrow aSb \ | \ ab$</p></li><li><p>$L_6={a^nb^nc^n|n≥1}$不能由上下文无关文法产生，但可由上下文有关文法产生</p></li></ul><img src="image-20200229155016138.png" style="zoom:33%"><ul><li>程序设计语言不是上下文无关语言，甚至不是上下文有关语言</li><li>$L_7={αcα| α∈{a,b}^※}$不能由上下文无关文法产生，甚至连上下文有关文法也不能产生，只能由0型文法产生<ul><li>标识符引用。比如编程语言中要求使用的变量必须前面声明过</li><li>过程调用过程中，“形-实参数的对应性”(如个数，顺序和类型一致性)</li></ul></li><li>对于现今程序设计语言，在编译程序中，仍然采用上下文无关文法来描述其语言结构 （上下文无关文法的成熟高效）</li></ul><h2 id="第三章-词法分析"><a href="#第三章-词法分析" class="headerlink" title="第三章 词法分析"></a>第三章 词法分析</h2><p><img src="image-20200620140813283.png" alt></p><h3 id="词法分析器的设计"><a href="#词法分析器的设计" class="headerlink" title="词法分析器的设计"></a>词法分析器的设计</h3><h4 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h4><p>词法分析的任务：</p><ul><li>从左至右逐个字符地对源程序进行扫描，产生一个个单词符号</li></ul><p>词法分析器 (Lexical Analyzer)：</p><ul><li>扫描器(Scanner)</li><li>执行词法分析的程序</li><li>功能：输入源程序、输出单词符号</li></ul><p>单词符号的种类：</p><ul><li>基本字：如begin，repeat，for，…</li><li>标识符：用来表示各种名字，如变量名、数组名和过程名</li><li>常数：各种类型的常数</li><li>运算符：+，-，*，/，…</li><li>界符：逗号、分号、括号和空白</li></ul><p>词法分析器的输出：</p><ul><li><p>输出的单词符号的表示形式：<br>&lt;<font color="red">单词种别</font>， <font color="red">单词自身的值</font>&gt;</p></li><li><p>单词种别通常用整数编码表示</p><ul><li>若一个种别只有一个单词符号，则种别编码就代表该单词符号。假定<font color="red">基本字</font>、<font color="red">运算符</font>和<font color="red">界符</font>都是一符一种。</li><li>若一个种别有多个单词符号，则对于每个单词符号，给出种别<font color="red">编码</font>和<font color="red">自身</font>的值。<ul><li><font color="red">标识符</font>单列一种；标识符自身的值表示成按机器字节划分的内部码</li><li><font color="red">常数</font>按类型分种；常数的值则表示成标准的二进制形式</li></ul></li></ul></li></ul><img src="image-20200229160338447.png" style="zoom:33%"><p>词法分析器作为一个独立子程序：</p><ul><li>词法分析作为一个独立的阶段<ul><li>结构简洁、清晰和条理化，有利于集中考虑词法分<br>析一些枝节问题</li></ul></li><li>但不一定不作为单独的一遍<ul><li>将其处理为一个子程序</li></ul></li></ul><img src="image-20200229160541181.png" style="zoom:33%"><p>词法分析器的结构（分解的思想）：</p><ul><li><img src="image-20200229161101668.png" style="zoom:40%"></li><li><p>扫描缓冲区，分成两个半区互补使用，一个半区也即单词的最大长度</p><img src="image-20200229161130080.png" style="zoom:40%"></li></ul><h4 id="超前搜索"><a href="#超前搜索" class="headerlink" title="超前搜索"></a>超前搜索</h4><p>超前搜索：</p><ul><li>有些语言（FORTRAN）允许基本字作为标识符，比如 IF 作为数组名</li><li>这给基本字的识别带来麻烦：<br>IF(5.EQ.M)GOTO5 // 条件判断+跳转<br>IF(5)=55 // 给数组赋值</li><li>这需要超前搜索来确定基本字</li><li>标识符识别、常数识别算符、界符的识别</li><li>超前搜索又涉及到回退，十分麻烦</li></ul><p>现代高级语言的几点限制 —— 不必使用超前搜索：</p><ul><li>所有基本字都是保留字;用户不能用它们作自己的标识符</li><li>基本字作为特殊的标识符来处理，使用保留字表</li><li>如果基本字、标识符和常数(或标号)之间没有确定的运算符或界符作间隔，则必须使用一个空白符作间隔</li></ul><h4 id="状态转换图"><a href="#状态转换图" class="headerlink" title="状态转换图"></a>状态转换图</h4><p><strong>状态转换图</strong>：</p><ul><li><p>状态转换图是一张有限方向图</p><ul><li><font color="red">结点</font>代表<font color="blue">状态</font>，用圆圈表示</li><li>状态之间用<font color="red">箭弧</font>连结，箭弧上的标记(字符)代表射出结状态下可能出现的输入<font color="blue">字符</font>或<font color="blue">字符类</font></li><li>一张转换图只包含<font color="red">有限个状态</font>，其中有一个为<font color="red">初态</font>，至少要有一个<font color="red">终态</font></li></ul></li><li><p>状态转换图可用于识别 (或接受) 一定的字符串</p><ul><li>若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于 α，则称α 被该状态转换图所<font color="red">识别(接受)</font></li></ul></li></ul><img src="image-20200229162546374.png" style="zoom:40%"> <img src="image-20200229163217081.png" style="zoom:50%"><p><strong>状态转换图的实现</strong>：</p><ul><li>变量 <code>curState</code> 用于保存现有的状态</li><li>用二维数组表示状态图：<code>stateTrans[state][ch]</code></li></ul><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">curState = 初态</span><br><span class="line">GetChar();</span><br><span class="line"><span class="hljs-keyword">while</span>( stateTrans[curState][ch] 有定义 ) &#123;</span><br><span class="line">    <span class="hljs-comment">// 存在后继状态，读入、拼接</span></span><br><span class="line">    Concat();</span><br><span class="line">    <span class="hljs-comment">// 转换入下一状态，读入下一字符</span></span><br><span class="line">    curState = stateTrans[curState][ch];</span><br><span class="line">    <span class="hljs-keyword">if</span> curState 是终态</span><br><span class="line">    then 返回 strToken中的单词</span><br><span class="line">    GetChar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正规表达式与有限自动机"><a href="#正规表达式与有限自动机" class="headerlink" title="正规表达式与有限自动机"></a>正规表达式与有限自动机</h3><h4 id="正规式和正规集"><a href="#正规式和正规集" class="headerlink" title="正规式和正规集"></a>正规式和正规集</h4><p>正规式和正规集：</p><ul><li><p><font color="blue">正规集</font>可以用<font color="red">正规式</font>表示（<font color="red">正规式</font>是表示<font color="blue">正规集</font>的一种方法）</p><ul><li><blockquote><p>程序设计语言定义的合法的单词的集合都是<font color="blue">正规集</font>，每个<font color="blue">正规集</font>可以抽象成<font color="red">正规式</font>来表示</p></blockquote></li></ul></li><li><p>一个字集合是<font color="blue">正规集</font>当且仅当它能用<font color="red">正规式</font>表示</p></li></ul><p>正规式和正规集的递归定义：</p><ul><li><p>对于给定的字母表 $\sum$</p><ul><li>$\varepsilon $ 和 $\O $ 都是 $\sum$ 上的正规式，它们所表示的正规集为 ${\varepsilon }$ 和 $\O$</li></ul></li><li><p>任何 <font color="green">a</font> $\in \sum$ ，<font color="red">a</font> 是 $\sum$ 上的正规式，它所表示的正规集为 <font color="blue">{a}</font></p></li><li><p>假定 <font color="red">$e_1$</font> 和 <font color="red">$e_2$</font> 都是 $\sum$ 上的正规式，它们所表示的正规集为 <font color="blue">$L(e_1)$</font> 和 <font color="blue">$L(e_2)$</font> ，则</p><ul><li><font color="red">$(e_1|e_2)$</font> 为正规式，它所表示的正规集为 <font color="blue">$L(e_1)\cup L(e_2)$</font></li><li><font color="red">$(e_1·e_2)$</font> 为正规式，它所表示的正规集为 <font color="blue">$L(e_1) L(e_2)$</font> （两个正规集的连接还是正规集）</li><li><font color="red">$(e_1)^※$</font> 为正规式，它所表示的正规集为 <font color="blue">$(L(e_1))^※$</font> （一个正规集的闭包还是正规集）</li></ul></li><li><p>仅由<strong>有限次</strong>使用上述三步骤而定义的表达式才是 Σ 上的正规式，仅由这些正规式表示的字集才是Σ上的正规集。</p></li></ul><p>正规集的等价性：</p><ul><li>若两个正规式所表示的正规集相同，则称这两个正规式等价。如 b(ab)*=(ba)*b</li></ul><img src="image-20200305152407737.png" style="zoom:50%"><p>正规式的性质：</p><ul><li>e1|e2 = e2|e1 交换律</li><li>e1 |(e2|e3) = (e1|e2)|e3 结合律</li><li>e1(e2e3) = (e1e2)e3 结合律</li><li>e1(e2|e3) = e1e2|e1e3 分配律</li><li>(e2|e3)e1 = e2e1|e3 e1 分配律</li><li>eε = εe = e <font color="red">e1e2 &lt;&gt; e2e1</font></li></ul><img src="image-20200305153622204.png" style="zoom:50%"><h4 id="有限自动机"><a href="#有限自动机" class="headerlink" title="有限自动机"></a>有限自动机</h4><h5 id="确定有限自动机"><a href="#确定有限自动机" class="headerlink" title="确定有限自动机"></a>确定有限自动机</h5><ul><li>对<strong>状态图</strong>进行初始化定义 (描述)，得到</li><li><font color="red">确定有限自动机</font> <font color="blue">(Deterministic Finite Automata， DFA)</font><br>M 是一个五元式 $M=(S, \sum, f, S_0, F)$ 其中<ul><li>S：有穷<font color="red">状态集</font></li><li>$\sum$ ：输入字母表 (有穷)</li><li>f ：状态转换函数，为 $S\times \sum \rightarrow S $ 的单值部分映射。<br>$f(s,a)=s’$ 表示当现行状态为 s，输入字符为 a 时，状态转移到 s’。</li><li>$S_0 \in S$ 是唯一的一个初态</li><li>$F\subseteq S$：终态集 (可空)</li></ul></li></ul><img src="image-20200305154857345.png" style="zoom:50%"><ul><li><p>DFA表示为状态转换图</p><ul><li>假定DFA M含有m个状态和n个输入字符</li><li>对应的状态转换图含有m个状态结点，每个结点顶多含有n条箭弧射出，且每条箭弧用Σ上的不同的输入字符来作标记</li></ul></li><li><p>对于Σ*中的任何字α，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α为DFA M所识别(接收)</p></li><li><p>DFA M所识别的字的全体记为L(M)</p></li></ul><img src="image-20200305155851764.png" style="zoom:50%"><h5 id="非确定有限自动机-（NFA）"><a href="#非确定有限自动机-（NFA）" class="headerlink" title="非确定有限自动机 （NFA）"></a>非确定有限自动机 （NFA）</h5><ul><li><p>定义：一个<font color="red">非确定有限自动机 (Nondeterministic Finite Automata, NFA) M</font><br>一个五元式 $M=(S, \sum, f, S_0, F)$ 其中</p><ul><li>S：有穷<font color="red">状态集</font></li><li>$\sum$ ：输入字母表 (有穷)</li><li>f ：状态转换函数，为<font color="red"> $S\times \sum^※ \rightarrow 2^S $ </font>的部分映射<br>$f(S, \alpha)=S’$，识别 $\alpha$ （字、正规式都行）后转移到 S’ 这个状态集合中的某个状态</li><li>$S_0 \subseteq S$ 是非空的初态集 （即初态可能不唯一）</li><li>$F\subseteq S$：终态集 (可空)</li></ul></li><li><p>非确定性：初始状态不唯一、识别一个字后所到达的后续状态不唯一</p></li></ul><img src="image-20200306201200798.png" style="zoom:50%"><ul><li>从状态图看 NFA 和 DFA 的区别<ul><li>NFA 可以有多个<font color="red">初态</font></li><li>弧上的标记可以是 Σ* 中的一个<font color="red">字</font>(甚至可以是一个<font color="red">正规式</font>)，而不一定是单个字符</li><li><strong><font color="red">同一个字</font>可能出现在同状态射出的<font color="red">多条弧</font>上</strong></li></ul></li><li>DFA 是 NFA 的特例</li></ul><h4 id="有限自动机的等价性"><a href="#有限自动机的等价性" class="headerlink" title="有限自动机的等价性"></a>有限自动机的等价性</h4><h5 id="DFA-与-NFA-的等价性"><a href="#DFA-与-NFA-的等价性" class="headerlink" title="DFA 与 NFA 的等价性"></a>DFA 与 NFA 的等价性</h5><ul><li>定义：对于任何两个有限自动机 M 和 M’，如果 L(M)=L(M’)，则称 M 与 M’ 等价</li><li>自动机理论中一个重要的结论：<font color="red">判定两个自动机等价性的算法是存在的</font></li><li>对于每个 NFA M 存在一个 DFA M’，使得 L(M)=L(M’)</li><li><font color="red">DFA 与 NFA 识别能力相同!</font></li></ul><table><thead><tr><th align="center"></th><th align="center">NFA</th><th align="center">DFA</th></tr></thead><tbody><tr><td align="center">初始状态</td><td align="center">不唯一</td><td align="center">唯一</td></tr><tr><td align="center">弧上的标记</td><td align="center">字 (单字符字、 $ \varepsilon $)</td><td align="center">字符</td></tr><tr><td align="center">转换关系</td><td align="center">非确定</td><td align="center">确定</td></tr><tr><td align="center">其他</td><td align="center">NFA 易于设计</td><td align="center">DFA 易于实现</td></tr></tbody></table><h5 id="NFA-转换为-DFA"><a href="#NFA-转换为-DFA" class="headerlink" title="NFA 转换为 DFA"></a>NFA 转换为 DFA</h5><ul><li><p>假定 NFA $M=&lt;S, \sum, \delta, S_0, F&gt;$ ，我们对 M 的状态转换图进行以下改造</p><ul><li><p>引进新的初态节点 X 和终态结点 Y，$X,Y\not\in S$，从 X 到 $S_0$ 中任意状态结点连一条 $\varepsilon$ 箭弧，从 F 中任意状态结点连一条 $\varepsilon $ 箭弧到 Y。<font color="red">(解决初始状态唯一性)</font></p><img src="image-20200307105150473.png" style="zoom:50%"></li><li><p>对 M 的状态转换图进一步施行替换，其中 k 是新引入的状态。<font color="red">(简化弧上的标记)</font></p><img src="image-20200307105233041.png" style="zoom:50%"></li></ul></li><li><p>逐步把这个图转变为每条弧只标记为Σ上的一个字符或ε，最后得到一个NFA M’，显然 L(M’)=L(M)</p></li></ul><img src="image-20200307105329591.png" style="zoom:50%"><ul><li><p>NFA 确定化 —— 子集法 <font color="red">(解决 $\varepsilon $ 弧和转换关系)</font></p><ul><li><p>设 I 是状态集的一个子集，定义 I 的 <font color="red">$\varepsilon $ 闭包 </font>$\varepsilon\text{-closure(I)} $ 为：</p><ul><li>若 $s\in I$，则 $s\in \varepsilon\text{-closure(I)} $</li><li>若 $s\in I$，则从 s 出发经过任意条 $\varepsilon $ 弧而能到达的任何状态 s’ 都属于 $\varepsilon\text{-closure(I)} $</li><li>即 $\varepsilon\text{-closure(I)} = I \cup {s’ | \text{从某个s}\in I \text{出发经过任意条}\varepsilon 弧能到达s’ }$</li></ul></li><li><p>设 a 是 $\sum$ 中的一个字符，定义 $I_a = \varepsilon\text{-closure(J)}$<br>其中 J 为 I 中的某个状态出发经过一条 a 弧而到达的状态集合</p><img src="image-20200307114044356.png" style="zoom:33%"></li></ul></li></ul><img src="image-20200307114059429.png" style="zoom:50%"><ul><li><p>确定化：不失一般性，设字母表只包含两个 a 和b，我们构造一张计算状态集的转换表</p><img src="image-20200307114905577.png" style="zoom:50%"><ul><li><p>首先，置 表(1,1) 为 $ \varepsilon\text{-closure({X})}$ 求出这一列的 $I_a, I_b$</p></li><li><p>然后，检查这两个 $I_a, I_b$，看它们是否已在表中的第一列中出现，把未曾出现的填入后面的空行的第 1 列，求出每行第 2, 3 列上的集合…</p></li><li><p>重复上述过程。例子如下图</p><img src="image-20200307115142739.png" style="zoom:50%"></li><li><p>经过确定化，得到了状态集之间的关系（状态集的转换表）</p></li><li><p>哦，状态集还可以编号，以免写的太麻烦 <img src="image-20200307135152356.png" style="zoom:33%"></p></li></ul></li><li><p>把经过确定化得到的表看作 <font color="red">状态转换矩阵</font>，子集视为状态</p><ul><li>转换表唯一刻画了一个确定的有限自动机 M<br><font color="red">初态</font>是 $ \varepsilon\text{-closure({X})}$<br><font color="blue">终态</font>是 含有原终态 Y 的子集</li><li>不难看出，这个 DFA M 与 M’ 等价</li><li>对于每个 NFA M 存在一个 DFA M’，使得 L(M)=L(M’)</li></ul></li></ul><h5 id="DFA-的化简"><a href="#DFA-的化简" class="headerlink" title="DFA 的化简"></a>DFA 的化简</h5><ul><li><p>—— 状态的等价性</p></li><li><p>DFA 的化简(最小化)：对于给定的 DFA M，寻找一个状态数比 M 少的 DFA M’，使得 L(M)=L(M’)</p></li><li><p>状态的等价性</p><ul><li>假设 s 和 t 为 M 的两个状态，称 s 和 t 等价：<br>如果从状态出发能读出某个字 α 而停止于终态，那么同样，从t 出发也能读出 α 而停止于终态（两个终态可以不是同一个）<br>反之亦然。</li><li>两个状态不等价，则称它们是<font color="red">可区别</font>的</li></ul></li><li><p>基本思想</p><ul><li><p>把 M 的状态集划分为一些不相交的子集，使得<font color="red">任何两个不同子集的状态是可区别的</font>，而<font color="blue">同一子集的任何两个状态是等价的</font>。(不断地不断地细分)</p></li><li><p>最后，让每个子集选出一个代表，同时消去其他状态。</p><img src="image-20200307140500652.png" style="zoom:40%"></li><li><p>举例，按照上述原则对DFA的状态集合S进行第一次划分，正确的分法是（B. 终态和非终态）</p><ul><li>可以 $\varepsilon$ 为例，终态识别 $\varepsilon$ 后仍为终态，非终态识别 $\varepsilon$ 后仍为非终态</li></ul></li></ul></li><li><p>化简算法 —— 最小化算法</p><ul><li><p>推导</p><ul><li><p>首先把 S 划分为<font color="blue">终态</font>和<font color="red">非终态</font>两个子集，形成基本划分 $\prod $</p></li><li><p>假定状态 <font color="blue">s1</font> 和 <font color="red">s2</font> 是I(i)={s1,s2, …,sk}中的两个状态，它们经 <font color="green">α</font> 弧分别到达 <font color="blue">t1</font> 和 <font color="red">t2</font>，而 <font color="blue">t1</font>和 <font color="red">t2 </font>属于现行 Π 中的两个不同子集</p></li><li><p>说明有一个字 <font color="green">α</font>， <font color="blue">t1</font> 读出 <font color="green">α</font> 后到达终态，而 <font color="red">t2</font> 读出 <font color="green">α</font> 后不能到达终态，或者反之</p></li><li><p>那么对于字 <font color="green">aα</font> ， <font color="blue">s1</font> 读出 <font color="green">aα</font> 后到达终态，而 <font color="red">t2 </font>读出 <font color="green">aα</font> 不能到达终态，或者反之</p></li><li><p>所以 <font color="blue">s1</font> 和 <font color="red">s2</font> 不等价</p><img src="image-20200307142759033.png" style="zoom:50%"></li><li><p>所以可以将 $I^{(i)}$ 分成两半，一半含有 s1，一半含有 s2</p></li></ul></li><li><p>广义上的算法</p><ul><li>对某个 a 和 $I^{(i)}$，若 $I_a^{(i)}$ 落入现行 Π 中 N 个不同子集，则应把 $I^{(i)}$ 划分成 N 个不相交的组，使得每个组 J 的 $J_a$ 都落入的 Π 同一子集。</li><li>重复上述过程，直到 Π 所含子集数不再增长</li><li>选取每个子集 I 中的一个状态代表其他状态，则可得到化简后的 DFA M’</li></ul></li><li><p>举例</p><img src="image-20200307143217175.png" style="zoom:50%"><ul><li><p>$I^{(1)}={0,1,2}、I^{(2)}={3,4,5,6}$</p></li><li><p>对于 $I^{(1)}={0,1,2}$，有 $I_a^{(1)}={1,3}$，所以 0,2 要和 1 分开，即得到<br>$I^{(11)}={0,2}、I^{(12)}={1}$</p></li><li><p>对于 $I^{(11)}={0,2}$，有 $I_a^{(11)}={1}、I_b^{(11)}={2,4}$，所以 0 要和 2 分开<br>$I^{(111)}={0}、I^{(112)}={2}$</p></li><li><p>而对于 $I^{(2)}={3,4,5,6}$，有 $I_a^{(2)}={3,6}、I_b^{(2)}={4,5}$ 都在 $I^{(2)}$ 里，故不需要分</p></li><li><p>最终为：$I^{(111)}={0}、I^{(112)}={2}、I^{(12)}={1}、I^{(2)}={3,4,5,6}$</p></li><li><p>缩写为：{0}{1}{2}{3,4,5,6}</p></li><li><p>{3,4,5,6} 可以选出 3 作代表，结果如下</p><img src="image-20200307143901838.png" style="zoom:45%"></li></ul></li></ul></li></ul><h4 id="正规式与有限自动机的等价性"><a href="#正规式与有限自动机的等价性" class="headerlink" title="正规式与有限自动机的等价性"></a>正规式与有限自动机的等价性</h4><h5 id="正规式与有限自动机的等价性-1"><a href="#正规式与有限自动机的等价性-1" class="headerlink" title="正规式与有限自动机的等价性"></a>正规式与有限自动机的等价性</h5><ul><li>一个正规式 r 与一个有限自动机 M 等价<ul><li>L(r) = L(M)，即正规式对应的正规集 = 有限自动机所识别的字的整体</li></ul></li><li>FA -&gt; 正规式（FA 转正规式）<ul><li>对任何 FA M，都存在一个正规式 r，使得 L(r) = L(M)</li></ul></li><li>正规式 -&gt; FA（正规式转 FA）<ul><li>对于任何正规式 r，都存在一个 FA M，使得 L(M)=L(r)</li></ul></li></ul><h5 id="为-NFA-构造正规式"><a href="#为-NFA-构造正规式" class="headerlink" title="为 NFA 构造正规式"></a>为 NFA 构造正规式</h5><ul><li><p>为了证明正规式与有限自动机的等价性，我们先拓展状态转换图的概念，令每条弧可用一个正规式<br>作标记。</p></li><li><p>弧上的 r 指：识别了 r 这个正规式对应的正规集中的某个字</p></li><li><p>定理：对于 ∑ 上任一 <font color="red">NFA M</font>，都存在一个 ∑ 上的<font color="blue">正规式 r </font>，使得 L(r) = L(M)</p></li><li><p>假定 NFA M，我们对 M 状态转换图做以下改造：</p><ul><li><p>在 M 的转换图上<font color="red">加进两个状态 X 和 Y</font>，X 用 ε 弧连所有初态节点，所有终态节点用 ε 弧连 Y</p><img src="image-20200314170910492.png" style="zoom:50%"></li><li><p>反复运用下图三条规则，逐步消去节点，直到只剩下 X 和 Y</p><img src="image-20200314170944980.png" style="zoom:50%"></li></ul></li><li><p>最后，X 到 Y 的弧上标记的正规式即为所构造的正规式 r</p><img src="image-20200314171015776.png" style="zoom:50%"></li><li><p>得证：对 Σ 上任一 NFA M，都存在一个 Σ 上的正规式 r，使得 L(r)=L(M)</p></li></ul><h5 id="为正规式构造-NFA"><a href="#为正规式构造-NFA" class="headerlink" title="为正规式构造 NFA"></a>为正规式构造 NFA</h5><p>对给定正规式r中的运算符数目进行归纳</p><ul><li>验证r中的运算符数目为0时，结论成立。</li><li>假设结论对于运算符数目少于k(k≥1)的正规式成立</li><li>基于该假设，证明结论对于运算符数目为k的正规式成立。</li></ul><p>当r具有零个运算符，则r=ε或r=φ或r=a，其中a∈Σ。</p><ul><li><img src="image-20200315095032188.png" style="zoom:50%"></li></ul><p>当r中含有k个运算符时，r有三种情形：</p><ul><li><img src="image-20200315095101453.png" style="zoom:50%"></li><li><img src="image-20200315095111620.png" style="zoom:50%"></li><li><img src="image-20200315095132716.png" style="zoom:50%"></li><li><p>证明过程中的形式化描述被省略了，可以看PPT</p></li></ul><p>转换算法，构造Σ上的NFA M’ 使得L(r)=L(M’)：</p><ul><li>首先，把r表示成 <img src="image-20200315095458795.png" style="zoom:50%"></li><li>按下面的三条规则对r进行分裂<img src="image-20200315095513772.png" style="zoom:50%"></li><li>逐步把这个图转变为每条弧只标记为Σ上的一个字符或ε，最后得到一个NFA M’，显然L(M’)=L(r)</li></ul><img src="image-20200315095822693.png" style="zoom:67%"><p>NFA 还可以转换为 DFA。 DFA 再经过最小化可以得到一个化简的 DFA。</p><h3 id="词法分析器的自动产生-——-LEX"><a href="#词法分析器的自动产生-——-LEX" class="headerlink" title="词法分析器的自动产生 —— LEX"></a>词法分析器的自动产生 —— LEX</h3><img src="image-20200315113226265.png" style="zoom:50%"><p>LEX的工作过程</p><ul><li>对每条识别规则 Pi 构造一个相应的非确定有限自动机 Mi；</li><li>引进一个新初态 X，通过 ε 弧，将这些自动机连接成一个新的 NFA；</li><li>把 M 确定化、最小化，生成该 DFA 的状态转换表和控制执行程序</li></ul><h2 id="第四章-语法分析-自上而下"><a href="#第四章-语法分析-自上而下" class="headerlink" title="第四章 语法分析-自上而下"></a>第四章 语法分析-自上而下</h2><p><img src="image-20200620151331790.png" alt></p><h3 id="语法分析基本概念"><a href="#语法分析基本概念" class="headerlink" title="语法分析基本概念"></a>语法分析基本概念</h3><h4 id="语法分析的任务"><a href="#语法分析的任务" class="headerlink" title="语法分析的任务"></a>语法分析的任务</h4><p>语法分析的任务：分析一个文法的句子的结构</p><p>语法分析器的功能：按照文法的产生式 (语言的语法规则)，识别输入符号串是否为一个句子 (合式程序)</p><h4 id="语法分析器在编译器中的地位"><a href="#语法分析器在编译器中的地位" class="headerlink" title="语法分析器在编译器中的地位"></a>语法分析器在编译器中的地位</h4><img src="image-20200321100051743.png" style="zoom:50%"><h4 id="语法分析的方法"><a href="#语法分析的方法" class="headerlink" title="语法分析的方法"></a>语法分析的方法</h4><p>自下而上：</p><ul><li>从输入串开始，逐步进行归约，直到文法的开始符号</li><li>归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号</li><li>从树叶节点开始，构造语法树</li><li>算符优先分析法、LR 分析法</li></ul><p>自上而下：</p><ul><li>从文法的开始符号出发，反复使用各种产生式，寻找”匹配”的推导</li><li>推导：根据文法的产生式规则，把串中出现的产生式的左部符号替换成右部</li><li>从树的根开始，构造语法树</li><li>常用方法：递归下降分析法、预测分析程序</li></ul><h3 id="自上而下分析的基本问题"><a href="#自上而下分析的基本问题" class="headerlink" title="自上而下分析的基本问题"></a>自上而下分析的基本问题</h3><h4 id="文法左递归问题"><a href="#文法左递归问题" class="headerlink" title="文法左递归问题"></a>文法左递归问题</h4><ul><li>一个文法是含有左递归的，如果存在非终结符 P</li></ul><h5 id="直接左递归的消除"><a href="#直接左递归的消除" class="headerlink" title="直接左递归的消除"></a>直接左递归的消除</h5><p>假定 P 关于的全部产生式是 $\begin{align<em>}\mathrm{P} \rightarrow \mathrm{P} \alpha_{1}\left|\mathrm{P} \alpha_{2}\right| \ldots\left|\mathrm{P} \alpha_{\mathrm{m}}\right| \beta_{1}\left|\beta_{2}\right| \ldots | \beta_{\mathrm{n}}\end{align</em>}$</p><p>左递归变右递归：$\begin{align<em>}\begin{array}{c}<br>\mathrm{P} \rightarrow \beta_{1} \mathrm{P}^{\prime}\left|\beta_{2} \mathrm{P}^{\prime}\right| \ldots\left|\beta_{\mathrm{n}} \mathrm{P}^{\prime}\right| \<br>\mathrm{P}^{\prime} \rightarrow \alpha_{1} \mathrm{P}^{\prime}\left|\alpha_{2} \mathrm{P}^{\prime}\right| \ldots\left|\alpha_{\mathrm{m}} \mathrm{P}^{\prime}\right| \varepsilon<br>\end{array}\end{align</em>}$</p><p>例题：<img src="image-20200321101859468.png" style="zoom:33%"></p><h5 id="间接左递归的消除"><a href="#间接左递归的消除" class="headerlink" title="间接左递归的消除"></a>间接左递归的消除</h5><p>基本思路：把候选中开头的非终结符替换成它的定义，逐步减少定义的圈中的结点，最后变成一个自圈，然后打破定义上的圈</p><img src="image-20200321102515498.png" style="zoom:50%"><h5 id="消除左递归的算法"><a href="#消除左递归的算法" class="headerlink" title="消除左递归的算法"></a>消除左递归的算法</h5><ol><li>把文法 G 的所有非终结符按任一种顺序排列 <font color="red">$P_1，P_2，\cdots，P_n$</font></li><li>FOR i:=1 TO n DO<pre><code>FOR j:=1 TO i-1 DO
    把形如 $P_i \rightarrow P_j \gamma$ 的规则改写成 $P_i \rightarrow \delta_1 \gamma | \delta_2 \gamma|\cdots|\delta_k \gamma $ （其中 $P_j \rightarrow \delta_1 | \delta_2|\cdots|\delta_k$）
消除关于 $P_i$ 规则的直接左递归性</code></pre></li><li>化简由 2 所得的文法，去除从开始符号出发永远无法到达的非终结符的产生规则</li></ol><p>习题：消除文法 G(s) 的左递归 $\begin{align<em>}\begin{aligned}<br>&amp;S \rightarrow Q c | c\<br>&amp;Q \rightarrow R b | b\<br>&amp;R \rightarrow S a | a<br>\end{aligned}\end{align</em>}$</p><ul><li>排序 R、Q、S （不同的排序产生的文法是等价的）</li><li>先看 R，$R \rightarrow Sa|a$，其中 S 排在 R 的后面，没关系</li><li>再看 Q，$Q\rightarrow Rb|b$，其中 R 排在 Q 的前面，对其进行替换 $Q\rightarrow Sab|ab | b$<br>此时文法变为 $\begin{align<em>}\begin{aligned}<br>&amp;S \rightarrow Q c | c\<br>&amp;Q\rightarrow Sab|ab | b\<br>&amp;R \rightarrow S a | a<br>\end{aligned}\end{align</em>}$</li><li>再看 S，$S \rightarrow Q c | c$ ，其中 Q 排在 S 的前面，对其进行替换 $S \rightarrow Sabc|abc|bc|c $<br>出现了直接左递归，消除掉 $\begin{align<em>}\begin{aligned}<br>&amp;S \rightarrow abcS’|bcS’|cS’\ &amp; S’ \rightarrow abcS’ | \varepsilon \<br>\end{aligned}\end{align</em>}$</li><li>此时文法为 $\begin{align<em>}\begin{aligned}<br>&amp;S \rightarrow abcS’|bcS’|cS’\ &amp; S’ \rightarrow abcS’ | \varepsilon \<br>&amp;Q\rightarrow Sab|ab | b\<br>&amp;R \rightarrow S a | a<br>\end{aligned}\end{align</em>}$，消除掉从开始符号出发永远无法到达的非终结符的产生规则</li><li>$\begin{align<em>}\begin{aligned}<br>&amp;S \rightarrow abcS’|bcS’|cS’\ &amp; S’ \rightarrow abcS’ | \varepsilon \<br>\end{aligned}\end{align</em>}$</li></ul><h4 id="回溯问题"><a href="#回溯问题" class="headerlink" title="回溯问题"></a>回溯问题</h4><ul><li>分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的</li><li>出错时，不得不“回溯”</li></ul><h5 id="消除回溯"><a href="#消除回溯" class="headerlink" title="消除回溯"></a>消除回溯</h5><p>为了消除回溯必须保证：</p><ul><li>对文法的任何非终结符，当要它去匹配输入串时，能够根据它所面临的输入符号准确地指派它的一个候选去执行任务，并且此候选的工作结果应是确信无疑的。</li></ul><h5 id="FIRST-集合"><a href="#FIRST-集合" class="headerlink" title="FIRST 集合"></a>FIRST 集合</h5><ul><li>令 G 是一个不含左递归的文法，对G的所有非终结符的每个候选 α 定义它的终结首符集 FIRST(α) 为：</li></ul><p>$$<br>F I R S T(\alpha)=\left{a | \alpha \overset{\*}{\Rightarrow} a \cdots, a \in V_{T}\right}<br>$$</p><ul><li><p>特别是，若 $\alpha \overset{\*}{\Rightarrow} \varepsilon$，则规定 $\varepsilon \in F I R S T(\alpha)$</p></li><li><p>如果非终结符 A 的所有候选首符集两两不相交，即 A 的任何两个不同候选 αi 和 αj，$\begin{align<em>}\mathrm{FIRST}\left(\alpha_{i}\right) \cap \mathrm{FIRST}\left(\alpha_{j}\right)=\phi\end{align</em>} $</p></li><li><p>当要求 A 匹配输入串时，A 能根据它所面临的第一个输入符号 a，准确地指派某一个候选去执行任务。这个候选就是那个终结首符集含 a 的 α。</p></li></ul><p>提取公共左因子：</p><ul><li><p>假定关于 A 的规则是 $\begin{align<em>}A \rightarrow \delta \beta_{1}\left|\delta \beta_{2}\right| \ldots\left|\delta \beta_{n}\right| \gamma_{1}\left|\gamma_{2}\right| \ldots | \gamma_{m}\end{align</em>}$</p></li><li><p>那么，可以把这些规则改写成 $\begin{align<em>}\begin{array}{c}<br>A \rightarrow \delta A^{\prime}\left|\gamma_{1}\right| \gamma_{2}|\ldots| \gamma_{m} \<br>A^{\prime} \rightarrow \beta_{1}\left|\beta_{2}\right| \ldots | \beta_{n}<br>\end{array}\end{align</em>}$</p></li><li><p>经过反复提取左因子，就能够把每个非终结符(包括新引进者)的所有候选首符集变成为两两不相交</p></li></ul><h5 id="FOLLOW-集合"><a href="#FOLLOW-集合" class="headerlink" title="FOLLOW 集合"></a>FOLLOW 集合</h5><ul><li><p>如果一个非终结符 A ，有多个候选，当面临着输入符号 a 要用 A 去匹配的时候，如果这个 a 又不在任何一个候选的首符集里面，但是，有一个候选是 $\varepsilon $ 。当前如果 a 在某个句型中能够跟在 A 的后面时，才能选择 A 的 $\varepsilon $ 去匹配这个 A。</p></li><li><p>假定S是文法G的开始符号，对于G的任何非终结符A，我们定义A的FOLLOW集合</p></li></ul><p>$$<br>\begin{align<em>}F O L L O W(A)=\left{a | S \overset{\</em>}{\Rightarrow} \cdots A a \cdots, a \in V_{T}\right}\end{align*}<br>$$</p><ul><li><p>特别是，若 $S \overset{\*}{\Rightarrow} \cdots A$，则规定 $# \in F O L L O W(A)$</p></li><li><p>现在表述改为：当 a 要扩展 A 时，a 不出现在任何候选的 FIRST 集合里，而且有个 $\varepsilon $ 候选，如果 a 在 A 的 FOLLOW 集合里面，就把 A 替换成 $\varepsilon $ 。</p></li></ul><h3 id="LL-1-文法"><a href="#LL-1-文法" class="headerlink" title="LL(1)文法"></a>LL(1)文法</h3><h4 id="LL-1-文法的条件"><a href="#LL-1-文法的条件" class="headerlink" title="LL(1)文法的条件"></a>LL(1)文法的条件</h4><p>构造不带回溯的自上而下分析的文法条件：</p><ol><li><p>文法不含左递归</p></li><li><p>对于文法中每一个非终结符A的各个产生式的候选首符集两两不相交。<br>即，若 $A \rightarrow \alpha_{1}\left|\alpha_{2}\right| \dots | \alpha_{n}$，则 $FIRST \left(\alpha_{i}\right) \cap \operatorname{FIRST}\left(\alpha_{j}\right)=\phi$</p></li><li><p>对文法中的每个非终结符A，若它存在某个候选首符集包含ε，则 $\text{FIRST(A)} \cap \text{FOLLOW(A)}=\phi, \quad i=1,2, \dots, n$</p></li></ol><p>如果一个文法 G 满足以上条件，则称该文法为 LL(1) 文法</p><ul><li>L：从左到右扫描输入串</li><li>L：最左推导</li><li>1：每一步只需向前查看一个符号</li></ul><h4 id="LL-1-分析法"><a href="#LL-1-分析法" class="headerlink" title="LL(1)分析法"></a>LL(1)分析法</h4><ul><li>对于 LL(1) 文法，可以对其输入串进行有效的无回溯的自上而下分析</li><li>假设要用非终结符 A 进行匹配，面临的输入符号为 a，A 的所有产生式为<br>$A \rightarrow \alpha_{1}\left|\alpha_{2}\right| \dots | \alpha_{n}$<ol><li>若 $a \in F IRST\left(\alpha_{i}\right)$，则指派 $\alpha_i$ 执行匹配任务；</li><li>若 a 不属于任何一个候选首符集，则<br>(1) 若 ε 属于某个 FIRST(αi ) 且 a∈FOLLOW(A)， 则让 A 与 ε 自动匹配。<br>(2) 否则，a 的出现是一种语法错误。</li></ol></li></ul><h3 id="FIRST-集和-FOLLOW-集的构造"><a href="#FIRST-集和-FOLLOW-集的构造" class="headerlink" title="FIRST 集和 FOLLOW 集的构造"></a>FIRST 集和 FOLLOW 集的构造</h3><p>思想：把对无穷推导空间的可能的考察，转换成对有限产生式的反复扫描</p><h4 id="构造-FIRST-α"><a href="#构造-FIRST-α" class="headerlink" title="构造 FIRST(α)"></a>构造 FIRST(α)</h4><p>$$<br>F I R S T(\alpha)=\left{a | \alpha \overset{\*}{\Rightarrow} a \cdots, a \in V_{T}\right}<br>$$</p><ul><li><font color="red">文法符号</font>：$\alpha=X, \quad X \in V_{T} \cup V_{N}$</li><li><font color="red">符号串</font>：$\alpha=X_{1} X_{2} \ldots X_{n}, \quad X_{i} \in V_{T} \cup V_{N}$</li></ul><p>构造每个<font color="red">文法符号</font>的 FIRST 集合：</p><ul><li>对每一 $X \in V_{T} \cup V_{N}$，连续使用下面的规则，直至每个集合 FIRST 不再增大为止：<ol><li>若 $X \in V_{T}$，则 $F IRST(X)={X}$</li><li>若 $X \in V_{N}$，且有产生式 $X\rightarrow a \cdots$，则把 a 加入到 $F IRST(X)$ 中；<br>若 $X\rightarrow \varepsilon$ 也是一条产生式，则把 $\varepsilon$ 也加到 $F IRST(X)$ 中</li><li><ul><li>若 $X\rightarrow Y \cdots$ 是一个产生式且 $Y\in V_N$ ，则把 $F IRST(Y)$ 中的所有非 $\varepsilon$ 也加到 $F IRST(X)$ 中</li><li>若 $X \rightarrow Y_{1} Y_{2} \ldots Y_{i-1} Y_{i} \ldots Y_{k}$ 是一个产生式，$Y_{1}, Y_{2} ,\cdots ,Y_{i-1}$ 都是非终结符<ul><li>对于任何 j，$1 \leq j \leq i-1$，$FIRST \left(Y_{j}\right)$ 都含有 $\varepsilon$ （$Y_{1} \cdots Y_{i-1} \overset{\*}{\Rightarrow} \varepsilon$），则把 $FIRST \left(Y_{i}\right)$ 中的所有非 $\varepsilon$ 也加到 $FIRST(X)$ 中</li><li>若所有的 $FIRST \left(Y_{j}\right)$ 都含有 $\varepsilon$ ，j=1,2,…,k，则把 $\varepsilon$ 加到 $FIRST(X)$ 中</li></ul></li></ul></li></ol></li></ul><p>构造任何<font color="red">符号串</font>的 FIRST 集合：</p><ul><li>对文法 G 的任何符号串 $\alpha=X_{1} X_{2} \cdots X_{n}$ 构造集合 $FIRST \left(\alpha\right) $<ol><li>置 $\mathrm{FIRST}(\alpha)=\mathrm{FIRST}\left(\mathrm{X}_{1}\right) \backslash{\varepsilon}$，斜杠表示集合去掉某个元素</li><li>若对任何 $1 \leq j \leq i-1 $ ，$\varepsilon \in \mathrm{FIRST}\left(\mathrm{X}<em>{\mathrm{j}}\right)$，则把 $\mathrm{FIRST}\left(\mathrm{X}</em>{i}\right) \backslash{\varepsilon}$ 加至 $\mathrm{FIRST}(\alpha)$ 中；<br>特别是，若所有的 $ \mathrm{FIRST}\left(\mathrm{X}_{\mathrm{j}}\right)$ 都含 $\varepsilon$ （$1 \leq j \leq n$），则把 $\varepsilon$ 也加至 $\mathrm{FIRST}(\alpha)$ 中。<br>显然，若 $\alpha = \varepsilon$ 则 $\mathrm{FIRST}(\alpha)={\varepsilon }$</li></ol></li></ul><h4 id="构造-FOLLOW-A"><a href="#构造-FOLLOW-A" class="headerlink" title="构造 FOLLOW(A)"></a>构造 FOLLOW(A)</h4><p>$$<br>\begin{align<em>}F O L L O W(A)=\left{a | S \overset{\</em>}{\Rightarrow} \cdots A a \cdots, a \in V_{T}\right}\end{align*}<br>$$</p><p>构造每个非终结符的 FOLLOW 集合：</p><ul><li>对于文法 G 的每个非终结符 A 构造 FOLLOW(A) 的办法是，连续使用下面的规则，直至每个 FOLLOW 不再增大为止：<ol><li>对于文法的开始符号 S，置＃于 FOLLOW(S) 中；</li><li>若 A→αBβ 是一个产生式，则把 FIRST(β)\{ε} 加至 FOLLOW(B) 中；</li><li>若（ A→αB 是一个产生式）或（ A→αBβ 是一个产生式而 ε ∈ FIRST(β) ），则把 FOLLOW(A) 加至 FOLLOW(B) 中<img src="image-20200321170843689.png" style="zoom:50%"></li></ol></li></ul><p>例题：</p><img src="image-20200321172809485.png" style="zoom:50%"><h3 id="递归下降分析程序"><a href="#递归下降分析程序" class="headerlink" title="递归下降分析程序"></a>递归下降分析程序</h3><p>概念：</p><ul><li>分析程序由一组子程序组成， 对每一语法单位(非终结符)构造一个相应的子程序，识别对应的语法单位</li><li>通过子程序间的相互调用实现对输入串的识别<ul><li>例如，A → B c D</li></ul></li><li>文法的定义通常是递归的，通常具有递归结构</li></ul><p>定义全局过程和变量：</p><ul><li>ADVANCE，把输入串指示器IP指向下一个输入符号，即读入一个单词符号</li><li>SYM，IP当前所指的输入符号</li><li>ERROR，出错处理子程序</li></ul><p>例子：</p><img src="image-20200322084740548.png" style="zoom:67%"><p>例子：$\begin{align<em>}\begin{aligned}<br>&amp;E \rightarrow T E^{\prime}\<br>&amp;E^{\prime} \rightarrow+T E^{\prime} | \varepsilon\<br>&amp;T \rightarrow F T^{\prime}\<br>&amp;T^{\prime} \rightarrow \text{</em>} F T^{\prime} | \varepsilon\<br>&amp;F \rightarrow(E) | i<br>\end{aligned}\end{align*}$ 的递归下降子程序为</p><img src="image-20200322085322815.png" style="zoom:50%"><h3 id="扩充的巴科斯范式"><a href="#扩充的巴科斯范式" class="headerlink" title="扩充的巴科斯范式"></a>扩充的巴科斯范式</h3><p>在元符号“→”或“::=”和“|”的基础上，扩充几个元语言符号：</p><ul><li>用花括号 {α} 表示闭包运算 α*。</li><li>用表示 ${α}_0^n$ 可任意重复 0 次至 n 次。</li><li>用方括号 [α] 表示 ${α}_0^1$ ，即表示 α 的出现可有可无 (等价于 α|ε )。</li></ul><p>例如，通常的 “实数” 可定义为：</p><ul><li><p>Decimal→ [Sign]Integer.{digit}[Exponent]</p></li><li><p>Exponent→ E[Sign]Integer</p></li><li><p>Integer→ digit{digit}</p></li><li><p>Sign→ + | -</p></li><li><p>用扩充的巴科斯范式来描述语法，直观易懂，便于表示左递归消去和因子提取。</p></li></ul><p>例如，$\begin{align<em>}\begin{aligned}<br>&amp;E \rightarrow T | E+T\<br>&amp;T \rightarrow F | T^{\star} F\<br>&amp;F \rightarrow i |(E)<br>\end{aligned}\end{align</em>} $ 可表示成 $\begin{align<em>}\begin{aligned}<br>&amp;E \rightarrow T{+T}\<br>&amp;T \rightarrow F{\star F}\<br>&amp;F \rightarrow i |(E)<br>\end{aligned}\end{align</em>} $，其语法图和递归下降子程序如下</p><img src="image-20200322091141519.png" style="zoom:33%"> <img src="image-20200322091311734.png" style="zoom:50%"><h3 id="预测分析程序"><a href="#预测分析程序" class="headerlink" title="预测分析程序"></a>预测分析程序</h3><h4 id="预测分析程序构成"><a href="#预测分析程序构成" class="headerlink" title="预测分析程序构成"></a>预测分析程序构成</h4><ul><li>总控程序，根据现行栈顶符号和当前输入符号，执行动作</li><li>分析表 $M[A，a]$ 矩阵，$A ∈ V_N ，a ∈ V_T$ 是终结符或 ‘＃’</li><li>分析栈 STACK 用于存放文法符号</li></ul><img src="image-20200322095752990.png" style="zoom:50%"><h4 id="预测分析过程"><a href="#预测分析过程" class="headerlink" title="预测分析过程"></a>预测分析过程</h4><p>总控程序根据当前栈顶符号X和输入符号a，执行下列三动作之一：</p><ol><li>若 X＝a＝‘＃’，则宣布分析成功，停止分析。</li><li>若 X＝a ≠‘＃’，则把 X 从 STACK 栈顶逐出，让 a 指向下一个输入符号。</li><li>若 X 是一个非终结符，则查看分析表 M。<ul><li>若 M[X，a] 中存放着关于 X 的一个产生式，把 X 逐出 STACK 栈顶，把产生式的右部符号串按反序一一推进 STACK 栈 (若右部符号为ε ，则意味不推什么东西进栈)。</li><li>若 M[X，a] 中存放着“出错标志”，则调用出错诊察程序 ERROR。</li></ul></li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">    首先把‘＃’然后把文法开始符号推进STACK栈；</span><br><span class="line">    把第一个输入符号读进a；</span><br><span class="line">    FLAG:=TRUE;</span><br><span class="line">    WHILE FLAG DO</span><br><span class="line">    BEGIN</span><br><span class="line">        把STACK栈顶符号上托出去并放在X中；</span><br><span class="line">        IF X∈VT THEN</span><br><span class="line">            IF X= a THEN 把下一输入符号读进a</span><br><span class="line">            ELSE ERROR</span><br><span class="line">        ELSE IF X=‘#’ THEN</span><br><span class="line">            IF X=a THEN FLAG:=FALSE</span><br><span class="line">            ELSE ERROR</span><br><span class="line">        ELSE IF M[X,a]=&#123;X→X1X2…Xk&#125;THEN</span><br><span class="line">            把Xk,Xk-1,…,X1一一推进STACK栈 /* 若X1X2…Xk=ε，不推什么进栈*/</span><br><span class="line">        ELSE ERROR</span><br><span class="line">    END OF WHILE;</span><br><span class="line">    STOP /*分析成功，过程完毕*/</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>例子：对于 $\begin{align<em>}\begin{aligned}<br>&amp;E \rightarrow T | E+T\<br>&amp;T \rightarrow F | T^{\star} F\<br>&amp;F \rightarrow i |(E)<br>\end{aligned}\end{align</em>} $ ，输入串为 $i_1* i_2+i_3$ ，利用分析表进行预测</p><img src="image-20200322100324202.png" style="zoom:60%"><h4 id="预测分析表的构造"><a href="#预测分析表的构造" class="headerlink" title="预测分析表的构造"></a>预测分析表的构造</h4><p>分析表 M[A，a] 的构造：</p><ul><li>构造 FIRST(α) 和 FOLLOW(A)</li><li>构造分析表 M[A，a]</li></ul><p>构造 G 的分析表 M[A，a]， 确定每个产生式A→α在表中的位置：</p><ol><li>对文法 G 的每个产生式 A→α 执行第 2 步和第 3 步；</li><li>对每个终结符 a∈FIRST(α)，把 A→α 加至 M[A，a] 中；</li><li>若 ε∈FIRST(α)，则对任何 b∈FOLLOW(A) 把 A→α 加至 M[A，b] 中。</li><li>把所有无定义的 M[A，a] 标上“出错标志”。</li></ol><h4 id="LL-1-文法与二义性"><a href="#LL-1-文法与二义性" class="headerlink" title="LL(1)文法与二义性"></a>LL(1)文法与二义性</h4><ul><li>如果 G 是左递归或二义的，那么，M 至少含有一个多重定义入口。因此，消除左递归和提取左因子将有助于获得无多重定义的分析表 M。</li><li>可以证明，一个文法 G 的预测分析表 M 不含多重定义入口，当且仅当该文法为 LL(1) 的。</li><li>LL(1) 文法不是二义的。</li></ul><h2 id="第五章-语法分析-自下而上"><a href="#第五章-语法分析-自下而上" class="headerlink" title="第五章 语法分析-自下而上"></a>第五章 语法分析-自下而上</h2><p><img src="image-20200620152127323.png" alt></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="语法分析的方法-1"><a href="#语法分析的方法-1" class="headerlink" title="语法分析的方法"></a>语法分析的方法</h4><p>自下而上：</p><ul><li>从输入串开始，逐步进行归约，直到文法的开始符号</li><li>归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号</li><li>从树叶节点开始，构造语法树</li><li>算符优先分析法、LR 分析法</li></ul><p>自上而下：</p><ul><li>从文法的开始符号出发，反复使用各种产生式，寻找”匹配”的推导</li><li>推导：根据文法的产生式规则，把串中出现的产生式的左部符号替换成右部</li><li>从树的根开始，构造语法树</li><li>常用方法：递归下降分析法、预测分析程序</li></ul><h4 id="自下而上分析示例"><a href="#自下而上分析示例" class="headerlink" title="自下而上分析示例"></a>自下而上分析示例</h4><img src="image-20200330152956480.png" style="zoom:50%"><h4 id="自下而上分析的基本思想"><a href="#自下而上分析的基本思想" class="headerlink" title="自下而上分析的基本思想"></a>自下而上分析的基本思想</h4><ul><li>采用 <font color="red">“移进－归约”</font> 思想进行自下而上分析</li><li>基本思想<ul><li>用一个寄存符号的先进后出栈，把输入符号一个一个地移进到栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换成(归约为)该产生式的左部符号。</li></ul></li></ul><h4 id="移进－归约分析示例"><a href="#移进－归约分析示例" class="headerlink" title="移进－归约分析示例"></a>移进－归约分析示例</h4><p>设文法G(S)：<br>(1) S → aAcBe<br>(2) A → b<br>(3) A → Ab<br>(4) B → d</p><p>试对 abbcde 进行 “移进－归约” 分析</p><img src="image-20200330154716910.png" style="zoom:67%"><ul><li><p>自下而上分析过程：边输入单词符号，边归约</p></li><li><p>核心问题：识别可归约串</p></li><li><p>分析树和语法树不一定一致</p></li></ul><h4 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h4><ul><li><p>定义：令 G 是一个文法，S 是文法的开始符号，假定 <font color="blue">α</font><font color="red">β</font><font color="blue">δ</font> 是文法 G 的一个句型，如果有 $\large \mathrm{S} \overset{*}{\Rightarrow} \alpha \mathrm{A} \delta \ \ \text{且}\ \ \mathrm{A} \overset{+}{\Rightarrow} \beta $，则 <font color="red">β</font> 称是句型 <font color="blue">α</font><font color="red">β</font><font color="blue">δ</font> 相对于非终结符 A 的短语。</p></li><li><p>如果有 $A\rightarrow β$，则称 β 是句型 αβδ 相对于规则 A→ β的直接短语。（一步推出则短语是直接短语）</p></li></ul><p>例子：</p><ul><li><p>考虑文法 G(E)：<br>E → T | E+T<br>T → F | T*F<br>F → (E) | i<br>和句型 i1*i2+i3：</p></li><li><p>短语：i1，i2，i3， i1*i2， i1*i2+i3<br>直接短语：i1，i2，i3</p></li><li><img src="image-20200330172613318.png" style="zoom:50%"></li><li><img src="image-20200330173224026.png" style="zoom:67%"></li></ul><p>在一个句型对应的语法树中</p><ul><li>以某非终结符为根的<font color="red">两代以上的子树的所有末端结点从左到右排列</font>就是相对于该非终结符的一个<font color="red">短语</font></li><li>如果子树只有两代，则该短语就是<font color="red">直接短语</font></li></ul><h3 id="算符优先文法"><a href="#算符优先文法" class="headerlink" title="算符优先文法"></a>算符优先文法</h3><ul><li><p>按照算符的优先关系和结合性质进行语法分析</p></li><li><p>适合分析表达式</p></li></ul><h4 id="算符优先级"><a href="#算符优先级" class="headerlink" title="算符优先级"></a>算符优先级</h4><p>下图中两个文法，左文法没有体现先乘除后加减同级从左到右的约定。右文法的非终结符的定义关系中，进一步体现了算符在规约上的优先关系。</p><img src="image-20200330213405879.png" style="zoom:67%"><h4 id="优先关系"><a href="#优先关系" class="headerlink" title="优先关系"></a>优先关系</h4><ul><li>任何两个可能相继出现的终结符 a 与 b 可能三种优先关系<ul><li>$a\lessdot b$，a的优先级低于b</li><li>$a \eqcirc b$，a的优先级等于b</li><li>$a \gtrdot b$，a的优先级高于b</li></ul></li><li>算符优先关系与数学上的 &lt;&gt;= 不同<ul><li>$+ \lessdot +$</li><li>$a \lessdot b$，并不意味着 $b \gtrdot a$，如 $(\ \lessdot +$ 和 $+ \lessdot\ ($</li></ul></li></ul><h4 id="算符文法"><a href="#算符文法" class="headerlink" title="算符文法"></a>算符文法</h4><ul><li>概念：一个文法，它的任一产生式的右部都不含两个相继 (并列) 的非终结符，即不含 <font color="red">…QR…</font> 形式的产生式右部</li><li>约定：<ul><li>a、b 代表任意终结符</li><li>P、Q、R 代表任意非终结符</li><li>‘…’ 代表由终结符和非终结符组成的任意序列，包括空字</li></ul></li></ul><h4 id="算符优先文法-1"><a href="#算符优先文法-1" class="headerlink" title="算符优先文法"></a>算符优先文法</h4><ul><li><p>假定 G 是一个不含 ε-产生式的算符文法。对于任何一对终结符 a、b，我们说：</p><ul><li><font color="red">$a \eqcirc b$ </font>，当且仅当文法 G 含有形如 <font color="blue">P→…ab… </font>或 <font color="blue">P→…aQb… </font>的产生式</li><li><font color="red">$a \lessdot b$ </font>，当且仅当文法 G 含有形如 <font color="blue">P→…aR… </font>的产生式 ，而 <font color="blue">$R\overset{+}{\Rightarrow} b…$ 或 $R\overset{+}{\Rightarrow} Rb…$</font></li><li><font color="red">$a \gtrdot b$ </font>，当且仅当文法 G 含有形如 <font color="blue">P→…Rb… </font>的产生式 ，而 <font color="blue">$R\overset{+}{\Rightarrow} a…$ 或 $R\overset{+}{\Rightarrow} aQ…$</font></li></ul></li><li><p>如果一个算符文法 G 中的任何终结符对 (a, b) 至多只满足 <font color="blue">$a \eqcirc b、a \lessdot b、a \gtrdot b$</font> 这三个关系之一，则称 G 是一个<font color="red">算符优先文法</font></p></li></ul><h4 id="优先关系表"><a href="#优先关系表" class="headerlink" title="优先关系表"></a>优先关系表</h4><ul><li><p>考虑下面的文法G(E)：<br>(1) E→E+T | T<br>(2) T→T*F | F<br>(3) F→P ↑ F | P<br>(4) P→(E) | i</p></li><li><p>根据优先关系的定义，可以计算优先关系如下</p></li></ul><img src="image-20200331153015865.png" style="zoom:67%"><ul><li>将所有的优先关系用一个 n×n 的表格表示，(1, 1) 这个格子表示左边的加号优先级高于右边的加号</li></ul><img src="image-20200331153034534.png" style="zoom:67%"><h5 id="优先关系表的前提"><a href="#优先关系表的前提" class="headerlink" title="优先关系表的前提"></a>优先关系表的前提</h5><ul><li><p>确定满足关系 $a \eqcirc b$ 的所有终结符对</p><ul><li>$a \eqcirc b$，当且仅当文法G中含有形如 <font color="blue">P→…ab…</font> 或 <font color="blue">P→…aQb…</font> 的产生式</li><li>通过检查 G 的每个产生式的每个候选式，可找出所有满足 $a \eqcirc b$ 的终结符对</li><li>只要检查产生式，无需考虑推导，就能计算所有可能的优先级相等关系</li></ul></li><li><p>确定满足关系 $\lessdot、\gtrdot$ 的所有终结符对</p><ul><li><font color="red">$a \lessdot b$ </font>，当且仅当文法 G 含有形如 <font color="blue">P→…aR… </font>的产生式 ，而 <font color="blue">$R\overset{+}{\Rightarrow} b…$ 或 $R\overset{+}{\Rightarrow} Rb…$</font></li><li><font color="red">$a \gtrdot b$ </font>，当且仅当文法 G 含有形如 <font color="blue">P→…Rb… </font>的产生式 ，而 <font color="blue">$R\overset{+}{\Rightarrow} a…$ 或 $R\overset{+}{\Rightarrow} aQ…$</font></li></ul></li><li><p>FIRSTVT 集：$FIRSTVT(P) = {a\ |\ P \overset{+}{\Rightarrow}a…或P \overset{+}{\Rightarrow}Qa…，a\in V_T 且 Q\in V_N }$</p></li><li><p>LASTVT 集：$LASTVT(P) = {a\ |\ P \overset{+}{\Rightarrow}…a或P \overset{+}{\Rightarrow}…aQ，a\in V_T 且 Q\in V_N }$</p></li></ul><h5 id="构造集合FIRSTVT-P-的算法"><a href="#构造集合FIRSTVT-P-的算法" class="headerlink" title="构造集合FIRSTVT(P)的算法"></a>构造集合FIRSTVT(P)的算法</h5><p>反复使用下面两条规则构造集合 FIRSTVT(P)</p><ol><li>若有产生式P→a…或P→Qa…，则a∈FIRSTVT(P)</li><li>若a∈FIRSTVT(Q)，且有产生式P→Q…，则a∈FIRSTVT(P)</li></ol><p>算法的一种实现（利用栈）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE INSERT(P，a)</span><br><span class="line">IF NOT F[P，a] THEN</span><br><span class="line">BEGIN</span><br><span class="line">	F[P，a]:=TRUE；</span><br><span class="line">	把(P，a)下推进STACK栈</span><br><span class="line">END；</span><br><span class="line"></span><br><span class="line">主程序：</span><br><span class="line">BEGIN</span><br><span class="line">	FOR 每个非终结符P和终结符a DO</span><br><span class="line">		F[P，a]:=FALSE；</span><br><span class="line">	FOR 每个形如P→a…或P→Qa…的产生式DO</span><br><span class="line">		INSERT(P，a)；</span><br><span class="line">	WHILE STACK 非空DO</span><br><span class="line">	BEGIN</span><br><span class="line">		把STACK的顶项，记为(Q，a)，上托出去；</span><br><span class="line">		FOR 每条形如P→Q…的产生式DO</span><br><span class="line">			INSERT(P，a)；</span><br><span class="line">	END OF WHILE；</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h5 id="构造集合LASTVT-P-的算法"><a href="#构造集合LASTVT-P-的算法" class="headerlink" title="构造集合LASTVT(P)的算法"></a>构造集合LASTVT(P)的算法</h5><p>反复使用下面两条规则构造集合 LASTVT(P)</p><ol><li>若有产生式P→… a或P→ … aQ，则a∈LASTVT(P)</li><li>若a∈LASTVT(Q)，且有产生式P→… Q，则a∈LASTVT(P)</li></ol><p>构造优先关系表的算法：</p><img src="image-20200401155319659.png" style="zoom:67%"><p>示例：</p><img src="image-20200401155353216.png" style="zoom:50%"><p>是算符优先文法，因为表里没有冲突项，任何一对终结符之间最多只有一种优先关系。</p><h4 id="最左素短语"><a href="#最左素短语" class="headerlink" title="最左素短语"></a>最左素短语</h4><p>概念：</p><ul><li>素短语：一个文法 G 的句型的素短语是指这样一个短语，它至少含有一个终结符，并且，除它自身之外不再含任何更小的素短语</li><li>最左素短语：处于句型最左边的那个素短语</li></ul><p>示例：</p><img src="image-20200401171604548.png" style="zoom:67%"><ul><li>语法树可以看出短语和素短语，但是我们没有语法树，语法分析的结果是分析树，检测短语和素短语是语法分析的过程，所以要有其他的方法来检测短语和素短语。</li></ul><p>最左素短语定理：</p><ul><li><p>算符优先文法句型(括在两个＃之间)的一般形式：<br>$#N_1a_1N_2a_2…N_na_nN_{n+1}#$<br>其中，ai 都是终结符，Ni是可有可无的非终结符。</p></li><li><p>定理：一个算符优先文法 G 的任何句型的最左素短语是<br>满足如下条件的最左子串 $N_ja_j\cdots N_ia_iN_{i+1}$，<br>$a_{j-1} \lessdot a_j，\ a_{j} \eqcirc a_{j+1}，\cdots，a_{i-1} \eqcirc a_i，\ a_i \gtrdot a_{i+1} $</p></li></ul><h4 id="算符优先分析算法"><a href="#算符优先分析算法" class="headerlink" title="算符优先分析算法"></a>算符优先分析算法</h4><ul><li>使用一个符号栈 S，用它寄存终结符和非终结符，k 代表符号栈 S 的使用深度</li><li>在正确的情况下，算法工作完毕时，符号栈 S 应呈现：# N #</li></ul><img src="image-20200401182913505.png" style="zoom:67%"><p>分析树与语法树：</p><p><img src="image-20200401183135757.png" alt></p><h3 id="LR分析法"><a href="#LR分析法" class="headerlink" title="LR分析法"></a>LR分析法</h3><h4 id="自下而上的思想"><a href="#自下而上的思想" class="headerlink" title="自下而上的思想"></a>自下而上的思想</h4><ul><li>基本思想<ul><li>从输入串开始，逐步<font color="red">归约</font>，直到文法的开始符号</li><li><font color="red">归约</font>：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号</li><li>从树叶节点开始，构造语法树</li></ul></li><li>算符优先分析法<ul><li>按照算符的优先关系和结合性质进行语法分析</li><li>适合分析表达式</li></ul></li><li>LR 分析法<ul><li>规范规约：<font color="red">句柄</font>作为可规约串</li></ul></li></ul><h4 id="句柄与规范规约"><a href="#句柄与规范规约" class="headerlink" title="句柄与规范规约"></a>句柄与规范规约</h4><p>概念：</p><ul><li><p>短语：令 G 是一个文法，S 是文法的开始符号，假定 <font color="blue">α</font><font color="red">β</font><font color="blue">δ</font> 是文法 G 的一个句型，如果有 $\large \mathrm{S} \overset{*}{\Rightarrow} \alpha \mathrm{A} \delta \ \ \text{且}\ \ \mathrm{A} \overset{+}{\Rightarrow} \beta $，则 <font color="red">β</font> 称是句型 <font color="blue">α</font><font color="red">β</font><font color="blue">δ</font> 相对于非终结符 A 的短语。</p></li><li><p>直接短语：如果有 $A\rightarrow β$，则称 β 是句型 αβδ 相对于规则 A→ β的直接短语。（一步推出则短语是直接短语）</p></li><li><p>句柄：一个句型的最左直接短语（感觉是语法树最左两代子树末端 / 最底的两层）</p></li></ul><p>例子：</p><img src="image-20200407154103534.png" style="zoom:67%"><p>规范规约：</p><ul><li>定义：假定 α 是文法 G 的一个句子，我们称序列 $\alpha_{n}, \alpha_{n-1}, \cdots, \alpha_0$ 是 α 的一个规范归约，如果此序列满足：<ol><li>$\alpha_n = \alpha$</li><li>$\alpha_0$ 为文法的开始符号，即 $\alpha_0 = S$</li><li>对任何 $i, 0\le 1\le n$，$\alpha_{i-1} $ 是从 $\alpha_i$ 经把句柄替换成相应产生式左部符号而得到</li></ol></li></ul><p>算符优先分析一般不等价于规范规约：</p><img src="image-20200407154545571.png" style="zoom:67%"><p>规范句型：</p><ul><li>规范归约是最左归约</li><li>规范归约的逆过程就是最右推导 $S \Rightarrow aAcBe \Rightarrow aAcde \Rightarrow aAbcde \Rightarrow abbcde $</li><li>最右推导也称为规范推导</li><li>由规范推导推出的句型称为规范句型</li></ul><h4 id="LR-分析表"><a href="#LR-分析表" class="headerlink" title="LR 分析表"></a>LR 分析表</h4><p>规范归约的关键问题是寻找句柄：</p><ul><li>历史：已移入符号栈的内容</li><li>展望：根据产生式推测未来可能遇到的输入符号</li><li>现实：当前的输入符号</li></ul><p>LR 分析方法：把”历史”及”展望”综合抽象成状态；由栈顶的状态和现行的输入符号唯一确定每一步工作</p><p>LR 分析器结构：</p><img src="image-20200407160627026.png" style="zoom:67%"><p>LR 分析器的核心是一张分析表：</p><ul><li>ACTION[s，a]：当状态 s 面临输入符号 a 时，应采取什么动作</li><li>GOTO[s，X]：状态 s 面对文法符号 X 时，下一状态是什么</li></ul><p>LR 分析表的使用（根据 $ACTION(s_m , a_i)$确定下一步动作）：</p><ul><li><p>$(s_0\ s_1\ s_m\ ,\quad #\ X_1 \cdots X_m\ ,\quad a_i \ a_{i+1} \cdots a_n # ) $</p></li><li><p>若 $ACTION(s_m , a_i)$ 为移进，且 s 为下一状态，则格局变为:<br>$(s_0\ s_1\ s_m\ s ,\quad #\ X_1 \cdots X_m\ a_i,\quad a_{i+1} \cdots a_n # ) $</p></li></ul><ol start="2"><li>若 $ACTION(s_m , a_i)$ 为按 $A \rightarrow \beta$ 归约，格局变为：<br>$(s_0\ s_1\ s_{m-r}\ s ,\quad #\ X_1 \cdots X_{m-r}\ A ,\quad a_i \ a_{i+1} \cdots a_n # ) $</li></ol><ul><li>此处，$s=GOTO(s_{m-r}, A)$，r 为 $\beta$ 的长度，$\beta = X_{m-r+1}\cdots X_m$</li></ul><ol start="3"><li>若 $ACTION(s_m , a_i)$ 为 “接受”，则格局变化过程终止，宣布分析成功。</li><li>若 $ACTION(s_m , a_i)$ 为 “报错”，则格局变化过程终止，报告错误。</li></ol><p>“移进-规约” 的过程（LR 分析表的使用）：</p><img src="image-20200407163258745.png" style="zoom:50%"><p>LR 文法：</p><ul><li><p>定义：对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这个文法就称为 LR 文法。</p></li><li><p>定义：一个文法，如果能用一个每步顶多向前检查 k 个输入符号的 LR 分析器进行分析，则这个文法就称为 LR(k) 文法.</p></li><li><p>LR 文法不是二义的，二义文法肯定不会是 LR 的</p></li><li><p>LR 文法 ⊂ 无二义文法</p></li><li><p>非 LR 结构：S → iCtS | iCtSeS</p></li></ul><h4 id="LR-0-分析表的构造"><a href="#LR-0-分析表的构造" class="headerlink" title="LR(0) 分析表的构造"></a>LR(0) 分析表的构造</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>前缀、活前缀：</p><ul><li>字的前缀：是指字的任意首部，如字 abc 的前缀有 ε，a，ab，abc</li><li>活前缀：是指规范句型的一个前缀，这种前缀不含句柄之后的任何符号。即，对于规范句型 αβδ，β为句柄，如果αβ=u1u2…ur，则符号串 u1u2…ui(1≤i≤r) 是 αβδ 的活前缀。(δ必为终结符串)</li><li>规范归约过程中，保证分析栈中总是活前缀，就说明分析采取的移进/归约动作是正确的</li></ul><p>拓广文法：</p><ul><li>构造文法 G′，它包含了整个 G，并引进不出现在 G 中的非终结符 S′、以及产生式 S′→S，S′ 是 G′ 的开始符号</li></ul><p>LR(0) 项目：</p><ul><li><p>在每个产生式的右部添加一个圆点，表示我们在分析过程中看到了产生式多大部分</p><ul><li>比如：A→XYZ有四个项目 A→ •XYZ、A→X•YZ、A→XY•Z、A→XYZ•</li></ul></li><li><p>A→α• 称为”归约项目”</p></li><li><p>归约项目 S′→α • 称为”接受项目”</p></li><li><p>A→α•aβ (a∈$V_T $) 称为”移进项目”</p></li><li><p>A→α•Bβ (B∈$V_N $) 称为”待约项目”</p></li><li><p>LR(0) 项目包括拓广文法在内的所有项目。</p></li><li><p>例子：<img src="image-20200410180138170.png" style="zoom:50%"></p></li></ul><h5 id="构造识别活前缀的-DFA"><a href="#构造识别活前缀的-DFA" class="headerlink" title="构造识别活前缀的 DFA"></a>构造识别活前缀的 DFA</h5><p>构造识别活前缀的 DFA：</p><ul><li><p>构造识别文法所有活前缀的 NFA</p><ul><li><p>若状态 $i$ 为$\begin{align<em>}X \rightarrow X_{1} \cdots X_{i-1} \bullet X_{i} \cdots X_{n}\end{align</em>}$ ，状态 $j$ 为 ，$\begin{align<em>}X \rightarrow X_{1} \cdots X_{i-1} X_{i}\bullet X_{i+1} \cdots X_{n}\end{align</em>}$，则画一条边 $\langle i, j,X_i\rangle$</p></li><li><p>若状态 $i$ 为 $X\rightarrow \alpha \bullet A\beta$，A 为非终结符，则从 i 画一条 ε 边到所有状态 A→•γ</p><img src="image-20200410181704379.png" style="zoom:50%"></li><li><p>例子：<img src="image-20200410182101319.png" style="zoom:50%"></p></li></ul></li><li><p>把 NFA 确定化</p><ul><li>例子：<img src="image-20200410182559422.png" style="zoom:50%"></li></ul></li></ul><p>LR(0) 项目集规范族：</p><ul><li>构成识别一个文法活前缀的 DFA 的项目集/状态 的全体称为文法的 LR(0) 项目集规范族。</li><li>例如上图中 0~11 状态的每个方框</li></ul><h5 id="通过计算项目集规范族构造识别活前缀的-DFA"><a href="#通过计算项目集规范族构造识别活前缀的-DFA" class="headerlink" title="通过计算项目集规范族构造识别活前缀的 DFA"></a>通过计算项目集规范族构造识别活前缀的 DFA</h5><ul><li>利用有效项目的概念，直接计算出项目集规范族，从而来构造 DFA</li></ul><p>有效项目：</p><ul><li><p>项目 <font color="red">A</font>→ <font color="blue">β1</font>•<font color="green">β2 </font>对活前缀 <font color="blue">αβ1</font> 是有效的，其条件是存在规范推导 $\Large \begin{align<em>}\mathrm{S}^{\prime} \overset{</em>}{\Rightarrow_{R}} \alpha A \omega \Rightarrow_{R} \alpha \beta_{1} \beta_{2} \omega\end{align*}$</p></li><li><p>在任何时候，分析栈中的活前缀 X1X2 … Xm 的有效项目集正是从识别活前缀的 DFA 的初态出发，读出 X1X2 … Xm 后到达的那个项目集(状态)。</p></li></ul><p>有效项目的性质：</p><ul><li><p>若项目 <font color="blue">A→α•Bβ</font> 对活前缀 <font color="red">η=δα</font> 是有效的且 <font color="blue">B→γ</font> 是一个产生式，则项目 <font color="blue">B → •γ</font> 对 <font color="red">η=δα</font> 也是有效的。</p></li><li><p>证明</p><ul><li><p>若项目 <font color="blue">A→α•Bβ</font> 对活前缀 <font color="red">η=δα</font> 是有效的，则有 $\large \begin{align<em>}S^{\prime} \overset{</em>}{\Rightarrow}<em>{R} \delta A \omega \Rightarrow</em>{R} \delta \alpha B \beta \omega\end{align*} $</p></li><li><p>设 $\large \begin{align<em>}\beta \omega \overset{</em>}{\Rightarrow_{R}} \varphi \omega\end{align<em>}$，那么 $\large \begin{align</em>}S^{\prime} \overset{<em>}{\Rightarrow}<em>{R} \delta A \omega \Rightarrow</em>{R} \delta \alpha B \beta \omega \Rightarrow_{R} \delta \alpha B \varphi \omega \overset{</em>}{\Rightarrow}_{R} \delta \alpha \gamma \varphi \omega\end{align*}$</p></li><li><p>所以，项目 <font color="blue">B → •γ</font> 对 <font color="red">η=δα</font> 也是有效的。</p></li></ul></li></ul><p>LR(0) 项目集规范族的构造:</p><ul><li>将文法 G(S) 拓广为 G′(S′)<ul><li>构造文法 G′，它包含了整个 G，并引进不出现在 G 中的非终结符 S′、以及产生式 S′→S，S′ 是G′ 的开始符号</li><li>G′ 唯一的 “接受” 态：仅含项目 S′→S• 的状态</li></ul></li></ul><p>项目集的闭包 CLOSURE：</p><ul><li>假定 I 是文法 G’ 的任一项目集，定义和构造 I 的闭包 CLOSURE(I) 如下：<ol><li>I 的任何项目都属于 CLOSURE(I)；</li><li>若 A→α•Bβ 属于 CLOSURE(I)，那么，对任何关于 A 的产生式 B→γ，项目 B→•γ 也属于 CLOSURE(I)；</li><li>重复执行上述两步骤直至 CLOSURE(I) 不再增大为止。</li></ol></li></ul><p>状态转换函数：</p><ul><li>为了识别活前缀，我们定义一个状态转换函数 GO</li><li>I 是一个项目集，X 是一个文法符号。函数值 GO(I，X) 定义为：$GO(I，X)＝CLOSURE(J)$</li><li>其中 J＝{ 任何形如 A→α•Bβ 的项目 | A→α•Bβ 属于I }</li><li>直观上说，若 I 是对某个活前缀 γ 有效的项目集，那么，GO(I，X) 便是对 γX 有效的项目集</li></ul><p>LR(0) 项目集规范族的构造算法：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PROCEDURE  ITEMSETS(G&apos;)；</span><br><span class="line">BEGIN</span><br><span class="line">	C:=&#123;CLOSURE(&#123;S‘→•S&#125;)&#125;；</span><br><span class="line">	REPEAT</span><br><span class="line">	    FOR  C中每个项目集I和G&apos;的每个符号X  DO</span><br><span class="line">		      IF  GO(I，X)非空且不属于C   THEN</span><br><span class="line">		            把GO(I，X)放入C族中;</span><br><span class="line">	UNTIL C	不再增大</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>例子：</p><ul><li>文法G(S′)<br>S′→E<br>E→aA|bB<br>A→cA|d<br>B→cB|d</li></ul><p><img src="image-20200411122958426.png" alt></p><ul><li>如果可以，约定作图原则为连线不造成封闭区域、每个点入度为 1 （下图是我的作业题）<ul><li><img src="image-20200411145641169.png" style="zoom:60%"></li></ul></li></ul><h5 id="LR-0-分析表构造"><a href="#LR-0-分析表构造" class="headerlink" title="LR(0) 分析表构造"></a>LR(0) 分析表构造</h5><ul><li>假若一个文法G的拓广文法G′的活前缀识别自动机中的每个状态(项目集)不存在下述情况：<ul><li>既含移进项目又含归约项目；</li><li>含有多个归约项目；</li></ul></li><li>则称G是一个LR(0)文法。</li></ul><p>LR(0) 分析表的 ACTION 和 GOTO 子表构造</p><ol><li>若项目 A→α•aβ 属于 $I_k$ 且 $GO(I_k, a)＝I_j$，a 为终结符，则置 ACTION[k, a] 为 “sj”。</li><li>若项目 A→α• 属于 $I_k$ ，那么，对任何终结符a(或结束符#)，置 ACTION[k, a]为“rj” (假定产生式 A→α 是文法 G′ 的第 j 个产生式)。</li><li>若项目 S′→S• 属于 $I_k$，则置 ACTION[k,#] 为 “acc”。</li><li>若 $GO(I_k, A)＝I_j$，A 为非终结符，则置 GOTO[k, A]=j。</li><li>分析表中凡不能用规则 1 至 4 填入信息的空白格均置上“报错标志”。</li></ol><img src="image-20200411153902806.png" style="zoom:67%"><h3 id="更强的-LR-分析"><a href="#更强的-LR-分析" class="headerlink" title="更强的 LR 分析"></a>更强的 LR 分析</h3><p>LR(0) 文法是非常简单的，稍微有些实际意义的文法，很可能就不属于 LR(0) 了</p><h4 id="SLR-1-冲突解决办法"><a href="#SLR-1-冲突解决办法" class="headerlink" title="SLR(1) 冲突解决办法"></a>SLR(1) 冲突解决办法</h4><ul><li>假定LR(0)规范族的一个项目集 $I={A_1→α•a_1β_1，A_2→α•a_2β_2，…，A_m→α•a_mβ_m，B_1→α•，B_2→α•，…，B_n→α• } $<br>如果集合 ${a_1，…，a_m}，FOLLOW(B_1)，…，FOLLOW(B_n)$ 两两不相交 (包括不得有两个 FOLLOW 集合有#)，则当状态 I 面临任何输入符号 a 时：<ol><li>若 a 是某个 $a_i，i=1,2,…,m$，则移进；</li><li>若 $a∈FOLLOW(B_i)，i=1,2,…,n$，则用产生式 $B_i→α$ 进行归约；</li><li>此外，报错。</li></ol></li><li>SLR(1) 解决办法： S 指 Simple， 1 指 最多向前看一个单词</li></ul><p>SLR(1) 分析表的 ACTION 和 GOTO 子表构造（与 LR(0) 的不同在红字标出）：</p><ol><li>若项目 A→α•aβ 属于 $I_k$ 且 $GO(I_k, a)＝I_j$，a 为终结符，则置 ACTION[k, a] 为 “sj”。</li><li>若项目 A→α• 属于 $I_k$ ，那么，<font color="red">对任何终结符 $a\in FOLLOW(A)$ </font>，置 ACTION[k, a]为“rj” (假定产生式 A→α 是文法 G′ 的第 j 个产生式)。</li><li>若项目 S′→S• 属于 $I_k$，则置 ACTION[k,#] 为 “acc”。</li><li>若 $GO(I_k, A)＝I_j$，A 为非终结符，则置 GOTO[k, A]=j。</li><li>分析表中凡不能用规则 1 至 4 填入信息的空白格均置上“报错标志”。</li></ol><p>SLR(1) 文法：</p><ul><li>按上述方法构造出的 ACTION 与 GOTO 表如果不含多重入口，则称该文法为 SLR(1) 文法。</li><li>使用 SLR 表的分析器叫做一个 SLR 分析器。</li><li>每个 SLR(1) 文法都是无二义的。但也存在许多无二义文法不是 SLR(1) 的。</li><li>LR(0) ⊂ SLR(1) ⊂ 无二义文法</li></ul><h4 id="SLR-冲突消解存在的问题"><a href="#SLR-冲突消解存在的问题" class="headerlink" title="SLR 冲突消解存在的问题"></a>SLR 冲突消解存在的问题</h4><ul><li>SLR 在方法中，如果项目集 $I_i$ 含项目 A→α• 而且下一输入符号 $a∈FOLLOW(A)$，则状态 i 面临 a 时，可选用 “用A→α归约” 动作</li><li>但在有些情况下，当状态 i 显现于栈顶时，当前单词是 a，栈里的活前缀 βα 未必允许把 α 归约为 A，因为可能根本就不存在一个形如 “βAa” 的规范句型</li><li>在这种情况下，用 “A→α” 归约不一定合适，为什么 SLR 会犯这种错误？因为 FOLLOW 集合提供的信息太泛，它提供了所有可能跟在 A 后面的终结符</li></ul><h4 id="LR-1-分析表构造"><a href="#LR-1-分析表构造" class="headerlink" title="LR(1) 分析表构造"></a>LR(1) 分析表构造</h4><p>LR(k) 项目：</p><ul><li>LR(k) 项目：扩展 LR(0) 项目，附带有 k 个终结符 [A→α•β, a1a2…ak]，a1a2…ak 称为向前搜索符串(或展望串)。</li><li>归约项目 [A→α•，a1a2…ak] 的意义：当它所属的状态呈现在栈顶且后续的 k 个输入符号为 a1a2…ak 时，才可以把栈顶上的 α 归约为 A</li><li>对于任何移进或待约项目 [A→α•β, a1a2…ak], β≠ε，搜索符串 a1a2…ak 没有直接作用</li></ul><p>有效项目：</p><ul><li><p>形式上我们说一个 LR(1) 项目 [A→α•β, a] 对于活前缀 γ 是有效的，如果存在规范推导<br>$\Large \begin{align<em>}\mathrm{S}^{\prime} \overset{</em>}{\Rightarrow_{R}} \delta A \omega \Rightarrow_{R} \delta \alpha \beta \omega\end{align*}$<br>其中，1) γ＝δα；2) a 是 ω 的第一个符号，或者 a 为 # 而 ω 为 ε。</p></li><li><p>性质：[A→α•Bβ, a] 对活前缀 γ＝δα 是有效的，则对于每个形如 B→ξ 的产生式， 对任何 b∈FIRST(βa)，[B→•ξ, b] 对 γ 也是有效的。</p><ul><li>若项目 [A→α•Bβ, a]对γ＝δα 有效， 则有 $\large \begin{align<em>}\mathrm{S}^{\prime} \overset{</em>}{\Rightarrow_{R}} \delta A \omega \Rightarrow_{R} \delta \alpha \beta \omega\end{align*}$</li><li>∵ b∈FIRST(βa)</li><li>∴ $𝛽𝑎𝜔 \overset{*}{\Rightarrow_{R}} 𝑏𝜑 $</li><li>若B→ξ是产生式，则 $\begin{align<em>}S \overset{</em>}{\Rightarrow_{R}} \delta \alpha B \beta a \omega \overset{<em>}{\Rightarrow_{R}} \delta \alpha B b \varphi \Rightarrow_{R} \delta \alpha \xi b \varphi\end{align</em>}$</li><li>∴ 项目 [B→•ξ, b] 对 γ＝δα 是有效的</li></ul></li></ul><p>项目集的闭包 CLOSURE：</p><ul><li>假定 I 是文法 G′ 的任一项目集，定义和构造 I 的闭包 CLOSURE(I) 如下：<ol><li>I 的任何项目都属于 CLOSURE(I)。</li><li><font color="red">若项目 [A→α•Bβ, a] 属于 CLOSURE(I)，B→ξ 是一个产生式，那么，对于 FIRST(βa) 中的每个终结符b，如果 [B→•ξ, b] 原来不在 CLOSURE(I) 中，则把它加进去。</font></li><li>重复执行步骤2，直至 CLOSURE(I) 不再增大为止。</li></ol></li></ul><p>LR(1) 项目集规范族的构造算法：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BEGIN</span><br><span class="line">  C:=&#123; CLOSURE( &#123; [S′→•S，#] &#125; ) &#125;;</span><br><span class="line">  REPEAT</span><br><span class="line">    FOR C中每个项目集 I 和文法 G′ 的每个符号 X DO</span><br><span class="line">      IF GO(I，X) 非空且不属于 C，THEN</span><br><span class="line">        把 GO(I，X) 加入 C 中</span><br><span class="line">  UNTIL C不再增大</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>LR(1) 分析表的 ACTION 和 GOTO 子表构造（与 LR(0) 的不同在红字标出）：</p><ol><li>若项目 A→α•aβ 属于 $I_k$ 且 $GO(I_k, a)＝I_j$，a 为终结符，则置 ACTION[k, a] 为 “sj”。</li><li>若项目 [A→α•，a] 属于 Ik，则置 ACTION[k, a] 为 “rj”；其中假定 A→α 为文法 G′ 的第 j 个产生式。</li><li>若项目 [S′→S•, #] 属于 Ik，则置 ACTION[k, #] 为“acc”。</li><li>若 $GO(I_k, A)＝I_j$，A 为非终结符，则置 GOTO[k, A]=j。</li><li>分析表中凡不能用规则 1 至 4 填入信息的空白格均置上“报错标志”。</li></ol><p>LR(1) 分析表和 LR(1) 文法：</p><ul><li>按上述算法构造的分析表，若不存在多重定义的入口(即，动作冲突)的情形，则称它是文法 G 的一张规范的 LR(1) 分析表。</li><li>具有规范的 LR(1) 分析表的文法称为一个 LR(1) 文法。</li><li>使用 LR(1) 分析表的分析器叫做一个规范的 LR 分析器。</li><li>LR(1) 状态比 SLR(1) 多</li><li>LR(0) ⊂ SLR(1) ⊂ LR(1) ⊂ 无二义文法</li></ul><img src="image-20200414155332231.png" style="zoom:50%"><p>示例：LR(1)分析表的构造</p><img src="image-20200414155845428.png" style="zoom:50%"> <img src="image-20200414160003499.png" style="zoom:50%"><h3 id="LALR-分析"><a href="#LALR-分析" class="headerlink" title="LALR 分析"></a>LALR 分析</h3><p>书上直接构造 LALR(1) 的算法是错的，得先构造 LR(1) 再合并同心项集。</p><p>基本思想：</p><ul><li>寻找具有相同核心的 LR (1) 项集，并将这些项集合并为一个项集。所谓项集的核心就是其第一分量的集合</li><li>然后根据合并后得到的项集族构造语法分析表</li><li>如果分析表中没有语法分析动作冲突，给定的文法就称为 LALR (1) 文法，就可以根据该分析表进行语法分析</li></ul><p>如下图中：</p><ul><li>$I_{10}、I_8$ 合并</li><li>$I_{11}、I_4$ 合并</li><li>$I_{12}、I_5$ 合并</li><li>$I_{13}、I_7$ 合并</li></ul><img src="image-20200414171301491.png" style="zoom:80%"><p>得到：<img src="image-20200414171405325.png" style="zoom:80%"></p><p>合并同心项集时产生归约-归约冲突的例子：</p><img src="image-20200414171450383.png" style="zoom:80%"><p>合并同心项集后，可能不产生冲突，但可能会推迟错误的发现</p><p>LALR (1) 的特点：</p><ul><li><p>形式上与 LR(1) 相同</p></li><li><p>大小上与 LR(0)/SLR 相当</p></li><li><p>分析能力介于 SLR 和 LR(1) 二者之间 SLR&lt;LALR(1)&lt;LR(1)</p><ul><li>合并后的展望符集合仍为 FOLLOW 集的子集</li></ul></li></ul><img src="image-20200414155332231.png" style="zoom:50%"><h2 id="第七章-语义分析和中间代码生成"><a href="#第七章-语义分析和中间代码生成" class="headerlink" title="第七章 语义分析和中间代码生成"></a>第七章 语义分析和中间代码生成</h2><p><img src="image-20200620230354685.png" alt></p><h3 id="中间语言"><a href="#中间语言" class="headerlink" title="中间语言"></a>中间语言</h3><h4 id="特点和作用"><a href="#特点和作用" class="headerlink" title="特点和作用"></a>特点和作用</h4><p>特点：</p><ul><li>独立于机器</li><li>复杂性界于源语言和目标语言之间</li></ul><p>引入中间语言的优点：</p><ul><li>使编译程序的结构在逻辑上更为简单明确</li><li>便于进行与机器无关的代码优化工作</li><li>易于移植</li></ul><img src="image-20200419110225405.png" style="zoom:50%"><p>常见的中间语言：</p><ul><li>后缀式，逆波兰表示</li><li>图表示： 抽象语法树(AST)、有向无环图(DAG)</li><li>三地址代码<ul><li>三元式</li><li>四元式</li><li>间接三元式</li></ul></li></ul><h4 id="后缀式"><a href="#后缀式" class="headerlink" title="后缀式"></a>后缀式</h4><p>后缀式，又称逆波兰表示法，定义：</p><ul><li>如果 E 是一个变量或常量，则 E 的后缀式是 E 自身。</li><li>如果 E 是 E1 op E2 形式的表达式，其中 op 是任何二元操作符，则 E 的后缀式为 E1′ E2′ op，其中 E1′ 和E2′ 分别为 E1 和 E2 的后缀式。</li><li>如果 E 是 (E1) 形式的表达式，则 E1 的后缀式就是 E 的后缀式。</li></ul><p>中缀表达式翻译成后缀式的翻译模式：</p><ul><li><p>数组 POST 存放后缀式：k 为下标，初值为 1</p></li><li><p>a+b+c 的分析和翻译：<img src="image-20200419110610732.png" style="zoom:50%"></p></li></ul><img src="image-20200419110623501.png" style="zoom:50%"><h4 id="图表示"><a href="#图表示" class="headerlink" title="图表示"></a>图表示</h4><img src="image-20200419110651073.png" style="zoom:50%"><h4 id="三地址代码"><a href="#三地址代码" class="headerlink" title="三地址代码"></a>三地址代码</h4><p>三地址代码可以看成是抽象语法树或有向无环图的一种线性表示</p><p>三地址语句的种类：</p><ul><li>x:=y op z</li><li>x:=op y</li><li>x:=y</li><li>goto L</li><li>if x relop y go L或if a goto L</li><li>传参、转子：param x、call p,n</li><li>返回语句：return y</li><li>地址和指针赋值：x:=&amp;y、x:=*y、*x:=y</li><li>索引赋值：x:=y[i]、x[i]:=</li></ul><h5 id="四元式"><a href="#四元式" class="headerlink" title="四元式"></a>四元式</h5><ul><li><p>一个带有四个域的记录结构，这四个域分别称为 op, arg1, arg2 及 result</p></li><li><p>a:=b*(-c)+b*(-c)的四元式形式</p></li></ul><img src="image-20200419111004220.png" style="zoom:67%"><h5 id="三元式"><a href="#三元式" class="headerlink" title="三元式"></a>三元式</h5><ul><li>用三个域表示：op、arg1 和 arg2</li><li>计算结果引用：引用计算该值的语句的位置</li><li>a:=b*(-c)+b*(-c) 的三元式形式</li></ul><img src="image-20200419111044379.png" style="zoom:67%"><ul><li>x[i] := y</li></ul><img src="image-20200419111113769.png" style="zoom:50%"><ul><li>x := y[i]</li></ul><img src="image-20200419111128659.png" style="zoom:50%"><h5 id="间接三元式"><a href="#间接三元式" class="headerlink" title="间接三元式"></a>间接三元式</h5><ul><li><p>思想：<font color="red">三元式表+间接码表</font></p></li><li><p>间接码表</p><ul><li>一张指示器表，按运算的先后次序列出有关三元式在三元式表中的位置</li></ul></li><li><p>优点：方便优化，节省空间</p></li></ul><p>a:=b*(-c)+b*(-c) 的间接三元式形式：</p><img src="image-20200419111446714.png" style="zoom:50%"><p>语句 X:=(A+B)*C; Y:=D↑(A+B) 的间接三元式：</p><img src="image-20200419111515021.png" style="zoom:50%"><h3 id="赋值语句的翻译"><a href="#赋值语句的翻译" class="headerlink" title="赋值语句的翻译"></a>赋值语句的翻译</h3><p>构造语义和适合一遍扫描的翻译模式</p><p>用属性文法描述语义</p><p>赋值</p><h4 id="赋值语句的属性文法和翻译模式"><a href="#赋值语句的属性文法和翻译模式" class="headerlink" title="赋值语句的属性文法和翻译模式"></a>赋值语句的属性文法和翻译模式</h4><p>简单算术表达式及赋值语句：</p><ul><li>赋值语句的形式<ul><li>id:=E</li></ul></li><li>赋值语句的意义 (功能)<ul><li>对表达式 E 求值并置于变量 T 中</li><li>id.place:=T</li></ul></li></ul><p>赋值语句生成三地址代码的 S-属性文法：</p><ul><li>非终结符号 S 有综合属性 S.code<br>它代表赋值语句 S 的三地址代码</li><li>非终结符号 E 有两个属性<ul><li>E.place ：存放 E 值的单元的名字 (地址)</li><li>E.code ：对 E 求值的三地址语句序列</li></ul></li><li><font color="blue">函数 newtemp 功能</font>：返回一个不同的临时变量名字，如 T1, T2, …</li><li>过程 emit ：将三地址代码送到输出文件中 <img src="image-20200516235137176.png" style="zoom:33%"></li></ul><table><thead><tr><th align="center">产生式</th><th align="center">语义规则</th><th align="center">翻译模式</th></tr></thead><tbody><tr><td align="center">S→id:=E</td><td align="center">S.code := E.code || gen(id.place ‘:=’ E.place)</td><td align="center">{ p:=lookup(id.name);<br>if p≠nil then emit(p ‘:=’ E.place)<br>else error }</td></tr><tr><td align="center">E→E1+E2</td><td align="center">E.place:=newtemp;<br>E.code:=E1.code || E2.code || gen(E.place ‘:=’ E1.place ‘+’ E2.place)</td><td align="center">{ E.place:=newtemp;<br>emit(E.place ‘:=’ E1.place ‘+’ E2.place)}</td></tr><tr><td align="center">E→E1*E2</td><td align="center">E.place:=newtemp;<br>E.code:=E1.code || E2.code || gen(E.place ‘:=’ E1.place ‘*’ E2.place)</td><td align="center">{ E.place:=newtemp;<br>emit(E.place ‘:=’ E1.place ‘*’ E2.place)}</td></tr><tr><td align="center">E→-E1</td><td align="center">E.place:=newtemp;<br>E.code:=E1.code || gen(E.place ‘:=’ ‘uminus’ E1.place)</td><td align="center">{ E.place:=newtemp;<br>emit(E.place‘:=’ ‘uminus’ E 1.place)}</td></tr><tr><td align="center">E→ (E1)</td><td align="center">E.place:=E1.place;<br>E.code:=E1.code</td><td align="center">{ E.place:=E1.place }</td></tr><tr><td align="center">E→id</td><td align="center">E.place:=id.place;<br>E.code=‘ ’</td><td align="center">{ p:=lookup(id.name);<br>if p≠nil then E.place:=p<br>else error }</td></tr></tbody></table><h4 id="数组元素引用的翻译"><a href="#数组元素引用的翻译" class="headerlink" title="数组元素引用的翻译"></a>数组元素引用的翻译</h4><p>数组元素引用：</p><ul><li>$X := A[i_1,i_2,\cdots,i_k] + Y$</li><li>$A[i_1,i_2,\cdots,i_k] := X + Y $</li></ul><p>数组元素地址的计算：</p><ul><li><p>设 A 为 n 维数组，按行存放，每个元素宽度为 w</p></li><li><p>$low_i$ 为第 i 维的下界</p></li><li><p>$up_i$ 为第 i 维的上界</p></li><li><p>$n_i$ 为第i维可取值的个数 $(n_i = up_i -low_i + 1)$</p></li><li><p>$base$ 为 A 的第一个元素相对地址</p></li><li><p>元素 $A[i_1,i_2,\cdots,i_k]$ 相对地址公式：<br>不变部分：<font color="blue">$\text{base-}\left(\left(\ldots\left(\left(low_{1}, n_{2}+ lo w_{2}\right) n_{3}+lo w_{3}\right) \dots\right) n_{k}+lo w_{k}\right) \times w $</font><br>加<br>可变部分<font color="red"> $\left.\left(\left(\ldots i_{1} n_{2}+i_{2}\right) n_{3}+i_{3}\right) \ldots\right) n_{k}+i_{k} j \times w$</font></p></li><li><p>id 出现的地方也允许下面产生式中的 L 出现<br>L → id [ Elist ] | id<br>Elist → Elist,E | E</p></li><li><p>为了便于处理，文法改写为<br>L → Elist ] | id<br>Elist → Elist, E | id [ E</p></li><li><p>引入下列语义变量或语义过程</p><ul><li>Elist.ndim：下标个数计数器</li><li>Elist.place：保存临时变量的名字，这些临时变量存放已形成的 Elist 中的下标表达式计算出来的值</li><li>Elist.array：保存数组名</li><li>limit(array，j) ：函数过程，它给出数组 array 的第 j 维的长度</li></ul></li><li><p>代表变量的非终结符 L 有两项语义值</p><ul><li>L.place<ul><li>若 L 为简单变量 i, 指变量 i 的符号表入口</li><li>若 L 为下标变量，指存放不变部分的临时变量的名字</li></ul></li><li>L.offset<ul><li>若 L 为简单变量，null</li><li>若 L 为下标变量，指存放可变部分的临时变量的名字</li></ul></li></ul></li></ul><table><thead><tr><th align="center">产生式</th><th align="center">翻译模式</th></tr></thead><tbody><tr><td align="center">S→L:=E</td><td align="center">{ if L.offset=null then emit(L.place ‘:=’ E.place) （即 L是简单变量）<br>else emit( L.place ‘ [’ L.offset ‘]’ ‘:=’ E.place)}</td></tr><tr><td align="center">E→E1 +E2</td><td align="center">{ E.place:=newtemp;<br>emit(E.place ‘:=’ E 1.place ‘+’ E 2.place)}</td></tr><tr><td align="center">E→(E1)</td><td align="center">{E.place:=E1.place}</td></tr><tr><td align="center">E→L</td><td align="center">{ if L.offset=null then E.place:=L.place （即 L 是简单变量）<br>else begin<br>E.place:=newtemp;<br>emit(E.place ‘:=’ L.place ‘[’ L.offset ‘]’ )<br>end }</td></tr><tr><td align="center">Elist→id [ E</td><td align="center">{ Elist.place:=E.place;<br>Elist.ndim:=1;<br>Elist.array:=id.place }</td></tr><tr><td align="center">Elist→ Elist1, E</td><td align="center">{ t:=newtemp;<br>m:=Elist1.ndim+1;<br>emit(t ‘:=’ Elist1.place ‘*’ limit(Elist1.array,m) );<br>emit(t ‘:=’ t ‘+’ E.place);<br>Elist.place:=t;<br>Elist.ndim:=m<br>Elist.array:= Elist1.array; }</td></tr><tr><td align="center">L→Elist ]</td><td align="center">{ L.place:=newtemp;<br>emit(L.place ‘:=’ Elist.array ‘－’ C);<br>L.offset:=newtemp;<br>emit(L.offset ‘:=’ w ‘*’ Elist.place) }</td></tr><tr><td align="center">L→id</td><td align="center">{ L.place:=id.place; L.offset:=null }</td></tr></tbody></table><img src="image-20200620172023728.png" style="zoom:67%"><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>例子：</p><ul><li><p><code>x := y＋i*j</code>，其中 x、y 为实型；i、j 为整型</p></li><li><p>该赋值句产生的三地址代码为：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">T1 := i int* j</span><br><span class="line">T3 := inttoreal T1</span><br><span class="line">T2 := y real+ T3</span><br><span class="line">x := T2</span><br></pre></td></tr></table></figure></li></ul><p>类型转换：</p><ul><li>用 E.type 表示非终结符 E 的类型属性</li><li>产生式 E→E1 op E2 的语义动作中关于 E.type 的语义规则可定义为：<br>{ if E1.type=integer and E2.type=integer<br>E.type:=integer<br>else E.type:=real }</li></ul><p>产生式 E→E1＋E2 的语义动作：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123; E.place:=newtemp;</span><br><span class="line">  if E1.type=integer and E2.type=integer then begin</span><br><span class="line">    emit (E.place ‘:=’ E 1.place ‘int+’ E 2.place);</span><br><span class="line">    E.type:=integer</span><br><span class="line">  end</span><br><span class="line">  else if E1.type=real and E2.type=real then begin</span><br><span class="line">    emit (E.place ‘:=’ E 1.place ‘real+’ E 2.place);</span><br><span class="line">    E.type:=real</span><br><span class="line">  end</span><br><span class="line">  else if E1.type=integer and E2.type=real then begin</span><br><span class="line">    u:=newtemp;</span><br><span class="line">    emit (u ‘:=’ ‘inttoreal’ E 1.place);</span><br><span class="line">    emit (E.place ‘:=’ u ‘real+’ E 2.palce);</span><br><span class="line">    E.type:=real</span><br><span class="line">  end</span><br><span class="line">  else if E1.type=real and E2.type=integer then begin</span><br><span class="line">    u:=newtemp;</span><br><span class="line">    emit (u ‘:=’ ‘inttoreal’ E 2.place);</span><br><span class="line">    emit (E.place ‘:=’ E 1.place ‘real+’ u);</span><br><span class="line">    E.type:=real</span><br><span class="line">  end</span><br><span class="line">  else E.type:=type_error&#125;</span><br></pre></td></tr></table></figure><h3 id="布尔表达式的翻译"><a href="#布尔表达式的翻译" class="headerlink" title="布尔表达式的翻译"></a>布尔表达式的翻译</h3><p>文法：<code>E → E or E | E and E | not E | (E) | i rop i | i</code></p><p>用途：用于逻辑演算，计算逻辑值；用于控制语句的条件式</p><h4 id="数值表示法"><a href="#数值表示法" class="headerlink" title="数值表示法"></a>数值表示法</h4><p>如果计算算术表达式一样一步步算，例子：</p><ul><li><p><code>A or B and C&gt;D</code> 翻译成</p><img src="image-20200517001324457.png" style="zoom:50%"></li><li><p>a&lt;b 的关系表达式可等价地写成 <code>if a&lt;b then 1 else 0</code>，翻译成<br>100: if a&lt;b goto 103<br>101: T := 0<br>102: goto 104<br>103: T := 1<br>104:</p></li></ul><p>翻译模式：</p><ul><li>过程 emit 将三地址代码送到输出文件中</li><li>nextstat：输出序列中下一条三地址语句的地址索引<img src="image-20200517001614055.png" style="zoom:33%"></li><li>过程 emit 每产生一条指令，nextstat 加 1</li></ul><table><thead><tr><th align="center">产生式</th><th align="center">翻译模式</th></tr></thead><tbody><tr><td align="center">E→E1 or E2</td><td align="center">{ E.place:=newtemp;<br>emit(E.place ‘:=’ E 1.place ‘or’ E2.place)}</td></tr><tr><td align="center">E→E1 and E2</td><td align="center">{ E.place:=newtemp;<br>emit(E.place ‘:=’ E 1.place ‘and’ E2.place)}</td></tr><tr><td align="center">E→not E1</td><td align="center">{ E.place:=newtemp;<br>emit(E.place ‘:=’ ‘not’ E 1.place) }</td></tr><tr><td align="center">E→(E1)</td><td align="center">{ E.place:=E1.place }</td></tr><tr><td align="center">E→id1 relop id2</td><td align="center">{ E.place:=newtemp;<br>emit(‘if’ id1.place relop.op id2.place ‘goto’ nextstat+3);<br>emit(E.place ‘:=’ ‘0’);<br>emit(‘goto’ nextstat+2);<br>emit(E.place‘:=’ ‘1’) }</td></tr><tr><td align="center">E→id</td><td align="center">{ E.place:=id.place }</td></tr></tbody></table><p>布尔表达式 <code>a&lt;b or c&lt;d and e&lt;f</code> 的翻译结果：</p><ul><li><font color="orange">100: if a&lt;b goto 103<br>101: T1:=0<br><br>102: goto 104<br><br>103: T1:=1</font><br><font color="green">104: if c&lt;d goto 107<br><br>105: T2:=0<br><br>106: goto 108<br><br>107: T2:=1</font><br><font color="pink">108: if e&lt;f goto 111<br>109: T3:=0<br><br>110: goto 112<br><br>111: T3:=1</font><br>112: T4:=T2 and T3<br>113: T5:=T1 or T4</li></ul><h4 id="带优化的翻译法"><a href="#带优化的翻译法" class="headerlink" title="带优化的翻译法"></a>带优化的翻译法</h4><p>适用于作为条件表达式的布尔表达式使用，例子：</p><ul><li>把 A or B 解释成 if A then true else B</li><li>把 A and B 解释成 if A then B else false</li><li>把 not A 解释成 if A then false else true</li></ul><p>作为条件控制的布尔式翻译：</p><ul><li>条件语句 if E then S1 else S2<br>赋予E 两种出口:一真一假<img src="image-20200517105749805.png" style="zoom:50%"></li></ul><p>条件语句的翻译：</p><ul><li><code>if a&gt;c or b &lt;d then S1 else S2</code> 翻译成三地址代码<img src="image-20200517105837635.png" style="zoom:50%"></li></ul><p>布尔表达式的属性文法：</p><ul><li>语义函数 newlabel，返回一个新的符号标号</li><li>对于一个布尔表达式 E，设置两个继承属性<ul><li>E.true 是 E 为 ‘真’ 时控制流转向的<font color="blue">标号</font></li><li>E.false 是 E 为 ‘假’ 时控制流转向的<font color="blue">标号</font></li></ul></li><li>E.code 记录 E 生成的三地址代码序列</li></ul><table><thead><tr><th align="center">产生式</th><th align="center">语义规则</th></tr></thead><tbody><tr><td align="center">E→E1 or E2</td><td align="center">E1.true:=E.true;<br>E1.false:=newlabel;<br>E2.true:=E.true;<br>E2.false:=E.false;<br>E.code:=E1.code || gen(E1.false ‘:’) || E2.code<br><img src="image-20200517110202573.png" style="zoom:33%"></td></tr><tr><td align="center">E→E1 and E2</td><td align="center">E1.true:=newlabel;<br>E1.false:=E.false;<br>E2.true:=E.true;<br>E2.false:=E.fasle;<br>E.code:=E1.code || gen(E1.true ‘:’) || E2.code<br><img src="image-20200517110256477.png" style="zoom:33%"></td></tr><tr><td align="center">E→not E1</td><td align="center">E1.true:=E.false;<br>E1.false:=E.true;<br>E.code:=E1.code</td></tr><tr><td align="center">E→ (E1)</td><td align="center">E1.true:=E.true;<br>E1.false:=E.false;<br>E.code:=E1.code</td></tr><tr><td align="center">E→id1 relop id2</td><td align="center">E.code:=gen(‘if ’ id1.place relop.op id2.place ‘goto’ E.true) || gen(‘goto’ E.false)</td></tr><tr><td align="center">E→true</td><td align="center">E.code:=gen(‘goto’ E.true)</td></tr><tr><td align="center">E→false</td><td align="center">E.code:=gen(‘goto’ E.false)</td></tr></tbody></table><ul><li>例子：翻译 <code>a&lt;b or c&lt;d and e&lt;f</code><br>假定整个表达式的真假出口已分别置为 Ltrue 和 Lfalse。<ul><li><img src="image-20200517110508971.png" style="zoom:33%"><img src="image-20200517110534259.png" alt></li><li><img src="image-20200517110538445.png" style="zoom:50%"></li></ul></li></ul><h4 id="一遍扫描的翻译模式"><a href="#一遍扫描的翻译模式" class="headerlink" title="一遍扫描的翻译模式"></a>一遍扫描的翻译模式</h4><p>布尔表达式的翻译：</p><ul><li>两遍 (多遍) 扫描<ul><li>为给定的输入串构造一棵语法树</li><li>遍历语法树，进行语义规则中规定的翻译</li></ul></li><li>一遍扫描<ul><li>以四元式为中间语言</li><li>四元式存入一个数组中，数组下标代表四元式的标号</li><li>约定<ul><li>四元式<code>(jnz, a, -, p)</code> 表示 <code>if a goto p</code></li><li>四元式 <code>(jrop, x, y, p)</code> 表示 <code>if x rop y goto p</code></li><li>四元式 <code>(j, -, -, p)</code> 表示 <code>goto p</code></li></ul></li><li>过程 emit 将四元式代码送到输出数组中<img src="image-20200517111237872.png" style="zoom:33%"></li><li>回填：<ul><li>产生跳转四元式时，它的转移地址无法立即知道 （例如上图中的 100 一开始并不知道第四区段要填 104）</li><li>需要以后扫描到特定位置时才能回过头来确定</li><li>把这些未完成的四元式地址作为 E 的语义值保存, 待机 “回填”</li><li>为非终结符 E 赋予两个综合属性 E.truelist 和 E.falselist。<br>它们分别记录布尔表达式 E 所对应的四元式中需回填 “真”、“假” 出口的四元式的标号所构成的链表<br>例如，假定 E 的四元式中需要回填 “真” 出口的 p，q，r 三个四元式，则 E.truelist 为下列链:<img src="image-20200517111540407.png" style="zoom:50%"></li></ul></li><li>引入语义变量和过程<ul><li><font color="blue">变量 nextquad</font><br>它指向下一条将要产生但尚未形成的四元式的地址 (标号)<br>nextquad 的初值为1，每当执行一次emit之后，nextquad 将自动增1</li><li><font color="blue">函数 makelist(i)</font><br>它将创建一个仅含 i 的新链表，其中 i 是四元式数组的一个下标 (标号)；函数返回指向这个链的指针</li><li><font color="blue">函数 merge(p1,p2)</font><br>把以 p1 和 p2 为链首的两条链合并为一，作为函数值，回送合并后的链首</li><li><font color="blue">过程 backpatch(p, t)</font><br>其功能是完成“回填”，把 p 所链接的每个四元式的第四区段都填为 t</li></ul></li></ul></li></ul><p>布尔表达式的翻译模式：</p><table><thead><tr><th align="center">产生式</th><th align="center">翻译模式</th></tr></thead><tbody><tr><td align="center">(7) M→ε</td><td align="center">{ M.quad:=nextquad }</td></tr><tr><td align="center">(1) E→E1 or M E2</td><td align="center">{ backpatch(E1.falselist, M.quad);<br>E.truelist:=merge(E1.truelist, E2.truelist);<br>E.falselist:=E2.falselist }</td></tr><tr><td align="center">(2) E→E1 and M E2</td><td align="center">{ backpatch(E1.truelist, M.quad);<br>E.truelist:=E2.truelist;<br>E.falselist:=merge(E1.falselist,E2.falselist) }</td></tr><tr><td align="center">(3) E→not E1</td><td align="center">{ E.truelist:=E1.falselist;<br>E.falselist:=E1.truelist}</td></tr><tr><td align="center">(4) E→(E1)</td><td align="center">{ E.truelist:=E1.truelist;<br>E.falselist:=E1.falselist}</td></tr><tr><td align="center">(5) E→id1 relop id2</td><td align="center">{ E.truelist:=makelist(nextquad);<br>E.falselist:=makelist(nextquad+1);<br>emit(‘j’ relop.op ‘,’ id 1.place ‘,’ id 2.place‘,’ ‘0’);<br>emit(‘j, －, －, 0’) }</td></tr><tr><td align="center">(6) E→id</td><td align="center">{ E.truelist:=makelist(nextquad);<br>E.falselist:=makelist(nextquad+1);<br>emit(‘jnz’ ‘,’ id .place ‘,’ ‘－’ ‘,’ ‘0’)；<br>emit(‘ j, -, -, 0’) }</td></tr></tbody></table><p>例子：翻译 <code>a&lt;b or c&lt;d and e&lt;f</code></p><ul><li><img src="image-20200517132331237.png" alt></li></ul><p>课本上更详细的版本：</p><img src="image-20200620224953998.png" style="zoom:67%"><h3 id="控制语句的翻译"><a href="#控制语句的翻译" class="headerlink" title="控制语句的翻译"></a>控制语句的翻译</h3><p>常见控制语句：</p><ul><li>S → if E then S1</li><li>S → if E then S1 else S2</li><li>S → while E do S1</li></ul><h4 id="属性文法与属性计算"><a href="#属性文法与属性计算" class="headerlink" title="属性文法与属性计算"></a>属性文法与属性计算</h4><table><thead><tr><th align="center">产生式</th><th align="center">语义规则</th></tr></thead><tbody><tr><td align="center">S → if E then S1</td><td align="center">E.true:=newlabel;<br>E.flase:=S.next;<br>S1.next:=S.next<br>S.code:=E.code || gen(E.true ‘:’) || S1.code<br><img src="image-20200517134958763.png" style="zoom:33%"></td></tr><tr><td align="center">S → if E then S1 else S2</td><td align="center">E.false:=newlabel;<br>S1.next:=S.next<br>S2.next:=S.next;<br>S.code:=E.code || gen(E.true ‘:’) || S1.code || gen(‘goto’ S.next) || gen(E.false ‘:’) || S2.code<br><img src="image-20200517135055276.png" style="zoom:33%"></td></tr><tr><td align="center">S → while E do S1</td><td align="center">S.begin:=newlabel;<br>E.true:=newlabel;<br>E.false:=S.next;<br>S1.next:=S.begin;<br>S.code:=gen(S.begin ‘:’) || E.code || gen(E.true ‘:’) || S1.code || gen(‘goto’ S.begin)<br><img src="image-20200517135143409.png" style="zoom:33%"></td></tr></tbody></table><p>例子，翻译：</p><ul><li>while a&lt;b do<pre><code>if c&lt;d then x:=y+z
else x:=y-z</code></pre></li><li><img src="image-20200517142018876.png" style="zoom:50%"></li></ul><h4 id="一遍扫描翻译控制语句"><a href="#一遍扫描翻译控制语句" class="headerlink" title="一遍扫描翻译控制语句"></a>一遍扫描翻译控制语句</h4><p>和自下而上结合的一遍扫描翻译控制语句</p><p>if 语句的文法与翻译模式：</p><ul><li><p>相关产生式</p><p>S → if E then S1<br>S → if E then S1 else S2</p></li><li><p>改写后的产生式<br>S → if E then M S1<br>S → if E then M1 S1 N else M2 S2<br>M → ε<br>N → ε</p></li></ul><table><thead><tr><th align="center">产生式</th><th align="center">翻译模式</th></tr></thead><tbody><tr><td align="center">3. M→ε</td><td align="center">{ M.quad:=nextquad }</td></tr><tr><td align="center">4. N→ε</td><td align="center">{ N.nextlist:=makelist(nextquad);<br>emit(‘j,－,－,－’) }</td></tr><tr><td align="center">1. S→if E then M S1</td><td align="center">{ backpatch(E.truelist, M.quad);<br>S.nextlist:=merge(E.falselist, S1.nextlist) }</td></tr><tr><td align="center">2. S→if E then M1 S1 N else M2 S2</td><td align="center">{ backpatch(E.truelist, M1.quad);<br>backpatch(E.falselist, M2.quad);<br>S.nextlist:=merge(S1.nextlist, N.nextlist, S2.nextlist) }</td></tr></tbody></table><p>if 语句的文法与翻译模式：</p><ul><li>相关产生式<br>S → while E do S1</li><li>改写后的产生式<br>S → while M1 E do M2 S1<br>M → ε</li></ul><table><thead><tr><th align="center">产生式</th><th align="center">翻译模式</th></tr></thead><tbody><tr><td align="center">2. M → ε</td><td align="center">{ M.quad := nextquad }</td></tr><tr><td align="center">1. S → while M1 E do M2 S1</td><td align="center">{ backpatch(E.truelist, M2.quad);<br>backpatch(S1.nextlist, M1.quad);<br>S.nextlist := E.falselist;<br>emit(‘j,－,－,’ M1.quad) }</td></tr></tbody></table><p>复合语句的文法：</p><ul><li>相关产生式<br>S → begin L end<br>L → L ; S | S</li><li>改写后的产生式<br>S → begin L end<br>L → L1; M S | S<br>M → ε</li></ul><table><thead><tr><th align="center">产生式</th><th align="center">翻译模式</th></tr></thead><tbody><tr><td align="center">3. M → ε</td><td align="center">{ M.quad := nextquad }</td></tr><tr><td align="center">2. L → L1; M S</td><td align="center">{ backpatch(L1.nextlist, M.quad);<br>L.nextlist := S.nextlist }</td></tr><tr><td align="center">1. S → begin L end</td><td align="center">{ S.nextlist := L.nextlist }</td></tr></tbody></table><p>其它几个语句的翻译：</p><ul><li>S → A { S.nextlist := makelist( ) }</li><li>L → S { L.nextlist := S.nextlist }</li></ul><p>例子 7.6，翻译：</p><ul><li><p>while a&lt;b do</p><pre><code>if c&lt;d then x:=y+z
else x:=y-z</code></pre></li><li><p><img src="image-20200517145532082.png" alt></p></li></ul><h2 id="第十章-优化"><a href="#第十章-优化" class="headerlink" title="第十章 优化"></a>第十章 优化</h2><h3 id="优化的基本概念"><a href="#优化的基本概念" class="headerlink" title="优化的基本概念"></a>优化的基本概念</h3><p>优化：对程序进行各种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。</p><ul><li>等价：不改变程序的运行结果</li><li>有效：目标代码运行时间短，占用存储空间小</li></ul><img src="image-20200529165743171.png" style="zoom:50%"><p>目的：产生更高效的代码</p><p>遵循的原则：</p><ul><li>等价原则：优化不应改变程序运行的结果</li><li>有效原则：使优化后所产生的目标代码运行时间较短，占用的存储空间较小</li><li>合算原则：应尽可能以较低的代价取得较好的优化效果</li></ul><p>优化的级别：</p><ul><li>局部优化、循环优化、全局优化</li></ul><p>优化的种类：</p><ul><li>删除多余运算(删除公用子表达式)</li><li>合并已知量</li><li>复写传播</li><li>删除无用赋值</li><li>代码外提</li><li>强度消弱</li><li>变换循环控制条件</li></ul><p>优化的实例：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void quicksort (m, n);</span><br><span class="line">int m, n;</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    int v, x;</span><br><span class="line">    if (n&lt;=m) return;</span><br><span class="line">    /* fragment begins here*/</span><br><span class="line">    i=m-1; j=n; v=a [n];</span><br><span class="line">    while (1) &#123;</span><br><span class="line">        do i=i+1; while (a [i]&lt;v);</span><br><span class="line">        do j=j-1; while (a [ j]&gt;v);</span><br><span class="line">        if (i&gt;=j) break;</span><br><span class="line">        x=a [i]; a[i]=a [ j]; a[ j]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    x=a[i]; a[i]=a [n]; a [n]=x;</span><br><span class="line">    /*fragment ends here*/</span><br><span class="line">    quicksort (m, j); quicksort (i+1, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>中间代码程序段： <img src="image-20200529174505933.png" style="zoom:50%"></p></li><li><p>复写传播后：<img src="image-20200529175137777.png" style="zoom:50%"></p></li><li><p>删除无用赋值后：<img src="image-20200529174632556.png" style="zoom:50%"></p></li><li><p>强度削弱后：<img src="image-20200529175159482.png" style="zoom:50%"></p></li><li><p>删除归纳变量后：<img src="image-20200529174721149.png" style="zoom:50%"></p></li></ul><p>优化类型：</p><ul><li>局部优化<ul><li>局限于基本块范围内的优化</li></ul></li><li>循环优化<ul><li>可能反复执行的代码序列</li></ul></li><li>全局优化</li></ul><h3 id="局部优化"><a href="#局部优化" class="headerlink" title="局部优化"></a>局部优化</h3><p>基本块：</p><ul><li>程序中一顺序执行语句序列，其中只有一个入口和一个出口。入口就是其中第一个语句，出口就是其中最后一个语句</li><li>对三地址语句为 x:=y+z，称对 x 定值并引用 y 和 z</li><li>基本块中的一个名字在程序中的某个给定点是活跃的，是指如果在程序中 (包括在本基本块或在其它基本块中) 它的值在该点以后被引用<img src="image-20200610231627032.png" style="zoom:50%"></li></ul><p>基本块划分算法：</p><ol><li><p>找出中间语言 (三地址语句) 程序中各个基本块的入口语句：</p><ul><li>程序第一个语句<br><font color="red">或</font></li><li>能由条件转移语句或无条件转移语句转移到的语句<br><font color="red">或</font></li><li>紧跟在条件转移语句后面的语句</li></ul></li><li><p>对以上求出的每个入口语句，确定其所属的基本块。<br>它是由 该入口语句到<br>下一入口语句 (不包括该入口语句)<br><font color="red">或</font> 一转移语句 (包括该转移语句)<br><font color="red">或</font> 一停语句 (包括该停语句)<br>之间的语句序列组成的</p><img src="image-20200610232612991.png" style="zoom:50%"></li><li><p>凡未被纳入某一基本块中的语句，可以从程序中删除</p></li></ol><p>基本块划分示例、流图：</p><ul><li><img src="image-20200610232704367.png" style="zoom:33%"></li><li><p>流图</p><ul><li><img src="image-20200610232751819.png" style="zoom:33%"></li><li>以基本块为结点构成流图，前驱和后继的概念</li></ul></li></ul><p>基本块的 DAG 表示：</p><ul><li><img src="image-20200610233152510.png" style="zoom:40%"></li><li><p>扩充，增加标记和附加信息</p><ul><li>图的叶结点以一标识符或常数作为标记，表示该结点代表该变量或常数的值</li><li>图的内部结点以一运算符作为标记，表示该结点代表应用该运算符对其后继结点所代表的值进行运算的结果</li><li>各个结点上可能附加一个或多个标识符 (称附加标识符) 表示这些变量具有该结点所代表的值</li></ul></li></ul><table><thead><tr><th align="center">四元式</th><th align="center">DAG 图</th></tr></thead><tbody><tr><td align="center">0型: A:=B<br>( :=，B，-，A)</td><td align="center"><img src="image-20200610233441193.png" style="zoom:33%"></td></tr><tr><td align="center">1型: A:=op B<br>(op，B，-，A)</td><td align="center"><img src="image-20200610233455523.png" style="zoom:33%"></td></tr><tr><td align="center">2型: A:=B op C<br>(op，B，C，A)</td><td align="center"><img src="image-20200610233522353.png" style="zoom:33%"></td></tr><tr><td align="center">2型: A:=B[C]<br>(=[]，B，C，A)</td><td align="center"><img src="image-20200610233533133.png" style="zoom:33%"></td></tr><tr><td align="center">2型: if B rop C goto (s)<br>( jrop，B，C，(s))</td><td align="center"><img src="image-20200610233543730.png" style="zoom:33%"></td></tr><tr><td align="center">3型: D[C]:=B<br>([]=，B，D，C)</td><td align="center"><img src="image-20200610233554691.png" style="zoom:33%"></td></tr><tr><td align="center">0型: goto (s)<br>( j，-，-，(s))</td><td align="center"><img src="image-20200610233601557.png" style="zoom:33%"></td></tr></tbody></table><p>基本块的优化算法：</p><ul><li>一个基本块，可用一个DAG来表示</li><li>对基本块中每一条四元式代码，依次构造对应的 DAG 图，最后基本块中所有四元式构造出来 DAG 连成整个基本块的 DAG</li><li>步骤：<ul><li>准备操作数的结点<br>如果 NODE(B) 无定义，则构造一标记为 B 的叶结点并定义 NODE(B) 为这个结点;<br>如果当前四元式是 0 型，则记 NODE(B) 的值为 n，转 4。<br>如果当前四元式是 1 型，则转 2(1)<br>如果当前四元式是 2 型，则 (i) 如果 NODE(C) 无定义，则构造一标记为 C 的叶结点并定义NODE(C)为这个结点；(ii) 转2(2)</li><li>合并已知量<br>(1) 如果 NODE(B) 是标记为常数的叶结点，则转 2(3)；否则，转 3(1)<br>(2) 如果 NODE(B) 和 NODE(C) 都是标记为常数的叶结点，则转2(4)；否则，转3(2)<br>(3) 执行 op B (即合并已知量)。令得到的新常数为 P。如果 NODE(B) 是处理当前四元式时新构造出来的结点，则删除它。如果 NODE(P) 无定义，则构造一用P作标记的叶结点 n。置 NODE(P)=n，转4<br>(4)执行 B op C (即合并已知量)。令得到的新常数为P。如果 NODE(B) 或 NODE(C) 是处理当前四元式时新构造出来的结点，则删除它。如果 NODE(P) 无定义，则构造一用P作标记的叶结点n。置 NODE(P)=n，转4</li><li>删除公共子表达式<br>(1) 检查 DAG 中是否已有一结点，其唯一后继为 NODE(B) 且标记为 op(即公共子表达式)。如果没有，则构造该结点 n，否则，把已有的结点作为它的结点并设该结点为 n。转4。<br>(2) 检查 DAG中是否已有一结点，其左后继为 NODE(B)，右后继为 NODE(C)，且标记为 op(即公共子表达式)。如果没有，则构造该结点n，否则，把已有的结点作为它的结点并设该结点为 n。转4。</li><li>删除无用赋值<br>如果 NODE(A) 无定义，则把 A 附加在结点 n 上并令 NODE(A)=n; 否则，先把 A 从 NODE(A) 结点上的附加标识符集中删除(注意，如果 NODE(A) 是叶结点，则其 A 标记不删除)。把 A 附加到新结点 n 上并置 NODE(A)=n。转处理下一四元式。</li></ul></li></ul><img src="image-20200610234104579.png" style="zoom:50%"><p>从 DAG 中得到的优化信息：</p><ul><li>在基本块外被定值并在基本块内被引用的所有标识符，就是作为叶子结点上标记的那些标识符</li><li>在基本块内被定值并且该值在基本块后面可以被引用的所有标识符，就是 DAG 各结点上的那些标记或者附加标识符</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>循环优化的措施：</p><ul><li>代码外提</li><li>强度消弱</li><li>删除归纳变量(变换循环控制条件)</li><li>循环展开</li><li>循环合并</li></ul><p>代码外提：</p><ul><li><p>所谓变量 A 在某点 d 的<font color="red">定值到达</font>另一点 u（或称变量 A 的定值点 d 到达另一点 u），是指流图中从 d 有一通路到达 u 且该通路上没有 A 的其它定值</p></li><li><p><font color="red">循环不变运算</font>：对四元式 A:=B op C，若 B 和 C 是常数，或者到达它们的 B 和 C 的定值点都在循环外</p><img src="image-20200610234842370.png" style="zoom:40%"> * 查找循环中不变运算的算法： * 依次查看 L 中各基本块的每个四元式，如果它的每个运算对象或为常数，或者定值点在 L 外，则将此四元式标记为 "不变运算"; * 重复第 3 步直至没有新的四元式被标记为 "不变运算" 为止; * 依次查看尚未被标记为 "不变运算" 的四元式，如果它的每个运算对象或为常数，或定值点在 L 之外，或只有一个到达-定值点且该点上的四元式已被标记为 "不变运算"，则把被查看的四元式标记为"不变运算"。 <img src="image-20200610235158704.png" style="zoom:33%"></li><li><p>把循环不变运算提到循环体外（前置结点）</p><img src="image-20200610235313069.png" style="zoom:33%"></li><li><p>简单的代码外提示例：<img src="image-20200613112800381.png" style="zoom:33%"></p></li><li><p>更复杂的情况下无法如此<br>四元式 S(A:=B OP C）外提的条件</p><img src="image-20200613112931188.png" style="zoom:33%"></li></ul><p>强度削弱：</p><ul><li>把程序中执行时间较长的运算转换为执行时间较短的运算</li><li>通常是针对循环控制变量有线性关系的变量赋值进行</li><li>经过强度消弱后，循环中可能出现一些新的无用赋值</li><li>对于消弱下标变量地址计算的强度非常有效</li><li>示例：<img src="image-20200613113107261.png" style="zoom:33%"><img src="image-20200613113127351.png" style="zoom:33%"></li></ul><p>删除归纳变量：</p><ul><li>如果循环中对变量 I 只有唯一的形如 I:=I±C 的赋值，且其中 C 为循环不变量，则称 I 为循环中的基本归纳变量</li><li>如果 I 是循环中一基本归纳变量，J 在循环中的定值总是可化归为 I 的同一线性函数<br>也即 J=C1*I± C2，其中 C1 和 C2 都是循环不变量，则称 J 是归纳变量，并称它与 I 同族。<br>基本归纳变量也是归纳变量</li><li>删除归纳变量在强度削弱后进行</li><li>示例：<img src="image-20200613114334857.png" style="zoom:33%"></li><li>强度削弱和删除归纳变量可以统一算法框架<img src="image-20200613114233961.png" style="zoom:50%"></li></ul><h2 id="第十一章-目标代码生成"><a href="#第十一章-目标代码生成" class="headerlink" title="第十一章 目标代码生成"></a>第十一章 目标代码生成</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>任务：把分析、翻译、优化后的中间代码变换成目标代码</p><p>输入：</p><ul><li>源程序的中间表示，以及符号表中的信息</li><li>类型检查</li></ul><p>输出：</p><ul><li>绝对指令代码：能够立即执行的机器语言代码，所有地址已经定位</li><li>可重新定位指令代码：待装配的机器语言模块，执行时，由连接装配程序把它们和某些运行程序连接起来，转换成能执行的机器语言代码</li><li>汇编指令代码：需要经过汇编程序转换成可执行的机器语言代码</li></ul><p>目标代码生成要考虑的问题：</p><ul><li>如何充分利用计算机的寄存器，减少目标代码中访问存贮单元的次数<ul><li>在寄存器分配期间，为程序的某一点选择驻留在寄存器中的一组变量</li><li>在随后的寄存器指派阶段，挑出变量将要驻留的具体寄存器</li></ul></li></ul><h3 id="目标机器模型"><a href="#目标机器模型" class="headerlink" title="目标机器模型"></a>目标机器模型</h3><p>引入：</p><ul><li>具有多个通用寄存器，可用作累加器和变址器</li><li>运算必须在某个寄存器中进行</li><li>含有四种类型的指令形式</li></ul><img src="image-20200613121230406.png" style="zoom:50%"> <img src="image-20200613121304674.png" style="zoom:50%"><h3 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h3><h4 id="最简单的代码生成"><a href="#最简单的代码生成" class="headerlink" title="最简单的代码生成"></a>最简单的代码生成</h4><ul><li><p>不考虑代码执行效率</p><img src="image-20200613124700115.png" style="zoom:33%"></li><li><p>以基本块为单位生成目标代码</p><ul><li>依次把四元式的中间代码变换成目标代码</li><li>在基本块的范围内考虑如何充分利用寄存器</li><li>进入基本块时，所有寄存器空闲</li><li>离开基本块时，把存在寄存器中的现行的值存回主存中，释放所有寄存器</li><li>不特别说明，所有说明变量在基本块出口之后均为非活跃变量</li></ul></li><li><p>在一个基本块的范围内考虑充分利用寄存器</p><img src="image-20200613124833337.png" style="zoom:50%"></li><li><p>待用信息和活跃信息的表示：</p><ul><li>二元组 (x, x) 表示变量的待用信息和活跃信息<ul><li>第 1 元：i 表示待用信息， ^ 表示非待用</li><li>第 2 元：y 表示活跃，^ 表示非活跃</li></ul></li><li>待用信息和活跃信息的变化<ul><li>(x，x)→(x，x)，用后者更新前者</li></ul></li><li>计算算法：<ul><li>把基本块中各变量的符号表中的待用信息栏填为“非待用”，并根据该变量在基本块出口之后是不是活跃的，把其中的活跃信息栏填为“活跃”或“非活跃”；</li><li>从基本块出口到入口由后向前依次处理各个四元式 i:A:=B op C：<br>1) 把符号表中变量 A 的待用信息和活跃信息附加到四元式i上；<br>2) 把符号表中 A 的待用信息和活跃信息分别置为 “非待用” 和 “非活跃”；<br>3) 把符号表中变量 B 和 C 的待用信息和活跃信息附加到四元式i上；<br>4) 把符号表中 B 和 C 的待用信息均置为 i，活跃信息均置为 “活跃”；</li></ul></li><li>计算示例：<img src="image-20200613125153302.png" style="zoom:33%"></li></ul></li><li><p>变量地址描述和寄存器描述：</p><ul><li>变量地址描述数组 AVALUE<ul><li>动态记录各变量现行值的存放位置</li><li>AVALUE[A]={R1, R2, A}</li></ul></li><li>寄存器描述数组RVALUE<ul><li>动态记录各寄存器的使用信息</li><li>RVALUE[R]={A,B}<br>表明 AB 变量值相同存在 R</li></ul></li><li>对于四元式 A:=B<ul><li>如果 B 的现行值在某寄存器 Ri 中，则无须生成目标代码</li><li>只须在 RVALUE(Ri) 中增加一个 A，(即把 Ri 同时分配给 B 和 A)，并把 AVALUE(A) 改为 Ri</li></ul></li><li>记录这些的作用是，尽量先不存数，减少指令的生成，如果变量后面要用再存（延迟）</li></ul></li></ul><h4 id="带寄存器分配优化的代码生成"><a href="#带寄存器分配优化的代码生成" class="headerlink" title="带寄存器分配优化的代码生成"></a>带寄存器分配优化的代码生成</h4><ul><li><p>算法，对每个四元式: i: A:=B op C，依次执行：</p><ul><li>以四元式 : i: A:=B op C 为参数，调用函数过程 GETREG(i: A:=B op C)，返回一个寄存器 R，用作存放 A 的寄存器</li><li>利用 AVALUE[B] 和 AVALUE[C]，确定 B 和 C 现行值的存放位置 B’ 和 C’。如果其现行值在寄存器中，则把寄存器取作 B’ 和 C’</li><li>如果 B’≠R，则生成目标代码：<br>LD R, B’<br>op R, C’<br>否则生成目标代码 op R, C’<br>如果 B’ 或 C’ 为 R，则删除 AVALUE[B] 或 AVALUE[C] 中的 R</li><li>令 AVALUE[A]={R}, RVALUE[R]={A}</li><li>若 B 或 C 的现行值在基本块中不再被引用，也不是基本块出口之后的活跃变量，且其现行值在某寄存器 Rk 中，则删除 RVALUE[Rk] 中的 B 或 C 以及 AVALUE[B] 或 AVALUE[C] 中的 Rk ，使得该寄存器不再为 B 或 C 占用</li></ul></li><li><p>寄存器分配算法 GETREG(i: A:=B op C)</p><ul><li>返回一个用来存放 A 的值的寄存器</li><li>策略：<br>尽可能用 B 独占的寄存器<br>尽可能用空闲寄存器<br>抢占非空闲寄存器</li><li>(1) 如果 <code>(B 的现行值在某个寄存器 Ri 中 &amp;&amp; RVALUE[Ri] 中只包含 B) &amp;&amp; (B 与 A 是同一个标识符 || B 的现行值在执行四元式 A:=B op C 之后不会再引用)</code><br>则选取 Ri 为所需要的寄存器 R，并转 (4)<br>(2) 如果有尚未分配的寄存器，则从中选取一个 Ri 为所需要的寄存器 R，并转 (4)<br>(3) 从已分配的寄存器中选取一个 Ri 为所需要的寄存器 R。尽量满足<br><code>(占用 Ri 的变量的值也同时存放在该变量的贮存单元中 || 在基本块中要在最远的将来才会引用到或不会引用到)</code><br>为 Ri 中的变量生成<font color="blue">必要</font>的存数指令。<br>(4) 给出 R，返回</li></ul></li><li><p>生成存数指令 （针对 GETREG(i: A:=B op C)）</p><ul><li><p>对 RVALUE[Ri] 中每一变量 M</p><p>需要存数的条件： <code>( M 不是 A || ( M 是 A 又是 C &amp;&amp; M 不是 B &amp;&amp; B 不在 RVALUE[Ri] 中</code></p><p>存数的操作：</p><p>(1) 如果 <code>AVALUE[M] 不包含 M</code>，则生成目标代码 ST Ri, M<br>(2) 如果 <code>M 是 B || (M 是 C &amp;&amp; B 在 RVALUE[Ri] 中)</code>，则令 AVALUE[M]={M， Ri} ，否则令 AVALUE[M]={M}<br>(3) 删除 RVALUE[Ri] 中的 M</p></li></ul></li><li><p>示例：<img src="image-20200613171806380.png" style="zoom:33%"></p></li></ul><h4 id="DAG-的目标代码"><a href="#DAG-的目标代码" class="headerlink" title="DAG 的目标代码"></a>DAG 的目标代码</h4><p>引入：</p><ul><li><img src="image-20200613192633817.png" style="zoom:33%"></li><li>假设可用寄存器为 $R_0$ 和 $R_1$，$T_4$ 是基本块出口的活跃变量<br>从上图中看出，经过 DAG 图后重构的四元式序列顺序，造成了不同的目标代码长度<br>因为，执行的顺序省去了存值指令</li><li>不难发现，$T_4 := A+B-(E-(C+D))$ ，左边的四元式序列对应着从左往右算，右边的则对应从右往左算</li></ul><p>基本块中间代码序列重排 - 算法：</p><ul><li><p>设 DAG 有 N 个内部结点，T 是一个线性表，它共有 N 个登记项，算法的步骤如下。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 置初值</span><br><span class="line">FOR k:=1 TO N</span><br><span class="line">DO T[k]:=null;</span><br><span class="line">i := N;</span><br><span class="line"></span><br><span class="line">WHILE 存在未列入T的内部节点 :</span><br><span class="line">    选取一个 未列入T但其全部父节点均已列入T 或者 没有父节点的内部节点 n;</span><br><span class="line">    T[i]:=n;  i:=i-1;    // 把 n 列入 T 中</span><br><span class="line">    WHILE n的最左子节点m不是叶子且其全部父节点均已列入T中 :</span><br><span class="line">        T[i]:=m;  i:=i-1;</span><br><span class="line">        n:=m;</span><br><span class="line">        </span><br><span class="line">// 最后T[1], T[2], ..., T[n]就是所求的节点顺序</span><br></pre></td></tr></table></figure></li><li><p>例子：</p><img src="image-20200614085346410.png" style="zoom:50%"></li></ul></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://zhangt.top/CS/Compilation-Principles-Study-Notes/">编译原理-学习笔记</a></li><li><strong>本文作者：</strong><a href="https://zhangt.top">ZhangT</a></li><li><strong>本文链接：</strong><a href="https://zhangt.top/CS/Compilation-Principles-Study-Notes/">https://zhangt.top/CS/Compilation-Principles-Study-Notes/</a></li><li><strong>发布时间：</strong>2020-02-17</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><hr style="height:1px;margin:1rem 0"><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><i class="fas fa-tags has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/tags/CS/">CS</a>,&nbsp;<a class="has-link-grey -link" href="/tags/Compilation-Principles/">Compilation-Principles</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？投喂一下吧！ヾ(●´∀｀●)</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i> </span><span>支付宝</span><div class="qrcode"><img src="/images/alipay.jpg" alt="支付宝"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/CS/My-Teaching-On-SDU-Programming/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">我在 SDU 讲课啦 —— 《程序设计思维与实践》讲师经历与复盘</span></a></div><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/CS/Information-Retrieval-Study-Notes/"><span class="level-item">信息检索技术-学习笔记</span> <i class="level-item fas fa-chevron-right"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"91f36240e98756fc091e",clientSecret:"20de2f4dadd54bc04ad8db6c1090fb00a9477ac4",id:"feb122618bffc366f28c7461e1ad8f4e",repo:"zhangt2333.github.io",owner:"zhangt2333",admin:"zhangt2333",createIssueManually:!1,distractionFreeMode:!1});gitalk.render("comment-container")</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered"><div><img class="image is-96x96 has-mb-6" src="/images/avatar.png" alt="Zhang T"><p class="is-size-4 is-block">Zhang T</p><p class="is-size-6 is-block">感受我的感受</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Nanjing &lt;- Qingdao, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><div class="level-item has-text-centered is-marginless"><a href="/archives/"><p class="heading">文章</p><p class="title has-text-weight-normal">21</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/categories/"><p class="heading">分类</p><p class="title has-text-weight-normal">5</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/tags/"><p class="heading">标签</p><p class="title has-text-weight-normal">23</p></a></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/zhangt2333" target="_blank"><i class="fab fa-github"></i>&nbsp;&nbsp;关注我</a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu" style="max-height:750px;overflow:auto"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#第一章-引论"><span class="has-mr-6">1</span> <span>第一章 引论</span></a><ul class="menu-list"><li><a class="is-flex" href="#什么是编译程序"><span class="has-mr-6">1.1</span> <span>什么是编译程序</span></a></li><li><a class="is-flex" href="#为什么要学习编译原理"><span class="has-mr-6">1.2</span> <span>为什么要学习编译原理</span></a></li><li><a class="is-flex" href="#编译过程"><span class="has-mr-6">1.3</span> <span>编译过程</span></a></li><li><a class="is-flex" href="#编译程序的结构"><span class="has-mr-6">1.4</span> <span>编译程序的结构</span></a></li><li><a class="is-flex" href="#编译程序的生成"><span class="has-mr-6">1.5</span> <span>编译程序的生成</span></a></li></ul></li><li><a class="is-flex" href="#第二章-高级程序设计语言定义与语法描述"><span class="has-mr-6">2</span> <span>第二章 高级程序设计语言定义与语法描述</span></a><ul class="menu-list"><li><a class="is-flex" href="#程序设计语言的定义"><span class="has-mr-6">2.1</span> <span>程序设计语言的定义</span></a></li><li><a class="is-flex" href="#程序设计语言的描述"><span class="has-mr-6">2.2</span> <span>程序设计语言的描述</span></a><ul class="menu-list"><li><a class="is-flex" href="#上下文无关文法"><span class="has-mr-6">2.2.1</span> <span>上下文无关文法</span></a></li><li><a class="is-flex" href="#文法与语言"><span class="has-mr-6">2.2.2</span> <span>文法与语言</span></a></li><li><a class="is-flex" href="#语法树与二义性"><span class="has-mr-6">2.2.3</span> <span>语法树与二义性</span></a></li><li><a class="is-flex" href="#形式语言鸟瞰"><span class="has-mr-6">2.2.4</span> <span>形式语言鸟瞰</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第三章-词法分析"><span class="has-mr-6">3</span> <span>第三章 词法分析</span></a><ul class="menu-list"><li><a class="is-flex" href="#词法分析器的设计"><span class="has-mr-6">3.1</span> <span>词法分析器的设计</span></a><ul class="menu-list"><li><a class="is-flex" href="#词法分析器"><span class="has-mr-6">3.1.1</span> <span>词法分析器</span></a></li><li><a class="is-flex" href="#超前搜索"><span class="has-mr-6">3.1.2</span> <span>超前搜索</span></a></li><li><a class="is-flex" href="#状态转换图"><span class="has-mr-6">3.1.3</span> <span>状态转换图</span></a></li></ul></li><li><a class="is-flex" href="#正规表达式与有限自动机"><span class="has-mr-6">3.2</span> <span>正规表达式与有限自动机</span></a><ul class="menu-list"><li><a class="is-flex" href="#正规式和正规集"><span class="has-mr-6">3.2.1</span> <span>正规式和正规集</span></a></li><li><a class="is-flex" href="#有限自动机"><span class="has-mr-6">3.2.2</span> <span>有限自动机</span></a></li><li><a class="is-flex" href="#有限自动机的等价性"><span class="has-mr-6">3.2.3</span> <span>有限自动机的等价性</span></a></li><li><a class="is-flex" href="#正规式与有限自动机的等价性"><span class="has-mr-6">3.2.4</span> <span>正规式与有限自动机的等价性</span></a></li></ul></li><li><a class="is-flex" href="#词法分析器的自动产生-——-LEX"><span class="has-mr-6">3.3</span> <span>词法分析器的自动产生 —— LEX</span></a></li></ul></li><li><a class="is-flex" href="#第四章-语法分析-自上而下"><span class="has-mr-6">4</span> <span>第四章 语法分析-自上而下</span></a><ul class="menu-list"><li><a class="is-flex" href="#语法分析基本概念"><span class="has-mr-6">4.1</span> <span>语法分析基本概念</span></a><ul class="menu-list"><li><a class="is-flex" href="#语法分析的任务"><span class="has-mr-6">4.1.1</span> <span>语法分析的任务</span></a></li><li><a class="is-flex" href="#语法分析器在编译器中的地位"><span class="has-mr-6">4.1.2</span> <span>语法分析器在编译器中的地位</span></a></li><li><a class="is-flex" href="#语法分析的方法"><span class="has-mr-6">4.1.3</span> <span>语法分析的方法</span></a></li></ul></li><li><a class="is-flex" href="#自上而下分析的基本问题"><span class="has-mr-6">4.2</span> <span>自上而下分析的基本问题</span></a><ul class="menu-list"><li><a class="is-flex" href="#文法左递归问题"><span class="has-mr-6">4.2.1</span> <span>文法左递归问题</span></a></li><li><a class="is-flex" href="#回溯问题"><span class="has-mr-6">4.2.2</span> <span>回溯问题</span></a></li></ul></li><li><a class="is-flex" href="#LL-1-文法"><span class="has-mr-6">4.3</span> <span>LL(1)文法</span></a><ul class="menu-list"><li><a class="is-flex" href="#LL-1-文法的条件"><span class="has-mr-6">4.3.1</span> <span>LL(1)文法的条件</span></a></li><li><a class="is-flex" href="#LL-1-分析法"><span class="has-mr-6">4.3.2</span> <span>LL(1)分析法</span></a></li></ul></li><li><a class="is-flex" href="#FIRST-集和-FOLLOW-集的构造"><span class="has-mr-6">4.4</span> <span>FIRST 集和 FOLLOW 集的构造</span></a><ul class="menu-list"><li><a class="is-flex" href="#构造-FIRST-α"><span class="has-mr-6">4.4.1</span> <span>构造 FIRST(α)</span></a></li><li><a class="is-flex" href="#构造-FOLLOW-A"><span class="has-mr-6">4.4.2</span> <span>构造 FOLLOW(A)</span></a></li></ul></li><li><a class="is-flex" href="#递归下降分析程序"><span class="has-mr-6">4.5</span> <span>递归下降分析程序</span></a></li><li><a class="is-flex" href="#扩充的巴科斯范式"><span class="has-mr-6">4.6</span> <span>扩充的巴科斯范式</span></a></li><li><a class="is-flex" href="#预测分析程序"><span class="has-mr-6">4.7</span> <span>预测分析程序</span></a><ul class="menu-list"><li><a class="is-flex" href="#预测分析程序构成"><span class="has-mr-6">4.7.1</span> <span>预测分析程序构成</span></a></li><li><a class="is-flex" href="#预测分析过程"><span class="has-mr-6">4.7.2</span> <span>预测分析过程</span></a></li><li><a class="is-flex" href="#预测分析表的构造"><span class="has-mr-6">4.7.3</span> <span>预测分析表的构造</span></a></li><li><a class="is-flex" href="#LL-1-文法与二义性"><span class="has-mr-6">4.7.4</span> <span>LL(1)文法与二义性</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第五章-语法分析-自下而上"><span class="has-mr-6">5</span> <span>第五章 语法分析-自下而上</span></a><ul class="menu-list"><li><a class="is-flex" href="#基本概念"><span class="has-mr-6">5.1</span> <span>基本概念</span></a><ul class="menu-list"><li><a class="is-flex" href="#语法分析的方法-1"><span class="has-mr-6">5.1.1</span> <span>语法分析的方法</span></a></li><li><a class="is-flex" href="#自下而上分析示例"><span class="has-mr-6">5.1.2</span> <span>自下而上分析示例</span></a></li><li><a class="is-flex" href="#自下而上分析的基本思想"><span class="has-mr-6">5.1.3</span> <span>自下而上分析的基本思想</span></a></li><li><a class="is-flex" href="#移进－归约分析示例"><span class="has-mr-6">5.1.4</span> <span>移进－归约分析示例</span></a></li><li><a class="is-flex" href="#短语"><span class="has-mr-6">5.1.5</span> <span>短语</span></a></li></ul></li><li><a class="is-flex" href="#算符优先文法"><span class="has-mr-6">5.2</span> <span>算符优先文法</span></a><ul class="menu-list"><li><a class="is-flex" href="#算符优先级"><span class="has-mr-6">5.2.1</span> <span>算符优先级</span></a></li><li><a class="is-flex" href="#优先关系"><span class="has-mr-6">5.2.2</span> <span>优先关系</span></a></li><li><a class="is-flex" href="#算符文法"><span class="has-mr-6">5.2.3</span> <span>算符文法</span></a></li><li><a class="is-flex" href="#算符优先文法-1"><span class="has-mr-6">5.2.4</span> <span>算符优先文法</span></a></li><li><a class="is-flex" href="#优先关系表"><span class="has-mr-6">5.2.5</span> <span>优先关系表</span></a></li><li><a class="is-flex" href="#最左素短语"><span class="has-mr-6">5.2.6</span> <span>最左素短语</span></a></li><li><a class="is-flex" href="#算符优先分析算法"><span class="has-mr-6">5.2.7</span> <span>算符优先分析算法</span></a></li></ul></li><li><a class="is-flex" href="#LR分析法"><span class="has-mr-6">5.3</span> <span>LR分析法</span></a><ul class="menu-list"><li><a class="is-flex" href="#自下而上的思想"><span class="has-mr-6">5.3.1</span> <span>自下而上的思想</span></a></li><li><a class="is-flex" href="#句柄与规范规约"><span class="has-mr-6">5.3.2</span> <span>句柄与规范规约</span></a></li><li><a class="is-flex" href="#LR-分析表"><span class="has-mr-6">5.3.3</span> <span>LR 分析表</span></a></li><li><a class="is-flex" href="#LR-0-分析表的构造"><span class="has-mr-6">5.3.4</span> <span>LR(0) 分析表的构造</span></a></li></ul></li><li><a class="is-flex" href="#更强的-LR-分析"><span class="has-mr-6">5.4</span> <span>更强的 LR 分析</span></a><ul class="menu-list"><li><a class="is-flex" href="#SLR-1-冲突解决办法"><span class="has-mr-6">5.4.1</span> <span>SLR(1) 冲突解决办法</span></a></li><li><a class="is-flex" href="#SLR-冲突消解存在的问题"><span class="has-mr-6">5.4.2</span> <span>SLR 冲突消解存在的问题</span></a></li><li><a class="is-flex" href="#LR-1-分析表构造"><span class="has-mr-6">5.4.3</span> <span>LR(1) 分析表构造</span></a></li></ul></li><li><a class="is-flex" href="#LALR-分析"><span class="has-mr-6">5.5</span> <span>LALR 分析</span></a></li></ul></li><li><a class="is-flex" href="#第七章-语义分析和中间代码生成"><span class="has-mr-6">6</span> <span>第七章 语义分析和中间代码生成</span></a><ul class="menu-list"><li><a class="is-flex" href="#中间语言"><span class="has-mr-6">6.1</span> <span>中间语言</span></a><ul class="menu-list"><li><a class="is-flex" href="#特点和作用"><span class="has-mr-6">6.1.1</span> <span>特点和作用</span></a></li><li><a class="is-flex" href="#后缀式"><span class="has-mr-6">6.1.2</span> <span>后缀式</span></a></li><li><a class="is-flex" href="#图表示"><span class="has-mr-6">6.1.3</span> <span>图表示</span></a></li><li><a class="is-flex" href="#三地址代码"><span class="has-mr-6">6.1.4</span> <span>三地址代码</span></a></li></ul></li><li><a class="is-flex" href="#赋值语句的翻译"><span class="has-mr-6">6.2</span> <span>赋值语句的翻译</span></a><ul class="menu-list"><li><a class="is-flex" href="#赋值语句的属性文法和翻译模式"><span class="has-mr-6">6.2.1</span> <span>赋值语句的属性文法和翻译模式</span></a></li><li><a class="is-flex" href="#数组元素引用的翻译"><span class="has-mr-6">6.2.2</span> <span>数组元素引用的翻译</span></a></li><li><a class="is-flex" href="#类型转换"><span class="has-mr-6">6.2.3</span> <span>类型转换</span></a></li></ul></li><li><a class="is-flex" href="#布尔表达式的翻译"><span class="has-mr-6">6.3</span> <span>布尔表达式的翻译</span></a><ul class="menu-list"><li><a class="is-flex" href="#数值表示法"><span class="has-mr-6">6.3.1</span> <span>数值表示法</span></a></li><li><a class="is-flex" href="#带优化的翻译法"><span class="has-mr-6">6.3.2</span> <span>带优化的翻译法</span></a></li><li><a class="is-flex" href="#一遍扫描的翻译模式"><span class="has-mr-6">6.3.3</span> <span>一遍扫描的翻译模式</span></a></li></ul></li><li><a class="is-flex" href="#控制语句的翻译"><span class="has-mr-6">6.4</span> <span>控制语句的翻译</span></a><ul class="menu-list"><li><a class="is-flex" href="#属性文法与属性计算"><span class="has-mr-6">6.4.1</span> <span>属性文法与属性计算</span></a></li><li><a class="is-flex" href="#一遍扫描翻译控制语句"><span class="has-mr-6">6.4.2</span> <span>一遍扫描翻译控制语句</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第十章-优化"><span class="has-mr-6">7</span> <span>第十章 优化</span></a><ul class="menu-list"><li><a class="is-flex" href="#优化的基本概念"><span class="has-mr-6">7.1</span> <span>优化的基本概念</span></a></li><li><a class="is-flex" href="#局部优化"><span class="has-mr-6">7.2</span> <span>局部优化</span></a></li><li><a class="is-flex" href="#循环"><span class="has-mr-6">7.3</span> <span>循环</span></a></li></ul></li><li><a class="is-flex" href="#第十一章-目标代码生成"><span class="has-mr-6">8</span> <span>第十一章 目标代码生成</span></a><ul class="menu-list"><li><a class="is-flex" href="#概述"><span class="has-mr-6">8.1</span> <span>概述</span></a></li><li><a class="is-flex" href="#目标机器模型"><span class="has-mr-6">8.2</span> <span>目标机器模型</span></a></li><li><a class="is-flex" href="#目标代码生成"><span class="has-mr-6">8.3</span> <span>目标代码生成</span></a><ul class="menu-list"><li><a class="is-flex" href="#最简单的代码生成"><span class="has-mr-6">8.3.1</span> <span>最简单的代码生成</span></a></li><li><a class="is-flex" href="#带寄存器分配优化的代码生成"><span class="has-mr-6">8.3.2</span> <span>带寄存器分配优化的代码生成</span></a></li><li><a class="is-flex" href="#DAG-的目标代码"><span class="has-mr-6">8.3.3</span> <span>DAG 的目标代码</span></a></li></ul></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/">TTTT&#39;s Blog</a><p class="is-size-7">&copy; 2022 ZhangT&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},skipTags:["script","noscript","style","textarea","pre","code"],processEscapes:!0,tex2jax:{inlineMath:[["$","$"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>