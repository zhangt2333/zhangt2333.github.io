<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>静态分析-学习笔记 - Zhang T&#39;s Blog</title><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-212316117-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-212316117-1")</script><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/">TTTT&#39;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i> </a><a class="navbar-item" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-content article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>静态分析-学习笔记</h1><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2021-09-30T18:00:00.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2021-10-01</time> <time class="level-item has-text-grey is-hidden-mobile" datetime="2022-01-05T02:40:00.000Z"><i class="far fa-calendar-check">&nbsp;</i>2022-01-05</time><div class="level-item"><i class="far fa-folder-open has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/categories/CS/">CS</a></div><span class="level-item has-text-grey"><i class="far fa-clock"></i>&nbsp; 1 小时 读完 (大约 12613 个字) </span><span class="level-item has-text-grey" id="busuanzi_container_page_pv"><i class="far fa-eye"></i> <span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p>软件分析，学习笔记</p><a id="more"></a><p>教程：</p><ul><li>南京大学《软件分析 Static Program Analysis》</li><li><a href="https://www.bilibili.com/video/BV1b7411K7P4" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1b7411K7P4</a></li><li>李樾/谭添，yyds！</li></ul><blockquote><p>网上有些笔记已经非常清楚了，故在其基础上再简单拼凑或加工咯：<a href="https://blog.csdn.net/panhewu9919/article/details/106007155、https://github.com/RangerNJU/Static-Program-Analysis-Book" target="_blank" rel="noopener">https://blog.csdn.net/panhewu9919/article/details/106007155、https://github.com/RangerNJU/Static-Program-Analysis-Book</a> 等，感谢如此优秀的笔记们。</p></blockquote><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>outline:</p><ul><li>PL 和 Static Program Analysis</li><li>为什么学这门课？ 对你的帮助？（理解计算机课程，尤其是 PL 方面）</li><li>SPA 是什么</li><li>SPA 的特征和例子</li><li>教学大纲</li></ul><p>复习重点：</p><ul><li>What are the differences between static analysis and (dynamic) testing</li><li>Understand soundness, completeness, false negatives, and false positives</li><li>Why soundness is <del>usually</del> required by static analysis</li><li>How to understand abstraction and over-approximation</li></ul><p>静态程序分析这个方向的定位：</p><img src="image-20220101110033089.png" style="zoom:50%"><ul><li>Background: In the last decade, the language cores had few changes, but the programs became significantly larger and more complicated.</li><li>Challenge: How to ensure the reliability, security and other promises of large-scale and complex programs?</li></ul><p>Why We Need Static Analysis?</p><ul><li>Program Reliability<ul><li>Null pointer dereference, memory leak, etc.</li></ul></li><li>Program Security<ul><li>Private information leak, injection attack, etc.</li></ul></li><li>Compiler Optimization<ul><li>Dead code elimination, code motion, etc.</li></ul></li><li>Program Understanding<ul><li>IDE call hierarchy, type indication, etc.</li></ul></li></ul><p>静态分析的定义：</p><ul><li>Static analysis analyzes a program P to reason about its behaviors and determines whether it satisfies some properties before running P.</li><li>Rice 定理告诉我们，对于这些 non-trivial properties，无法给出确切答案</li></ul><p>下图中需要理解的概念（下面几个图很重要）：</p><ul><li>Sound, Complete, Overapproximate, Underapproximate</li><li>soundness：对程序进行了 over-approximate 过拟合，不会漏报（有 false positives 误报）</li><li>completeness：对程序进行了 under-approximate 欠拟合，不会误报（有 false negatives 漏报）</li><li>complete表示报告包含的错误都是真实的错误，但可能并未包含全部的错误，造成了漏报；sound表示报告包含了所有的真实错误，但可能包含了误报的错误，导致误报。</li></ul><img src="image-20220101111046522.png" style="zoom:50%"><ul><li><p>妥协 soundness 会有漏报；妥协 completeness 会有误报</p><img src="image-20220101111235642.png" style="zoom:50%"></li></ul><p>为什么需要 soundness：</p><ul><li>Soundness is critical to a collection of important (static-analysis) applications such as compiler optimization and program verification</li><li>Soundness is also preferable to other (static-analysis) applications for which soundness is not demanded, e.g., bug detection, as better soundness implies more bugs could be found</li><li>Static Analysis: ensure (or get close to) soundness, while making good trade-offs between analysis precision and analysis speed.</li></ul><p>最后 PPT 给了个简单例子（加减法后正负数分析），将人代入分析器的视角，来说明静态分析的两大内核：</p><ul><li><font color="red">(Data) Abstraction</font>：对于不同的程序，我们都将其行为/语义抽象到一个指定的域中，之后，我们对定义的域进行分析。<br>广义来说，是对世间万物规则的理解和抽象</li><li><font color="blue">Safe-approximation (Strategies)</font>：根据程序的语义和要分析的问题，设计 “转换函数”。<br>广义来说，是在具体问题下，是我们重新设定和 model 的世间运转规则<ul><li>Transfer Functions</li><li>Control Flows</li></ul></li></ul><h2 id="Intermediate-Representation"><a href="#Intermediate-Representation" class="headerlink" title="Intermediate Representation"></a>Intermediate Representation</h2><p>复习重点：</p><ul><li>The relation between compilers and static analyzers</li><li>Understand 3AC and its common forms</li><li>How to build basic blocks on top of IR</li><li>How to construct control flow graphs on top of BBs</li></ul><blockquote><p>编译原理知识：</p><ul><li>编译器是一个软件，分为前端和后端两部分，将源代码生成机器码。</li><li>编译器的前端一般由词法分析，语法分析，语义分析组成，词法分析是将源程序分成一个一个的token，也就是说，需要将字符串流（源程序）切分成一个个小的单元，划分出是关键字还是标识符还是运算符等等，一般用正则表达式来定义规则。语法分析就是将一个个的Token组成句子，它的功能比较受限，但是也能检测出一些错误出来，比如<code>f(a,b,)</code>这样子的错误，在此阶段构造出AST。语义分析会进行类型检查，构造出修饰后的AST。</li><li>而后端一般分为代码生成和优化相关的操作。那么静态分析和编译器的关系是什么呢？如下图所示，在生成了源代码的中间表示之后可以用静态分析来对代码进行一系列的操作。<img src="image-20220101112624682.png" style="zoom:50%"></li></ul><p>AST 与 IR：</p><ul><li>Abstract Syntax Tree、Intermediate Representation</li></ul><img src="image-20220101112921593.png" style="zoom:50%"></blockquote><p>那么为什么静态分析在IR的层面上而不是在AST上面呢？</p><ul><li>IR相比于AST更底层，更接近于机器码，而AST更接近于语法结构。</li><li>IR相比于AST，与语言的关联性更低。</li><li>AST相比于IR会缺少控制流信息，同时IR也会更紧凑</li></ul><h3 id="Three-Address-Code-3AC"><a href="#Three-Address-Code-3AC" class="headerlink" title="Three-Address Code (3AC)"></a>Three-Address Code (3AC)</h3><ul><li><p>三地址码（3AC）是一种IR，因为在一条指令最多含有3个地址，所以我们称这样的表示方法为3地址码。</p></li><li><p>如</p><ul><li>x = y bop z</li><li>x = uop y</li><li>x = y</li><li>goto L</li><li>if x goto L</li><li>if x rop y goto L</li></ul></li></ul><h3 id="Static-Single-Assignment-SSA"><a href="#Static-Single-Assignment-SSA" class="headerlink" title="Static Single Assignment (SSA)"></a>Static Single Assignment (SSA)</h3><ul><li>定义：给每一个定义变量一个新的名字，传递到接下来的使用当中，每个变量有1个定义（赋值的目标变量）。<ul><li>Give each definition a fresh name</li><li>Propagate fresh name to subsequent uses</li><li>Every variable has exactly one definition<img src="image-20220101113608085.png" style="zoom:50%"></li></ul></li><li>优点：<ul><li>唯一的变量名可以间接体现程序流信息，简化分析过程；</li><li>清楚的Define-Use信息</li></ul></li><li>缺点：<ul><li>引入很多变量和phi-function；<img src="image-20220101113543593.png" style="zoom:50%"></li><li>转换为机器码时效率变低（引入很多拷贝操作）</li></ul></li></ul><h3 id="★Basic-Blocks-BB"><a href="#★Basic-Blocks-BB" class="headerlink" title="★Basic Blocks (BB)"></a>★Basic Blocks (BB)</h3><ul><li>输入一个程序的若干三地址码，将其划分成几块，每一块是 Basic Block，满足一些性质（比如 entry 和 exit 块智能在程序开始和结束）</li><li>构造算法：<ul><li>选 leaders<ul><li>The first instruction in P is a leader</li><li>Any target instruction of a conditional or unconditional jump is a leader</li><li>Any instruction that immediately follows a conditional or unconditional jump is a leader</li></ul></li><li>构造 BB<ul><li>A BB consists of a leader and all its subsequent instructions until the next leader<img src="image-20220101114230553.png" style="zoom:50%"></li></ul></li></ul></li></ul><p>Control Flow Graphs (CFG)：</p><ul><li>控制流边：<ul><li>基本块A的结尾有跳转指令跳转到基本块B；</li><li>原始指令序列中，B紧跟着A，且A的结尾不是无条件跳转。<img src="image-20220101115548529.png" style="zoom:50%"></li></ul></li></ul><h2 id="Data-Flow-Analysis"><a href="#Data-Flow-Analysis" class="headerlink" title="Data Flow Analysis"></a>Data Flow Analysis</h2><h3 id="D-F-A-应用"><a href="#D-F-A-应用" class="headerlink" title="D.F.A. 应用"></a>D.F.A. 应用</h3><p>复习重点：</p><ul><li>理解三种数据流分析应用，如何设计类似的算法，如何优化<ul><li>reaching definitions</li><li>live variables</li><li>available expressions</li></ul></li><li>理解数据流分析的共性与区别</li><li>理解迭代算法并弄懂算法为什么能停止</li></ul><p>Safe-approximation:</p><ul><li><p>may analysis：输出可能正确的信息（over-approximation），==注意大多数静态分析都是 may analysis==</p></li><li><p>must analysis：输出必须正确的信息（under-approximation）</p></li><li><p>对 may analysis 来说 safe 是 over</p></li><li><p>对 must analysis 来说 safe 是 under</p></li></ul><p>不同的数据流分析有：</p><ul><li>不同的 <font color="red">data abstraction</font></li><li>不同的 <font color="blue">flow safe-approximation</font> strategies，如不同的 transfer functions 和 control-flow handlings</li></ul><h4 id="Preliminaries-序言"><a href="#Preliminaries-序言" class="headerlink" title="Preliminaries 序言"></a>Preliminaries 序言</h4><ul><li>输入/输出状态 Input/Output States<br>（本质是抽象的数据的状态，如变量的状态）</li><li>数据流分析的结果：每一个程序点对应一个 data-flow value，表示该点所有可能程序状态的一个抽象。例如，我只关心x、y的值，抽象表示x、y所有可能的值的集合（输入/输出的值域/约束）就代表了该程序点的程序状态。<img src="image-20220101163136601.png" style="zoom:33%"></li></ul><blockquote><p>Forward Analysis 前向分析：按程序执行顺序的分析。$OUT[s]=f_s(IN[s]) $，s 是 statement</p><p>Backward Analysis 反向分析：逆向分析。$IN[s]=f_s(OUT[s]) $</p></blockquote><p>控制流约束：约束求解做的事情，推断计算输入到输出，或反向分析</p><img src="image-20220101163436568.png" style="zoom:33%"><p>以下介绍的数据流分析暂不涉及（都在后面的课介绍）：</p><ul><li>Method Calls 方法调用，即暂只处理 Intra-procedural CFG</li><li>Aliases 别名。假设不存在两个变量指向内存中同一个地址</li></ul><h4 id="Reaching-Definitions-Analysis"><a href="#Reaching-Definitions-Analysis" class="headerlink" title="Reaching Definitions Analysis"></a>Reaching Definitions Analysis</h4><p>Reaching Definitions：</p><ul><li><p>定义：<br>A definition <strong>d</strong> at program point <strong>p</strong> reaches a point <strong>q</strong><br>if there is a path from <strong>p</strong> to <strong>q</strong> such that <strong>d</strong> is not “killed” along that path</p><p>给变量v一个定义d，存在一条路径使得程序点p能够到达q，且在这个过程中不能改变v的赋值</p><img src="image-20220101164907927.png" style="zoom:33%"></li><li><p>应用：detect possible undefined variables<br>用来分析未定义的变量。例如，我们在程序入口为各变量引入一个 dummy 定值。当程序出口的某变量定值依然为 dummy，则我们可以认为该变量未被定义。程序中间用到了，就得报 undefined error 啦。</p></li><li><p>特点：</p><ul><li>may analysis / over-approximation</li><li>forward</li></ul></li><li><p>Transfer Function:</p><ul><li>$\text{OUT[B]} = gen_B \cup (\text{IN[B]} - kill_B) $</li><li>gen 的是新的 definition</li><li>kill 的是其他 Basic Block 里定义 v 的 definitions（如对于一条赋值语句 <code>D: v = x op y</code>，该语句生成了 v 的一个定值 D，并杀死程序中其它对变量 v 定义的定值）</li></ul></li><li><p>Control Flow:</p><ul><li>$\text{IN[B]} = \cup_{P\ \text{a predecessor of B}}\ \text{OUT[P]} $</li></ul></li></ul><ul><li><p>算法：</p><img src="image-20220101165709321.png" style="zoom:33%"> * 为什么在第 2 行要排除 entry，和第一行结合一下不香吗？ —— 这是一个数据流分析的算法模板，它可以不仅适用于 Reaching Definition * 为什么会终止？ —— OUT[S] never shrinks 收缩且状态是有限的（到达不动点） <img src="image-20220101182509399.png" style="zoom:30%"></li><li><p>一个运行实例的最终结果（看不懂就回去看 PPT）：</p><p>这里的数据抽象是 BitVector（每个 bit 表示某个 definition 是否在当前还有用），在 Tai-e 实现是 Set。理解这个 Fact 的流转即可，表现形式是次要的。</p><img src="image-20220101171401678.png" style="zoom:33%"></li></ul><h4 id="Live-Variables-Analysis"><a href="#Live-Variables-Analysis" class="headerlink" title="Live Variables Analysis"></a>Live Variables Analysis</h4><p>Live Variables：</p><ul><li><p>定义：<br>Live variables analysis tells whether the value of <strong>variable v</strong> at <strong>program point p</strong> could be used along <strong>some path</strong> in CFG starting at p. If so, v is live at p; otherwise, v is dead at p.</p><p>某程序点p处的变量v，从p开始到exit块的CFG中是否有某条路径用到了v，如果用到了v，则v在p点为live，否则为dead。其中有一个隐含条件，在点p和引用点之间不能重定义v。</p><img src="image-20220101184433425.png" style="zoom:33%"></li><li><p>应用：可用于寄存器分配，如果寄存器满了，就需要替换掉不会被用到的变量</p></li><li><p>特点：</p><ul><li>may analysis / over-approximation</li><li>backward</li></ul></li><li><p>Control Flow:</p><ul><li>$\text{OUT[B]} = \cup_{S\ \text{a successor of B}} \text{IN[S]} $</li></ul></li><li><p>Transfer Function:</p><ul><li>$\text{IN[B]} = use_B \cup (\text{OUT[B]} - def_B) $</li><li>use 是指那些被用到，且用之前在本 basic block 没有被重定义过的变量</li><li>def 是指在本 basic block 中重定义的变量</li><li>一个例子，便于理解：<img src="image-20220101192219571.png" style="zoom:25%"></li></ul></li><li><p>算法：</p><img src="image-20220101190112322.png" style="zoom:33%"></li><li><p>一个运行实例的最终结果（看不懂就回去看 PPT）：</p><p>这里的数据抽象是 BitVector（每个 bit 表示某个 Variable 在未来是否还 live）</p><img src="image-20220101190443742.png" style="zoom:30%"></li></ul><h4 id="Available-Expressions-Analysis"><a href="#Available-Expressions-Analysis" class="headerlink" title="Available Expressions Analysis"></a>Available Expressions Analysis</h4><p>Available Expressions：</p><ul><li><p>定义：An expression <code>x op y</code> is available at program point p if</p><ul><li><strong>all</strong> paths from <code>the entry</code> to <code>p</code> must pass through the evaluation of <code>x op y</code>, and</li><li>after the last evaluation of <code>x op y</code>, there is <strong>no redefinition</strong> of <code>x</code> or <code>y</code></li></ul><p>程序点p处的表达式<code>x op y</code>可用需满足2个条件，一是从 entry 到 p 点必须经过<code>x op y</code>，二是最后一次使用 <code>x op y</code> 之后，没有重定义操作数 x、y。（如果重定义了 x 或 y，如 x = <code>a op2 b</code>，则原来的表达式 <code>x op y</code> 中的x或y就会被替代）</p></li><li><p>应用：用于优化，检测全局公共子表达式</p></li><li><p>特点：</p><ul><li>must analysis / under-approximation</li><li>forward</li></ul></li><li><p>Transfer Function:</p><ul><li>$\text{OUT[B]} = gen_B \cup (\text{IN[B]} - kill_B) $</li><li>gen：基本块求值 x op y，且之后没有对 x 或 y 赋值</li><li>kill：基本块对 x 或 y 赋值，且没有重新计算 x op y（如果重新计算，即使值不一样，也属于 gen）<img src="image-20220101194333310.png" style="zoom:33%"></li><li>问题：该分析为什么属于 must analysis 呢？<ul><li>因为我们允许有漏报，不能有误报</li><li>比如以下示例中，改为去掉 $b=e^{16}*x $，该公式会把该表达式识别为不可用，即在 $c = …$ 处不做优化。</li><li>尽管这个式子在下面可能是 available 的，比如当 x=… 是重赋值，但是 x 实际上没变化时，虽然漏报了，但是很 safe，不影响程序分析结果的正确性 <img src="image-20220103154843493.png" style="zoom:25%"></li></ul></li></ul></li><li><p>Control Flow:</p><ul><li>$\text{IN[B]} = \cap_{P\ \text{a predecessor of B}} \text{OUT[P]} $</li></ul></li><li><p>算法：</p><img src="image-20220101194412116.png" style="zoom:33%"></li><li><p>一个运行实例的最终结果（看不懂就回去看 PPT）：</p><img src="image-20220101194440312.png" style="zoom:33%"></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><img src="image-20220101200958287.png" style="zoom:33%"><p>怎样判断是 May 还是 Must：</p><ul><li>Reaching Definitions 表示只要从赋值语句到点p<strong>存在1条路径</strong>，则为 reaching，结果不一定正确；</li><li>Live Variables 表示只要从点 p 到 Exit <strong>存在1条路径</strong>使用了变量v，则为 live，结果不一定正确；</li><li>Available Expressions 表示从 Entry 到点 p 的<strong>每一条路径</strong>都经过了该表达式，则为 available，结果肯定正确。</li></ul><h3 id="D-F-A-基础"><a href="#D-F-A-基础" class="headerlink" title="D.F.A. 基础"></a>D.F.A. 基础</h3><p>复习重点：</p><ul><li>Understand the functional view of iterative algorithm</li><li>The definitions of lattice and complete lattice</li><li>Understand the fixed-point theorem</li><li>How to summarize may and must analyses in lattices</li><li>The relation between MOP and the solution produced by the iterative algorithm</li><li>Constant propagation analysis</li><li>Worklist algorithm</li></ul><p>Outline:</p><ul><li><p>迭代算法——另一个角度</p></li><li><p>偏序（Partial Order）</p></li><li><p>上下界（Upper and Lower Bounds）</p></li><li><p>格（Lattice），半格（Semilattice），全格和格点积（Complete and Product Lattice）</p></li><li><p>数据流分析框架（via Lattice）</p></li><li><p>单调性与不动点定理（Monotonicity and Fixed Point Theorem）</p></li><li><p>迭代算法转化为不动点理论</p></li><li><p>从 lattice 的角度看 may/must 分析</p></li><li><p>分配性（Distributivity）和 MOP</p></li><li><p>常量传播</p></li><li><p>Worklist 算法</p></li></ul><blockquote><p>上节课是介绍了 3 种数据流分析迭代算法，本节课将从数学理论的角度来讨论数据流分析，加深对数据流分析算法的理解。</p></blockquote><h4 id="迭代算法——另一个角度"><a href="#迭代算法——另一个角度" class="headerlink" title="迭代算法——另一个角度"></a>迭代算法——另一个角度</h4><p>理论：</p><ul><li><p>定义1：给定有 k 个节点（基本块）的 CFG，迭代算法就是在每次迭代时，更新每个节点 n 的 OUT[n]</p></li><li><p>定义2：设数据流分析的值域是 V，可定义一个 k-tuple：$(\text{OUT}\left[n_{1}\right], \text {OUT}\left[n_{2}\right], \cdots, \text {OUT}\left[n_{k}\right])$。<br>其是集合 $V_1 \times V_2\cdots V_k $ 的一个元素，表示每次迭代后 k 个节点整体的值</p></li><li><p>定义3：每一次迭代可看作是 $V_k$ 映射到新的 $V_k$，通过 Transfer Function 和 Control Flow 来映射，记作函数 $F: V^k \rightarrow V^k $</p></li><li><p>迭代算法本质：</p><ul><li>常见的数据流迭代算法，目的是通过迭代计算，最终得到一个稳定不变的解。</li><li>有了上述定义后：通过不断迭代，直到相邻两次迭代的 k-tuple 值一样，算法结束。<br><img src="Static-Analysis-Study-Notes/image-20220102160552266.png" alt="image-20220102160552266"></li></ul></li><li><p>不动点：$X_i = F(X_i) $</p></li><li><p>几个问题（学完之后就懂了）：</p><ul><li>是否一定会停止（到达不动点）？</li><li>如果会终止，会得到几个解（几个不动点）？</li><li>迭代几次会得到解（到达不动点）？</li></ul></li></ul><h4 id="Partial-Order"><a href="#Partial-Order" class="headerlink" title="Partial Order"></a>Partial Order</h4><p>定义：</p><ul><li>给定偏序集 $(P, \sqsubseteq)$，$\sqsubseteq$ 是集合 P 上的二元关系，若满足以下性质则为偏序集：<ul><li>自反性 Reflexivity：<code>∀x∈P, x⊑x</code></li><li>对称性 Antisymmetry：<code>∀x,y∈P, x⊑y∧y⊑x ⇒ x=y</code></li><li>传递性 Transitivity：<code>∀x,y∈P, x⊑y∧y⊑z ⇒ x⊑z</code></li></ul></li><li>偏序关系与全序关系的区别在于，全序关系可以让任意两个元素比较，而偏序关系不保证所有元素都能进行比较。</li></ul><p>例子：</p><ul><li>P 是整数集，$\sqsubseteq $ 表示 $\leq$ ，则是偏序集；若 $\sqsubseteq$ 表示 $&lt; $，则显然不是偏序集</li><li>P 是英文单词集合，$\sqsubseteq $ 表示子串关系（可以存在两个元素不具有偏序关系，不可比性），是偏序集</li><li>P 是 S 的 power set，$\sqsubseteq $ 表示 $\subseteq $，则是偏序集</li></ul><h4 id="Upper-and-Lower-Bounds"><a href="#Upper-and-Lower-Bounds" class="headerlink" title="Upper and Lower Bounds"></a>Upper and Lower Bounds</h4><p>定义：给定偏序集 $(P, \sqsubseteq) $，且有 $P$ 的子集 $S⊆P $：</p><ul><li><p>上界：$∀x∈S, x⊑u $，其中 $u∈P $，则 u 是子集 S 的上界（注意，u 并不一定属于 S 集）</p></li><li><p>下界：$∀x∈S, l⊑x $，其中 $l∈P $，则 l 是 S 的下界</p></li><li><p>最小上界：least upper bound（lub 或者称为 join），用 <code>⊔S</code> 表示</p><ul><li>对于子集 S 的任何一个上界 <code>u</code>，均有 <code>⊔S ⊑ u</code></li></ul></li><li><p>最大下界：greatest lower bound（glb 或者称为 meet），用 <code>⊓S</code> 表示</p><ul><li>对于子集 S 的任何一个下界 <code>l</code>，均有 <code>l ⊑ ⊓S</code></li></ul></li></ul><p>例子：</p><ul><li>若 S = {a, b}，那么最小上界可以表示为 <code>a⊔b</code>，最大下界可以表示为 <code>a⊓b</code><img src="image-20220102162134822.png" style="zoom:33%"></li></ul><p>特性：</p><ul><li><p>并非每个偏序集都有上下确界</p><img src="image-20220102162258335.png" style="zoom:25%"></li><li><p>如果存在上下确界，则是唯一的。利用传递性和反证法即可证明。</p></li></ul><h4 id="Lattice格、Semilattice半格、全格和格点积（Complete-and-Product-Lattice）"><a href="#Lattice格、Semilattice半格、全格和格点积（Complete-and-Product-Lattice）" class="headerlink" title="Lattice格、Semilattice半格、全格和格点积（Complete and Product Lattice）"></a>Lattice格、Semilattice半格、全格和格点积（Complete and Product Lattice）</h4><blockquote><p>这些都是基于上下确界来定义的</p></blockquote><p>格 Lattice：</p><ul><li><p>定义：给定一个偏序集 <code>(P, ⊑)</code>，<code>∀a,b∈P</code>，如果存在 <code>a⊔b</code> 和 <code>a⊓b</code>，那么就称该偏序集为格。<br>即偏序集中的任意两个元素构成的集合均存在最小上界和最大下界。</p></li><li><p>例子：</p><ul><li>(S, ⊑) 中 S 是整数子集，$\sqsubseteq $ 是 $\leq$，是格；</li><li>(S, ⊑) 中 S 是英文单词集，$\sqsubseteq $ 表示子串关系，不是格，因为单词 pin 和 sin 就没有上确界；<img src="image-20220102163017356.png" style="zoom:33%"></li><li>(S, ⊑) 中 S 是 {a, b, c} 的幂集，$\sqsubseteq $ 表示 $\subseteq $ 子集，是格。</li></ul></li></ul><p>半格 semilattice：</p><ul><li>给定一个偏序集 <code>(P,⊑)</code>，∀a,b∈P：</li><li>当且仅当 a⊔b 存在，该偏序集叫做 join semilatice；</li><li>当且仅当 a⊓b 存在，该偏序集叫做 meet semilatice</li></ul><p>全格：</p><ul><li>对于格 $(P, \sqsubseteq) $ 的任意子集 S，⊔S 和 ⊓S 都存在，则 $(P, \sqsubseteq) $ 为全格 complete lattice。</li><li>例子：<ul><li>P 是整数集，$\sqsubseteq $ 是 $\leq $，不是全格（因为 P 的子集正整数集没有上确界）</li><li>$(S, ⊑) $ 中 S 是 ${a, b, c} $ 的幂集，$\sqsubseteq $ 表示 $\subseteq $ 子集，是全格（这感觉和前面 “并非每个偏序集都有上下确界” 那个例子有点冲突了）</li></ul></li><li>符号：<ul><li>$\top = \sqcup P$ ，叫做 top</li><li>$\perp = \sqcap P $，叫做 bottom</li></ul></li></ul><ul><li>性质：<ul><li>有穷的格点必然是 complete lattice。全格一定有穷吗？ 不一定，如实数界 [0, 1]。</li></ul></li></ul><p>格点积：</p><ul><li>给定一组格，$L_1=(P_1, \sqsubseteq_1) ，L_2=(P_2, \sqsubseteq_2)，… ，L_n=(Pn, \sqsubseteq _n) $，都有上确界 $\sqcup_i $ 和下确界 $\sqcap_i$，则定义格点积 $L_n = (P, \sqsubseteq)$</li><li>$P = P_1 \cdots P_n $</li><li>$ \begin{aligned}<br>&amp;\left(x_{1}, \ldots x_{n}\right) \sqsubseteq\left(y_{1}, \ldots y_{n}\right) \Leftrightarrow\left(x_{1} \sqsubseteq y_{1}\right) \wedge \ldots \wedge\left(x_{n} \sqsubseteq y_{n}\right) \<br>&amp;\left(x_{1}, \ldots x_{n}\right) \sqcup\left(y_{1}, \ldots y_{n}\right)=\left(x_{1} \sqcup y_{1}, \ldots, x_{n} \sqcup y_{n}\right) \<br>&amp;\left(x_{1}, \ldots x_{n}\right) \sqcap\left(y_{1}, \ldots y_{n}\right)=\left(x_{1} \sqcap y_{1}, \ldots, x_{n} \sqcap y_{n}\right)<br>\end{aligned} $</li><li>性质：<ul><li>格点积也是格点；</li><li>格点都是全格，则格点积也是全格</li></ul></li></ul><h4 id="D-F-A-Framework-via-Lattice"><a href="#D-F-A-Framework-via-Lattice" class="headerlink" title="D.F.A. Framework via Lattice"></a>D.F.A. Framework via Lattice</h4><p>一个数据流分析框架（D, L, F）由以下元素组成：</p><ul><li>D: 数据流的方向，forward 还是 backward</li><li>L: 包含了数据值 V 和 meet, join 符号的格</li><li>F: a family of transfer functions from V to V (V -&gt; V)</li></ul><p>从而，数据流分析可以被视为在 lattice 的值上迭代地应用转移方程和 meet/join 操作符。</p><h4 id="Monotonicity-单调性-and-Fixed-Point-Theorem"><a href="#Monotonicity-单调性-and-Fixed-Point-Theorem" class="headerlink" title="Monotonicity 单调性 and Fixed Point Theorem"></a>Monotonicity 单调性 and Fixed Point Theorem</h4><p>目标问题：</p><ul><li>迭代算法一定会停止（到达不动点）吗？</li><li>在什么条件下可以停机？</li></ul><p>单调性 Monotonicity：</p><ul><li>函数 $f: L \rightarrow L $，满足 $∀x,y∈L,\ x⊑y⇒f(x)⊑f(y) $，则称之为单调的</li></ul><p>不动点理论：</p><ul><li>定义：给定一个 complete lattice $(L,⊑) $，如果 $f:L→L $ 是单调的，且 L 有限</li><li>最小不动点：通过迭代：$f(⊥), f(f(⊥)), \cdots, f^k(⊥) $ 直到找到最小的一个不动点</li><li>最大不动点：通过迭代：$f(⊤),f(f(⊤)), \cdots, f^kk(⊤) $ 直到找到最大的一个不动点。</li><li>证明：<ul><li>根据 $\bot$ 和 f 的定义，我们可以得到：$\bot \sqsubseteq f(\bot)$</li><li>由于 L 是有限的，且 f 单调，根据鸽巢原理，必然存在一个 k 使得 $\bot \sqsubseteq f(\bot) \sqsubseteq f^2(\bot)\sqsubseteq …\sqsubseteq f^k(\bot)\sqsubseteq f^{k+1}(\bot) $，且$f^k(\bot) = f^{k+1}(\bot)$</li><li>假设我们有另一个任意不动点 x，由于 f 是单调的，因此 $f(\bot) \sqsubseteq f(x), f^2(\bot) \sqsubseteq f^2(x),…,f^{Fix} = f^k(\bot)\sqsubseteq f^k(x) = x$</li><li>可知的确 $f^{Fix} $ 是最小不动点</li></ul></li><li>通过上面的证明，我们又回答了一个问题：如果我们的迭代算法符合不动点定理的要求，那么迭代得到的不动点，确实就是最优不动点</li></ul><h4 id="Relate-Iterative-Algorithm-to-Fixed-Point-Theorem"><a href="#Relate-Iterative-Algorithm-to-Fixed-Point-Theorem" class="headerlink" title="Relate Iterative Algorithm to Fixed Point Theorem"></a>Relate Iterative Algorithm to Fixed Point Theorem</h4><blockquote><p><strong>问题</strong>：我们如何在理论上证明<strong>迭代算法有解</strong>、<strong>有最优解</strong>、<strong>何时到达不动点</strong>？那就是将迭代算法转化为<strong>不动点理论</strong>。因为不动点理论已经证明了，单调、有限的完全 lattice，存在不动点，且从⊤开始能找到最大不动点，从⊥开始能找到最小不动点。</p></blockquote><p>目标：证明迭代算法是一个 complete lattice $(L, \sqsubseteq) $，且 L 是有限的、F 是单调的</p><ul><li>Complete Lattice 证明<ul><li>迭代算法里，每个 basic block 的值域相当于一个 Lattice</li><li>每次迭代，k 个 basic block 的值域就是一个 k-tuple</li><li>k-tuple 可以看作 Lattice 积，根据 product lattice 的性质，若 $L^K $ 中每一个 Lattice 都是 complete 的，那 $L^k$ 也是 complete 的</li></ul></li><li>L 是有限的<ul><li>迭代算法中，值域是 0/1，是有限的，则 Lattice 有限，则 $L^K $ 也有限</li></ul></li><li>F 是单调的<ul><li>Transfer Function：由于 gen 和 kill 是固定的，值一旦变成 1，就不会变回 0，显然单调</li><li>Join/Meet操作：L x L -&gt; L。要证明其单调，就是要证明：$\forall x,y,z\in L, x\sqsubseteq y$，有$x \sqcup z \sqsubseteq y \sqcup z$<ul><li>由定义，$y \sqsubseteq y \sqcup z$</li><li>由传递性，$x \sqsubseteq y \sqcup z$</li><li>则 $y \sqcup z$ 是 $x, z$ 的 ub</li><li>又 $x \sqcup z$ 是 $x, z$ 的 lub</li><li>因此 $x \sqcup z \sqsubseteq y \sqcup z$，证毕。</li></ul></li></ul></li></ul><p>算法何时到达不动点？</p><ul><li>定义 Lattice 的高度：从 lattice 的 top 到 bottom 之间最长的路径 <img src="image-20220103150717473.png" style="zoom:33%"></li><li>最坏情况迭代次数：设有 n 个块，每次迭代只有 1 个 BB 的 OUT/IN 值的其中 1 位发生变化（则从 top→bottom 这 1 位都变化），则最多迭 (n × h) 次。</li></ul><p>最后我们再列出这三个问题与其回答：</p><ul><li>算法是否确保一定能停止/达到不动点？<strong>能！</strong>会不会总是有一个解答？<strong>可以！</strong></li><li>如果能到达不动点，那么是不是只有一个不动点？<strong>可以有很多。</strong>如果有多个不动点，我们的结果是最优的吗？<strong>是的！</strong></li><li>什么时候我们会能得到不动点？<strong>最坏情况下，是 lattice 的高度与 CFG 的节点数的乘积。</strong></li></ul><h4 id="May-Must-Analysis-A-Lattice-View"><a href="#May-Must-Analysis-A-Lattice-View" class="headerlink" title="May/Must Analysis, A Lattice View"></a>May/Must Analysis, A Lattice View</h4><p>无论 may 还是 must 分析，都是从一个方向到另一个方向去走（从 unsafe 到 safe，从准确到不准确）。考虑我们的 lattice 抽象成这样一个视图：</p><img src="image-20220103151014807.png" style="zoom:25%"><p>终极超级无敌的图（需理解）：</p><img src="image-20220103151251860.png" style="zoom:33%"><p>May 分析（右图，以 Reaching Definitions 分析为例）：</p><ul><li>从 $\perp $ 开始。</li><li>$\perp $ 表示我们坚定一个结论 “所有 definitions 都不可达”<br>根据下图回顾一下 reaching definitions 定义，即<strong>说明我们认为所有变量在中间都进行了赋值</strong>，那我们在开始时就不需要对变量进行初始化，这就很 unsafe <img src="image-20220101164907927.png" style="zoom:33%"></li><li>$\top $ 表示所有 definitions 都可达，那我们就得在开始时为所有变量都初始化，很 safe，但如果都确保每个变量都初始化了，那做这个分析干嘛</li><li>Truth 表示最准确的验证结果，假设 {a,c} 是 truth，那么包括其以上的都是 safe 的，以下的都是 unsafe，就是下图的绿色和红色 <img src="image-20220103153549475.png" style="zoom:25%"></li><li>从 $\perp $ 到 $\top $，得到的最小不动点最准确，离 Truth 最近。上面还有多个不动点，越往上越不准</li></ul><p>Must 分析（左图，以 Available Expressions 分析为例）：</p><ul><li>从 $\top $ 开始，表示所有表达式都 available，不需要重新计算。显然，假如有表达式被重定义了，那这个优化就是错误的，不安全！</li><li>$\perp $ 表示没有表达式可用，都不需要优化，都需要重新计算，很安全！但没有用</li><li>从 $\top $ 到 $\perp $，就是从不安全到安全，存在一个 Truth，代表准确的结果</li><li>从 $\top $到 $\perp $，达到一个最大不动点，离 truth 最近的最优解</li></ul><p>迭代算法转化到 lattice 上，may/must 分析分别初始化为最小值 $\perp $ 和最大值 $\top $，最后求最小上界/最大下界。</p><h4 id="Distributivity-and-MOP"><a href="#Distributivity-and-MOP" class="headerlink" title="Distributivity and MOP"></a>Distributivity and MOP</h4><p>MOP：</p><ul><li>目的：引入 MOP（meet-over-all-paths）来衡量迭代算法的精度</li><li>定义：最终将所有路径一起来进行 join/meet 操作（不是根据节点与其前驱/后继节点的关系来迭代计算数据流）</li><li>路径 P：在 cfg 图上从 entry 到基本块 $s_i$ 的一条路径 $P = Entry → s_1 → s_2 → … → s_i $</li><li>路径 P 上的转移函数 $F_p$：该路径上所有语句的转移函数的组合 $f_{s1}, f_{s2},\cdots,f_{s_{i-1}} $ 构成 $F_p $</li><li>MOP：从 entry 到 $s_i$ 所有路径的 $F_p$ 的 meet 操作。本质是求这些值的 最小上界/最大下界 <img src="image-20220103190752114.png" style="zoom:50%"></li><li>MOP 准确性：<ul><li>有些路径不会被执行，所以不准确；路径可能包含循环，或者路径爆炸，所以实操性不高，只能作为理论的一种衡量方式。</li><li>与迭代算法比较：<img src="image-20220103191211391.png" style="zoom:25%"></li><li>证明 $F(x)\sqcup F(y)\sqsubseteq F(x\sqcup y) $：<ul><li>根据最小上界的定义，有 <code>x ⊑ x⊔y</code> 和 <code>y ⊑ x⊔y</code></li><li>由于转换函数是单调的，则有 <code>F(x) ⊑ F(x⊔y)</code> 和 <code>F(y) ⊑ F(x⊔y)</code>，所以 <code>F(x⊔y)</code> 就是 <code>F(x)</code> 和 <code>F(y)</code> 的上界</li><li>根据定义，<code>F(x)⊔F(y)</code> 是 <code>F(x)</code> 和 <code>F(y)</code> 的最小上界</li><li>所以 <code>F(x) ⊔ F(y) ⊑ F(x⊔y)</code></li></ul></li><li>所以，MOP 更准确。</li><li>若 F 满足分配律，则<strong>迭代算法和 MOP 精确度一样</strong> <code>F(x⊔y)=F(x)⊔F(y)</code>。<br>若对于控制流的 join/meet，是进行集合的交或并操作，则满足分配律。</li></ul></li></ul><h4 id="Constant-Propagation"><a href="#Constant-Propagation" class="headerlink" title="Constant Propagation"></a>Constant Propagation</h4><blockquote><p>有些问题下 F 是不满足分配律的，如常量传播（Constant Propagation）</p></blockquote><p>问题描述：</p><ul><li>在程序点 p 处的变量 x，判断x是否一定指向常量值。</li></ul><p>类别：</p><ul><li><font color="red">may analysis</font>，注意哦</li><li>此时的结果包含 true positive 和 false positive，而如果是 must analysis，那只包含部分的 true positive</li><li>有同学表示 “从结果来看，NAC的结果是may的，const的结果则是must的”<ul><li>是 may analysis 本质上是因为 constant propagation 做法是 over-approximation。不能从结果上去看，哦结果只包括 true positive，没有误报，就是 must，不能这样</li><li>还有 undef，undef 和 const 结合是 const，此时就是是一种 over-approximation，因为你又不确定 const 这个值的 branch 一定能 true</li></ul></li></ul><p>表示：</p><ul><li>CFG 每个节点的 OUT 是 <code>pair&lt;variable, value&gt;</code> 的集合，表示变量 variable 是否指向常数 value</li></ul><p>D.F.A. Framework:</p><ul><li><p>D：Forward 更直观</p></li><li><p>L：Lattice</p></li><li><p>变量值域：</p><ul><li>所有实数</li><li>$\top $ 是 UNDEF</li><li>$\perp $ 是 NAC <img src="image-20220103200510323.png" style="zoom:33%"></li></ul></li><li><p>meet 操作 $\sqcap $：在每个路径汇聚点 PC，对流入的所有变量进行 meet 操作，但并非常见的交和并，所以不满足分配律</p><ul><li>$NAC \sqcap v = NAC $</li><li>$UNDEF \sqcap v = v $，因为未初始化的变量不是我们分析的目标。</li><li>$c \sqcap v = ? $<ul><li>$c \sqcap c = c $</li><li>$c1 \sqcap c2 =NAC $</li></ul></li></ul></li><li><p>Transfer Function <code>F</code>：</p><ul><li><code>OUT[s] = gen U (IN[s] - {(x, _)})</code></li><li>对所有的赋值语句进行分析（不是赋值语句则不管，用val(x)表示x指向的值）： <img src="image-20220103194749368.png" style="zoom:25%"></li><li>运算中出现 undef 的规则是 <code>c op undef -&gt; undef</code><br>因为 undef 变成 const 的过程中是降级，而如果 <code>const1 + undef -&gt; const2</code>，那么 undef 变化为 const 时，const2 会发生改变，原来的 const2 与现在的 const2 不具有偏序关系，那么就不满足偏序关系的单调性了；<br>另一种解释：在 run-time 时表达式出现 undef 就该报错了，不能给你算出一个值来。</li></ul></li></ul><p>性质：</p><ul><li>不满足分配律 <img src="image-20220103194854202.png" style="zoom:33%"></li><li>MOP 更准确。$F(X\sqcap Y) \sqsubseteq F(X) \sqcap F(Y) $，但是是单调的</li></ul><h4 id="Worklist-Algorithm"><a href="#Worklist-Algorithm" class="headerlink" title="Worklist Algorithm"></a>Worklist Algorithm</h4><p><strong>本质</strong>：对迭代算法进行优化，采用队列来存储需要处理的基本块，减少大量的冗余的计算。</p><img src="image-20220103200813219.png" style="zoom:33%"><h2 id="Interprocedural-Analysis"><a href="#Interprocedural-Analysis" class="headerlink" title="Interprocedural Analysis"></a>Interprocedural Analysis</h2><p>复习重点：</p><ul><li>How to build call graph via class hierarchy analysis</li><li>Concept of interprocedural control-flow graph</li><li>Concept of interprocedural data-flow analysis</li><li>Interprocedural constant propagation</li></ul><h3 id="过程间分析简介"><a href="#过程间分析简介" class="headerlink" title="过程间分析简介"></a>过程间分析简介</h3><p>本小节通过四个部分介绍过程间分析。</p><ul><li>Motivation<ul><li><strong>为什么</strong>要引入过程间分析？</li></ul></li><li>Call Graph Construction<ul><li>介绍一个过程间分析 <strong>必要的数据结构Call Graph</strong></li><li>当前有数种方法来<strong>构建Call Graph</strong>，本节介绍其中<strong>速度最快的一种（Class hierarchy analysis，简称CHA）</strong></li></ul></li><li>Interprocedural Control-Flow Graph (ICFG)<ul><li>之前的章节关注CFG，引入过程间分析后，我们向 CFG 中<strong>添加相应的元素</strong>，得到过程间的控制流图（ICFG）</li><li>讨论由于添加了新元素而需要<strong>增加的操作</strong></li></ul></li><li>Interprocedural Data-Flow Analysis<ul><li>通过一个例子（也就是实验一中做的常量传播分析）来<strong>总结</strong>过程间分析。</li></ul></li></ul><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h3><p><strong>问题</strong>：过程内的分析未考虑函数调用，导致分析不精确。</p><p><strong>过程间分析</strong>：Inter-procedural Analysis，考虑函数调用，又称为全程序分析（Whole Program Analysis），需要构建调用图，加入 Call edges 和 Return edges</p><p>一种最简单的处理方式是（这里以常量传播作例子）：</p><ul><li><p>做最保守的假设，即<strong>为函数调用返回 NAC</strong></p></li><li><p>而这种情况会<strong>丢失精度</strong>。如果使用最简单的处理方式，下图中的n和y分析结果都不是常量，尽管我们能够一眼看出他们的运行时值是n=10，y=43</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> n=bar(<span class="hljs-number">42</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> y=x+<span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Call-Graph-Construction"><a href="#Call-Graph-Construction" class="headerlink" title="Call Graph Construction"></a>Call Graph Construction</h3><p>调用图：</p><ul><li>定义：本质是调用边的集合，从调用点（call-sites）到目标函数（target methods / callees）的边</li><li>示例： <img src="image-20220103205416031.png" style="zoom:33%"></li><li>应用：<ul><li>所有过程间分析的基础！</li><li>Program optimization</li><li>Program understanding</li><li>Program debugging</li><li>Program testing</li></ul></li></ul><h4 id="面向对象语言的调用图构造（Java）"><a href="#面向对象语言的调用图构造（Java）" class="headerlink" title="面向对象语言的调用图构造（Java）"></a>面向对象语言的调用图构造（Java）</h4><p><strong>代表性算法</strong>：从上往下精度变高，速度变慢，划掉的是本课程不关注的</p><ul><li>Class hierarchy analysis(CHA)</li><li><del>Rapid type analysis(RTA)</del></li><li><del>Variable type analysis(VTA)</del></li><li>Pointer analysis(k-CFA)</li></ul><p>Call types in Java：</p><ul><li>本课主要关注 Java 的调用关系图构建。</li><li>为此，我们需要先了解Java中调用的类型。Java 中 call 可分为三类（不需要理解透彻，之后会详细介绍）：</li></ul><table><thead><tr><th></th><th><strong>Static call</strong></th><th><strong>Special call</strong></th><th><strong>Virtual call</strong></th></tr></thead><tbody><tr><td>指令 Instruction</td><td>invokestatic</td><td>invokespecial</td><td>invokeinterface、 invokevirtual</td></tr><tr><td>Receiver objects（返回后赋值的目标对象）</td><td>×</td><td>✓</td><td>✓</td></tr><tr><td>目标函数 Target methods</td><td>Static方法</td><td>构造器、 私有方法、父类的实例方法</td><td>其他实例方法</td></tr><tr><td><strong>目标函数个数</strong></td><td>1</td><td>1</td><td>≥1 (<strong>polymorphism</strong>多态性)</td></tr><tr><td>何时确定 Determinacy</td><td>Compile-time</td><td>Compile-time</td><td>Run-time</td></tr></tbody></table><p>Method Dispatch：</p><ul><li><p><strong>找到最终调用的实际函数</strong>，最难的是 <strong>Virtual call</strong></p></li><li><p>virtual call 在程序运行时才能得到，基于2个要素得到：</p><ul><li>receiver object 的具体类型：C</li><li>调用点的方法签名：<strong>m</strong>（通过 signature 可以唯一确定一个方法）<ul><li>signature = 函数所在的类 + 函数名 + 描述符</li><li>描述符 = 返回类型 + 参数类型</li></ul></li><li>以上，记为 <code>C.foo(P, Q, R)</code> <img src="image-20220103210215454.png" style="zoom:33%"></li></ul></li><li><p>用 <code>Dispatch(c, m)</code> 来模拟动态 Method Dispatch 过程，c 表示 receiver object，m 表示函数签名，式子如下：</p><img src="image-20220103210419034.png" style="zoom:33%"> 即若该类的非抽象方法中包含和 m 同名且同描述符的方法 m‘，则直接返回；否则到 c 的父类中找。</li><li><p>示例：</p><img src="image-20220103210637980.png" style="zoom:33%"></li></ul><h4 id="★-Class-Hierarchy-Analysis-CHA-类层级分析"><a href="#★-Class-Hierarchy-Analysis-CHA-类层级分析" class="headerlink" title="★ Class Hierarchy Analysis (CHA) 类层级分析"></a>★ Class Hierarchy Analysis (CHA) 类层级分析</h4><p>目的：根据每个 virtual call 的 receiver varible 的<strong>声明类型</strong>来求解所有可能调用的目标函数。如 <code>A a = ... ;</code> <code>a.foo();</code> 这个a就是receiver varible，声明类型就是 A。假定 a 可以指向 A 以及 A 所有子类对象，CHA 的过程就是从 A 和子类中去找目标函数</p><p>算法（对一个 call site 执行 Resolve 方法得到所有可能的 target methods）：</p><img src="image-20220103211000578.png" style="zoom:50%"><p>示例：</p><img src="image-20220103211049073.png" style="zoom:33%"> <img src="image-20220103211444888.png" style="zoom:33%"><ul><li>该例子中的错误信息：以上b.foo()的调用目标 C.foo()和D.foo()是错误的，因为<strong>已经指定了是B类型</strong>，所以b.foo()根本不会调用C、D的foo()。因为CHA只考虑声明类型，也就是B，导致准确度下降。</li></ul><p>优缺点：</p><ul><li>只考虑声明类型，所以优点是速度快</li><li>忽略数据流和控制流，所以缺点是准确度低 <img src="image-20220103211845358.png" style="zoom:20%"></li></ul><h4 id="调用图构造"><a href="#调用图构造" class="headerlink" title="调用图构造"></a>调用图构造</h4><p>基本思路：</p><ul><li>通过CHA构造整个程序的call graph</li><li>通常从main函数开始</li><li>递归地处理每个可达的方法</li><li>当不能拓展新的可达方法时停止</li></ul><img src="image-20220103212112332.png" style="zoom:33%"><p>示例：</p><img src="image-20220103224300250.png" style="zoom:33%"><h3 id="Interprocedural-Control-Flow-Graph"><a href="#Interprocedural-Control-Flow-Graph" class="headerlink" title="Interprocedural Control-Flow Graph"></a>Interprocedural Control-Flow Graph</h3><blockquote><p>ICFG = CFGs + <strong>call &amp; return edges</strong></p><ul><li>Call edges: from call sites to the entry nodes of their callees</li><li>Return edges: from exit nodes of the callees to the statementsfollowing their call sites (i.e., return sites)</li></ul></blockquote><img src="image-20220103225436192.png" style="zoom:40%"><h3 id="Interprocedural-Data-Flow-Analysis"><a href="#Interprocedural-Data-Flow-Analysis" class="headerlink" title="Interprocedural Data-Flow Analysis"></a>Interprocedural Data-Flow Analysis</h3><p>目前这一分析领域没有标准方法。首先对过程间和过程内的分析做一个对比，并以常量传播为例子进行解释。</p><table><thead><tr><th></th><th><font color="red">Intra</font>procedural</th><th><font color="red">Inter</font>procecdural</th></tr></thead><tbody><tr><td>Program representation</td><td>CFG</td><td>ICFG = CFGs + <font color="red">call &amp; return edges</font></td></tr><tr><td>Transfer functions</td><td>Node transfer</td><td>Node transfer + <font color="red">edge transfer</font></td></tr></tbody></table><p>一共要处理 4 种 transfer 方法</p><ul><li>Node transfer（之前的 transfer function ）<ul><li>大部分与过程内的常数传播分析一样</li><li>但对于调用语句节点来说，the transfer function is identity function<br>（Leave the handling of the LHS variable (return value) to edge transfer）</li></ul></li><li>Edge transfer<ul><li>Call edge transfer<ul><li>从调用者向被调用者传递参数</li></ul></li><li>Return edge transfer<ul><li>被调用者向调用者传递返回值</li></ul></li><li>Call-to-return edge transfer<ul><li>propagate the local data-flow on ICFG<br>（without such edges, we have to propagate local data-flow across other methods, which is very inefficient）</li><li>同时 kill 掉 call site 的 LHS 变量，因为对应的值会从 return edges 流过来了</li></ul></li></ul></li></ul><img src="image-20220103230840844.png" style="zoom:33%"><h2 id="Pointer-Analysis"><a href="#Pointer-Analysis" class="headerlink" title="Pointer Analysis"></a>Pointer Analysis</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>复习重点：</p><ul><li>What is pointer analysis?</li><li>Understand the key factors of pointer analysis</li><li>Understand what we analyze in pointer analysis</li></ul><p>指针分析：</p><ul><li><p>Motivation（指针分析必要性）：</p><img src="image-20220104131300047.png" style="zoom:33%"></li><li><p>目标：分析程序指针可以指向哪些内存。对于 Java 等面向对象语言，主要分析指针指向哪个对象。</p></li><li><p>说明：指针分析属于 may analysis，分析的结果是某指针所有可能指向哪些对象，是个 over-approximation 集合。</p></li><li><p>示例：面向对象语言中的指针指向问题。<br>对于 setB() 函数，this 指向 <code>new A()</code>，因为是调用者是 a.setB()；<br>setB() 中的 b 是 x 传过来的，所以 b 指向 new B()，A.b 指向 new B()</p><img src="image-20220104132140050.png" style="zoom:67%"></li><li><p>区别：</p><ul><li><p>指针分析：分析指针所有可能指向的对象</p></li><li><p>别名分析：分析两个指针是否指向相同的对象，可通过指针分析来推导得到</p></li></ul></li><li><p>应用：</p><ul><li><p>Fundamental information（Call graph, aliases）</p></li><li><p>Compiler optimization（Virtual call inlining）</p></li><li><p>Bug detection（Null pointer detection）</p></li><li><p>Security analysis（Information flow analysis）</p></li><li><p>…</p></li></ul></li></ul><p>影响指针分析的关键要素：</p><ul><li>指标：<ul><li>精度（precision）</li><li>效率（efficiency）</li></ul></li><li>影响因素：本课程，我们主要分析 allocation site 的堆抽象技术、上下文敏感/不敏感、流不敏感、全程序分析</li></ul><table><thead><tr><th>因素</th><th>问题</th><th>选项</th></tr></thead><tbody><tr><td>Heap abstraction</td><td>如何建模堆内存？</td><td>• Allocation-site<br>• Storeless</td></tr><tr><td>Context sensitivity</td><td>如何建模调用上下文？</td><td>• Context-sensitive<br>• Context-insensitive</td></tr><tr><td>Flow sensitivity</td><td>如何建模控制流？</td><td>• Flow-sensitive<br>• Flow-insensitive</td></tr><tr><td>Analysis scope</td><td>分析哪部分程序？</td><td>• Whole-program<br>• Demand-driven</td></tr></tbody></table><h4 id="堆抽象（内存建模）"><a href="#堆抽象（内存建模）" class="headerlink" title="堆抽象（内存建模）"></a>堆抽象（内存建模）</h4><ul><li><p><strong>问题</strong>：程序动态执行时，堆对象个数理论上是无穷无尽的，但静态分析无法处理这个问题<br>所以为保证指针分析可以终止，我们采用堆抽象技术，将无穷的具体对象抽象成有限的抽象对象<br>也即，将有共性的对象抽象成1个静态对象，从而限制静态分析对象的个数</p><img src="image-20220104133559270.png" style="zoom:67%"><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 示例</span></span><br><span class="line"><span class="hljs-keyword">for</span> (...) &#123;</span><br><span class="line">    A a = <span class="hljs-keyword">new</span> A();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>技术概览：</p><img src="image-20220104133758886.png" style="zoom:80%"><p>Vini Kanvar, Uday P. Khedker, “<em>Heap Abstractions for Static Analysis</em>”. ACM CSUR 2016</p></li><li><p><strong><code>Allocation-Site</code>原理</strong>：</p><ul><li>将动态对象抽象成它们的创建点（<code>Allocation-Site</code>），来表示在该点创建的所有动态对象。<code>Allocation-Site</code> 个数是有限的。<br>（我们只学习 <code>Allocation-Site</code> 技术，最常见也最常被使用）</li><li>示例：循环创建了 3 个对象，我们用 O2 来抽象表示这 3 个动态对象<img src="image-20220104134002685.png" style="zoom:67%"></li></ul></li></ul><h4 id="上下文敏感-Context-Sensitivity"><a href="#上下文敏感-Context-Sensitivity" class="headerlink" title="上下文敏感 Context Sensitivity"></a>上下文敏感 Context Sensitivity</h4><p>问题：考虑是否区分不同 call-site 对同一方法的调用。</p><ul><li>Context-sensitive：根据某方法调用上下文的不同，对参数不同时的调用做不同的分析，多次分析同一函数。</li><li>Context-insensitive：每个方法只分析一次。</li></ul><img src="image-20220104141618777.png" style="zoom:67%"><h4 id="流敏感-Flow-Sensitivity"><a href="#流敏感-Flow-Sensitivity" class="headerlink" title="流敏感 Flow Sensitivity"></a>流敏感 Flow Sensitivity</h4><p>问题：</p><ul><li>考虑语句顺序（控制流）的影响 vs 把程序当做无序语句的集合</li></ul><p>方法：</p><ul><li>流敏感会在每个程序点都保存一份指针指向关系映射，而流不敏感则对整个程序保存一份指向关系映射<img src="image-20220104141936893.png" style="zoom:67%"></li></ul><p>说明：</p><ul><li>目前流敏感对 Java 提升不大，不过在 C 中很有效，本课程分析的是 Java，所以重点讨论流不敏感技术</li></ul><h4 id="分析范围-Analysis-Scope"><a href="#分析范围-Analysis-Scope" class="headerlink" title="分析范围 Analysis Scope"></a>分析范围 Analysis Scope</h4><p>问题：分析程序的哪一部分？</p><ul><li>Whole-program 全程序：分析全程序的指向关系</li><li>Demand-driven 需求驱动：只分析影响特定域的指针的指向关系</li></ul><h4 id="分析哪些语句"><a href="#分析哪些语句" class="headerlink" title="分析哪些语句"></a>分析哪些语句</h4><p>问题：</p><ul><li>哪些语句会影响指针指向，那就只分析这些语句。</li></ul><p>Java 指针类型：</p><ul><li>Lacal variable: x</li><li>Static field: C.f<br>（有时称为全局变量）——不分析</li><li>Instance field: x.f<br>（对象的field）</li><li>Array element: array[i]<br>不分析，因为静态分析无法确定下标，所以将array中所有成员映射到一个field中，等价于<strong>Instance field</strong>，所以不重复分析<img src="image-20220104142358618.png" style="zoom:67%"></li></ul><p>影响指针指向的语句 pointer affecting statements：</p><ul><li>New: <code>x = new T()</code></li><li>Assign：<code>x = y</code></li><li>Store： <code>x.f = y</code></li><li>Load： <code>y = x.f</code></li><li>Call： <code>r = x.k(a,...)</code><ul><li>Static call： <code>C.foo()</code></li><li>Special call： <code>super.foo()</code> / <code>x.&lt;init&gt;()</code> / <code>this.privateFoo()</code></li><li><strong>Virtual call</strong>：<code>x.foo()</code></li></ul></li></ul><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>复习重点：</p><ul><li>Understand pointer analysis rules</li><li>Understand pointer flow graph</li><li>Understand pointer analysis algorithms</li><li>Understand pointer analysis rule for method call</li><li>Understand inter-procedural pointer analysis algorithm</li><li>Understand on-the-fly call graph construction</li></ul><blockquote><p>先关注前4种语句：New / Assign / Store / Load</p></blockquote><p>Notation：</p><ul><li><code>pt(p)</code> 代表的是指针 p 可能指向的对象<br>可能指向的目标可以记为 $ {o_2,o_4} $（以行号作为 object 的下标）</li></ul><img src="image-20220104143135029.png" style="zoom:67%"><p>规则：采用推导形式，横线上面是条件 premises，横线下面是结论 conclusion</p><ul><li>New：创建对象，将 <code>new T()</code> 对应的对象 oi 加入到 x 的指针集</li><li>Assign：将 y 的指针集加入到 x 对应的指针集</li><li>Store：让 oi 的 field 指向 oj</li><li>Load：Store的反操作</li></ul><img src="image-20220104150123154.png" style="zoom:67%"><h4 id="实现指针分析"><a href="#实现指针分析" class="headerlink" title="实现指针分析"></a>实现指针分析</h4><p>算法要求：</p><ul><li>全程序指针分析，要容易理解和实现。</li></ul><p>本质：</p><ul><li>在指针（变量/域）之间传递指向信息。Andersen-style 分析（很普遍）<br>——很多solving system把指针分析看作是一种包含关系，eg，<code>x = y</code>，x 包含 y。</li></ul><p>问题：</p><ul><li>当一个指针的指向集发生变化，必须更新与它相关的其他指针。<br>如何表示这种传递关系？PFG。</li></ul><p>PFG：用指针流图 PFG 来表示指针之间的关系，PFG 是<strong>有向图</strong>。</p><ul><li>Nodes：<code>Pointer = V U (O x F)</code> 节点n表示一个变量或抽象对象的域。</li><li>Edges：<code>Pointer x Pointer</code> 边x -&gt; y 表示指针x指向的对象may会流入指针y。</li></ul><p>Edges 添加规则：根据程序语句 + 对应的规则。</p><img src="image-20220104150704133.png" style="zoom:67%"><p>示例：</p><img src="image-20220104150823181.png" style="zoom:67%"><h4 id="PTA-算法"><a href="#PTA-算法" class="headerlink" title="PTA 算法"></a>PTA 算法</h4><p>PTA 步骤（下面两步相互依赖，即是 on-the-fly 地进行构造 PFG）：</p><ol><li>构造 PFG（根据以上示例，PFG 也受指向关系影响）</li><li>根据 PFG传播指向信息<img src="image-20220104151234364.png" style="zoom:50%"></li></ol><p>过程内 PTA 算法：</p><img src="image-20220104151634111.png" style="zoom:67%"><ul><li><p><strong>符号</strong>：</p><ul><li>S：程序语句的集合</li><li>WL：Work list，待合并的指针信息，二元组的集合，&lt;指针n，指向的对象集合pts&gt;。pts将被加入到n的指向集pt(n)中</li><li>PFG：指针流图</li></ul></li><li><p>问题：</p><ul><li>为什么要去重？避免冗余，英文叫做Differential propagation差异传播。</li><li>指针集用什么数据结构存储？混合集 Hibra-set，集合元素小于 16 个用 hash set，大于 16 个用 big-vector 位存储</li></ul></li><li><p>示例（需要掌握，看着下面这个程序，画出 PFG）：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">1</span> b = <span class="hljs-keyword">new</span> C(); </span><br><span class="line"><span class="hljs-number">2</span> a = b;</span><br><span class="line"><span class="hljs-number">3</span> c = <span class="hljs-keyword">new</span> C(); </span><br><span class="line"><span class="hljs-number">4</span> c.f = a;</span><br><span class="line"><span class="hljs-number">5</span> d = c;</span><br><span class="line"><span class="hljs-number">6</span> c.f = d; </span><br><span class="line"><span class="hljs-number">7</span> e = d.f;</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>WL</th><th>正处理</th><th>PFG</th><th>指针集</th><th>处理语句</th><th>算法语句</th></tr></thead><tbody><tr><td>1</td><td>[&lt;b, {o1}&gt;, &lt;c, {o3}&gt;]</td><td></td><td></td><td></td><td>1，3</td><td>处理New</td></tr><tr><td>2</td><td>[&lt;b, {o1}&gt;, &lt;c, {o3}&gt;]</td><td></td><td>a&lt;-b；d&lt;-c；</td><td></td><td>2，4</td><td>处理Assign</td></tr><tr><td>3</td><td>[&lt;c, {o3}&gt;]</td><td>&lt;b, {o1}&gt;</td><td>a&lt;-b；d&lt;-c；</td><td>pt(b)={o1}</td><td></td><td>while开头</td></tr><tr><td>4</td><td>[&lt;c, {o3}&gt;], &lt;a, {o1}&gt;]</td><td></td><td>a&lt;-b；d&lt;-c；</td><td></td><td></td><td>Propagate()传递，没有b.f语句</td></tr><tr><td>5</td><td>[&lt;a, {o1}&gt;]</td><td>&lt;c, {o3}&gt;</td><td>a&lt;-b；d&lt;-c；</td><td>pt(c)={o3}</td><td></td><td>while开头</td></tr><tr><td>6</td><td>[&lt;a, {o1}&gt;, &lt;d, {o3}&gt;]</td><td></td><td>a&lt;-b；d&lt;-c；</td><td></td><td></td><td>Propagate()传递，有c.f语句</td></tr><tr><td>7</td><td>[&lt;a, {o1}&gt;, &lt;d, {o3}&gt;]</td><td></td><td>a&lt;-b；d&lt;-c；o3.f&lt;-a；o3.f&lt;-d；<img src="image-20220104152529169.png" style="zoom:67%"></td><td></td><td>4，6</td><td>处理Store/Load，添加边</td></tr><tr><td>8</td><td>[&lt;d, {o3}&gt;]</td><td>&lt;a, {o1}&gt;</td><td></td><td>pt(a)={o1}；</td><td></td><td>while开头</td></tr><tr><td>9</td><td>[&lt;d, {o3}&gt;,&lt;o3.f, {o1}&gt;]</td><td></td><td></td><td></td><td></td><td>Propagate()传递</td></tr><tr><td>10</td><td>[&lt;o3.f, {o1}&gt;]</td><td>&lt;d, {o3}&gt;</td><td></td><td>pt(d)={o3}</td><td></td><td>while开头</td></tr><tr><td>11</td><td>[&lt;o3.f, {o1}&gt;, &lt;o3.f, {o3}&gt;]</td><td></td><td></td><td></td><td></td><td>Propagate()传递，有d.f语句</td></tr><tr><td>12</td><td>[&lt;o3.f, {o1}&gt;, &lt;o3.f, {o3}&gt;]</td><td></td><td>a&lt;-b；d&lt;-c；o3.f&lt;-a；o3.f&lt;-d；e&lt;-o3.f；<img src="image-20220104152630621.png"></td><td></td><td>7</td><td>处理Load，添加边</td></tr><tr><td>13</td><td>[&lt;o3.f, {o3}&gt;]</td><td>&lt;o3.f, {o1}&gt;</td><td></td><td>pt(o3.f)={o1}；</td><td></td><td>while开头</td></tr><tr><td>14</td><td>[&lt;o3.f, {o3}&gt;, &lt;e, {o1}&gt;]</td><td></td><td></td><td></td><td></td><td>Propagate()传递</td></tr><tr><td>15</td><td>[&lt;e, {o1}&gt;]</td><td>&lt;o3.f, {o3}&gt;</td><td></td><td>pt(o3.f)={o1, o3}</td><td></td><td>while开头</td></tr><tr><td>16</td><td>[&lt;e, {o1}&gt;, &lt;e, {o3}&gt;]</td><td></td><td></td><td></td><td></td><td>Propagate()传递</td></tr><tr><td>17</td><td></td><td>&lt;e, {o1}&gt;；&lt;e, {o3}&gt;</td><td><img src="image-20220104152733943.png" style="zoom:80%"></td><td>pt(e)={o1, o3}</td><td></td><td>while开头</td></tr></tbody></table></li></ul><h4 id="处理函数调用"><a href="#处理函数调用" class="headerlink" title="处理函数调用"></a>处理函数调用</h4><p>构造 call gragh 技术对比：</p><ul><li>CHA：基于声明类型，不精确，引入错误的调用边和指针关系。</li><li>指针分析：基于pt(a)，即a指向的类型，更精确，构造更准的CG并对指针分析有正反馈（所以过程间指针分析和CG构造同时进行，很复杂）。</li></ul><p>调用语句规则：</p><ul><li>找目标函数 m：Dispatch(oi, k)<br>——找出 pt(x)，也即 oi 类型对象中的 k 函数。</li><li>receiver object：把 x 指向的对象们即 pt(x) 传到 m 函数的 this 变量，即 $m_{this}$</li><li>传参数：pt(aj), 1&lt;=j&lt;=n 传给 m 函数，即 $p(m_{p_j})$, 1&lt;=j&lt;=n。建立PFG边，$a_1\rightarrow m_{p_1}，\cdots，a_n\rightarrow m_{p_n} $</li><li>传返回值：$pt(m_{ret}) $ 传给 pt(r)。建立 PFG 边，$r \leftarrow m_{ret} $</li></ul><img src="image-20220104155933741.png" style="zoom:80%"><ul><li>问题：一般语言如何处理过程调用。即过程调用时到底发生了什么。<ul><li>保存现场，构造调用栈帧，传递参数，跳转到目标函数开始执行</li><li>目标函数执行完毕跳转回来，后从预定的位置取返回值（若需要），恢复现场，继续往下执行</li></ul></li><li>问题：为什么 PFG 中不添加 $x \rightarrow m_{this} $ 边<ul><li>因为 m_this 只和自己这个对象相关，而 x 可能有 pt(x)={new A, new B, new C}</li><li>加入这条边后，可能有错误的对象 oi 流向 m_this</li><li>对应的 receiver object 应该只流向对应的 target method 的 m_this<img src="image-20220104160549785.png" style="zoom:40%"></li></ul></li></ul><h4 id="过程间-PTA-算法"><a href="#过程间-PTA-算法" class="headerlink" title="过程间 PTA 算法"></a>过程间 PTA 算法</h4><p><strong>问题</strong>：</p><ul><li>由于指针分析和CG构造互相影响，所以每次迭代只分析可达的函数和语句。然后不断发现和分析新的可达函数<img src="image-20220104161007273.png" style="zoom:67%"></li></ul><p>算法（黄色背景的代码是和过程内分析不同的地方）：<br><img src="image-20220104161104996.png" style="zoom:80%"></p><ul><li><strong>问题</strong>：为什么ProcessCall(x, oi)中，要判断<code>L-&gt;m</code>这条边是否已经加入到CG？<ul><li>因为x可能指向多个对象，就会多次处理L这个调用指令，可能x中别的对象oj早就已经将这条边加入进去了。</li></ul></li></ul><p>示例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-number">1</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;</span><br><span class="line"><span class="hljs-number">2</span>   <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="line"><span class="hljs-number">3</span>       A a = <span class="hljs-keyword">new</span> A();</span><br><span class="line"><span class="hljs-number">4</span>       A b = <span class="hljs-keyword">new</span> B();</span><br><span class="line"><span class="hljs-number">5</span>       A c = b.foo(a);</span><br><span class="line"><span class="hljs-number">6</span>   &#125;</span><br><span class="line"><span class="hljs-number">7</span>   <span class="hljs-function">A <span class="hljs-title">foo</span><span class="hljs-params">(A x)</span></span>&#123;...&#125;</span><br><span class="line"><span class="hljs-number">8</span> &#125;</span><br><span class="line"><span class="hljs-number">9</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;  </span><br><span class="line"><span class="hljs-number">10</span>    <span class="hljs-function">A <span class="hljs-title">foo</span><span class="hljs-params">(A y)</span> </span>&#123;</span><br><span class="line"><span class="hljs-number">11</span>      A r=newA();</span><br><span class="line"><span class="hljs-number">12</span>      <span class="hljs-keyword">return</span> r;</span><br><span class="line"><span class="hljs-number">13</span>    &#125;</span><br><span class="line"><span class="hljs-number">14</span>  &#125;</span><br></pre></td></tr></table></figure><img src="image-20220104161818080.png" style="zoom:80%"><h3 id="★★-上下文敏感"><a href="#★★-上下文敏感" class="headerlink" title="★★ 上下文敏感"></a>★★ 上下文敏感</h3><p>复习重点：</p><ul><li>Algorithm for context-sensitive pointer analysis</li><li>Common context sensitivity variants</li><li>Differences and relationship among common context sensitivity variants</li></ul><p>概念：</p><ul><li>call-site sensitivity (call-string)：根据调用点位置的不同来区分上下文</li><li>Cloning-Based Context Sensitivity：每种上下文对应一个节点，标记调用者行数。克隆多少数据，后面会讨论</li><li>Context-Sensitive Heap：面向对象程序（如 Java）会频繁修改堆对象，称为 heap-insensitive。所以不仅要给变量加上下文，也要给堆抽象加上下文，称为 heap context（本课程是基于allocate-site来进行堆抽象的）<img src="image-20220104164410956.png" style="zoom:70%"></li></ul><p>Notation：</p><img src="image-20220104164836060.png" style="zoom:67%"><p>Rules：</p><img src="image-20220104165033135.png" style="zoom:87%"> <img src="image-20220104165154281.png" style="zoom:80%"><p>算法：<br><img src="image-20220104170306605.png" style="zoom:80%"></p><h4 id="上下文选取"><a href="#上下文选取" class="headerlink" title="上下文选取"></a>上下文选取</h4><blockquote><p>在上文算法中有一句 $c^t = Select(c, l, c’:o_i) $ 其中 c 是 caller context, l 是 call site, c’ 是 receiver object 的 heap context，下面就涉及 Select 的选择方法</p></blockquote><p>上下文的选取主要采用3类：</p><ul><li>Call-Site Sensitivity</li><li>Object Sensitivity</li><li>Type Sensitivity</li><li>…</li></ul><p>Call-Site Sensitivity：</p><ul><li><p>原理：又称为 k-call-site sensitivity / k-CFA，不断添加调用行号。1991年<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.ccs.neu.edu%2Fhome%2Fshivers%2Fpapers%2Fdiss.pdf" target="_blank" rel="noopener">Olin Shivers</a>提出。</p></li><li><p>$Select(c,l,_) =[l’,\cdots,l’’, l] $ 其中 $c=[l’, \cdots, l’’] $</p><img src="image-20220104193147986.png" style="zoom:67%"></li><li><p><em>k</em>-Limiting Context Abstraction</p><ul><li><p>上图中函数调用自身，无限递归，故需要限制上下文长度呀</p></li><li><p>方法：只取最后 k 个上下文，通常取 k&lt;=3。</p><p>Method contexts 和 Heap contexts 一般用不同的 k 值（比如，Method contexts 取 2，Heap contexts 取 1）</p></li><li><p>1-call-site: $Select(_,l,_) = [l] $</p></li><li><p>2-call-site: $Select(c,l,_) = [l’’,l] $，其中 $c = [l’,l’’] $</p></li></ul></li></ul><p>Object Sensitivity:</p><ul><li><strong>原理</strong>：针对面向对象语言，用 <code>receiver object</code> 来表示上下文。<br>对比 k=1 层的 call-site sensitivity 和 object sensitivity，时间和准确性上对象敏感显然更优，这是由面向对象语言的特点所确定的。</li><li>$ Select(_,_,c’:o_i) = [ o_j, \cdots, o_k, o_i] $ 其中 $ c’=[o_j,\cdots,o_k] $</li><li>k-limiting 和 call-site sensitivity 是一样道理哦</li><li>示例 1：<img src="image-20220104194844470.png" style="zoom:67%"></li><li>示例 2：<img src="image-20220104194924604.png" style="zoom:67%"></li><li>对比：对比<code>1-Call-Site</code>和<code>1-object</code>上下文<ul><li>在示例 1 中<code>1-object</code>明显更准确。<br>原因是面向对象语言的特性，多态性产生很多继承链，一层一层调用子对象，其中最关键的是<code>receiver object</code>，<code>receiver object</code>决定了调用者的根源。本例有多层调用，若采用 2-Call-Site就不会出错。</li><li>在示例 2 中 <code>1-Call-Site</code> 更准确。<br>因为同一个<code>receiver object</code>用不同参数多次调用了子函数，导致局部变量无法区分。</li></ul></li><li>结论：所以理论上，object 敏感与 callsite 敏感的准确度无法比较。<br>但是对于面向对象语言，对象敏感的准确度要优于 callsite 敏感。</li></ul><p>Type Sensitivity：</p><ul><li><p>原理：牺牲精度，提高速度。</p></li><li><p>A coarser abstraction over object sensitivity 相较于 object sensitivity 是一种粗粒度的抽象</p></li><li><p>$Select(_,_,c’:o_i) =[t_j,\cdots,t_k, \text{InType}(o_i)] $ 其中 $c’=[t_j,\cdots,t_k] $</p></li><li><p>==<font color="red">注意上式中的 InType 是 Container 的 Type</font>==，而不是 $o_i $ 的类型</p><img src="image-20220104194545970.png" style="zoom:67%"></li></ul><p>总体对比：</p><ul><li>精度：object &gt; type &gt; call-site</li><li>效率：type &gt; object &gt; call-site</li></ul><p>问题1：流敏感和上下文敏感对变量/堆抽象的表示有什么区别？</p><ul><li>上下文敏感：某个变量在不同上下文的指向，以调用点位置作为区分度。</li><li>流敏感：比如说程序运行到第4行，在这个位置变量的指向是什么，第20行又指向哪些，以控制流的位置来作为区分度。</li></ul><p>对于面向对象语言，Steensgaard算法不实用。</p><p>问题2：如果循环中同一行多次调用同一函数，会区分每次调用吗？循环展开还是不展开？</p><ul><li>本课程分析的是流不敏感，所以不会展开循环。Java 分析不需要流敏感，开销太大了，效果不明显。</li></ul><h2 id="Static-Analysis-for-Security"><a href="#Static-Analysis-for-Security" class="headerlink" title="Static Analysis for Security"></a>Static Analysis for Security</h2><p>复习重点：</p><ul><li>Concept of information flow security</li><li>Confidentiality and Integrity<ul><li>Confidentiality 保护信息不泄露</li><li>Integrity 防止不可信息损坏关键信息</li></ul></li><li>Explicit flows and covert channels</li><li>Use taint analysis to detect unwanted information flow</li></ul><p><a href="https://www.jianshu.com/p/f43218636968" target="_blank" rel="noopener">https://www.jianshu.com/p/f43218636968</a> 好详细了</p><h2 id="Datalog-Based-Analysis"><a href="#Datalog-Based-Analysis" class="headerlink" title="Datalog-Based Analysis"></a>Datalog-Based Analysis</h2><p>复习重点：</p><ul><li>Datalog language</li><li>How to implement pointer analysis via Datalog</li><li>How to implement taint analysis via Datalog</li></ul><p><a href="https://www.jianshu.com/p/a8930401dee9" target="_blank" rel="noopener">https://www.jianshu.com/p/a8930401dee9</a></p><h2 id="CFL-Reachability-amp-IFDS"><a href="#CFL-Reachability-amp-IFDS" class="headerlink" title="CFL-Reachability &amp; IFDS"></a>CFL-Reachability &amp; IFDS</h2><p>复习重点：</p><ul><li>Understand CFL-Reachability</li><li>Understand the basic idea of IFDS</li><li>Understand what problems can be solved by IFDS</li></ul><p><a href="https://www.jianshu.com/p/2bd21a34eb8b" target="_blank" rel="noopener">https://www.jianshu.com/p/2bd21a34eb8b</a></p><h2 id="Soundness-amp-Soundiness"><a href="#Soundness-amp-Soundiness" class="headerlink" title="Soundness &amp; Soundiness"></a>Soundness &amp; Soundiness</h2><p>复习重点：</p><ul><li>Understand soundiness: its motivation and concept</li><li>Understand why Java reflection and native code are hard to analyze</li></ul><p><a href="https://www.jianshu.com/p/1ca6e11b1e72" target="_blank" rel="noopener">https://www.jianshu.com/p/1ca6e11b1e72</a></p></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://zhangt.top/CS/Static-Analysis-Study-Notes/">静态分析-学习笔记</a></li><li><strong>本文作者：</strong><a href="https://zhangt.top">ZhangT</a></li><li><strong>本文链接：</strong><a href="https://zhangt.top/CS/Static-Analysis-Study-Notes/">https://zhangt.top/CS/Static-Analysis-Study-Notes/</a></li><li><strong>发布时间：</strong>2021-10-01</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><hr style="height:1px;margin:1rem 0"><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><i class="fas fa-tags has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/tags/PL/">PL</a>,&nbsp;<a class="has-link-grey -link" href="/tags/Static-Analysis/">Static-Analysis</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？投喂一下吧！ヾ(●´∀｀●)</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i> </span><span>支付宝</span><div class="qrcode"><img src="/images/alipay.jpg" alt="支付宝"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/MUSIC/Music-Theory/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">乐理/吉他-学习笔记</span></a></div><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/CS/FSPL-Study-Notes/"><span class="level-item">程序设计语言的形式语义-学习笔记</span> <i class="level-item fas fa-chevron-right"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"91f36240e98756fc091e",clientSecret:"20de2f4dadd54bc04ad8db6c1090fb00a9477ac4",id:"d128f6c5224f7d3a2f6b94657d0c2421",repo:"zhangt2333.github.io",owner:"zhangt2333",admin:"zhangt2333",createIssueManually:!1,distractionFreeMode:!1});gitalk.render("comment-container")</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered"><div><img class="image is-96x96 has-mb-6" src="/images/avatar.png" alt="Zhang T"><p class="is-size-4 is-block">Zhang T</p><p class="is-size-6 is-block">感受我的感受</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Nanjing &lt;- Qingdao, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><div class="level-item has-text-centered is-marginless"><a href="/archives/"><p class="heading">文章</p><p class="title has-text-weight-normal">24</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/categories/"><p class="heading">分类</p><p class="title has-text-weight-normal">5</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/tags/"><p class="heading">标签</p><p class="title has-text-weight-normal">24</p></a></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/zhangt2333" target="_blank"><i class="fab fa-github"></i>&nbsp;&nbsp;关注我</a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu" style="max-height:750px;overflow:auto"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#Introduction"><span class="has-mr-6">1</span> <span>Introduction</span></a></li><li><a class="is-flex" href="#Intermediate-Representation"><span class="has-mr-6">2</span> <span>Intermediate Representation</span></a><ul class="menu-list"><li><a class="is-flex" href="#Three-Address-Code-3AC"><span class="has-mr-6">2.1</span> <span>Three-Address Code (3AC)</span></a></li><li><a class="is-flex" href="#Static-Single-Assignment-SSA"><span class="has-mr-6">2.2</span> <span>Static Single Assignment (SSA)</span></a></li><li><a class="is-flex" href="#★Basic-Blocks-BB"><span class="has-mr-6">2.3</span> <span>★Basic Blocks (BB)</span></a></li></ul></li><li><a class="is-flex" href="#Data-Flow-Analysis"><span class="has-mr-6">3</span> <span>Data Flow Analysis</span></a><ul class="menu-list"><li><a class="is-flex" href="#D-F-A-应用"><span class="has-mr-6">3.1</span> <span>D.F.A. 应用</span></a><ul class="menu-list"><li><a class="is-flex" href="#Preliminaries-序言"><span class="has-mr-6">3.1.1</span> <span>Preliminaries 序言</span></a></li><li><a class="is-flex" href="#Reaching-Definitions-Analysis"><span class="has-mr-6">3.1.2</span> <span>Reaching Definitions Analysis</span></a></li><li><a class="is-flex" href="#Live-Variables-Analysis"><span class="has-mr-6">3.1.3</span> <span>Live Variables Analysis</span></a></li><li><a class="is-flex" href="#Available-Expressions-Analysis"><span class="has-mr-6">3.1.4</span> <span>Available Expressions Analysis</span></a></li><li><a class="is-flex" href="#总结"><span class="has-mr-6">3.1.5</span> <span>总结</span></a></li></ul></li><li><a class="is-flex" href="#D-F-A-基础"><span class="has-mr-6">3.2</span> <span>D.F.A. 基础</span></a><ul class="menu-list"><li><a class="is-flex" href="#迭代算法——另一个角度"><span class="has-mr-6">3.2.1</span> <span>迭代算法——另一个角度</span></a></li><li><a class="is-flex" href="#Partial-Order"><span class="has-mr-6">3.2.2</span> <span>Partial Order</span></a></li><li><a class="is-flex" href="#Upper-and-Lower-Bounds"><span class="has-mr-6">3.2.3</span> <span>Upper and Lower Bounds</span></a></li><li><a class="is-flex" href="#Lattice格、Semilattice半格、全格和格点积（Complete-and-Product-Lattice）"><span class="has-mr-6">3.2.4</span> <span>Lattice格、Semilattice半格、全格和格点积（Complete and Product Lattice）</span></a></li><li><a class="is-flex" href="#D-F-A-Framework-via-Lattice"><span class="has-mr-6">3.2.5</span> <span>D.F.A. Framework via Lattice</span></a></li><li><a class="is-flex" href="#Monotonicity-单调性-and-Fixed-Point-Theorem"><span class="has-mr-6">3.2.6</span> <span>Monotonicity 单调性 and Fixed Point Theorem</span></a></li><li><a class="is-flex" href="#Relate-Iterative-Algorithm-to-Fixed-Point-Theorem"><span class="has-mr-6">3.2.7</span> <span>Relate Iterative Algorithm to Fixed Point Theorem</span></a></li><li><a class="is-flex" href="#May-Must-Analysis-A-Lattice-View"><span class="has-mr-6">3.2.8</span> <span>May/Must Analysis, A Lattice View</span></a></li><li><a class="is-flex" href="#Distributivity-and-MOP"><span class="has-mr-6">3.2.9</span> <span>Distributivity and MOP</span></a></li><li><a class="is-flex" href="#Constant-Propagation"><span class="has-mr-6">3.2.10</span> <span>Constant Propagation</span></a></li><li><a class="is-flex" href="#Worklist-Algorithm"><span class="has-mr-6">3.2.11</span> <span>Worklist Algorithm</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#Interprocedural-Analysis"><span class="has-mr-6">4</span> <span>Interprocedural Analysis</span></a><ul class="menu-list"><li><a class="is-flex" href="#过程间分析简介"><span class="has-mr-6">4.1</span> <span>过程间分析简介</span></a></li><li><a class="is-flex" href="#Motivation"><span class="has-mr-6">4.2</span> <span>Motivation</span></a></li><li><a class="is-flex" href="#Call-Graph-Construction"><span class="has-mr-6">4.3</span> <span>Call Graph Construction</span></a><ul class="menu-list"><li><a class="is-flex" href="#面向对象语言的调用图构造（Java）"><span class="has-mr-6">4.3.1</span> <span>面向对象语言的调用图构造（Java）</span></a></li><li><a class="is-flex" href="#★-Class-Hierarchy-Analysis-CHA-类层级分析"><span class="has-mr-6">4.3.2</span> <span>★ Class Hierarchy Analysis (CHA) 类层级分析</span></a></li><li><a class="is-flex" href="#调用图构造"><span class="has-mr-6">4.3.3</span> <span>调用图构造</span></a></li></ul></li><li><a class="is-flex" href="#Interprocedural-Control-Flow-Graph"><span class="has-mr-6">4.4</span> <span>Interprocedural Control-Flow Graph</span></a></li><li><a class="is-flex" href="#Interprocedural-Data-Flow-Analysis"><span class="has-mr-6">4.5</span> <span>Interprocedural Data-Flow Analysis</span></a></li></ul></li><li><a class="is-flex" href="#Pointer-Analysis"><span class="has-mr-6">5</span> <span>Pointer Analysis</span></a><ul class="menu-list"><li><a class="is-flex" href="#简介"><span class="has-mr-6">5.1</span> <span>简介</span></a><ul class="menu-list"><li><a class="is-flex" href="#堆抽象（内存建模）"><span class="has-mr-6">5.1.1</span> <span>堆抽象（内存建模）</span></a></li><li><a class="is-flex" href="#上下文敏感-Context-Sensitivity"><span class="has-mr-6">5.1.2</span> <span>上下文敏感 Context Sensitivity</span></a></li><li><a class="is-flex" href="#流敏感-Flow-Sensitivity"><span class="has-mr-6">5.1.3</span> <span>流敏感 Flow Sensitivity</span></a></li><li><a class="is-flex" href="#分析范围-Analysis-Scope"><span class="has-mr-6">5.1.4</span> <span>分析范围 Analysis Scope</span></a></li><li><a class="is-flex" href="#分析哪些语句"><span class="has-mr-6">5.1.5</span> <span>分析哪些语句</span></a></li></ul></li><li><a class="is-flex" href="#基础"><span class="has-mr-6">5.2</span> <span>基础</span></a><ul class="menu-list"><li><a class="is-flex" href="#实现指针分析"><span class="has-mr-6">5.2.1</span> <span>实现指针分析</span></a></li><li><a class="is-flex" href="#PTA-算法"><span class="has-mr-6">5.2.2</span> <span>PTA 算法</span></a></li><li><a class="is-flex" href="#处理函数调用"><span class="has-mr-6">5.2.3</span> <span>处理函数调用</span></a></li><li><a class="is-flex" href="#过程间-PTA-算法"><span class="has-mr-6">5.2.4</span> <span>过程间 PTA 算法</span></a></li></ul></li><li><a class="is-flex" href="#★★-上下文敏感"><span class="has-mr-6">5.3</span> <span>★★ 上下文敏感</span></a><ul class="menu-list"><li><a class="is-flex" href="#上下文选取"><span class="has-mr-6">5.3.1</span> <span>上下文选取</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#Static-Analysis-for-Security"><span class="has-mr-6">6</span> <span>Static Analysis for Security</span></a></li><li><a class="is-flex" href="#Datalog-Based-Analysis"><span class="has-mr-6">7</span> <span>Datalog-Based Analysis</span></a></li><li><a class="is-flex" href="#CFL-Reachability-amp-IFDS"><span class="has-mr-6">8</span> <span>CFL-Reachability &amp; IFDS</span></a></li><li><a class="is-flex" href="#Soundness-amp-Soundiness"><span class="has-mr-6">9</span> <span>Soundness &amp; Soundiness</span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/">TTTT&#39;s Blog</a><p class="is-size-7">&copy; 2022 ZhangT&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},skipTags:["script","noscript","style","textarea","pre","code"],processEscapes:!0,tex2jax:{inlineMath:[["$","$"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>