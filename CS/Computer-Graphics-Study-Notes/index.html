<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>计算机图形学-学习笔记 - Zhang T&#39;s Blog</title><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-212316117-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-212316117-1")</script><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/">TTTT&#39;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i> </a><a class="navbar-item" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-image"><span class="image is-7by1"><img class="thumbnail" src="/thumbnails/Computer-Graphics-Study-Notes.png" alt="计算机图形学-学习笔记"></span></div><div class="card-content article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>计算机图形学-学习笔记</h1><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2019-05-02T13:08:01.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-05-02</time> <time class="level-item has-text-grey is-hidden-mobile" datetime="2022-01-05T11:27:18.949Z"><i class="far fa-calendar-check">&nbsp;</i>2022-01-05</time><div class="level-item"><i class="far fa-folder-open has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/categories/CS/">CS</a></div><span class="level-item has-text-grey"><i class="far fa-clock"></i>&nbsp; 3 小时 读完 (大约 29509 个字) </span><span class="level-item has-text-grey" id="busuanzi_container_page_pv"><i class="far fa-eye"></i> <span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><h2 id="第1章-绪论"><a href="#第1章-绪论" class="headerlink" title="第1章 绪论"></a>第1章 绪论</h2><h3 id="全书概述"><a href="#全书概述" class="headerlink" title="全书概述"></a>全书概述</h3><a id="more"></a><ul><li>图形学基本知识<ul><li>光栅图形学<ul><li>扫描转换、区域填充、裁减、反走样、消隐</li></ul></li><li>二维、三维图形变换及观察准均匀 B 样条曲线</li></ul></li><li>几何造型<ul><li>参数曲线曲面基本概念、Bezier曲线曲面、B样条曲线等</li></ul></li><li>真实感图形学<ul><li>颜色模型、简单光照模型、纹理映射、光线跟踪</li></ul></li></ul><h3 id="计算机图形学定义"><a href="#计算机图形学定义" class="headerlink" title="计算机图形学定义"></a>计算机图形学定义</h3><ul><li>计算机图形学<ul><li>计算机图形是计算机产生的图像。</li><li>计算机图形学就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理和算法。</li><li>IEEE定义：<font face="STCAIYUN" color="brown">Comput graphics</font> is the art or science of producing graphical images with the aid of computer.</li></ul></li><li>计算机图形学的发展和应用在某种意义上已成为计算机软、硬件发展水平的标志。</li></ul><h3 id="计算机图形学研究内容"><a href="#计算机图形学研究内容" class="headerlink" title="计算机图形学研究内容"></a>计算机图形学研究内容</h3><ul><li>主要研究内容<ul><li>如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法，构成了计算机图形学的主要研究内容。</li></ul></li><li>计算机生成一副表示物体的图形的三个步骤<ul><li><font face="STCAIYUN" color="brown">造型技术</font><ul><li>在计算机中建立所要生成图像的物体的模型，即给出表示该物体的几何数据和拓扑关系</li><li>比如教室里的桌子、椅子、墙，用圆柱、平面等表示出来。</li></ul></li><li><font face="STCAIYUN" color="brown">光照模型</font><ul><li>希望用一些简单的数学模型来近似、代替那些物理学的模型，为模拟物体表面的光照物理现象的数学模型叫光照模型。</li></ul></li><li><font face="STCAIYUN" color="brown">绘制（渲染）技术</font><ul><li>选择适当的绘制算法来把这个场景画 (渲染) 出来。</li><li>绘制一幅三维物体图像所涉及的知识，实际上就是计算机图形中每个像素看上去应该是什么颜色的问题。</li></ul></li></ul></li><li>计算机图形的发展方向<ul><li>准确性 -&gt; 真实性 -&gt; 实时性</li></ul></li></ul><h3 id="计算机图形学的发展历史"><a href="#计算机图形学的发展历史" class="headerlink" title="计算机图形学的发展历史"></a>计算机图形学的发展历史</h3><ul><li><p>1950年，第一台图形显示器作为美国麻省理工学院 (MIT) 旋风 I 号计算机的附件诞生。</p></li><li><p>1963年，Suther land 发表博士论文。其中第一次提出了 graphics 这个词。</p><ul><li><strong>Suther land 被公认为开创交互式图形技术的奠基人，被称为 “计算机图形学之父”，并于 1988 年获 “图灵奖”。</strong></li></ul></li><li><p>1962年，雷诺汽车公司的工程师 Bezier 提出 Bezier 曲线、曲面的理论，成为 CAGD (计算机辅助几何设计) 的先驱。</p></li><li><p>1964年，MIT教授 Steven A. Coons 提出了超限插值的新思想，通过插值四条任意的边界曲线来构造曲面。</p></li><li><p>70年代，光栅显示器出现了。光栅显示器屏幕是由像素组成的，由此诞生了大量算法，如区域填充、裁剪、消隐等基本图形概念、及其相应算法。</p></li><li><p>真实感图形和几何造型技术这个时候也开始出现了。</p></li><li><p>1975年，Phong 提出了著名的简单光照模型 - Phong模型 (标志着真实感图形的出现和实用化，直到现在 Phong 模型还被大量的采用)</p></li><li><p>1980年，Whitted 提出了光透视模型 - Whitted 模型，成为第一次提出光线跟踪算法的范例。</p></li><li><p>几何造型技术：通俗地讲，该技术就像小孩搭积木，用简单的一些体素来构建复杂的模型。</p><p><img src="1560589193983.png" alt="1560589193983"></p></li></ul><h3 id="计算机图形学的应用领域"><a href="#计算机图形学的应用领域" class="headerlink" title="计算机图形学的应用领域"></a>计算机图形学的应用领域</h3><ul><li>人机交互和图形用户界面<ul><li>最理想的是开发 “能听、能说、能理解人类语言” 的计算机，人们可以和计算机交谈，而不像现在这样仅限于窗口、图标、鼠标、指针 (WIMP) 界面。</li></ul></li><li>计算机辅助设计与制造 (CAD/CAM)<ul><li>CAD/CAM 是计算机图形学在工业界最广泛、最活跃的应用领域。<ul><li>飞机、汽车、船舶、宇宙飞船的外形设计</li><li>发电厂、化工厂等的布局</li></ul></li></ul></li><li>真实感图形实时绘制与自然景物仿真<ul><li>计算机中重现真实世界的场景叫做真实感绘制。</li></ul></li><li>计算机动画、游戏、电影</li><li>计算机艺术<ul><li>计算机艺术是科学与技术相结合的一门新兴的交叉学科，是计算机应用的一个崭新、富有时代气息的领域。</li></ul></li><li>计算机仿真<ul><li>计算机仿真是计算机技术建立被仿真系统的模型，并在某些实验条件下对模型进行动态实验的一门综合性技术。</li></ul></li><li>科学计算可视化</li><li>虚拟现实<ul><li>虚拟现实是利用计算机模拟现实的场景，使参与者获得与现实一样的感觉。</li><li>准确地说，是利用电脑模拟产生一个三维空间的虚拟世界，提供使用者关于视觉、听觉、触觉等感官的模拟，让使用者如同身历其境一般，可以及时、没有限制地观察三度空间内的事物。</li></ul></li><li>地理信息系统<ul><li>地理信息系统是建立在地理图形之上的关于各种资源的综合信息管理系统，是计算机图形学的一个重要应用领域。</li></ul></li><li>农业上的应用<ul><li>借助计算机图形生成技术来保存和再现不同作物种类和不同生长时期的植物形态，模拟植物的生长过程，从而合理地进行选种、播种、田间管理以及收获等。</li></ul></li></ul><p>计算机图形系统组成</p><ul><li><p>五大功能</p><ul><li><p>一个交互式计算机图形系统应具有计算、存储、对话、输入和输出等 5 个方面的功能。</p><p><img src="1560589234970.png" alt="1560589234970"></p></li></ul></li><li><p>图形系统</p><ul><li>图形软件<ul><li>图形应用数据结构：对应一组图形数据文件，其中存放着欲生成的图形对象的全部描述信息。</li><li>图形应用软件<ul><li>解决某种应用问题的图形软件，是图形系统中的核心部分，包括了各种图形生成和处理技术。如：photoshop、3Dmax等。</li><li>图形支撑软件：大多数图形应用程序是建立在一定的图形支撑软件上。图形支撑软件需具有规范接口。</li></ul></li></ul></li><li>图形硬件</li></ul></li></ul><h3 id="图形显示设备"><a href="#图形显示设备" class="headerlink" title="图形显示设备"></a>图形显示设备</h3><ul><li>阴级射线管<ul><li>使用广泛：现在的图形显示设备绝大多数是基于阴极射线管 (CRT) 的显示器。</li><li>阴极射线管的技术指标<ul><li><strong>分辨率：一个阴极射线管在水平和垂直方向单位长度上能识别出的最大光点数称之为分辨率。光点亦称之为像素 (pixel)。</strong></li><li>显示速度</li></ul></li><li>要保持荧光屏上有稳定的图像就必须不断地发射电子束。只有刷新频率高到一定值后，图像才能稳定显示。大约达到每秒 60 帧即 60Hz 时，人眼才能感觉到屏幕不闪烁，要人眼觉得舒服，一般必须有 85Hz 以上的刷新频率。</li></ul></li><li>彩色阴极射线管<ul><li>三只电子枪，分别涂有红、绿、蓝三种颜色的光。</li></ul></li><li>CRT图形显示器<ul><li>随机扫描的图形显示器 (画线设备)<ul><li>电子束的扫描轨迹随显示内容而变化，只在需要的地方扫描，而不必全屏扫描，因此速度快，图像清晰。</li><li>一条线一条线地画图，因此也称为向量显示器。</li><li>随机扫描系统是为画线应用设计的，因此不能显示逼真的有阴影场景。</li></ul></li><li>光栅扫描显示器 (画点设备)<ul><li>不能直接从一个可编地址的像素画一条直线到另一个可编地址的像素，只可能用尽可能靠近这条直线路径的像素点来近似地表示这条直线。</li><li>在光栅扫描系统中，电子束横向扫描屏幕，一次一行，从上到底顺次进行。当电子束横向沿每一行移动时，电子束的强度不断变化来建立亮点的图案。</li><li>由于光栅扫描系统具有存储每一个屏幕点亮度信息的能力，所以，最适合显示浓淡和色彩图形。</li></ul></li></ul></li><li>例题：显卡有 2MB 显存，当分辨率为 1024×768 时，可支持的色彩数是多少？<br>$2MB = 2\times 1024 \times 1024 =2097152 (字节)$<br>$1024\times 768 = 786432 (个像素) $<br>每个像素如果需要 3 个字节表示，将超过 2MB 显存，最多只需要 2 个字节表示，故只能支持 64K 色彩数</li></ul><h3 id="图形学相关概念"><a href="#图形学相关概念" class="headerlink" title="图形学相关概念"></a>图形学相关概念</h3><ul><li>分辨率<ul><li>光点<ul><li>光点指电子束打在显示器荧光屏上，显示器能够显示的最小的发光点，一般用其直径来表明光点的大小。</li></ul></li><li>像素点<ul><li>像素点是指图形显示在屏幕上时候，按当前的图形显示分辨率所能提供的最小元素点。</li></ul></li><li>屏幕分辨率<ul><li>屏幕上显示的像素个数，以 (水平像素数 * 垂直像素数) 表示。</li></ul></li><li>显示分辨率<ul><li>是计算机显示控制器所能够控制的显示模式分辨率，简称显示模式。</li><li>对于文本显示方式，显示分辨率用水平和垂直方向上所能显示的字符总数的乘积来表示。</li><li>对于图形显示方式，则用水平和垂直方向上所能显示的像素点总数的乘积来表示。</li></ul></li><li>显卡分辨率<ul><li>显卡分辨率就是表示显卡输出给显示器，并能在显示器上描绘像素点的数量。</li><li>一台电脑的最高分辨率是由显卡和显示器共同决定的。显示器最高分辨率是可以显示出来的最大分辨率。显卡的最大分辨率是最大能支持多少分辨率。</li><li>电脑的最高分辨率取决于显卡和显示器最低的一个。</li></ul></li></ul></li><li>显示器的点距<ul><li>指相邻像素点之间的距离。两点之间的距离越小越好。</li><li>15寸显示器，点距达到0.28mm就足够。17寸显示器，需要0.27mm、0.25mm等。</li></ul></li><li>显示卡的作用与性能指标<ul><li>显示卡的基本作用就是显示图文，显示卡和显示器构成了计算机的显示系统。</li><li>除了CPU和内存外，显卡对计算机的显示性能起着决定性的作用。</li></ul></li></ul><h3 id="图形图像的区别及存储格式"><a href="#图形图像的区别及存储格式" class="headerlink" title="图形图像的区别及存储格式"></a>图形图像的区别及存储格式</h3><ul><li><p>图形图像的区别</p><ul><li>说法一<ul><li>图形是由计算机绘制而成的，而图像则是人为的用外部设备所捕捉到的外部的景象。</li></ul></li><li>说法二<ul><li>图形是矢量图，而图像是位图 (点阵图)</li></ul></li></ul></li><li><p>图形 (像) 的构成属性</p><ul><li>几何属性<ul><li>刻画对象的轮廓、形状。包括点、线、面、体等。</li></ul></li><li>非几何属性<ul><li>视觉属性，刻画对象的颜色、材质等。包括明暗、色彩、纹理、透明性、线型、线宽。</li></ul></li><li>从构图要素上看，将图形分为两类<ul><li>几何属性有突出作用：工程图、等高线地图、曲面的线框图</li><li>非几何属性有突出作用 (明暗图)：真实感图形</li></ul></li></ul></li><li><p>位图和矢量图定义</p><ul><li>位图 (点阵图)<ul><li>点阵图或像素图，计算机屏幕上的图是由屏幕上的像素构成的，每个点用二进制数据来描述其颜色与亮度等信息。</li></ul></li><li>矢量图<ul><li>面向对象的图形或绘图图形，是用数学方式描述的曲线及曲线围成的色块制作的图形。</li><li>矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</li></ul></li></ul></li><li><p>位图和矢量图区别</p><ul><li><p>存储方式的区别</p><ul><li>点阵文件存储图的各个像素点的位置信息、颜色信息以及灰度信息。</li><li>矢量文件是用数学方程、数学形式对图形进行描述，通常使用图形的形状参数和属性参数来表示图形。</li><li>因此，点阵文件存储空间比矢量文件大。</li></ul></li><li><p>缩放的区别</p><ul><li>点阵文件与分辨率有关，即在一定面积的图像上包含有固定数量的像素。</li><li>矢量图形与分辨率无关，可以将它缩放到任意大小和以任意分辨率在输出设备上打印出来，不会影响清晰度。</li></ul></li><li><p>存储格式的区别</p><ul><li>位图存储格式：BMP、TIFF、GIF、JPEG、PNG</li><li>矢量图存储格式：DXF、SVG、EPS、WMF、EMF</li></ul></li><li><p>总结</p><table><thead><tr><th align="center"></th><th align="center">位图</th><th align="center">矢量图</th></tr></thead><tbody><tr><td align="center">存储内容</td><td align="center">各像素点位置信息、颜色信息以及灰度信息</td><td align="center">数学方程</td></tr><tr><td align="center">存储空间</td><td align="center">大</td><td align="center">小</td></tr><tr><td align="center">常见存储格式</td><td align="center">BMP、TIFF、GIF、JPEG、PNG</td><td align="center">DXF、SVG、EPS、WMF、EMF</td></tr><tr><td align="center">图形缩放</td><td align="center">失真</td><td align="center">不失真</td></tr><tr><td align="center">真实感图形效果</td><td align="center">容易实现</td><td align="center">不容易实现</td></tr></tbody></table></li></ul></li></ul><h2 id="第2章-光栅图形学"><a href="#第2章-光栅图形学" class="headerlink" title="第2章 光栅图形学"></a>第2章 光栅图形学</h2><h3 id="直线段的扫描转换"><a href="#直线段的扫描转换" class="headerlink" title="直线段的扫描转换"></a>直线段的扫描转换</h3><h4 id="数值微分法（DDA）"><a href="#数值微分法（DDA）" class="headerlink" title="数值微分法（DDA）"></a>数值微分法（DDA）</h4><p>对于线段 $ (x_0, y_0) \rightarrow (x_1, y_1)$，其斜率为 $k = \frac{y_1-y_0}{x_1-x_0}$ 。</p><p>从点 $(x_0, y_0) \rightarrow (x_0+\Delta x, y_0+k \Delta x) \rightarrow (x_0+2\Delta x, y_0+2k \Delta x) \rightarrow \cdots \rightarrow (x_i,y_i) \rightarrow \cdots \rightarrow (x_1, y_1)$ 逐步绘点</p><p><img src="1556937014719.png" alt="1556937014719"></p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DDALine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color PIXEL_COLOR)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> x;</span><br><span class="line">    <span class="hljs-keyword">float</span> dx = x1-x0, dy = y1-y0;</span><br><span class="line">    <span class="hljs-keyword">float</span> k = dy/dx, y = y0;</span><br><span class="line">    <span class="hljs-keyword">for</span>(x=x0;x&lt;=x1;x++,y+=k)</span><br><span class="line">    	drawPixel(x, <span class="hljs-keyword">int</span>(y+<span class="hljs-number">0.5</span>), PIXEL_COLOR); <span class="hljs-comment">// int(y+0.5)是四舍五入,找到离交点更近的整点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是——斜率问题，上述算法仅在斜率 $|k| \le 1 $ 的情况适用，因为这种情况下，$x $每次增加1，$y $每次最多增加1。当 $|k| \gt 1 $时，可以举例看到 $ (0, 0) \rightarrow (2, 5) $以及 $ (0, 0) \rightarrow (2, 100)$ 都将只有三个点绘成！</p><p>这种情况下，只要把 $x、y$ 的地位互换即可。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">DDALine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color PIXEL_COLOR)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(x0 &gt; x1) swap(x0, x1), swap(y0, y1); <span class="hljs-comment">// (x0,y0)-&gt;(x1,y1)</span></span><br><span class="line">    <span class="hljs-keyword">bool</span> bigK = <span class="hljs-built_in">abs</span>(y1-y0)&gt;x1-x0;           <span class="hljs-comment">// 斜率|k|&gt;1</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(bigK) swap(x0, y0), swap(x1, y1);    <span class="hljs-comment">// x,y地位互换</span></span><br><span class="line">    <span class="hljs-keyword">float</span> k = (y1-y0)*<span class="hljs-number">1.0f</span>/(x1-x0), y = y0;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> x=x0;x&lt;=x1;x++,y+=k)</span><br><span class="line">        <span class="hljs-keyword">if</span>(bigK) drawPixel(<span class="hljs-keyword">int</span>(y+<span class="hljs-number">0.5</span>), x, PIXEL_COLOR);</span><br><span class="line">        <span class="hljs-keyword">else</span> drawPixel(x, <span class="hljs-keyword">int</span>(y+<span class="hljs-number">0.5</span>), PIXEL_COLOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，代码中没有特判处理 $k=0$ 情况。</p><h4 id="中点画线法"><a href="#中点画线法" class="headerlink" title="中点画线法"></a>中点画线法</h4><p>在DDA画直线过程中，当前点 $(x_0, y_0) $，下一个点可能是 $(x_0+1, y_0) $ 或 $(x_0+1, y_0+1) $ ，所以采用四舍五入进行抉择，本质上来说，真实交点在中点 $M(x_0+1, y_0+0.5) $ 上方，则选 $(x_0+1, y_0+1) $ ，下方则选 $(x_0+1, y_0) $ 。</p><p>中点画线法，就是基于这种思想，判断交点与中点的位置关系，替代原本四舍五入这一涉及浮点数的方法去做抉择，并且核心是从斜截式方程改为一般式方程。</p><p>对于线段 $ (x_0, y_0) \rightarrow (x_1, y_1)$，其一般式方程为 $F(x,y) = ax+by+c $，其中$a =y_0-y_1，b=x_1-x_0，c=x_0y_1-x_1y_0 $ 。</p><p>将中点带入方程，构建判别式 $d = F(M) = F(x_p+1, y_p+0.5) = a(x_p+1)+b(y_p+0.5)+c$，</p><ul><li><p>若 $d \ge 0$， 则交点在中点下方，画点 $(x_p+1,y_p)$，下一次 $d ‘ = F(x_p+2,y_p+0.5) = d+a$，增量为 $a$；</p></li><li><p>若 $d \lt 0$， 则交点在中点上方，画点 $(x_p+1,y_p+1)$，下一次 $d ‘ = F(x_p+2,y_p+1.5) = d+a+b$，增量为 $a+b$；</p></li></ul><p>从 $(x_0,y_0) $ 开始画线时候，$d $ 的初值 $d_0 = F(x_0+1,y_0+0.5) = F(x_0, y_0) + a + 0.5b = a+0.5b$，涉及浮点数，故采用 $2d $ 替代 $d$ 摆脱浮点数，此时，算法仅包含整数运算。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">MidPointLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color PIXEL_COLOR)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> a,b,d1,d2,d,x,y;</span><br><span class="line">    a = y0-y1, b = x1-x0, d=<span class="hljs-number">2</span>*a+b;</span><br><span class="line">    d1 = <span class="hljs-number">2</span>*a, d2 = <span class="hljs-number">2</span>*(a+b);</span><br><span class="line">    x = x0, y = y0;</span><br><span class="line">    drawPixel(x, y, PIXEL_COLOR);</span><br><span class="line">    <span class="hljs-keyword">while</span>(x &lt; x1)</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="hljs-keyword">if</span>(d &lt; <span class="hljs-number">0</span>) x++, y++, d+=d2;</span><br><span class="line">        <span class="hljs-keyword">else</span> x++, d+=d1;</span><br><span class="line">        drawPixel(x, y, PIXEL_COLOR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，代码仅处理了 $ 0 \le k \le 1$ 情况。</p><h4 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h4><p>Bresenham算法类似于中点法，由误差项符号决定下一个像素取右边点或右上点。</p><p>对于线段 $ (x_0, y_0) \rightarrow (x_1, y_1)$，其斜截式为 $y = kx+b$，对于 $(x_0, y_0) $ 的下一个点理应为 $(x_0+1, \text{round}(y_0+k)) $，即将 $y_0+k $ 四舍五入，又因为其中 $y_0 $为整数，故只需要判断 $k $ 与 $0.5 $ 的大小关系。同理，下下个点 $(x_0+2, \text{round}(y_0+2k)) $，决定因素是 $2k $，或者说 $2k $ 的小数部分，故增量为 $k$，注意模1。我们接下来用 $e$ 表示当前误差项。</p><p><img src="1556937103971.png" alt="1556937103971"></p><p>第一个优化：将判断 $e $ 与 $0.5 $ 的大小关系，优化为判断 $e-0.5 $ 与 $0 $ 的大小关系，即 $e $ 的初值设置。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bresenhamLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color PIXEL_COLOR)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> x = x0, y = y0;</span><br><span class="line">    <span class="hljs-keyword">float</span> k = (y1-y0)*<span class="hljs-number">1.0</span>/(x1-x0), e = <span class="hljs-number">-0.5</span>;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=x1-x0;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        drawPixel(x, y, PIXEL_COLOR);</span><br><span class="line">        x++; e+=k;</span><br><span class="line">        <span class="hljs-keyword">if</span>(e &gt;= <span class="hljs-number">0</span>) y++, e--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个优化：将 $e$ 整数化，由于算法中只用到误差项的符号，原增量 $k · \Delta= \frac{y_1-y_0}{x_1-x_0} · \Delta $，移项后 $k· (x_1-x_0)\Delta = (y_1-y_0) \Delta $，考虑上 $e $ 的初值设置，故将增量换成 $k ‘ = k· (x_1-x_0) \Delta=(y_1-y_0) \Delta $，$e_0 = \Delta · -(x_1-x_0)/2$。要完全去浮点数，取 $ \Delta = 2 $ 即可。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bresenhamLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color PIXEL_COLOR)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> x = x0, y = y0, dx = x1-x0, dy = y1-y0;</span><br><span class="line">    <span class="hljs-keyword">int</span> e = -dx;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=dx;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        drawPixel(x, y, PIXEL_COLOR);</span><br><span class="line">        x++; e+=<span class="hljs-number">2</span>*dy;</span><br><span class="line">        <span class="hljs-keyword">if</span>(e &gt;= <span class="hljs-number">0</span>) y++, e-=<span class="hljs-number">2</span>*dx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时注意，算法中仅处理了$ 0 \le k \le 1$ 情况。</p><p>第三个优化：处理斜率 $k \ge 1$ 情况，和DDA方法一样，将$x、y $ 地位互换。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bresenhamLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color PIXEL_COLOR)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(x0 &gt; x1) swap(x0, x1), swap(y0, y1); <span class="hljs-comment">// (x0,y0)-&gt;(x1,y1)</span></span><br><span class="line">    <span class="hljs-keyword">bool</span> bigK = y1-y0&gt;x1-x0;           <span class="hljs-comment">// 斜率k&gt;1</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(bigK) swap(x0, y0), swap(x1, y1);</span><br><span class="line">    <span class="hljs-keyword">int</span> x = x0, y = y0, dx = x1-x0, dy = y1-y0;</span><br><span class="line">    <span class="hljs-keyword">int</span> e = -dx;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=dx;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        drawPixel(bigK?y:x, bigK?x:y, PIXEL_COLOR);</span><br><span class="line">        x++; e+=<span class="hljs-number">2</span>*dy;</span><br><span class="line">        <span class="hljs-keyword">if</span>(e &gt;= <span class="hljs-number">0</span>) y++, e-=<span class="hljs-number">2</span>*dx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四个优化：处理斜率为负数情况，将线段沿着 $x $ 轴对称后做上述算法，画点时 $y $ 值注意乘-1。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bresenhamLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x0, <span class="hljs-keyword">int</span> y0, <span class="hljs-keyword">int</span> x1, <span class="hljs-keyword">int</span> y1, Color PIXEL_COLOR)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span>(x0 &gt; x1) swap(x0, x1), swap(y0, y1); <span class="hljs-comment">// (x0,y0)-&gt;(x1,y1)</span></span><br><span class="line">    <span class="hljs-keyword">bool</span> negK = y1&lt;y0;                 <span class="hljs-comment">// 负斜率</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(negK) y0=-y0, y1=-y1;</span><br><span class="line">    <span class="hljs-keyword">bool</span> bigK = y1-y0&gt;x1-x0;           <span class="hljs-comment">// 斜率|k|&gt;1</span></span><br><span class="line">    <span class="hljs-keyword">if</span>(bigK) swap(x0, y0), swap(x1, y1);</span><br><span class="line">    <span class="hljs-keyword">int</span> x = x0, y = y0, dx = x1-x0, dy = y1-y0;</span><br><span class="line">    <span class="hljs-keyword">int</span> e = -dx;</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=dx;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        drawPixel(bigK?y:x, negK?(bigK?-x:-y):(bigK?x:y), PIXEL_COLOR);</span><br><span class="line">        x++; e+=<span class="hljs-number">2</span>*dy;</span><br><span class="line">        <span class="hljs-keyword">if</span>(e &gt;= <span class="hljs-number">0</span>) y++, e-=<span class="hljs-number">2</span>*dx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆弧的扫描转换"><a href="#圆弧的扫描转换" class="headerlink" title="圆弧的扫描转换"></a>圆弧的扫描转换</h3><h4 id="圆的八对称性"><a href="#圆的八对称性" class="headerlink" title="圆的八对称性"></a>圆的八对称性</h4><p>$(x,y)、(y,x)、(-x,y)、(y,-x)、(x,-y)、(-y,x)、(-x,-y)、(-y,-x) $ 对称。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">drawEightCirclePoints</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, Color c, <span class="hljs-keyword">int</span> size=<span class="hljs-number">1</span>)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    glPointSize(size);</span><br><span class="line">    glColor3f(c.r, c.g, c.b);</span><br><span class="line">    glBegin(GL_POINTS);</span><br><span class="line">    glVertex3f(cx+x, cy+y, <span class="hljs-number">0.0f</span>); glVertex3f(cx+y, cy+x, <span class="hljs-number">0.0f</span>);</span><br><span class="line">    glVertex3f(cx-x, cy+y, <span class="hljs-number">0.0f</span>); glVertex3f(cx+y, cy-x, <span class="hljs-number">0.0f</span>);</span><br><span class="line">    glVertex3f(cx+x, cy-y, <span class="hljs-number">0.0f</span>); glVertex3f(cx-y, cy+x, <span class="hljs-number">0.0f</span>);</span><br><span class="line">    glVertex3f(cx-x, cy-y, <span class="hljs-number">0.0f</span>); glVertex3f(cx-y, cy-x, <span class="hljs-number">0.0f</span>);</span><br><span class="line">    glEnd();</span><br><span class="line">    glFlush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中点画圆法"><a href="#中点画圆法" class="headerlink" title="中点画圆法"></a>中点画圆法</h4><p>由于中点画圆法与Bresenham画线法有相似之处，故又被称为Bresenham画圆法。</p><p>圆：$F(x,y) = x^2+y^2-R^2$，圆内的点 $F(x,y) \lt 0 $，圆外的点 $F(x,y) \gt 0$。</p><p><img src="1556699209242.png" alt="1556699209242"></p><p>构建判别式：$d = F(M) = F(x_p+1, y_p-0.5) = (x_p+1)^2+(y_p-0.5)^2-R^2 $。</p><ul><li>若 $d \lt 0 $，画点 $P_1(x_p+1,y_p)$，下一像素判别式 $d_1 = F(x_p+2, y_p-0.5)=d+2x_p+3$</li><li>若 $d \gt 0 $，画点 $P_2(x_p+1,y_p-1) $，下一像素判别式 $d_1 = F(x_p+2, y_p-1.5)=d+2(x_p-y_p)+5 $</li></ul><p>从$(0,R) $开始顺时针画圆，$ d $ 的初始值 $d_0 = F(1,R-0.5) = 1.25-R $</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bresenhamDrawCircle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cx, <span class="hljs-keyword">int</span> cy, <span class="hljs-keyword">int</span> r)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> x, y;</span><br><span class="line">    <span class="hljs-keyword">float</span> d;</span><br><span class="line">    x = <span class="hljs-number">0</span>; y = r; d = <span class="hljs-number">1.25</span>-r;</span><br><span class="line">    drawEightCirclePoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE);</span><br><span class="line">    <span class="hljs-keyword">while</span>(x &lt;= y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(d &lt; <span class="hljs-number">0</span>) d+=<span class="hljs-number">2</span>*x+<span class="hljs-number">3</span>;</span><br><span class="line">        <span class="hljs-keyword">else</span> d+=<span class="hljs-number">2</span>*(x-y)+<span class="hljs-number">5</span>, y--;</span><br><span class="line">        x++;</span><br><span class="line">        drawEightCirclePoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑优化掉浮点数，优化乘法为加法。</p><h4 id="中点画椭圆法"><a href="#中点画椭圆法" class="headerlink" title="中点画椭圆法"></a>中点画椭圆法</h4><p>与中点画圆法类似，参照则写即可。</p><p>椭圆：$F(x,y) = b^2 x^2+a^2 y^2-a^2 b^2$</p><p><img src="1556699209242.png" alt="1556699209242"></p><p>构建判别式：$d = F(M) = F(x_p+1\Delta, y_p-0.5\Delta) = b^2 (x_p+\Delta)^2+ a^2 (y_p-0.5\Delta)^2 - a^2 b^2 $。</p><ul><li><p>若 $d \lt 0 $，画点 $P_1(x_p+1\Delta,y_p)$，下一像素判别式 $d_1 = F(x_p+2\Delta, y_p-0.5\Delta)=d+(2 x_p \Delta + 3 \Delta ^2)b^2$</p></li><li><p>若 $d \gt 0 $，画点 $P_2(x_p+1\Delta,y_p-1\Delta) $，下一像素判别式</p><p>$d_1 = F(x_p+2\Delta, y_p-1.5\Delta)=d+(2 x_p \Delta + 3 \Delta ^2)b^2 + (-2y_p \Delta + 2\Delta^2)a^2 $</p></li></ul><p>从$(0,b) $开始顺时针利用四对称性画椭圆，$ d $ 的初始值 $d_0 = F(1\Delta,b-0.5\Delta) = 0.25 a^2 \Delta^2 + b^2 \Delta^2 - a^2 b \Delta $。其中 $\Delta $ 是网格单位距。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bresenhamDrawOval</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cx, <span class="hljs-keyword">int</span> cy, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> x, y;</span><br><span class="line">    <span class="hljs-keyword">float</span> d;</span><br><span class="line">    x = <span class="hljs-number">0</span>; y = a; d = <span class="hljs-number">4</span>*b*b<span class="hljs-number">-2</span>*a*b+a*a;</span><br><span class="line">    drawFourOvalPoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE);</span><br><span class="line">    <span class="hljs-keyword">while</span>(y &gt;= <span class="hljs-number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(d &lt; <span class="hljs-number">0</span>) d+=<span class="hljs-number">2</span>*b*b*x+<span class="hljs-number">3</span>*b*b;</span><br><span class="line">        <span class="hljs-keyword">else</span> d+=<span class="hljs-number">2</span>*(b*b*x-a*a*y)+<span class="hljs-number">3</span>*b*b+<span class="hljs-number">2</span>*a*a, y--;</span><br><span class="line">        x++;</span><br><span class="line">        drawFourOvalPoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你认为上述代码能生成一个椭圆，那就错了！</p><p><img src="1556717142431.png" alt="1556717142431"></p><p>椭圆只有四对称性，极接近 $x $ 轴时，会出现切线斜率为 -1 的情况，这时主导地位应换为 $y $。即要分为两区域画图。在椭圆上过点 $P(x_0, y_0) $的切线斜率为：$k = -\frac{b^2 x_0}{a^2 y_0}$ ，特判 $k\le-1 $时退出第一区域。</p><p><img src="1556718832370.png" alt="1556718832370"></p><p>构建判别式：$d = F(M) = F(x_p+0.5\Delta, y_p-1\Delta) = b^2 (x_p+0.5\Delta)^2+ a^2 (y_p-1\Delta)^2 - a^2 b^2 $。</p><ul><li>若 $d \lt 0 $，画点 $P_1(x_p+1\Delta,y_p-1\Delta)$，下一像素判别式 $d_1 = F(x_p+1.5, y_p-2)=d + (-2y_p\Delta+3\Delta^2)a^2 +(2x_p\Delta+2\Delta^2)b^2$</li><li>若 $d \gt 0 $，画点 $P_2(x_p,y_p-1\Delta) $，下一像素判别式 $d_1 = F(x_p+0.5\Delta, y_p-2\Delta)=d+(-2y_p\Delta+3\Delta^2)a^2 $</li></ul><p>最终版：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bresenhamDrawOval</span><span class="hljs-params">(<span class="hljs-keyword">int</span> cx, <span class="hljs-keyword">int</span> cy, <span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">float</span> x, y;</span><br><span class="line">    <span class="hljs-keyword">float</span> d;</span><br><span class="line">    x = <span class="hljs-number">0</span>; y = b; d = <span class="hljs-number">0.25</span>*a*a + b*b - a*a*b;</span><br><span class="line">    drawFourOvalPoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE);</span><br><span class="line">    <span class="hljs-keyword">while</span>(y &gt;= <span class="hljs-number">0</span>)</span><br><span class="line">    &#123; <span class="hljs-comment">// 区域一</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(d &lt; <span class="hljs-number">0</span>) d+=<span class="hljs-number">2</span>*b*b*x+<span class="hljs-number">3</span>*b*b;</span><br><span class="line">        <span class="hljs-keyword">else</span> d+=<span class="hljs-number">2</span>*(b*b*x-a*a*y)+<span class="hljs-number">3</span>*b*b+<span class="hljs-number">2</span>*a*a, y--;</span><br><span class="line">        x++;</span><br><span class="line">        drawFourOvalPoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE);</span><br><span class="line">        <span class="hljs-comment">// 如果斜率=-1 则跳出循环</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(-b*b*x / (a*a*y) &lt;= <span class="hljs-number">-1</span>) <span class="hljs-keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    d = b*b*(x+<span class="hljs-number">0.5</span>)*(x+<span class="hljs-number">0.5</span>) + a*a*(y<span class="hljs-number">-1</span>)*(y<span class="hljs-number">-1</span>) - a*a*b*b;</span><br><span class="line">    <span class="hljs-keyword">while</span>(y &gt;= <span class="hljs-number">0</span>)</span><br><span class="line">    &#123; <span class="hljs-comment">// 区域二</span></span><br><span class="line">        <span class="hljs-keyword">if</span>(d &gt; <span class="hljs-number">0</span>) d+=(<span class="hljs-number">-2</span>*y+<span class="hljs-number">3</span>)*a*a;</span><br><span class="line">        <span class="hljs-keyword">else</span> d+=(<span class="hljs-number">-2</span>*y+<span class="hljs-number">3</span>)*a*a+(<span class="hljs-number">2</span>*x+<span class="hljs-number">2</span>)*b*b, x++;</span><br><span class="line">        y--;</span><br><span class="line">        drawFourOvalPoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多边形的扫描转换"><a href="#多边形的扫描转换" class="headerlink" title="多边形的扫描转换"></a>多边形的扫描转换</h3><p>多边形的两种表示：</p><ul><li>顶点表示：直观、几何意义强、占内存少、易进行几何变换，但不能直接用于面着色。</li><li>点阵表示：便于帧缓冲器表示图形、面着色，但丢失了许多几何信息。</li></ul><p>多边形分为：凸、凹多边形，以及含内环的多边形。</p><h4 id="X-扫描线算法-活性边表法"><a href="#X-扫描线算法-活性边表法" class="headerlink" title="X-扫描线算法(活性边表法)"></a>X-扫描线算法(活性边表法)</h4><ol><li>从$y = y_{min} $ 到 $y = y_{max} $ ，每条扫描线 $y = y_i$ 与多边形的相交区间 $[L_1, R_1]、\cdots、 [L_n, R_n]$</li><li>指定颜色显示区间像素 ${(x, y_i) \ | \ x = L_1,L_1+1,\cdots,R_1,L_2,\cdots,R_n}$</li></ol><p><img src="1556777590096.png" alt="1556777590096"></p><p>当扫描线与多边形顶点相交时，交点的取舍策略为保证交点数目偶数个：</p><ul><li>若共享顶点的两条边分别落在扫描线的两边，交点只算 1 个</li><li>若共享顶点的两条边在扫描线的同一边，这时交点作为 0 个或 2 个</li></ul><p><img src="1557146422539.png" alt="1557146422539"></p><p>上述算法（求交、排序、配对、填色）的重要思想是<strong>扫描线</strong>和<strong>增量</strong>，但求交的效率十分低，故算法需要优化，主要从3个方面考虑：</p><ul><li>与有效边求交：在处理一条扫描线时，仅对与它相交的多边形的边进行求交运算</li><li>扫描线的连贯性：当前扫描线与各边的交点与下一条扫描线与各边的交点很可能相同或非常相似</li><li>多边形的连贯性：当某条边与当前扫描线相交时，它很可能也与下一条扫描线相交</li></ul><p>引入数据结构 1 ——<strong>活性边表</strong>(AET)：</p><ul><li><p>活性边：与当前扫描线相交的边</p></li><li><p>表：将活性边按交点 x 坐标升序存放在于链表</p></li><li><p>节点内容</p><ul><li><p>$x $：活性边与扫描线的交点 x 坐标</p></li><li><p>$ \Delta x $ ：从”当前扫描线与活性边交点”到”下一条扫描线与活性边交点”间的 x 增量。</p><p>由活性边斜率 $k = \frac{y_{i+1}-y_i}{x_{i+1}-x_i} \Rightarrow \Delta x = \frac{1}{k \Delta } $，其中单个 $\Delta $ 为扫描线增量。</p></li><li><p>$y_{max} $：该活性边所交的最高扫描线的 y 坐标</p></li></ul></li></ul><p><img src="1556779269256.png" alt="1556779269256"></p><p>引入数据结构 2 ——<strong>新边表</strong>(NET)：</p><ul><li>表：按照扫描线第一次交于该边的高度，建立链表</li><li>节点内容<ul><li>$y_{max} $：该边的最高 y 值</li><li>$x_{min} $：该边<strong>较低点</strong>的 x 值，注意是较低点不是左点</li><li>$1/k $：该边的斜率倒数</li></ul></li></ul><p><img src="1556779715911.png" alt="1556779715911"></p><p>上图扫描线$y = 1 $ 交的两条边$P_1P_2、P_1P_6 $ 即可以放入活性边表处理。</p><p>每次做新的扫描线时，要对活性边进行三个处理：</p><ol><li><p>是否去除该活性边。</p></li><li><p>若不去除，就更新其数据，$x = x + \frac{1}{k \Delta} $</p></li><li><p>根据新边表判断有无新边进入，有则插入排序到活性边表。</p></li></ol><p>如此算法避免了求交，伪码如下：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">polyFill</span><span class="hljs-params">(polygon, color)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;	</span><br><span class="line">    <span class="hljs-keyword">for</span> (各条扫描线i)</span><br><span class="line">	&#123; </span><br><span class="line">        初始化新边表头指针NET[i];</span><br><span class="line">     	把ymin=i的边放进新边表NET[i];</span><br><span class="line">    &#125;</span><br><span class="line">    y = 最低扫描线号;</span><br><span class="line">    初始化活性边表AET为空;</span><br><span class="line">    <span class="hljs-keyword">for</span> (各条扫描线i)</span><br><span class="line">    &#123;</span><br><span class="line">        把NET[i]中的边结点用插入排序法插入AET表;</span><br><span class="line">        遍历AET表,把配对交点区间(左闭右开)上的象素(x,y)，用putpixel(x,y,color)改写象素颜色值;</span><br><span class="line">        遍历AET表，把ymax=i的结点从AET表中删除,并把ymax&gt;i的结点的x值递增Δx;</span><br><span class="line">        若允许多边形的边自相交，则用冒泡排序法对AET表重新排序;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="边界标志算法"><a href="#边界标志算法" class="headerlink" title="边界标志算法"></a>边界标志算法</h4><p>在帧缓冲器中对多边形的每条边进行直线扫描转换，即对多边形边界所经过的像素打上标记。</p><p>从左到右逐个访问扫描线的像素，进行上色。</p><p>边界标志算法更适合硬件实现，这时它的执行速度比有序边表算法快一至两个数量级。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">edgemarkFill</span><span class="hljs-params">(polydef, color)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    对多边形polydef每条边进行直线扫描转换;</span><br><span class="line">    <span class="hljs-keyword">for</span> (每条与多边形polydef相交的扫描线y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="hljs-keyword">bool</span> inside = <span class="hljs-literal">false</span>;</span><br><span class="line">        <span class="hljs-keyword">for</span> (扫描线上的每个像素x)</span><br><span class="line">        &#123;</span><br><span class="line">        	<span class="hljs-keyword">if</span> (像素x被打上边标记) inside = !inside;</span><br><span class="line">            <span class="hljs-keyword">if</span> (inside) drawPixel(x, y, color);</span><br><span class="line">            <span class="hljs-keyword">else</span> drawPixel(x, y, backgroudColor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="边缘填充算法"><a href="#边缘填充算法" class="headerlink" title="边缘填充算法"></a>边缘填充算法</h4><p>一张图：</p><p><img src="1556802276001.png" alt="1556802276001"></p><h4 id="栅栏填充算法"><a href="#栅栏填充算法" class="headerlink" title="栅栏填充算法"></a>栅栏填充算法</h4><p>对边缘填充算法的改进，栅栏指一条过多边形顶点且与扫描线垂直的直线，它把多边形分为两半。</p><p>在处理每条边与扫描线的交点时，将交点与栅栏之间的像素取补。</p><h3 id="多边形的区域填充"><a href="#多边形的区域填充" class="headerlink" title="多边形的区域填充"></a>多边形的区域填充</h3><ul><li><p>区域：已经表示成点阵形式的填充图形，是像素的集合</p></li><li><p>区域填充：指将区域内的一点(常称种子点)赋予给定颜色，然后将这种颜色扩展到整个区域内的过程。</p></li></ul><h4 id="区域填充算法-泛滥填充算法"><a href="#区域填充算法-泛滥填充算法" class="headerlink" title="区域填充算法(泛滥填充算法)"></a>区域填充算法(泛滥填充算法)</h4><p>DFS/BFS</p><h4 id="扫描线种子填充算法"><a href="#扫描线种子填充算法" class="headerlink" title="扫描线种子填充算法"></a>扫描线种子填充算法</h4><p>区域填充扫描线方法。上一算法从种子点开始DFS/BFS，其中多次入栈(队)，费时费内存效率不高。实际上知道了一个点，我们可以从该点向左向右循环填充直至碰触边界。扫描线种子填充算法就是用这个结合扫描线，解决了多次入栈(队)的问题。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ScanLineFill4</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, Color oldColor, Color newColor)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><span class="hljs-keyword">int</span> x,y;&#125; Seed;</span><br><span class="line">    <span class="hljs-keyword">int</span> xl, xr;</span><br><span class="line">    <span class="hljs-keyword">bool</span> spanNeedFill;</span><br><span class="line">    <span class="hljs-built_in">stack</span>&lt;Seed&gt; S;</span><br><span class="line">    S.push(&#123;x, y&#125;);</span><br><span class="line">    <span class="hljs-keyword">while</span>(!S.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        Seed u = S.top(); S.pop();</span><br><span class="line">        x = u.x; y = u.y;</span><br><span class="line">        <span class="hljs-keyword">for</span>(xr=x;readPixelRGB(xr, y) == oldColor;xr++)</span><br><span class="line">            drawPixel(xr, y, newColor);</span><br><span class="line">        xr--;</span><br><span class="line">        <span class="hljs-keyword">for</span>(xl=x<span class="hljs-number">-1</span>;readPixelRGB(xl, y) == oldColor;xl--)</span><br><span class="line">            drawPixel(xl, y, newColor);</span><br><span class="line">        xl++;</span><br><span class="line">        <span class="hljs-comment">// 分别处理上下两条扫描线</span></span><br><span class="line">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> yy=y<span class="hljs-number">-1</span>;yy&lt;=y+<span class="hljs-number">1</span>;yy+=<span class="hljs-number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = xl;</span><br><span class="line">            <span class="hljs-keyword">while</span>(x &lt;= xr)</span><br><span class="line">            &#123;</span><br><span class="line">                spanNeedFill = <span class="hljs-literal">false</span>;</span><br><span class="line">                <span class="hljs-keyword">for</span>(;readPixelRGB(x, yy) == oldColor;x++) spanNeedFill = <span class="hljs-literal">true</span>;</span><br><span class="line">                <span class="hljs-keyword">if</span>(spanNeedFill) S.push(&#123;x<span class="hljs-number">-1</span>, yy&#125;);</span><br><span class="line">                <span class="hljs-keyword">while</span>(readPixelRGB(x, yy)!=oldColor &amp;&amp; x&lt;=xr) x++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="扫描转换与区域填充的不同"><a href="#扫描转换与区域填充的不同" class="headerlink" title="扫描转换与区域填充的不同"></a>扫描转换与区域填充的不同</h4><ul><li>基本思想不同<ul><li>扫描转换：将多边形顶点转换为点阵表示。</li><li>区域填充：只改变区域颜色，不改变区域的表示方法。</li></ul></li><li>基本条件不同<ul><li>扫描转换：从多边形的边界(顶点)信息出发，利用多种形式的连贯性进行填充点阵。</li><li>区域填充：给定区域内一点作为种子点，然后从点根据连通性将新的颜色扩散到整个区域。</li></ul></li><li>目的不同<ul><li>扫描转换：知道多边形边界，求多边形内部的像素集。</li><li>区域填充：知道边界、区域内一点，内部填色。</li></ul></li></ul><h3 id="反走样"><a href="#反走样" class="headerlink" title="反走样"></a>反走样</h3><h4 id="走样现象"><a href="#走样现象" class="headerlink" title="走样现象"></a>走样现象</h4><ul><li>光栅图形缠身的阶梯型（锯齿形）</li></ul><p><img src="1557734619560.png" alt="1557734619560"></p><ul><li>小物体由于走样而消失</li></ul><p><img src="1557734746397.png" alt="1557734746397"></p><ul><li>动画序列中时隐时现，产生闪烁（仅在矩形覆盖像素中心时显示）</li></ul><p><img src="1557734918664.png" alt="1557734918664"></p><h4 id="反走样技术原理"><a href="#反走样技术原理" class="headerlink" title="反走样技术原理"></a>反走样技术原理</h4><p>反走样(Antialiasing)</p><p><img src="1557737078537.png" alt="1557737078537"></p><ul><li>提高设备分辨率：由于存储器代价、扫描转换时间代价、轰击屏幕电子枪的速度代价，所以不可取</li></ul><p><img src="1557735574657.png" alt="1557735574657"></p><ul><li><p>模糊：对于白色背景中黑色矩形，在矩形边界掺入灰色像素，柔化从黑到白的尖锐变化。从远处观察图像，人眼把这些缓和变化的暗影融合在一起，从而看到更平滑的边界。</p><p><img src="1557735786217.png" alt="1557735786217"></p></li></ul><h4 id="非加权区域采样方法"><a href="#非加权区域采样方法" class="headerlink" title="非加权区域采样方法"></a>非加权区域采样方法</h4><p>方法：根据物体的覆盖率（某个像素区域被物体覆盖的比例）计算像素的颜色。</p><p><img src="1557736273466.png" alt="1557736273466"></p><p>两个缺点：</p><ul><li><p>像素亮度与相交区域面积成正比，而与相交区域在像素内的位置无关 -&gt; 仍有锯齿效应</p></li><li><p>直线条上沿理想直线方向的相邻两个象素有时会有较大的灰度差（因为每个像素的权值都一样）</p></li></ul><h4 id="加权区域采样方法"><a href="#加权区域采样方法" class="headerlink" title="加权区域采样方法"></a>加权区域采样方法</h4><p>在加权方法中，将像素亮度与相交区域在像素内的位置看作有关。</p><p>思想：直线段对一个像素亮度的贡献正比于相交区域与像素中心的距离 $d $</p><p><img src="1557736675852.png" alt="1557736675852"></p><p>方法：设置相交区域面积与像素中心距离的权函数（高斯函数）反映相交面积对整个像素亮度的贡献大小，利用权函数积分求相交区域面积，再乘以最大亮度值即为像素实际亮度值。</p><p>简化方案：将积分改为离散计算</p><p><img src="1557737269895.png" alt="1557737269895"></p><h3 id="直线裁剪算法"><a href="#直线裁剪算法" class="headerlink" title="直线裁剪算法"></a>直线裁剪算法</h3><h4 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h4><p>裁剪：确定图形哪些部分落于显示区之内/外。</p><p>最简单的剪裁：转换为点的剪裁</p><p>点的剪裁：判断 $\begin{cases} x_{left} \le x \le x_{right} \ y_{bottom} \le y \le y_{top} \end{cases}$</p><p>直线段的剪裁：判断 $\begin{cases} 完全落在窗口内 \ 完全落在窗口外 \ 与窗口边界相交 \end{cases} $</p><h4 id="Cohen-Sutherland算法"><a href="#Cohen-Sutherland算法" class="headerlink" title="Cohen-Sutherland算法"></a>Cohen-Sutherland算法</h4><p>又称编码裁剪算法。</p><p>思想：对每条直线段分是三种情况</p><ul><li>若点 $p_1 $ 和 $p_2 $ 完全在剪裁窗口内：取之</li><li>若点为下图四种之一：弃之</li></ul><p><img src="1557738683086.png" alt="1557738683086"></p><ul><li>其他情况，可以采用编码的方法：顶点编码$D_3D_2D_1D_0 $， $\begin{cases} D_0 = x&lt;x_{left} \ D_1 = x&gt;x_{right} \ D_2 = y&lt;y_{bottom} \ D_3 = y&gt;y_{top} \ \end{cases} $<ul><li>若 $p1 \ |\ p2 = 0 $，取之</li><li>若 $p1 \ &amp;\ p2 \not= 0$ ，丢之</li><li>若上述都不满足，则<strong>依次按左、右、上、下的顺序</strong>求出线段与窗口的交点。<br>然后在交点处把线段一分为二，根据上述两个原则舍/取一部分。</li></ul></li></ul><p><img src="1557738830653.png" alt="1557738830653"></p><p>特点</p><ul><li><p>较适合两种情况——大部分线可见、大部分线不可见。</p></li><li><p>存在问题：下图线段要多次经过算交点才会被舍弃。</p><p><img src="1557743068830.png" alt="1557743068830"></p></li></ul><h4 id="中点分割算法"><a href="#中点分割算法" class="headerlink" title="中点分割算法"></a>中点分割算法</h4><p>与Cohen-Sutherland算法相似，需要对位置进行编码。</p><p>思想：通过<strong>二分逼近</strong>来确定线段与窗口的交点</p><ul><li><p>完全在窗口内/外的情况</p></li><li><p>和窗口有交点，构建线段中点</p><ul><li><p>若中点在窗口内，则不断构建交点与端点的中点</p><p><img src="1557743446302.png" alt="1557743446302"></p></li><li><p>若中点在窗口外，则把 (中点, 离窗口边界较远的端点) 部分去掉。</p></li></ul><p><img src="1557743506141.png" alt="1557743506141"></p><ul><li>以此逼近。</li></ul></li></ul><h4 id="Liang-Barsky算法"><a href="#Liang-Barsky算法" class="headerlink" title="Liang-Barsky算法"></a>Liang-Barsky算法</h4><p>线段 $(x_1,y_1) \rightarrow (x_2,y_2) $</p><p>特判：</p><ul><li>若 $x_1 = x_2 $，判断 $x_1-x_{left} \lt 0$ 或 $x_{right}-x_1 \lt 0$ 则线段不在窗口内</li><li>若 $y_1=y_2$，判断 $y_1 - y_{bottom} \lt 0 $ 或 $y_{top}-y_1 \lt 0 $ 则线段不在窗口内</li></ul><p>思想：</p><ul><li><p>用参数方程表示直线段 $\begin{cases} x = x_1 + u·(x_2-x_1) = x_1 + u·\Delta x \ y = y_1+u·(y_2-y_1)=y_1 + u·\Delta y \end{cases} ， 0 \le u \le1$</p></li><li><p>将直线段看成一条有方向的线段（标记端点为绿色），把窗口的四条边及其延长线分成入边、出边两种。</p><ul><li>入边：直线由窗口<strong>外向内</strong>移动时和窗口边界相交的边（标记交点为红色）</li><li>出边：直线由窗口<strong>内向外</strong>移动时和窗口边界相交的边（标记交点为红色）</li></ul><p><img src="1557744279100.png" alt="1557744279100"></p><ul><li>用 $u_1、u_2$ 分别表示线段 $(u_1 \le u_2)$ 可见部分的开始和结束 $\large \begin{cases} u_1 = max(0,u_{left},u_{bottom}) \ u_2 = min(1,u_{top},u_{right}) \end{cases} $</li></ul><p><img src="1557744846784.png" alt="1557744846784"></p></li></ul><p>问题：</p><ul><li><p>问题1.如何判断哪两个边是入边，哪两个边是出边</p></li><li><p>问题2.直线和窗口边界线四个交点参数 u 值如何求出</p></li><li><p>将裁剪转换为不等式：$\begin{cases} x_{left} \le x_1 + u·\Delta x \le x_{right} \ y_{bottom} \le y_1+u·\Delta y \le y_{top} \end{cases} \Rightarrow \begin{cases} u·(-\Delta x) \le x_1 - x_{left} \ u·\Delta x \le x_{right} - x_1 \ u·(-\Delta y) \le y_1 - y_{bottom} \ u·\Delta y \le y_{top} - y_1 \ \end{cases} $</p><p>将上面不等式看作 $u·p_k \le q_k$，四个不等式参数意义一一对应。当不等式取等号时， $u = \frac{q_k}{p_k} $即为直线和窗口四条边交点处的参数。（问题 2 解决）</p><p>除此之外，对于问题 1 的解决，根据 $p_k$ 的符号判断：</p><p><img src="1557747467656.png" alt="1557747467656"></p></li></ul><p>故，$u_1、u_2 $ 进一步得到为 $\large \begin{cases} u_1 = max(0,u_{k|p_k \lt 0},u_{k|p_k \lt 0}) \ u_2 = min(1,u_{k|p_k \gt 0},u_{k|p_k \gt 0}) \end{cases} $，若 $u_1 \gt u_2$ 则在窗口外。</p><p>例子：</p><p><img src="1557748368458.png" alt="1557748368458"></p><h3 id="多边形裁剪"><a href="#多边形裁剪" class="headerlink" title="多边形裁剪"></a>多边形裁剪</h3><p>一个简单的想法：多边形裁剪转换为直线的裁剪，然而会得到一些不连续直线段。</p><p><img src="1558339530111.png" alt="1558339530111"></p><p>然而目标却是：多边形边界的顶点序列</p><p><img src="1558339588036.png" alt="1558339588036"></p><h4 id="Sutherland-Hodgeman多边形裁剪"><a href="#Sutherland-Hodgeman多边形裁剪" class="headerlink" title="Sutherland-Hodgeman多边形裁剪"></a>Sutherland-Hodgeman多边形裁剪</h4><p>算法思想：</p><ul><li>将多边形边界作为一个整体</li><li>每次用窗口的一条边对 被裁剪的多边形、中间结果多边形 进行裁剪（分治）</li></ul><p><img src="1558340325531.png" alt="1558340325531"></p><p>顶点的舍取——以下图左边界裁剪多边形123456为例，考虑四种情况：</p><ul><li>都在不可见侧：都不加入。例如边12都不加入</li><li>源S在不可见侧，目标T在可见侧：加入交点、T。例如边23加入2 ‘ 3</li><li>都在可见侧：只加入目标T。例如边34加入4</li><li>源S在可见侧，目标T在不可见侧：加入源点、交点。例如边56加入56’</li></ul><p><img src="1558340618583.png" alt="1558340618583"></p><p>算法缺点：</p><ul><li>对凹多边形可能会得到多余线段</li></ul><p><img src="1558340958109.png" alt="1558340958109"></p><h3 id="文字裁剪"><a href="#文字裁剪" class="headerlink" title="文字裁剪"></a>文字裁剪</h3><p>文字裁剪分类：</p><ul><li>串精度裁剪：仅保留字符串全在窗口内的串</li></ul><p><img src="1558341126387.png" alt="1558341126387"></p><ul><li>字符精度裁剪：仅保留字符全在窗口内的字符</li></ul><p><img src="1558341168278.png" alt="1558341168278"></p><ul><li>笔划/像素精度裁剪：仅保留字符像素(笔画)在窗口内的部分</li></ul><p><img src="1558341221436.png" alt="1558341221436"></p><h3 id="消隐算法"><a href="#消隐算法" class="headerlink" title="消隐算法"></a>消隐算法</h3><p>消隐：绘制时消除被遮挡的不可见的线或面，也称消除隐藏线和隐藏面。</p><p><img src="1558341507888.png" alt="1558341507888"></p><p><img src="1558341582016.png" alt="1558341582016"></p><p>消除隐藏线、隐藏面，这里介绍的主要算法：</p><ul><li>Z缓冲区(Z-Buffer)算法</li><li>扫描线Z-buffer算法</li><li>区域子分割算法</li></ul><p>消隐的分类：</p><ul><li>按消隐对象分<ul><li>线消隐</li><li>面消隐</li></ul></li><li>按消隐空间分<ul><li>物体空间：将场景中的 1 个物体与剩下的 n-1 个物体逐一比较，仅显示可见表面（常用线段图的消隐）</li><li><strong>图像空间</strong>：对屏幕窗口内的每个像素判断</li></ul></li></ul><h4 id="画家算法"><a href="#画家算法" class="headerlink" title="画家算法"></a>画家算法</h4><p>比较简单的想法：先画远的物体，再画近的物体，近物体会覆盖远物体。</p><p>只能解决简单情况。</p><p><img src="1558342005389.png" alt="1558342005389"></p><h4 id="Z缓冲区-Z-Buffer-算法"><a href="#Z缓冲区-Z-Buffer-算法" class="headerlink" title="Z缓冲区(Z-Buffer)算法"></a>Z缓冲区(Z-Buffer)算法</h4><p>能跟踪屏幕上每个像素的深度。</p><p>维护两个数组：</p><ul><li><p>帧缓冲器，Intensity(x, y)——属性数组，图像空间每个可见像素的光强/颜色</p></li><li><p>深度缓冲区，Depth(x, y)——深度数组，图像空间每个可见像素的 z 坐标</p></li></ul><p><img src="1558342314960.png" alt="1558342314960"></p><p>算法思想：</p><ul><li>将 Z 缓冲器中各单元的初始值置为最小值</li><li>当要改变某个像素的颜色值时，仅在当前 z 值大于原来 z 值时，才替换</li></ul><p>算法优点：</p><ul><li>简单、直观</li><li>在像素级上以近物取代远物，而与物体的出现顺序无关，利于硬件实现</li><li>内存容量不再是问题后，变得受欢迎</li></ul><p>算法缺点：</p><ul><li>占用空间大</li><li>没有利用图形的相关性和连续性，这是严重缺陷</li><li>像素级的算法，效率低</li></ul><p>算法改进——改进占用空间（去数组，时间换空间）：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">void</span> Z-Buffer()</span><br><span class="line">&#123; </span><br><span class="line">  帧缓存全置为背景色</span><br><span class="line">  <span class="hljs-keyword">for</span>(屏幕上的每个像素(i,j))</span><br><span class="line">  &#123;</span><br><span class="line">    深度缓存遍历 zb = -INF;</span><br><span class="line">    <span class="hljs-keyword">for</span>(多面体上的每个多边形P_k)</span><br><span class="line">      <span class="hljs-keyword">if</span>(像素点(i,j)在P_k的投影在多边形内 &amp;&amp; P_k的depth(i,j)&gt;zb)</span><br><span class="line">        zb = depth(i,j), indexp = k;</span><br><span class="line">    <span class="hljs-keyword">if</span>(zb != -INF) </span><br><span class="line">      计算P_indexp在(i, j)的光照颜色并显示</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>面的深度计算：$ax + by + cz + d = 0 \Rightarrow depth = -\frac{ai+bj+d}{c} $</p></li><li><p>点与多边形的包含性</p><ul><li><p>射线法，缺点是计算量大、有误差不稳定</p><p><img src="1558343490086.png" alt="1558343490086"></p></li><li><p>弧长法，缺点是算弧长效率低</p><p><img src="1558343734873.png" alt="1558343734873"></p></li><li><p>以顶点符号为基础的弧长累加法</p><p><img src="1558344174810.png" alt="1558344174810"></p></li></ul></li><li><p>该改进未解决像素级算法的本质，效率仍然低。</p></li></ul><h4 id="区间扫描线算法"><a href="#区间扫描线算法" class="headerlink" title="区间扫描线算法"></a>区间扫描线算法</h4><p>考虑Z-Buffer没有利用图形的相关性和连续性的缺陷，该算法放弃了Z-Buffer的思想（一个像素可能被多个多边形覆盖，即一个像素要多次判别，效率极低），是消隐算法中最快的算法之一。</p><p>思想：</p><ul><li>把扫描线和多边形的这些交点都求出来，对每个区间，只判一个像素的颜色，那么整个区间都是该颜色</li><li>像素计算 -&gt; 逐段计算，效率大大提高。</li></ul><p><img src="1558350237847.png" alt="1558350237847"></p><p>确定小区间的颜色：</p><ul><li>小区间无任何多边形，如[a4, a5]，用背景色显示</li><li>小区间仅有一多边形，如[a1, a2]，显示该多边形颜色</li><li>小区间存在两个以上多边形，如[a6, a7]，用深度检测</li></ul><p>问题：</p><ul><li>真实求交点？<ul><li>不用，利用增量算法简化求交</li></ul></li><li>每段区间上要求 z 值最大的面，如何得知区间与哪些多边形相关<ul><li>利用扫描线的两个特殊数据结构？？？</li></ul></li></ul><h4 id="Warnock消隐算法"><a href="#Warnock消隐算法" class="headerlink" title="Warnock消隐算法"></a>Warnock消隐算法</h4><p>区域子分割算法，发明人Warnock，图像空间中非常经典的算法，其重要性不体现在其效率，而是体现在分治思想和堆栈数据结构的运用。</p><p>思想：</p><ul><li>把物体投影到全屏幕窗口</li><li>递归分割窗口，直到窗口内目标足够简单（可以显示）</li></ul><p><img src="1558351906311.png" alt="1558351906311"></p><p>如何判断窗口内图形足够简单：</p><p><img src="1558351029861.png" alt="1558351029861"></p><ol><li>仅包含一个多边形，即<strong>内含</strong></li></ol><p><img src="1558351097414.png" alt="1558351097414"></p><ol start="2"><li><p>窗口与一个多边形<strong>相交</strong>，但窗口内无其他多边形（用直线方程作判别函数）</p></li><li><p>窗口被一个多边形所<strong>包围</strong></p></li><li><p>窗口与一个多边形相<strong>分离</strong></p></li></ol><p><img src="1558351086277.png" alt="1558351086277"></p><ol start="5"><li>若窗口仅像素那么大，但仍有两个以上的面，则不必再分割，取窗口内最近的可见面颜色或所有可见面平均颜色。</li></ol><h2 id="第3章-二维图形几何变换"><a href="#第3章-二维图形几何变换" class="headerlink" title="第3章 二维图形几何变换"></a>第3章 二维图形几何变换</h2><p>本章内容：</p><ul><li>主要：向量、世界坐标系、用户坐标系、窗口与视区、齐次坐标、二维变换</li><li>向量、矩阵以及它们的运算</li><li>坐标系的概念和坐标系之间的变换 齐次坐标的概念</li><li>二维图形的各种变换</li><li>窗口与视区的变换</li></ul><h3 id="向量基础"><a href="#向量基础" class="headerlink" title="向量基础"></a>向量基础</h3><p>图形学中，处理三维物体，在意绘制对象的形状、位置、方向。</p><p>两大基本工具：向量分析、图形变换</p><p>向量：点和方向的实体（没有位置）</p><p>向量两种特殊线性组合（$w = a_1v_1 + a_2v_2+…+a_nv_n $）：</p><ul><li>仿射组合：线性组合的系数和等于 1，$ \sum\limits_{i=1}^n a_i = 1 $</li><li>凸组合：线性组合的系数和等于 1，且各系数非负，$ \sum\limits_{i=1}^n a_i = 1 （a_i \ge 0） $</li></ul><p>向量的运算，$a = (a_1, a_2)，b=(b_1,b_2) $：</p><ul><li>相加</li><li>数乘</li><li>点积：$a · b = a_1b_1+a_2b_2 = |a||b|cos\langle a,b\rangle $，用向量描述新闻，新闻相似，则向量夹角余弦接近于 1</li><li>叉积：$a=(a_x,a_y,a_z)，b=(b_x,b_y,b_z)，a \times b = \begin{vmatrix} i &amp; j &amp; k \ a_x &amp; a_y &amp; a_z \ b_x &amp; b_y &amp; b_z \end{vmatrix}=|a||b|sin\langle a,b\rangle $</li></ul><h3 id="图形坐标系"><a href="#图形坐标系" class="headerlink" title="图形坐标系"></a>图形坐标系</h3><p>坐标系：建立图形和数之间对应联系的参考系</p><p>数学坐标系分类：</p><ul><li>直角坐标系</li><li>极坐标系</li><li>圆柱坐标系</li><li>球坐标系</li></ul><p>计算机图形学坐标系分类：</p><ul><li><p>世界坐标系：公共坐标系，现实中物体或场景的统一参照系</p></li><li><p>建模坐标系：又称局部坐标系，每个物体(对象)有它自己的局部中心和坐标系</p></li><li><p>观察坐标系：依据观察窗口的方向和形状在世界坐标系中定义的坐标系。观察坐标系用于指定图形的输出范围。</p></li><li><p>设备坐标系：屏幕坐标，坐标单位是整数</p></li><li><p>规范化坐标系：归一化后的坐标，坐标轴取值范围 0~1，</p></li></ul><h3 id="二维图形变换原理"><a href="#二维图形变换原理" class="headerlink" title="二维图形变换原理"></a>二维图形变换原理</h3><p>变换：比例、旋转、镜像、错切、平移</p><p>对于一个图形，可用顶点表描述图形的几何关系，用连边表来描述图形的拓扑关系。故对图形的变换，只变换图形的顶点表</p><p>仿射变换：</p><ul><li><p>Affine Transformation</p></li><li><p>平直性：直线变换后仍是直线</p></li><li><p>平行性：平行线变换后仍平行</p></li><li><p>二维仿射变换： $\begin{cases} x ‘ = a_1x+b_1y+c_1 \ y ‘ =a_2x+b_2y+c_2 \end{cases}$</p></li><li><p>二维仿射变换，矩阵形式：$\left[ \begin{matrix} x^* &amp; y^* \end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} a_1 &amp; a_2 \ b_1 &amp; b_2 \ c_1 &amp; c_2 \end{matrix} \right] $</p></li></ul><h4 id="齐次坐标"><a href="#齐次坐标" class="headerlink" title="齐次坐标"></a>齐次坐标</h4><ul><li><p>二维平面中用(x, y)表示一个点，不妨说是一个向量(x, y)表示一个点。所以可以用第3维为常数的(x, y, 1)表示二维平面上的向量</p></li><li><p>这种n+1维表示n维的方法称为——齐次坐标表示法，n维向量 $(p_1,p_2,\cdots,p_n)$ 表示为 $(hp_1,hp_2,\cdots,hp_n, h)$，其中 $h $ 称为哑坐标，特别的 h=1 时称齐次坐标为规格化坐标。</p></li><li><p>二维仿射变换，齐次坐标表示：$\left[ \begin{matrix} x^* &amp; y^*&amp;1 \end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} a_1 &amp; a_2 &amp;0 \ b_1 &amp; b_2&amp;0 \ c_1 &amp; c_2 &amp;1\end{matrix} \right] $</p></li><li><p>不使用齐次坐标可以做比例、对称、旋转变换，但做不到平移变化，无法增加常数项。</p></li></ul><h4 id="平移变换"><a href="#平移变换" class="headerlink" title="平移变换"></a>平移变换</h4><ul><li><p>不产生变形而移动物体的<strong>刚体变换</strong>，即物体上的每个点移动相同数量的坐标</p></li><li><p>坐标形式：$\begin{cases} x^* = x+T_x \ y^*=y + T_y \end{cases} $</p></li><li><p>齐次坐标形式：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} 1 &amp; 0 &amp;0 \ 0&amp;1&amp;0 \ T_x&amp;T_y&amp;1 \end{matrix} \right] $</p></li></ul><h4 id="比例变换"><a href="#比例变换" class="headerlink" title="比例变换"></a>比例变换</h4><ul><li>相对于坐标原点沿x方向放缩$S_x$倍，沿y方向放缩$S_y$倍。S &gt; 1放大，S &lt; 1 缩小。</li><li>坐标形式：$\begin{cases} x^* = x·S_x \ y^*=y·S_y \end{cases} $</li><li>齐次坐标形式：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} S_x &amp; 0 &amp;0 \ 0&amp;S_y&amp;0 \ 0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x·S_x &amp; y·S_y &amp;1\end{matrix}\right] $</li><li>当 $S_x =S_y $ 时，为整体比例变换，$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} 1 &amp; 0 &amp;0 \ 0&amp;1&amp;0 \ 0&amp;0&amp;S \end{matrix} \right] =\left[ \begin{matrix} \frac{x}{S} &amp; \frac{y}{S} &amp;1\end{matrix}\right] $，S&gt;1缩小，0&lt;S&lt;1缩小，S&lt;0发生关于原点的对称等比变换</li></ul><h4 id="对称变换"><a href="#对称变换" class="headerlink" title="对称变换"></a>对称变换</h4><ul><li>也称镜像变换。有关于x轴、y轴、原点、某条直线的对称变换</li><li>关于 x 轴对称：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} 1 &amp; 0 &amp;0 \ 0&amp;-1&amp;0 \ 0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x&amp;-y&amp;1\end{matrix}\right] $</li><li>关于 y 轴对称：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} -1 &amp; 0 &amp;0 \ 0&amp;1&amp;0 \ 0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} -x&amp;y&amp;1\end{matrix}\right] $</li><li>关于原点对称：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} -1 &amp; 0 &amp;0 \ 0&amp;-1&amp;0 \ 0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} -x&amp;-y&amp;1\end{matrix}\right] $</li></ul><h4 id="旋转变换"><a href="#旋转变换" class="headerlink" title="旋转变换"></a>旋转变换</h4><ul><li><p>将点绕原点旋转角度 $\theta$ ，逆时针为正，顺时针为负</p></li><li><p>坐标形式（逆时针）：$\begin{cases} x^* =r·cos(\alpha+\theta)=r·cos\alpha ·cos\theta-r·sin\alpha ·sin\theta \ y^* =r·sin(\alpha+\theta)=r·cos\alpha ·sin\theta + r·sin\alpha ·cos\theta\end{cases} \Rightarrow \begin{cases} x^* =x ·cos\theta-y ·sin\theta \ y^* =x ·sin\theta + y ·cos\theta\end{cases} $</p></li><li><p>齐次坐标形式（逆时针）：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} cos\theta &amp; sin\theta &amp;0 \ -sin\theta&amp;cos\theta &amp; 0 \ 0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x ·cos\theta-y ·sin\theta &amp; x ·sin\theta + y ·cos &amp;1\end{matrix}\right] $</p></li><li><p>顺时针只要将 $\theta = -\theta $ 即可。</p></li></ul><h4 id="错切变换"><a href="#错切变换" class="headerlink" title="错切变换"></a>错切变换</h4><ul><li>弹性物体的变形处理</li></ul><p><img src="1559033084287.png" alt="1559033084287"></p><ul><li>变换矩阵中的非对角元素起着把图形沿x或y方向错切的作用</li><li>齐次坐标形式：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} 1 &amp; b &amp; 0 \ c &amp;1 &amp;0 \ 0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix}c+cy&amp;bx+y &amp;1\end{matrix}\right] $</li><li>沿 x 方向错切，即 b=0 ：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} 1 &amp; 0 &amp; 0 \ c &amp;1 &amp;0 \ 0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix}c+cy&amp;y &amp;1\end{matrix}\right] $</li></ul><h4 id="复合变换"><a href="#复合变换" class="headerlink" title="复合变换"></a>复合变换</h4><ul><li><p>图形作大于一次的变换，$P^* = P · T = P·(T_1·T_2·\cdots ·T_n) ，n\gt 1$，<strong>矩阵相乘</strong>不可交换！</p></li><li><p>二维复合平移：$T = T_{t1}·T_{t2} = \left[ \begin{matrix} 1 &amp; 0 &amp;0 \ 0&amp;1&amp;0 \ T_{x1}&amp;T_{y1}&amp;1 \end{matrix} \right] · \left[ \begin{matrix} 1 &amp; 0 &amp;0 \ 0&amp;1&amp;0 \ T_{x1}&amp;T_{y1}&amp;1 \end{matrix} \right] =\left[ \begin{matrix} 1 &amp; 0 &amp;0 \ 0&amp;1&amp;0 \ T_{x1}+T_{x2}&amp;T_{y1}+T_{y2}&amp;1 \end{matrix} \right] $</p></li><li><p>二维复合比例：$T = T_{s1}·T_{s2} = \left[ \begin{matrix} S_{x1} &amp; 0 &amp;0 \ 0&amp;S_{y1}&amp;0 \ 0&amp;0&amp;1 \end{matrix} \right]· \left[ \begin{matrix} S_{x2} &amp; 0 &amp;0 \ 0&amp;S_{y2}&amp;0 \ 0&amp;0&amp;1 \end{matrix} \right]=- C \left[ \begin{matrix} S_{x1}·S_{x2} &amp; 0 &amp;0 \ 0&amp;S_{y1}·S_{y2}&amp;0 \ 0&amp;0&amp;1 \end{matrix} \right] $</p></li><li><p>二维复合旋转：$T = T_{r1}·T_{r2} = \left[ \begin{matrix} cos\theta_1 &amp; sin\theta_1 &amp;0 \ -sin\theta_1&amp;cos\theta_1 &amp; 0 \ 0&amp;0&amp;1 \end{matrix} \right] · \left[ \begin{matrix} cos\theta_2 &amp; sin\theta_2 &amp;0 \ -sin\theta_2&amp;cos\theta_2 &amp; 0 \ 0&amp;0&amp;1 \end{matrix} \right]=\left[ \begin{matrix} cos(\theta_1+\theta_2) &amp; sin(\theta_1+\theta_2) &amp;0 \ -sin(\theta_1+\theta_2)&amp;cos(\theta_1+\theta_2) &amp; 0 \ 0&amp;0&amp;1 \end{matrix} \right] $</p></li></ul><h4 id="坐标系变换"><a href="#坐标系变换" class="headerlink" title="坐标系变换"></a>坐标系变换</h4><ul><li>图形变换经常需要从一个坐标系变换到另一个坐标系，如下图从x0y变换到x ‘ 0 ‘ y ‘</li></ul><p><img src="1559034067979.png" alt="1559034067979"></p><ul><li>上图可以拆分成，$x ‘ 0 ‘ y ‘ \xrightarrow{平移} x ‘ 0y ‘ \xrightarrow{旋转} x0y $，注意是从目标到源</li><li>$T = T_{t}·T_{r} = \left[ \begin{matrix} 1 &amp; 0 &amp;0 \ 0&amp;1&amp;0 \ -x_0&amp;-y_0&amp;1 \end{matrix} \right] · \left[ \begin{matrix} cos(-\theta) &amp; sin(-\theta) &amp;0 \ -sin(-\theta)&amp;cos(-\theta) &amp; 0 \ 0&amp;0&amp;1 \end{matrix} \right] $</li></ul><h4 id="任意参考点的几何变换"><a href="#任意参考点的几何变换" class="headerlink" title="任意参考点的几何变换"></a>任意参考点的几何变换</h4><ul><li>在以往的变换中，以 (0, 0) 为参考点，倘若以任意点为参考点，则：<ul><li>将参考点移到原点（平移）</li><li>针对原点进行二维几何变换（变换）</li><li>将原点移到参考点（反平移）</li></ul></li></ul><h4 id="二维变换矩阵"><a href="#二维变换矩阵" class="headerlink" title="二维变换矩阵"></a>二维变换矩阵</h4><ul><li><p>二维空间中某点的变化可以表示成点的齐次坐标与 3 阶的二维变换矩阵 $T_{2d} $ 相乘</p><p>$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} a&amp;b&amp;p \ c&amp;d&amp;q \ l&amp;m&amp;s \end{matrix} \right] $</p></li><li><p><img src="1559035081804.png" alt="1559035081804"></p></li></ul><h4 id="二维图形几何变换的计算"><a href="#二维图形几何变换的计算" class="headerlink" title="二维图形几何变换的计算"></a>二维图形几何变换的计算</h4><ul><li><p>点的变换：$\left[ \begin{matrix} x^* &amp; y^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; 1 \end{matrix}\right]· T $</p></li><li><p>直线的变换（两端点的变换）：$\left[ \begin{matrix} x_1^* &amp; y_1^* &amp;1 \ x_2^* &amp; y_2^* &amp;1\end{matrix}\right] =\left[ \begin{matrix} x_1 &amp; y_1 &amp;1 \ x_2 &amp; y_2 &amp;1\end{matrix}\right] ·T $</p></li><li><p>多边形的变换（每个顶点的变换）：$p =\left[ \begin{matrix} x_1^* &amp; y_1^* &amp;1 \ x_2^* &amp; y_2^* &amp;1 \ \cdots&amp;\cdots&amp;\cdots \ x_n^* &amp;y_n^*&amp;1\end{matrix}\right] $</p></li></ul><h3 id="窗口、视图及变换"><a href="#窗口、视图及变换" class="headerlink" title="窗口、视图及变换"></a>窗口、视图及变换</h3><h4 id="窗口和视区"><a href="#窗口和视区" class="headerlink" title="窗口和视区"></a>窗口和视区</h4><ul><li><p>窗口：世界坐标系中要显示的区域</p></li><li><p>视区：窗口映射到显示器上的区域</p></li><li><p>窗口定义显示什么；视区定义在何处显示</p><p><img src="1559035457686.png" alt="1559035457686"></p></li><li><p>世界坐标系中的一个窗口可以对应于多个视区</p></li></ul><p><img src="1559035487387.png" alt="1559035487387"></p><ul><li>$ 窗口\xrightarrow{观察变换} 视区$</li></ul><h4 id="观察变换"><a href="#观察变换" class="headerlink" title="观察变换"></a>观察变换</h4><ul><li><p>Viewing Transformation</p></li><li><p>变焦距效果</p><ul><li>窗口放大/缩小，视区不变，图形缩小/放大</li></ul><p><img src="1559035899696.png" alt="1559035899696"></p></li><li><p>整体缩放效果</p><ul><li>窗口不变，视区放大/缩小，图形放大/缩小</li></ul><p><img src="1559035942154.png" alt="1559035942154"></p></li></ul><h4 id="窗口到视区的变换"><a href="#窗口到视区的变换" class="headerlink" title="窗口到视区的变换"></a>窗口到视区的变换</h4><ul><li>窗口的点 -&gt; 视区的点</li></ul><p><img src="1559036093678.png" alt="1559036093678"></p><ul><li>保持比例的映射<ul><li>$\begin{cases} sx = A\times x+C \ sy = B\times y+D\end{cases}$</li><li>比例保持：$\Large \frac{x-w_{xl}}{w_{xr}-w_{xl}} = \frac{sx-v_{xl}}{v_{xr}-v_{xl}} \Rightarrow sx = \frac{x-w_{xl}}{w_{xr}-w_{xl}}(v_{xr}-v_{xl})+v_{xl}$</li><li>根据倍数关系：$\large sx = \frac{v_{xr}-v_{xl}}{w_{xr}-w_{xl}} x + (v_{xl}-\frac{v_{xr}-v_{xl}}{w_{xr}-w_{xl}} w_{xl}) = Ax + C， \ A = \frac{v_{xr}-v_{xl}}{w_{xr}-w_{xl}}，C=v_{xl}-A\times w_{xl} $</li><li>同理，$\large B= \frac{v_{yt}-v_{yb}}{w_{yt}-w_{yb}}，D=v_{yb}-B\times w_{yb} $</li></ul></li></ul><h2 id="第4章-三维图形几何变换"><a href="#第4章-三维图形几何变换" class="headerlink" title="第4章 三维图形几何变换"></a>第4章 三维图形几何变换</h2><p>主要关注：</p><ul><li>如何对三维物体进行方向、尺寸、形状的变换</li><li>三维物体在二维输出</li><li>变换有两种：几何变换、投影变换</li></ul><h3 id="三维几何变换"><a href="#三维几何变换" class="headerlink" title="三维几何变换"></a>三维几何变换</h3><p>三维基本几何变换皆是相对于坐标原点和坐标轴进行的几何变换。</p><ul><li>$p ‘ = \left[ \begin{matrix} x^* &amp; y^* &amp; z^* &amp; 1\end{matrix}\right] =\left[ \begin{matrix} x &amp; y &amp; z &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} a&amp;b&amp;c&amp;p \ d&amp;e&amp;f&amp;q \ g&amp;h&amp;i&amp;r \ l&amp;m&amp;n&amp;s \end{matrix} \right] $</li></ul><p><img src="1559044604537.png" alt="1559044604537"></p><h4 id="平移变换-1"><a href="#平移变换-1" class="headerlink" title="平移变换"></a>平移变换</h4><ul><li>$ \left[ \begin{matrix} x &amp; y &amp; z &amp; 1\end{matrix}\right] · \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ T_x&amp;T_y&amp;T_z&amp;1 \end{matrix} \right] = \left[ \begin{matrix} x+T_x &amp; y+T_y &amp; z+T_z &amp; 1\end{matrix}\right] $</li></ul><h4 id="比例变换-1"><a href="#比例变换-1" class="headerlink" title="比例变换"></a>比例变换</h4><ul><li>局部比例变换：$ \left[ \begin{matrix} x &amp; y &amp; z &amp; 1\end{matrix}\right] ·\left[ \begin{matrix} a&amp;0&amp;0&amp;0 \ 0&amp;e&amp;0&amp;0 \ 0&amp;0&amp;i&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] = \left[ \begin{matrix} ax&amp;ey&amp;iz &amp; 1\end{matrix}\right] $</li><li>整体比例变换：$ \left[ \begin{matrix} x &amp; y &amp; z &amp; 1\end{matrix}\right] ·\left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;s \end{matrix} \right] = \left[ \begin{matrix} \frac{x}{s}&amp;\frac{y}{s}&amp;\frac{z}{s} &amp; 1\end{matrix}\right] $</li></ul><h4 id="旋转变换-1"><a href="#旋转变换-1" class="headerlink" title="旋转变换"></a>旋转变换</h4><ul><li>右手定则：右手大拇指指向旋转轴的正向，其余四指指向旋转角的正向</li></ul><p><img src="1559045122619.png" alt="1559045122619"></p><ul><li><p>绕 z 轴旋转：$ \left[ \begin{matrix} x &amp; y&amp;z &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} cos\theta &amp; sin\theta &amp;0&amp;0 \ -sin\theta&amp;cos\theta &amp; 0&amp;0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x ·cos\theta-y ·sin\theta &amp; x ·sin\theta + y ·cos\theta &amp;z&amp;1\end{matrix}\right] $</p></li><li><p>绕 x 轴旋转：$ \left[ \begin{matrix} x &amp; y&amp;z &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;cos\theta &amp; sin\theta &amp;0 \ 0&amp;-sin\theta&amp;cos\theta &amp; 0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x &amp; y·cos\theta-z ·sin\theta &amp; y ·sin\theta + z ·cos\theta &amp;1\end{matrix}\right] $</p></li></ul><ul><li>绕 y 轴旋转：$ \left[ \begin{matrix} x &amp; y&amp;z &amp; 1 \end{matrix}\right]· \left[ \begin{matrix} cos\theta &amp;0&amp; -sin\theta &amp;0 \ 0&amp;1&amp;0&amp;0 \ sin\theta&amp;0&amp;cos\theta &amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x·sin\theta+x·cos\theta &amp; y &amp; z·cos\theta-x·sin\theta &amp; 1 \end{matrix}\right] $</li><li>绕任意轴旋转：</li></ul><h4 id="对称变换-1"><a href="#对称变换-1" class="headerlink" title="对称变换"></a>对称变换</h4><ul><li>关于坐标平面的对称<ul><li>关于 x0y 平面对称：$T = \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;-1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</li><li>关于 y0z 平面对称：$T = \left[ \begin{matrix} -1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</li><li>关于 z0x 平面对称：$T = \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;-1&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</li></ul></li><li>关于坐标轴的对称<ul><li>关于 x 轴对称：$T = \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;-1&amp;0&amp;0 \ 0&amp;0&amp;-1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</li><li>关于 x 轴对称：$T = \left[ \begin{matrix} -1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;-1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</li><li>关于 z 轴对称：$T = \left[ \begin{matrix} -1&amp;0&amp;0&amp;0 \ 0&amp;-1&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</li></ul></li></ul><h3 id="三维投影变换"><a href="#三维投影变换" class="headerlink" title="三维投影变换"></a>三维投影变换</h3><p>解决三维输出到二维</p><p>投影法分类（区别在于投影中心道投影面之间的距离是有/无限的）：</p><p><img src="1559047018319.png" alt="1559047018319"></p><ul><li>透视投影法（中心投影法），比如建筑透视<ul><li>表示真实看到的物体</li></ul></li><li>平行投影法<ul><li>正投影法，比如工程样图</li><li>斜投影法</li><li>表示真实大小和形状的物体</li></ul></li></ul><h4 id="平行投影"><a href="#平行投影" class="headerlink" title="平行投影"></a>平行投影</h4><p>特点：</p><ul><li>物体各个面的精确视图又平行投影而得</li><li>没有给出三维物体外表的真实性但保持比例</li></ul><p><img src="1559047046295.png" alt="1559047046295"></p><p>正投影 之 三视图：</p><p><img src="1559047352925.png" alt="1559047352925"></p><ul><li>主视图变换矩阵<ul><li>$T = \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;0&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</li></ul></li><li>俯视图变换矩阵<ul><li>$T = \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;0&amp;-1&amp;0 \ 0&amp;0&amp;0&amp;0 \ 0&amp;0&amp;-z_0&amp;1 \end{matrix} \right] $<ul><li>直接置 y=0，$T = \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;0&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</li><li>为了使俯视图与主视图都画在一个平面内，就要使H面绕x轴顺时针转90°，$T = \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;cos(-90^ \circ)&amp;sin(-90^ \circ)&amp;0 \ 0&amp;-sin(-90^ \circ)&amp;cos(-90^ \circ)&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;0&amp;-1&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</li><li>为了使主视图和俯视图有一定的间距，还要使H面沿z方向平移一段距离 $-z_0 $ ，$T = \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;-z_0 &amp;1 \end{matrix} \right] $</li></ul></li></ul></li><li>侧视图变换矩阵<ul><li>$T = \left[ \begin{matrix} 0&amp;0&amp;0&amp;0 \ -1&amp;0&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ -x_0&amp;0&amp;0&amp;1 \end{matrix} \right] $<ul><li>直接置 y=0，$T = \left[ \begin{matrix} 0&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</li><li>为了使侧视图与主视图也在一个平面内，就要使W面绕z轴正转90°，$T = \left[ \begin{matrix} cos(-90^ \circ)&amp;sin(-90^ \circ)&amp;0&amp;0 \ -sin(-90^ \circ)&amp;cos(-90^ \circ)&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} 0&amp;1&amp;0&amp;0 \ -1&amp;0&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</li><li>为使主视图和侧视图有一定的间距，还要使W面沿负x方向平移一段距离$-x_0 $，$T = \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ -x_0&amp;0&amp;0 &amp;1 \end{matrix} \right] $</li></ul></li></ul></li><li>主视图： $\left[ \begin{matrix} x ‘ &amp; y ‘ &amp;z ‘ &amp; 1 \end{matrix}\right] = \left[ \begin{matrix} x &amp; 0&amp;z &amp; 1 \end{matrix}\right]$</li><li>俯视图： $\left[ \begin{matrix} x ‘ &amp; y ‘ &amp;z ‘ &amp; 1 \end{matrix}\right] = \left[ \begin{matrix} x &amp; 0&amp;-(y+z_0 ) &amp; 1 \end{matrix}\right]$</li><li>侧视图： $\left[ \begin{matrix} x ‘ &amp; y ‘ &amp;z ‘ &amp; 1 \end{matrix}\right] = \left[ \begin{matrix} -(y+x_0) &amp; 0&amp;z &amp; 1 \end{matrix}\right] $</li><li>三个视图中的y’均为0，表明三个视图均落在xOz面上</li></ul><p>正投影 之 正轴侧：</p><ul><li>等轴侧：当投影面与三个坐标轴之间的夹角都相等</li><li>正二测：当投影面与两个坐标轴之间的夹角相等</li><li>正三测：当投影面与三个坐标轴之间的夹角都不相等</li></ul><p><img src="1559551088678.png" alt="1559551088678"></p><p><img src="1559551159470.png" alt="1559551159470"></p><p>正投影 之 正轴侧变换矩阵：</p><ul><li><p>以 V 面为轴测投影面，先将物体绕 Z 轴转 γ 角，接着绕X轴转 -α 角，最后向 V 面投影</p><p><img src="1559551322005.png" alt="1559551322005"></p></li><li><p>$T_正 = T_Z ·T_X·T_V = \left[ \begin{matrix} cos\gamma &amp; sin\gamma &amp; 0&amp;0 \ -sin\gamma &amp; cos\gamma &amp; 0&amp; 0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] · \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;cos\alpha&amp;-sin\alpha&amp;0 \ 0&amp;sin\alpha&amp;cos\alpha&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] · \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;0&amp;0&amp;0 \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] \ = \left[ \begin{matrix} cos\gamma &amp; 0 &amp; -sin\gamma sin\alpha &amp;0 \ -sin\gamma &amp; 0&amp;-cos\gamma sin\alpha &amp; 0 \ 0&amp;0&amp;cos\alpha&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</p></li><li><p>即 $\left[ \begin{matrix} x ‘ &amp; y ‘ &amp;z ‘ &amp; 1 \end{matrix}\right] = \left[ \begin{matrix} xcos\gamma-ysin\gamma &amp; 0&amp; -xsin\gamma sin\alpha-ycos\gamma sin\alpha + zcos\alpha &amp; 1 \end{matrix}\right] $</p></li><li><p>正等轴测图：取 $\gamma = 45^\circ ， \alpha = -35.26^\circ $，$T_{\text{正等轴测}} = \left[ \begin{matrix} 0.7071&amp;0&amp;-0.4082&amp;0 \ -0.7071&amp;0&amp;-0.4082&amp;0 \ 0&amp;0&amp;0.8165&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</p></li><li><p>正二测图：取 $\gamma = 20.7^\circ ， \alpha = 19.47^\circ $，$T_{\text{正二测}} = \left[ \begin{matrix} 0.9354&amp;0&amp;-0.1178&amp;0 \ -0.7071&amp;0&amp;-0.3118&amp;0 \ 0&amp;0&amp;0.9428&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $</p></li></ul><h4 id="中心投影-透视投影"><a href="#中心投影-透视投影" class="headerlink" title="中心投影(透视投影)"></a>中心投影(透视投影)</h4><p>特点：</p><ul><li>物体投影视图由计算投影线与观察平面之交点而得</li><li>生成真实感视图但不保持比例</li></ul><p><img src="1559046811865.png" alt="1559046811865"></p><ul><li>三维变换矩阵，$ T_{3D} = \left[ \begin{matrix} a&amp;b&amp;c&amp;p \ d&amp;e&amp;f&amp;q \ g&amp;h&amp;i&amp;r \ l&amp;m&amp;n&amp;s \end{matrix} \right] $，其中 p、q、r 能产生透视变换的效果。</li></ul><p><img src="1559552205924.png" alt="1559552205924"></p><p>一点透视：</p><ul><li>假设 $q \not=0，p=r=0$</li><li>$\left[ \begin{matrix} x&amp;y&amp;z&amp;1 \end{matrix} \right]· \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;q \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x&amp;y&amp;z&amp;qy+1 \end{matrix} \right] $</li><li>齐次化后：$\left[ \begin{matrix} x ‘ &amp;y ‘ &amp;z ‘ &amp;1 \end{matrix} \right]=\left[ \begin{matrix} \frac{x}{qy+1}&amp;\frac{y}{qy+1}&amp;\frac{z}{qy+1}&amp;1 \end{matrix} \right] $<ul><li>当y=0时，$\left[ \begin{matrix} x ‘ &amp;y ‘ &amp;z ‘ &amp;1 \end{matrix} \right]=\left[ \begin{matrix}x&amp;0&amp;z&amp;1 \end{matrix} \right] $，即处于 y=0 平面内的点变换后无变化</li><li>当y-&gt;∞时，$\left[ \begin{matrix} x ‘ &amp;y ‘ &amp;z ‘ &amp;1 \end{matrix} \right]=\left[ \begin{matrix}0&amp;\frac{1}{q}&amp;0&amp;1 \end{matrix} \right] $，所有点都集中到y轴的1/q处，这点叫<strong>灭点</strong></li></ul></li></ul><p><img src="1559552761561.png" alt="1559552761561"></p><ul><li>形成灭点的透视变换即为一点透视。</li><li>同样的分别假设 p、r 其中一个不为 0 ，另外两个为 0 ，都会产生灭点(1/p, 0, 0)、(0, 0, 1/r)。</li></ul><p>多点透视：</p><ul><li>根据一点透视的原理予以推广，如果p、q、r三个元素中有两个为非零元素时，将会生成两个灭点，因此得到两点透视；相应的三点透视概念也可得知。<ul><li>如当 $p\not=0，r\not=0 $，$\left[ \begin{matrix} x&amp;y&amp;z&amp;1 \end{matrix} \right]· \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;q \ 0&amp;0&amp;1&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x&amp;y&amp;z&amp;px+rz+1 \end{matrix} \right] $</li><li>齐次化后：$\left[ \begin{matrix} x ‘ &amp;y ‘ &amp;z ‘ &amp;1 \end{matrix} \right]=\left[ \begin{matrix} \frac{x}{px+rz+1}&amp;\frac{y}{px+rz+1}&amp;\frac{z}{px+rz+1}&amp;1 \end{matrix} \right] $</li><li>分别看到两个灭点，(1/p, 0, 0)、(0, 0, 1/r)</li></ul></li></ul><p><img src="1559552978511.png" alt="1559552978511"></p><p>生成透视投影图的方法：</p><p><img src="1559553468238.png" alt="1559553468238"></p><ul><li>设投影中心：c(0, 0, -d)，现在推空间一点 p(x, y, z) 的透视投影点 p ‘ (x ‘ , y ‘ , z ‘ )</li><li>$\large \triangle ABC \sim \triangle A ‘ OC \Rightarrow \frac{x ‘ }{x} =\frac{y ‘ }{y} = \frac{d}{d+z} \Rightarrow x ‘ = \frac{x}{1+z/d}，y ‘ = \frac{y}{1+z/d}，z ‘ = 0 $</li><li>矩阵形式是：$\left[ \begin{matrix} x&amp;y&amp;z&amp;1 \end{matrix} \right]· \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;1&amp;\frac{1}{d} \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] =\left[ \begin{matrix} x&amp;y&amp;z&amp;\frac{z}{d}+1 \end{matrix} \right] $<ul><li>透视坐标与z值成反比。即z值越大，透视坐标值越小</li><li>d的取值不同，可以对形成的透视图有放大和缩小的功能。当值较大时，形成的透视图变大；反之缩小。</li></ul></li><li>再乘以向投影面投影的变换矩阵，就得到点在画面上的投影$\left[ \begin{matrix} x&amp;y&amp;z&amp;1 \end{matrix} \right]· \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;1&amp;\frac{1}{d} \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] · \left[ \begin{matrix} 1&amp;0&amp;0&amp;0 \ 0&amp;1&amp;0&amp;0 \ 0&amp;0&amp;0&amp;0 \ 0&amp;0&amp;0&amp;1 \end{matrix} \right] $<ul><li>若投影中心在无穷远处，则 1/d -&gt; 0，上式变为平行投影</li></ul></li></ul><p>一点透视投影实例：</p><p><img src="1559554190675.png" alt="1559554190675"></p><ul><li>设 l=-0.8, m=-1.6, n=-2, 视距 d=-2.5</li></ul><p><img src="1559554489679.png" alt="1559554489679"></p><p>二点透视投影实例：</p><p><img src="1559554591054.png" alt="1559554591054"></p><ul><li><img src="1559554650113.png" alt="1559554650113"><ul><li>将物体平移到适当位置l、m、n</li><li>将物体绕y轴旋转θ角</li><li>进行透视变换</li><li>最后向xoy面做正投影，即得二点透视图</li></ul></li></ul><h2 id="第5章-曲线曲面"><a href="#第5章-曲线曲面" class="headerlink" title="第5章 曲线曲面"></a>第5章 曲线曲面</h2><p>描述物体的三维模型：</p><ul><li>线框模型：顶点和棱边</li><li>曲面模型：只描述物体表面和表面的连接关系，不描述物体内部的点属性</li><li>实体模型：不但有物体的外观而且也有物体内点的描述</li></ul><h3 id="曲线曲面基础"><a href="#曲线曲面基础" class="headerlink" title="曲线曲面基础"></a>曲线曲面基础</h3><h4 id="曲线曲面的非参数表示"><a href="#曲线曲面的非参数表示" class="headerlink" title="曲线曲面的非参数表示"></a>曲线曲面的非参数表示</h4><p>分为显/隐式</p><ul><li>显式表示，y = f(x)，x -&gt; y 一一对应，故不能表示封闭或多值曲线</li><li>隐式表示，f(x, y)=0，优点是容易判断点是否在曲线上</li><li>显/隐式表示存在的问题<ul><li>与坐标轴相关</li><li>用隐函数表示不直观，作图不方便</li><li>用显函数表示存在多值性</li><li>会出现斜率为无穷大的情形</li></ul></li></ul><h4 id="曲线曲面的参数表示"><a href="#曲线曲面的参数表示" class="headerlink" title="曲线曲面的参数表示"></a>曲线曲面的参数表示</h4><p>为了克服非参数表示的问题</p><ul><li>p(t) = [x(t), y(t)]、p(t) = [x(t), y(t), z(t)]，等价于笛卡尔分量表示是p(t) = x(t)i + y(t)j + z(t)k</li><li>归一化表示：$t ‘ =\frac{t-a}{b-a}（a\le t\le b） \Rightarrow p(t)（t \in [0,1]）$</li><li>曲面则可表示为双参数：$p(u, v) = p(x(u,v), y(u,v), z(u,v))，(u, v) \in [0,1]\times [0,1] $</li></ul><p>优势：</p><ul><li>可以满足几何不变性的要求。即形状的数学表示及其所表达的形状不随所取坐标系而改变的性质</li><li>更大的自由度来控制曲线、曲面的形状，$y = ax^3+bx^2+cx+d \rightarrow p(t) =\left[ \begin{matrix} a_1t^3+b_1t^2+c_1t+d_1 \ a_2t^3+b_2t^2+c_2t+d_2 \end{matrix} \right] $，有8个系数来控制曲线。</li><li>直接对参数方程进行几何变换：对非参数方程表示的曲线、曲面进行变换，必须对曲线 、曲面上的每个型值点进行几何变换；而对参数表示的曲线、曲面可对其参数方程直接进行几何变换</li><li>便于处理斜率为无穷大的情形，不会因此而中断计算</li><li>界定曲线、曲面的范围十分简单：$t \in [0,1]$</li><li>易于用向量（矢量）和矩阵运算，简化计算</li></ul><h4 id="参数曲线的相关概念"><a href="#参数曲线的相关概念" class="headerlink" title="参数曲线的相关概念"></a>参数曲线的相关概念</h4><p>内容来自微分几何（用微分的方法来研究曲线的局部性质，比如弯曲程度）</p><p><img src="1559561811659.png" alt="1559561811659"></p><ul><li><p>$\begin{cases} x=x(t) \ y=y(t) \ z=z(t)\end{cases}，p ‘ (t)=\frac{dP}{dt}，p ‘ ‘ (t)=\frac{d^2 P}{dt^2} $</p></li><li><p>位置矢量</p><ul><li>曲线上任一点的位置矢量可表示为：$p(t) = [x(t), y(t), z(t)] $</li></ul></li><li><p>切矢量</p><ul><li>选择弧长s作为参数，当 △t→0时，弦长△s→0，但方向不能趋向于0。</li><li>单位失切量：$T = \frac{dP}{ds} =\lim\limits_{\Delta x \rightarrow 0} \frac{\Delta P}{\Delta s}= \frac{dP}{dt}·\frac{dt}{ds} = \frac{P ‘ (t)}{|P ‘ (t)|}$</li></ul></li><li><p>曲率</p><ul><li>切向量再求导</li><li>几何意义：曲线的单位切向量对弧长的转动率，刻画某一点曲线的弯曲程度</li></ul><p><img src="1559562497335.png" alt="1559562497335"></p><ul><li>曲率 $ K = |T ‘ |= \lim\limits_{\Delta x \rightarrow 0} |\frac{\Delta T}{\Delta s}|= \lim\limits_{\Delta x \rightarrow 0} |\frac{T(s+\Delta s) - T(s)}{\Delta s}| = \lim\limits_{\Delta x \rightarrow 0} |\frac{\Delta \theta}{\Delta s}| $，越大曲线越弯</li><li>曲率半径 $\rho = \frac{1}{K} $ ，越小圆弧越陡越大圆弧越平缓</li></ul></li><li><p>法矢量</p><ul><li>法矢量是与切矢量垂直的向量</li></ul><p><img src="1559563874431.png" alt="1559563874431"></p></li><li><p>挠率</p><ul><li>空间曲线不但要弯曲，而且还要扭曲，即要离开它的密切平面。为了能刻画这一扭曲程度，等价于去研究密切平面的法矢量（即曲线的副法矢量）关于弧长的变化率。</li><li>挠率 τ 的绝对值等于副法线方向(或密切平面)对于弧长的转动率：$ |\tau| = \lim\limits_{\Delta x } |\frac{\Delta \theta}{\Delta s}|$</li></ul></li></ul><h4 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h4><p>自由曲线、自由曲面一般通过少数分散的点生成，这些点即“型值点”、“样本点”或“控制点”。</p><p>插值曲线：插值(interpolation)构造出来的曲线</p><p><img src="1559564532129.png" alt="1559564532129"></p><ul><li><p>线性插值</p><ul><li>f(x)在两个不同点x1和x2间值，用线形函数y=ax+b近似代替</li></ul><p><img src="1559564624619.png" alt="1559564624619"></p></li><li><p>抛物线插值</p><ul><li>f(x)在三个不同点x1、x2、x3间值，用抛物线 $\varphi (x) = ax^2+bx+c $ 近似代替</li></ul><p><img src="1559564729325.png" alt="1559564729325"></p></li></ul><h4 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h4><p>拟合曲线：构造一条曲线使之在某种意义下最接近给定的数据点(但未必通过这些点)</p><p>逼近：通常指用一些性质较好的函数近似表示一些性质不好的函数。插值和拟合都可以视为逼近</p><p>对于逼近样条，连接控制点序列的折线（控制多边形/特征多边形）通常被显示出来，以提醒设计者控制点的次序</p><p><img src="1559565055807.png" alt="1559565055807"></p><h4 id="光顺"><a href="#光顺" class="headerlink" title="光顺"></a>光顺</h4><p>指曲线的拐点不能太多（有一、二阶导数等）</p><p><img src="1559565125603.png" alt="1559565125603"></p><p>相对光顺：</p><ul><li>具有二阶几何连续性($G^2 $)</li><li>不存在多余拐点和奇异点</li><li>曲率变化较小</li></ul><h4 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h4><p>曲线段首尾相接，在连接处如何有合乎要求的连续性</p><p>曲线段 $p_i = p_i(t)，t\in [t_{i0}, t_{i1}] $</p><ul><li><p>参数连续性</p><ul><li>0阶参数连续性，又称$C^0 $连续性，指曲线的几何位置连接，即前后两曲线相接处的x,y,z值相等</li><li>1阶参数连续性，又称$C^1 $连续性，即前后两曲线相接处的一阶导数(切线)相等</li><li>2阶参数连续性，又称$C^2 $连续性，即前后两曲线相接处的一阶导数和二阶导数都相等。$C^2 $连续性交点处的切向量变化率相等，即切线从一个曲线段平滑地变化到另一个曲线段</li></ul><p><img src="1559565518737.png" alt="1559565518737"></p></li><li><p>几何连续性</p><ul><li>经典的参数连续性在图形学不适合，太苛刻。几何连续性只要求曲线段在相交处的参数导数成比例即可</li><li>0阶几何连续性，又称$G^0 $连续性。与0阶参数连续性的定义相同，满足：$ p_i(t_i1) = p_{(i+1)}(t_{(i+1)0}) $</li><li>1阶几何连续性，又称$G^1 $连续性。满足$G^0 $连续的前提下，有公共的切矢：$Q ‘ (0) = \alpha P ‘ (1)，(\alpha &gt; 0 ) $<ul><li>导数相等指大小方向都相等，公共切矢指方向相等大小不一定等</li></ul></li><li>2阶几何连续性，又称$G^2 $连续性。满足$G^1 $连续的前提下，有公共的曲率</li></ul></li></ul><h4 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h4><p>过三点构造参数表示的插值多项式有无数。</p><p>常用方法</p><ul><li>均匀参数化<ul><li>节点在参数轴等距分布</li></ul></li><li>累加弦长参数化<ul><li>根据长度的比例关系来确定 t</li><li>$\begin{cases} t_0=0 \ t_i=t_{i-1}+|\Delta P_{i-1}|,i=1,\cdots , n\end{cases}, \Delta P_i = P_{i+1}-P_i $</li></ul></li><li>向心参数化法<ul><li>向心参数化法假设在一段曲线弧上的向心力与曲线切矢从该弧段始端至末端的转角成正比，加上一些简化假设，得到向心参数化法。此法尤其适用于非均匀型值点分布。</li><li>$\begin{cases} t_0=0 \ t_i=t_{i-1}+|\Delta P_{i-1}|^{\frac{1}{2}},i=1,\cdots , n\end{cases} $</li></ul></li></ul><h4 id="参数曲线的代数形式和几何形式"><a href="#参数曲线的代数形式和几何形式" class="headerlink" title="参数曲线的代数形式和几何形式"></a>参数曲线的代数形式和几何形式</h4><ul><li><p>代数形式</p><ul><li>$\begin{cases} x(t) = a_{3x}t^3 + a_{2x}t^2 + a_{1x} t + a_{0x} \ y(t) = a_{3y}t^3 + a_{2y}t^2 + a_{1y} t + a_{0y} \ z(t) = a_{3z}t^3 + a_{2z}t^2 + a_{1z} t + a_{0z}\end{cases}, t\in [0,1] $</li><li>上式的矢量式为 $P(t) = a_3 t^3 +a_2t^2+a_1t+a_0 $，$a_i $是参数曲线的系数，且不是常数是向量，比如 $a_3 $ 对应 $a_{3x}, a_{3y}, a_{3z} $，但改变系数曲线如何变化不清楚，这是代数形式的缺点</li></ul></li><li><p>几何形式</p><ul><li>利用一条曲线端点的几何性质来刻画一条曲线，比如利用曲线的端点位置、切向量、各阶导数等端点的信息。</li><li>对三次参数曲线，若用其端点位矢P(0)、P(1)和切矢P’(0)、P’(1)描述。需要这四个量来刻画三次参数曲线</li></ul></li></ul><h4 id="Hermit曲线的推导"><a href="#Hermit曲线的推导" class="headerlink" title="Hermit曲线的推导"></a>Hermit曲线的推导</h4><p>参数曲线的几何形式，对三次参数曲线，若用其端点位矢P(0)、P(1)和切矢P’(0)、P’(1)描述。需要这四个量来刻画三次参数曲线：</p><ol><li><p>将位矢P(0)、P(1)和切矢P’(0)、P’(1) 简记为 $P_0、P_1、P_0 ‘ 、P_1 ‘ $，代入三次参数曲线 $P(t) = a_3t^3+a_2t^2+a_1t+a_0，t\in [0,1] $</p></li><li><p>得 $\begin{cases} P_0 = a_0 \ P_1 = a_3+a_2+a_1+a_0 \ P_0 ‘ = a_1 \ P_1 ‘ = 3a_3+2a_2+a_1 \end{cases} \Rightarrow \begin{cases} a_0 = P_0 \ a_1 = P_0 ‘ \ a_2 = -3P_0 + 3P_1 -2P_0 ‘ -P_1 ‘ \ a_3=2P_0 -2P_1+P_0 ‘ +P_1 ‘ \end{cases} $</p></li><li><p>回代入 $P(t) $ 得 $P(t) = (2t^3-3t^2+1)P_0 + (-2t^3+3t^2)P_1 + (t^3-2t^2+t)P_0 ‘ +(t^3-t^2)P_1 ‘ ，t\in [0,1] $</p></li><li><p>令 $ \begin{cases} F_0(t) = 2t^3-3t^2+1 \ F_1(t) = -2t^3+3t^2 \ G_0(t)=t^3-2t^2+t \ G_1(t) = t^3-t^2 \end{cases} \Rightarrow P(t) = F_0P_0 + F_1P_1 + G_0P_0 ‘ + G_1P_1 ‘ ，t\in [0,1] $</p></li></ol><p>上式即是三次 Hermit 曲线的几何形式，几何系数是 $P_0、P_1、P_0 ‘ 、P_1 ‘ $ ，调和函数是 $F_0、F_1、G_0、G_1 $。</p><h3 id="Bezier曲线与曲面"><a href="#Bezier曲线与曲面" class="headerlink" title="Bezier曲线与曲面"></a>Bezier曲线与曲面</h3><h4 id="Bezier曲线的背景"><a href="#Bezier曲线的背景" class="headerlink" title="Bezier曲线的背景"></a>Bezier曲线的背景</h4><p>插值：曲线通过所有的数据点</p><p>逼近：曲线逼近这些数据点</p><p>当用曲线段拟合曲线f(x)时，可以把曲线表示为许多小线段 $\varphi_i(x) $ 之和，其中 $\varphi_i(x) $ 称为基（混合）函数：$f(x) = \sum\limits_{i=0}^n a_i\phi_i(x) $。经常会选择多项式作基函数。</p><p>Bezier博士的想法是：先勾画折线多边形，再用光滑的参数曲线（Bezier曲线）逼近折线多边形（特征多边形）</p><p><img src="1559614251748.png" alt="1559614251748"></p><p>他的方程是： $ \begin{cases} p(t) = \sum\limits_{i=0}^n P_i · f_{i,n}(t)，t\in [0,1] \ f_{i,n}(t)= \begin{cases} 1, i=0 \ \frac{(-t)^i}{(i-1)!} \frac{d^{i-1}}{dt^{i-1}} \frac{(1-t)^{n-1}-1}{t} 称为Bezier基函数 \end{cases} \end{cases} $</p><p>后来，剑桥大学博士生Forrest证明了Bezier曲线的基函数可以简化成伯恩斯坦基函数 $B_{i,n}(t) = C_n^it^i(1-t)^{n-i} = \frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}，i=0,1,\cdots ,n $</p><h4 id="Bezier曲线的定义"><a href="#Bezier曲线的定义" class="headerlink" title="Bezier曲线的定义"></a>Bezier曲线的定义</h4><p>设空间 n+1 个点的位置矢量 $P_i，i=0,1,\cdots , n$</p><p>则Bezier曲线段的参数方程 $p(t) = \sum\limits_{i=0}^n P_i · B_{i,n}(t)，t\in [0,1]$</p><p>由二项式定理，$\sum\limits_{i=0}^n B_{i,n}(t) $ 恰好是二项式 $[t+(1-t)]^n $的展开式（$0^0 = 0! = 1$）</p><ul><li><p>一次Bezier曲线</p><ul><li>对 p(t)，当n=1，有两个控制点 p0、p1，Bezier多项式为一次多项式</li><li>$\begin{cases}p(t) = P_0B_{0,1}(t) + P_1B_{1,1}(t) \ B_{0,1}(t) = 1-t \ B_{1,1} = t \end{cases} \Rightarrow p(t) = (1-t) P_0 + tP_1 $</li><li>是连接 p0、p1 的直线段</li></ul></li><li><p>二次Bezier曲线</p><ul><li>对 p(t)，当n=2，有两个控制点 p0、p1、p2，Bezier多项式为二次多项式</li><li>$\begin{cases}p(t) = P_0B_{0,2}(t) + P_1B_{1,2}(t)+ P_2B_{2,2}(t) \ B_{0,2}(t) = (1-t)^2 \ B_{1,2} = 2t(1-t) \ B_{2,2}=t^2 \end{cases} \Rightarrow p(t) = (1-t)^2 P_0 + 2t(1-t)P_1+t^2P_2 $</li><li>是一条抛物线，其矩阵形式为 $ p(t) = \left[ \begin{matrix} t^2 &amp; t&amp;1 \end{matrix} \right] · \left[ \begin{matrix} 1&amp;-2&amp;1 \ -2&amp;2&amp;0 \ 1&amp;0&amp;0 \end{matrix} \right] · \left[ \begin{matrix} P_0 \ P_1 \ P_2 \end{matrix} \right] $</li></ul></li><li><p>三次Bezier曲线</p><ul><li>对 p(t)，当n=3，有两个控制点 p0、p1、p2、p3，Bezier多项式为三次多项式</li><li>$\begin{cases}p(t) = P_0B_{0,3}(t) + P_1B_{1,3}(t)+ P_2B_{2,2}(t) + P_3B_{3,3}(t) \ B_{0,3}(t)=(1-t)^3 \ B_{1,3}(t)=3t(1-t)^2 \ B_{2,3}(t)=3t^2(1-t) \ B_{3,3}(t)=t^3 \end{cases} \Rightarrow \ p(t) = (1-t)^3 P_0 + 3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3 $</li><li><img src="1559616363334.png" alt="1559616363334"></li><li>矩阵形式：$ p(t) = \left[ \begin{matrix}t^3 t^2 &amp; t&amp;1 \end{matrix} \right] · \left[ \begin{matrix} -1&amp;3&amp;-3&amp;1 \ 3&amp;-6&amp;3&amp;0 \ -3&amp;3&amp;0&amp;0 \ 1&amp;0&amp;0&amp;0 \end{matrix} \right] · \left[ \begin{matrix} P_0 \ P_1 \ P_2 \ P_3 \end{matrix} \right] = T·M_{be}·G_{be}$，其中 $M_{be} $ 是三次Bezier曲线系数矩阵，$G_{be} $ 是4个控制点位置矢量。</li></ul></li></ul><h4 id="Bernstein基函数的性质"><a href="#Bernstein基函数的性质" class="headerlink" title="Bernstein基函数的性质"></a>Bernstein基函数的性质</h4><p>$B_{i,n}(t) = C_n^it^i(1-t)^{n-i} = \frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}，i=0,1,\cdots ,n $</p><ul><li><p>非负性</p><ul><li>$B_{i,n}(t) = \begin{cases}=0 &amp; t=0,1 \ &gt;0 &amp; t\in(0,1),i=1,\cdots ,n-1 \end{cases}$</li></ul></li><li><p>权性</p><ul><li>$\sum\limits_{i=0}^n B_{i,n}(t) = 1， t\in(0,1) $</li></ul></li><li><p>端点性质</p><ul><li>$B_{i,n}(0) = \begin{cases}i &amp;(i=0) \ 0&amp; otherwise \end{cases} \ B_{i,n}(1) = \begin{cases}i &amp;(i=n) \ 0&amp; otherwise \end{cases} $</li></ul></li><li><p>对称性</p><ul><li>保持n次Bezier曲线控制多边形的顶点位置不变，而把次序颠倒过来，则此时曲线仍不变，只不过曲线的走向相反而已</li></ul><p><img src="1559616846775.png" alt="1559616846775"></p></li><li><p>递推性</p><ul><li>$B_{i,n}(t) = (1-t)B_{i,n-1}(t) + tB_{i-1,n-1}(t)， i=0,\cdots, n$</li></ul></li><li><p>导函数</p><ul><li>$ B ‘ {i,n}(t) = n[B_{i-1,n-1}(t) - B_{i,n-1}(t)]，i=0,\cdots, n $</li></ul></li><li><p>最大值</p><ul><li>$B_{i,n}(t) $ 在 $t =\frac{i}{n} $ 处取最大值</li></ul></li><li><p>积分</p><ul><li>$\int_0^1 B_{i,n}(t)dt = \frac{1}{n+1}$</li></ul></li><li><p>降阶公式</p><ul><li>一个n次Bernstein基函数能表示成两个n-1次基函数的线性和，$B_{i,n}(u) = (1-u)B_{i,n-1}(u)+uB_{i-1,n-1}(u) $</li></ul></li><li><p>升阶公式</p><ul><li>$ B_{i,n}(u) = (1-\frac{i}{n+1}) B_{i,n+1}(t) + \frac{i+1}{n+1} B_{i+1, n+1}(t) $</li></ul></li></ul><h4 id="Bezier曲线的性质"><a href="#Bezier曲线的性质" class="headerlink" title="Bezier曲线的性质"></a>Bezier曲线的性质</h4><ul><li><p>端点性质</p><ul><li>顶点 $p_0$ 和 $p_n$ 分别位于实际曲线段的起点和终点上</li></ul><p><img src="1559617244477.png" alt="1559617244477"></p><ul><li>$p(0) = \sum\limits_{i=0}^n P_i ·B_{i,n}(0) = P_0 \ p(1) = \sum\limits_{i=1}^n P_i · B_{i,n}(1) = P_1 $</li></ul></li><li><p>一阶导数</p><ul><li>Bernstein基函数的一阶导数 $ B’ <em>{i,n}(t) = n[B</em>{i-1,n-1}(t) - B_{i,n-1}(t)]，i=0, \cdots , n \ p ‘ (t) = n \sum\limits_{i=1}^n (p_i-p_{i-1}) B_{i-1,n-1}(t) $</li><li>$ p ‘ (0) =n(p_1-p_0) \ p ‘ (1)=n(p_n-p_{n-1}) $，这说明Bezier曲线的起点和终点处的切线方向和特征多边形的第一条边及最后一条边的走向一致。</li></ul></li><li><p>几何不变形</p><ul><li>指某些几何特性不随坐标变换而变化的特性。Bezier曲线的形状仅与控制多边形各顶点的相对位置有关，而与坐标系的的选择无关</li></ul></li><li><p>变差缩减性</p><ul><li>若Bezier曲线的特征多边形是一个平面图形，则平面内任意直线与p(t)的交点个数不多于该直线与其特征多边形的交点个数</li><li>此性质反映了Bezier曲线比其特征多边形的波动还小，也就是说Bezier曲线比特征多边形的折线更光顺</li></ul><p><img src="1559617541070.png" alt="1559617541070"></p></li></ul><h4 id="Bezier曲线的生成"><a href="#Bezier曲线的生成" class="headerlink" title="Bezier曲线的生成"></a>Bezier曲线的生成</h4><p>根据定义直接生成：</p><ul><li>给出 $C_n^i $ 的递归计算式：$C_n^i = \frac{n!}{i!(n-i)!} = \frac{n-i+1}{i}C_n^{i-1}，n \ge i $</li><li>将 $p(t) = \sum\limits_{i=0}^n P_i · B_{i,n}(t)，t\in [0,1] $ 表示成分量坐标形式： $\begin{cases} x(t) = \sum\limits_{i=0}^n x_i · B_{i,n}(t) \ y(t) = \sum\limits_{i=0}^n y_i · B_{i,n}(t) \ z(t) = \sum\limits_{i=0}^n z_i · B_{i,n}(t) \end{cases}，t\in[0,1]$</li></ul><p>de Casteljau算法（Bezier曲线的递推算法）：</p><ul><li>每次取每条线段上等比例t的点P连线，n次后得到的单一连线的比例t处是Bezier曲线上一点，不断的变化 t ( 0-&gt;1 )，即可得到Bezier曲线</li><li>二次Bezier曲线举例：</li></ul><p><img src="1559650056409.png" alt="1559650056409"></p><ul><li>三次Bezier曲线举例：</li></ul><p><img src="1559650216713.png" alt="1559650216713"></p><ul><li>公式：$P_i^k = \begin{cases} P_i &amp; k=0 \ (1-t)P_i^{k-1}+tP_{i+1}^{k-1} &amp; k=1,\cdots ,n，i=0,\cdots ,n-k \end{cases}$，$P_i $为控制点，$k $ 为第k级递推时</li></ul><p><img src="1559651613564.png" alt="1559651613564"></p><h4 id="Bezier曲线的拼接"><a href="#Bezier曲线的拼接" class="headerlink" title="Bezier曲线的拼接"></a>Bezier曲线的拼接</h4><p>几何设计中，一条Bezier曲线往往难以描述复杂的曲线形状。这是由于增加特征多边形的顶点数，会引起Bezier曲线次数的提高，而高次多项式又会带来计算上的困难。所以采用分段设计，然后将各段曲线相互连接起来，并在接合处保持一定的连续条件</p><p>拼接：</p><ul><li>给两条Bezier曲线P(t)和Q(t)，相应控制点为Pi(i =0,1,…,n)和Qi(i=0,1,…,m)</li><li>要使它们达到 $G^0 $ 连续，保证：$P_n= Q_0 $</li><li>要使它们达到 $G^1 $ 连续，保证$P_{n-1}，P_n = Q_0，Q_1 $三点共线</li></ul><p><img src="1559652788052.png" alt="1559652788052"></p><h4 id="Bezier曲线的升阶和降阶"><a href="#Bezier曲线的升阶和降阶" class="headerlink" title="Bezier曲线的升阶和降阶"></a>Bezier曲线的升阶和降阶</h4><p>升阶：保证曲线的形状和定向保持不变，增加顶点个数。比如将找一个三次多项式逼近一个二次多项式，但伯恩斯坦基函数不是简单的多项式函数。</p><p>降阶，则是反之。</p><p>Bezier升阶：</p><p><img src="1559652992898.png" alt="1559652992898"></p><ul><li><p>定义原控制顶点为 $P_0,P_1,\cdots ,P_n $，升阶增加一个顶点后仍定义为 $ P_0^<em>,P_1^</em>,\cdots ,P_{n+1}^* $</p></li><li><p>要求曲线形状和定向不变，则 $\sum\limits_{i=0}^n C_n^i P_i t^i (1-t)^{n-i} = \sum\limits_{i=0}^{n+1} C_{n+1}^i P_i^* t^i (1-t)^{n+1-i} $</p></li><li><p>对上式左乘 $(t+(1-t)) $ 得： $\sum\limits_{i=0}^n C_n^i P_i(t^i (1-t)^{n+1-i}+t^{i+1}(1-t)^{n-i}) = \sum\limits_{i=0}^{n+1} C_{n+1}^i P_i^* t^i (1-t)^{n+1-i} $</p></li><li><p>比较等式两边 $t^i(1-t)^{n+1-t} $ 项的系数，得到： $P_i^* C_{n+1}^i = P_i C_n^i +P_{i-1} C_n^{i-1} $</p></li><li><p>化简得：$P_i^* = \frac{i}{n+1}P_{i-1} + (1-\frac{i}{n+1})P_i， (i=0,\cdots ,n+1) $ 其中 $P_{-1} = P_{n+1} = (0,0) $</p><ul><li>此式说明<br>新的控制顶点 $P_i^* $ 是以参数值 $\frac{i}{n+1} $按分段线性插值从原始特征多边形得到的<br>升阶后的新特征多边形在原始特征多边形的凸包内<br>特征多边形更靠近曲线</li></ul></li></ul><p>Bezier降阶：</p><ul><li>$\begin{cases} P_i^<em>\frac{nP_i-iP_{i-1}^</em>}{n-i} &amp; i=0,1,\cdots, n-1 \ P_{i-1}^* = \frac{nP_i-(n-i)P_i^*}{i} &amp; i=n,n-1,\cdots ,1 \end{cases} $</li></ul><p>Bezier升降阶的重要性：</p><ul><li>它是CAD系统之间数据传递与交换的需要</li><li>它是系统中分段(片)线性逼近的需要，通过逐次降阶，把曲面化为直线平面，便于求交和曲面绘制</li><li>它是外形信息压缩的需要。降阶处理以后可以减少存储的信息量</li></ul><h4 id="Bezier曲面"><a href="#Bezier曲面" class="headerlink" title="Bezier曲面"></a>Bezier曲面</h4><p>基于Bezier曲线拓展给出基于Bezier曲面的定义</p><p>定义：</p><ul><li>设 $P_{i,j} （i=0,1,\cdots ,m，j=0,1,\cdots ,n）$ 为 $(n+1)\times (m+1) $ 个空间点，则 $m\times n $ Bezier曲面为：$P(u,v) = \sum\limits_{i=0}^m\sum\limits_{j=0}^n P_{ij}·B_{i,m}(u)·B_{j,n}(v) ， u,v\in[0,1] $</li><li>$ B_{i,m}(u) = C_m^i u^i (1-u)^{m-i} \ B_{j,n}(v) = C_n^j v^j (1-v)^{n-j} $</li><li>矩阵表示式：$P(u,v) = \left[ \begin{matrix} B_{0,m}(u) &amp; B_{1,m}(u)&amp; \cdots &amp; B_{m,m}(u) \end{matrix} \right] · \left[ \begin{matrix} P_{00}&amp;P_{01}&amp;\cdots&amp;P_{0n} \ P_{10}&amp;P_{11}&amp;\cdots&amp;P_{1n} \ \cdots&amp;\cdots&amp;\cdots&amp;\cdots \ P_{m0}&amp;P_{m1}&amp;\cdots&amp;P_{mn}\end{matrix} \right]· \left[ \begin{matrix}B_{0,n}(v) \ B_{1,n}(v) \ \cdots \ B_{n,n}(v) \ \end{matrix} \right]$ ​</li><li>特征网格：依次用线段连接点列中相邻两点所形成的空间网格</li></ul><p><img src="1559653679192.png" alt="1559653679192"></p><ul><li>角点位置：控制网络的四个点</li><li>边界线：Bezier曲面的四条边界线是Bezier曲线</li></ul><p><img src="1559654173150.png" alt="1559654173150"></p><p>性质：</p><ul><li><p>Bezier曲面特征网格的四个角点正好是Bezier曲面的四个角点，即 $P(0, 0) = P_{00} ， \cdots $</p></li><li><p>Bezier曲面特征网格最外一圈顶点定义Bezier曲面的四条边界</p></li><li><p>几何不变性</p></li><li><p>对称性</p></li><li><p>凸包性</p></li></ul><p>Bezier曲面片的拼接：</p><ul><li>设两张 $m\times n$ 次Bezier曲面片：$P(u,v) = \sum\limits_{i=0}^m\sum\limits_{j=0}^n P_{ij}·B_{i,m}(u)·B_{j,n}(v) ， u,v\in[0,1] \ Q(u,v) = \sum\limits_{i=0}^m\sum\limits_{j=0}^n Q_{ij}·B_{i,m}(u)·B_{j,n}(v) ， u,v\in[0,1] $</li><li>要求两曲面片达到 $G^0$ 连续，则它们有公共的边界，则 $P (1, v) = Q (0, v)\Rightarrow P_{ni}=Q_{0i}，i=0,\cdots , m $</li><li>要求沿该公共边界达到 $G^1$ 连续，则两曲面片在该边界上有公共的切平面，因此曲面的法向应跨界连续，$Q_u(0,v)\times Q_v(0,v) = \alpha(v) P_u(1,v)\times P_v(1,v) $</li></ul><p>递推(de Casteljau)算法（曲面的求值）：</p><ul><li>一条曲线可表示成两条低一次曲线的组合，则将一张曲面表示成低一次的四张曲面的线性组合</li><li>$ P_{i,j}^{k,l} = \begin{cases} P_{ij} &amp; k=l=0 \ (1-u)P_{ij}^{k-1,0}+uP_{i+1,j}^{k-1,0} &amp; k=1,\cdots ,m， l=0 \ (1-v)P_{0,j}^{m,l-1} + vP_{0,j+1}^{m,l-1} &amp; k=m， l=1,\cdots ,n \end{cases} $</li><li>按上式，以 u 为参数值对控制网格 u 方向的 n+1 个多边形执行递推算法，m级递推后，得到 n+1 个顶点 $P_{0j}^{m0} $ 构成的多边形，再以 v 参数值拿这 n+1 个顶点当作新控制顶点来算，得到 $P_{00}^{mn}$ 为曲面上一点</li></ul><h3 id="B样条曲线与曲面"><a href="#B样条曲线与曲面" class="headerlink" title="B样条曲线与曲面"></a>B样条曲线与曲面</h3><h4 id="B样条产生的背景"><a href="#B样条产生的背景" class="headerlink" title="B样条产生的背景"></a>B样条产生的背景</h4><p>Bezier曲线的不足：</p><ul><li><p>一旦确定了特征多边形的顶点数，即确定了曲线的阶次</p></li><li><p>Bezier曲线/面的拼接比较复杂</p></li><li><p>Bezier曲线/面不能作局部修改</p><ul><li>Bernstein多项式在[0, 1] 上都有支撑，故每个控制项都对 $t \in [0,1] $有影响。</li></ul><p><img src="1559741749636.png" alt="1559741749636"></p></li></ul><p>样条(Spline)：</p><ul><li><p>分段连续多项式</p></li><li><p>整条曲线用一个完整的表达形式，但内在的量是一段一段的</p><ul><li>比如5个点，用Bezier曲线构造的多项式应是四次多项式，用样条构造四段曲线，每一段都是三次，且段间 $C^2$ 连续。</li></ul></li><li><p>既克服了波动现象，曲线又是低次的。既有统一的表达时，又有统一的算法</p></li></ul><h4 id="B样条的递推定义和性质"><a href="#B样条的递推定义和性质" class="headerlink" title="B样条的递推定义和性质"></a>B样条的递推定义和性质</h4><p>Ｂ样条曲线的数学表达式为：$ P(u) = \sum\limits_{i=0}^n P_i B_{i,k}(u)，u\in[u_{k-1}, u_{n+1}] ，P_i $ 是控制多边形的顶点。对比Bezier曲线：$ P(u) = \sum\limits_{i=0}^n P_i B_{i,n}(u)，u\in[0,1] $ ，有两点不一样：</p><ul><li><p>一是伯因斯坦基函数的下标参数</p><ul><li>$ B_{i,k}(u) $ 称为 k 阶(k-1次)的B样条基函数，k 是刻画次数的。</li><li>对于Bezier曲线，阶数等于次数，B样条而言，阶数等于次数加一</li></ul></li><li><p>二是 u 的取值范围</p><ul><li>B样条基函数是一个非递减的参数u的序列（称为节点向量）所决定的k阶分段多项式</li></ul><p><img src="1559742527922.png" alt="1559742527922"></p></li></ul><p>de Boor-Cos递推定义：</p><ul><li><p>公认的最容易理解</p></li><li><p>原理：由0次构造1次，1次构造2次，依次类推。</p></li><li><p>$\large \begin{cases} B_{i,1}(u) = \begin{cases} 1&amp;u_i\lt u \lt u_{i+1} \ 0&amp;otherwise \end{cases} \ B_{i,k}(u) = \frac{u-u_i}{u_{i+k-1}-u_i}B_{i,k-1}(u) + \frac{u_{i+k}-u}{u_{i+k}-u_{i+1}} B_{i+1,k-1}(u) \end{cases} ，约定 \frac{0}{0}=0 $</p></li><li><p>若确定第i个k阶B样条 $B_{i,k}(u) $，需要用到 $u_i,u_{i+1},…,u_{i+k} $ 共k+1个节点，称区间 $ [u_i,u_{i+k}]$ 为$B_{i,k}(u) $的支撑区间</p></li><li><p>$ B_{i,1}(u) $ 是0次多项式，推出1次的 $B_{i,2}(u) $ 是一个分段函数</p><p><img src="1559743057710.png" alt="1559743057710"></p></li></ul><p>de Boor-Cos递推公式：$d_j^i = \begin{cases}d_j, &amp; l=0 \ (1-\alpha_j^l )d_{j-1}^{l-1}+\alpha_j^l d_j^{l-1}, &amp; l=1,\cdots ,阶数-1 \end{cases}， \alpha <em>j^l = \frac{u-u_j}{u</em>{j+阶数-l}-t_j } $</p><h4 id="B样条基函数定义区间及节点向量"><a href="#B样条基函数定义区间及节点向量" class="headerlink" title="B样条基函数定义区间及节点向量"></a>B样条基函数定义区间及节点向量</h4><p>ezie &amp; cr曲线的定义区间 [0, 1]</p><p>K阶B样条对应节点向量数：</p><ul><li>$B_{i,1} $涉及 $[u_i, u_{i+1}]$ 一个区间，即涉及 1 个区间 2 个节点；<br>$B_{i,2} $ 由 $B_{i,1} $ 和 $B_{i+1,1} $ 组成，即涉及 2 个区间 3 个节点；<br>…<br>$B_{i,k} $ 涉及 k 个区间 k+1 个节点。</li></ul><p>B样条函数定义区间——$u\in[u_{k-1}, u_{n+1}] $：</p><ul><li><p>即在 $[u_{k-1}, u_{n+1}] $ 产生拼接。</p></li><li><p>首先，区间要合法，区间里必要有足够的基函数与定点配对。B样条基函数严重依赖于节点向量的分布。</p></li></ul><p><img src="1559743920990.png" alt="1559743920990"></p><ul><li>上图中区间 $[u_3,u_5]（从u_{k-1}到u_{n+1}） $是第一个开始有意义的区间，故此上面的曲线被分成两段 $u_3u_4 ， u_4u_5 $，即考虑拼接 $P_0P_1P_2P_3 $ （刚好在$u_3u_4 $区间有定义）和 $P_1P_2P_3P_4 $（刚好在$u_4u_5 $区间有定义），两端有三个定点相同，拼接效果良好</li></ul><p>节点向量：</p><ul><li>$u_i $ 是节点值， $U = (u_0,u_1,\cdots ,u_{n+k}) $ 构成了k阶(k-1次)的B样条函数的节点向量</li></ul><h4 id="B样条基函数的主要性质"><a href="#B样条基函数的主要性质" class="headerlink" title="B样条基函数的主要性质"></a>B样条基函数的主要性质</h4><ul><li><p>局部支承性</p><ul><li>$B_{i,k}(u)\begin{cases} \ge 0 &amp; u\in [u_i, u_{i+k}] \ =0 &amp; otherwise \end{cases} $ 而Bezier在整个区间非0</li><li>反过来，对每一个区间 $(u_i, u_{i+k})$ ，至多只有 k 个基函数在其上非零</li></ul></li><li><p>权性</p><ul><li>$\sum\limits_{i=0}^n B_{i,k}(u) = 1，u \in [u_{k-1}, u_{n+1}] $</li></ul></li><li><p>连续性</p><ul><li>$B_{i,k}(u) $ 在 r 重节点处的连续阶不低于 k-1-r</li></ul></li><li><p>分段参数多项式</p><ul><li>$B_{i,k}(u) $ 在每个长度非零的区间 $[u_i, u_{i+1})$ 上都是次数不高于 k-1 的多项式，它在整个参数轴上是分段多项式</li></ul></li></ul><h4 id="B样条函数的主要性质"><a href="#B样条函数的主要性质" class="headerlink" title="B样条函数的主要性质"></a>B样条函数的主要性质</h4><ul><li>局部性<ul><li>k阶B样条曲线上的一点至多与k个控制顶点有关，与其它控制顶点无关</li><li>移动曲线的第i个控制顶点$P_i$ ，至多影响到定义在区间上那部分曲线的形状，对曲线其余部分不发生影响</li></ul></li><li>变差缩减性<ul><li>设平面内 n+1 个控制顶点构成B样条曲线 P(t) 的特征多边形。在该平面内的任意一条直线与 P(t) 的交点个数不多于该直线和特征多边形的交点个数</li></ul></li><li>几何不变性<ul><li>B样条曲线的形状和位置与坐标系的选择无关</li></ul></li><li>凸包性<ul><li>B样条曲线落在Pi构成的凸包之中。其凸包区域小于或等于同一组控制顶点定义的Bezier曲线凸包区域</li><li>凸包就是包含右边这6个顶点的最小凸多边形。凸多边形是把多边形的每条边延长，其它边都在它的同一侧<br><img src="1560587703864.png" alt="1560587703864"></li><li>该性质导致顺序k+1个顶点重合时，由这些顶点定义的k次B样条曲线段退化到这一个重合点；<br>顺序k+1个顶点共线时，由这些顶点定义的k次B样条曲线形状是？</li></ul></li></ul><h4 id="B样条曲线类型的划分"><a href="#B样条曲线类型的划分" class="headerlink" title="B样条曲线类型的划分"></a>B样条曲线类型的划分</h4><p>均匀B样条曲线（uniform B-splinecurve）</p><ul><li><p>当节点沿参数轴均匀等距分布，即 $u_{i+1} - u_i = 常数 \gt 0 $ 时，表示均匀B样条函数<br>{0, 1, 2, 3, 4, 5, 6}<br>{0, 0.2, 0.4, 0.6, 0.6, 0.8, 1}</p></li><li><p>均匀B样条的基函数呈周期性。即给定n和k，所有的基函数有相同形状。每个后续基函数仅仅是前面基函数在新位置上的重复：$B_{i,k}(u) = B_{i+1,k}(u+\Delta u) = B_{i+2,u}(u+2\Delta u) $</p></li><li><p>其中 $\Delta u $ 是相邻节点值的间距，等价地，可以写为： $B_{i,k}(u) = B_{0,k}(u-k\Delta u) $</p></li></ul><p>均匀周期性B样条基函数的计算举例：</p><ul><li>以均匀二次（三阶）B样条曲线为例</li><li>假定有四个控制点，取参数值 n=3，k=3，则 n+m=6，$u = (0,1,2,3,4,5,6) $</li><li>根据de Boor-Cox递推公式<br>$ P(u) = \sum\limits_{i=0}^n P_iB_{i,k}(u) $，$ \begin{cases} B_{i,1}(u) = \begin{cases} 1&amp;u_i\lt u \lt u_{i+1} \ 0&amp;otherwise \end{cases} \ B_{i,k}(u) = \frac{u-u_i}{u_{i+k-1}-u_i}B_{i,k-1}(u) + \frac{u_{i+k}-u}{u_{i+k}-u_{i+1}} B_{i+1,k-1}(u) \end{cases} ， 约定 \frac{0}{0}=0 $</li><li>算得：$ B_{0,1}(u) = \begin{cases} 1&amp;0\le u \lt 1 \ 0&amp;otherwise \end{cases}，u=(0,1,2,3,4,5,6) \ B_{0,2}(u) = uB_{0,1}(u) + (2-u)B_{1,1}(u) = \begin{cases} u &amp; 0\le u \lt 1 \ 2-u &amp; 1\le u \lt 2 \end{cases} \ B_{0,3}(u) = \frac{u}{2} B_{0,2}(u) + \frac{3-u}{2} B_{1,2}(u-1) = \begin{cases} \frac{1}{2}u^2 &amp; 0\le u \lt 1 \ \frac{1}{2}u(2-u) + \frac{1}{2}(u-1)(3-u) &amp; 1\le u\lt 2 \ \frac{1}{2}(3-u)^2 &amp; 2\le u \lt 3 \end{cases} \ B_{1,3}(u) = \begin{cases} \frac{1}{2}(u-1)^2 &amp; 1\le u \lt 2 \ \frac{1}{2} (u-1)(3-u) + \frac{1}{2}(u-2)(4-u) &amp; 2\le u \lt 3 \ \frac{1}{2}(4-u)^2 &amp; 3\le u \lt 4 \end{cases} \ B_{3,3}(u) = \begin{cases} \frac{1}{2}(u-3)^2 &amp; 3\le u \lt 4 \ \frac{1}{2} (u-3)(5-u) + \frac{1}{2}(u-4)(6-u) &amp; 4\le u \lt 5 \ \frac{1}{2}(6-u)^2 &amp; 5\le u \lt 6 \end{cases} $</li></ul><p>准均匀 B 样条曲线（Quasi-uniform B-splinecurve）：</p><p><img src="1560588911955.png" alt="1560588911955"></p><ul><li>与均匀B样条曲线的差别在于两端节点具有重复度k，这样的节点矢量定义了准均匀的B样条基</li><li>均匀：u = (0,1,2,3,4,5,6)</li><li>准均匀：u = (0,0,0,1,2,3,4,5,5,5)</li><li>均匀B样条曲线没有保留Bezier曲线端点的几何性质，采用准均匀的B样条曲线解决了这个问题</li></ul><p>分段Bezier曲线（Piecewise Bezier Curve）：</p><p><img src="1560588946151.png" alt="1560588946151"></p><ul><li>节点矢量中两端节点具有重复度k，所有内节点重复度为k-1，这样的节点矢量定义了分段的Bernstein基</li><li>B样条曲线用分段Bezier曲线表示后，各曲线段就具有了相对的独立性</li><li>另外，Bezier曲线一整套简单有效的算法都可以原封不动地采用</li><li>缺点是增加了定义曲线的数据，控制顶点数及节点数</li></ul><p>非均匀B样条曲线（non-uniform B-splinecurve）：</p><ul><li>当节点沿参数轴的分布不等距，即 $u_{i+1}-u_i \not= 常数 $ 时，表示非均匀B样条函数</li></ul><h4 id="B样条曲面"><a href="#B样条曲面" class="headerlink" title="B样条曲面"></a>B样条曲面</h4><p>给定参数轴 u 和 v 的节点矢量：$\begin{cases} U=[u_0,u_1, \cdots, u_{m+p}] \ V=[v_0,v_1, \cdots, v_{n+q}] \end{cases} $</p><p>则 $p\times q $ 阶B样条曲面定义为： $ P(u, v) = \sum\limits_{i=0}^m \sum\limits_{j=0}^n P_{i,j} N_{i,p}(u) N_{j,q}(v) $</p><p>B样条曲面的特征网络： $P_{i , j}$ 构成的一张控制网格</p><p>$N_{i,p}(u)，N_{j,v) - C$ 是B样条基，分别由节点矢量U和V按deBoor-Cox递推公式决定</p><h2 id="第6章-真实感图形学"><a href="#第6章-真实感图形学" class="headerlink" title="第6章 真实感图形学"></a>第6章 真实感图形学</h2><p>真实感图形学的三部曲：</p><ul><li>建模：建立三维场景</li><li>消隐：消隐解决物体深度的显示及确认物体内的相互关系</li><li>渲染：消隐后，在可见面上进行敏感光泽的处理，然后绘制</li></ul><p>学习本章之前，先完全记住以下单词：</p><ul><li>incident light，入射光</li><li>diffuse，扩散，漫反射</li><li>specular，缩写spec，镜面的</li><li>refracted，折射的</li><li>transparent，透明的</li><li>Distribution，分布</li><li>Intensity，光强</li></ul><h3 id="颜色模型"><a href="#颜色模型" class="headerlink" title="颜色模型"></a>颜色模型</h3><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><ul><li>颜色是人的视觉系统对可见光的感知结果，感知到的颜色由光波的波长决定。</li><li>人眼对于颜色的观察和处理是一种生理和心理现象，其机理还没有完全搞清楚。</li><li>视觉系统能感觉的波长范围为380～780nm。<br><img src="1560479200313.png" alt="1560479200313"></li></ul><h4 id="颜色模型-1"><a href="#颜色模型-1" class="headerlink" title="颜色模型"></a>颜色模型</h4><ul><li>颜色模型（颜色空间），是表示颜色的一种数学方法，人们用它来标定颜色。通常用三个参数表示。</li><li>几乎所有的颜色模型都从RGB颜色模型导出。</li><li>目前现有颜色模型还没有一个完全符合人的视觉感知特性、颜色本身的物理特性或发光物体和光反射物体的特性。</li></ul><h4 id="RGB颜色工业模型"><a href="#RGB颜色工业模型" class="headerlink" title="RGB颜色工业模型"></a>RGB颜色工业模型</h4><ul><li>如图所示，单位立方体中的三个角对应红色(R)、绿色(G)、蓝色(B)三基色，而其余三个角分别对应于三基色的补色——青色(C)、黄色(Y)、品红色(M)</li><li>从RGB单位立方体的原点即黑色(0,0,0)到白色顶点(1,1,1)的主对角线被称为灰度线，线上所有的点具有相等的分量，产生灰度色调。<br><img src="1560479318134.png" alt="1560479318134"></li></ul><h4 id="其他颜色工业模型"><a href="#其他颜色工业模型" class="headerlink" title="其他颜色工业模型"></a>其他颜色工业模型</h4><ul><li>主要用于彩色电视信号传输标准，主要有YIQ、 YUV、 YCbCr彩色模型。</li><li>三种彩色模型中，Y分量均代表黑白亮度分量，其余分量用于显示彩色信息。只需利用Y分量进行图像显示，彩色图像就转为灰度图像。</li></ul><h4 id="颜色视觉模型"><a href="#颜色视觉模型" class="headerlink" title="颜色视觉模型"></a>颜色视觉模型</h4><ul><li><p>以上彩色模型是从色度学或硬件实现的角度提出的</p></li><li><p>但用色调(Hue)、饱和度(Saturation，也称彩度)、亮度(Illumination)三要素来描述彩色空间能更好地与人的视觉特性相匹配。</p></li><li><p>颜色的三个基本属性（也称人眼视觉三要素）</p><ul><li>色调(Hue)：由物体反射光线中占优势的波长决定的，是彩色互相区分的基本特性。</li><li>饱和度(Saturation)或彩度：彩色的深浅程度，它取决于彩色中白色的含量。饱和度越高，彩色越深，白色光越少。</li><li>亮度(Illumination)：光波作用于感受器所发生的效应，它取决于物体的反射系数。反射系数越大，物体亮度越大。</li></ul><p><img src="1560479466939.png" alt="1560479466939"></p></li><li><p>HSI彩色模型是截面为三角形或圆形的锥体模型。</p><ul><li>H，色调，颜色的外观，用角度表示：如赤橙黄绿青蓝紫<br><img src="1560479643866.png" alt="1560479643866"></li><li>S，饱和度，分为<br>低(0%～20%)，不管色调如何而产生灰色<br>中(40%～60%)，产生柔和的色泽(pastel)<br>高(80%～100%)，产生鲜艳的颜色(vivid color)<br><img src="1560479708264.png" alt="1560479708264"></li><li>I，光照，颜色的量度，取值范围从0%(黑)～100%(最亮)<br><img src="1560479742546.png" alt="1560479742546"></li></ul></li></ul><h4 id="其他颜色视觉模型"><a href="#其他颜色视觉模型" class="headerlink" title="其他颜色视觉模型"></a>其他颜色视觉模型</h4><ul><li>HSV彩色模型（Hue，Saturation，Value）<br><img src="1560479832611.png" alt="1560479832611"></li><li>HSL采用亮度L(lightness)、HSV采用明度V(value)作为坐标。</li></ul><h3 id="简单光照模型"><a href="#简单光照模型" class="headerlink" title="简单光照模型"></a>简单光照模型</h3><p>光照明模型：illumination model，模拟物体表面的光照明物理现象的数学模型。简单光照明模型只考虑光源对物体的直接光照</p><h4 id="光照模型的发展"><a href="#光照模型的发展" class="headerlink" title="光照模型的发展"></a>光照模型的发展</h4><ul><li>1967年，Wylie等人第一次在显示物体时加进光照效果，认为光强与距离成反比。</li><li>1970年，Bouknight提出第一个光反射模型：Lambert漫反射＋环境光（第一个可用的光照模型）。</li><li>1971年，Gouraud提出漫反射模型加插值的思想（漫反射的意思是光强主要取决于入射光的强度和入射光与法线的夹角）。</li><li>1975年，Phong提出图形学中第一个最有影响的光照明模型 。在漫反射模型的基础上加进了高光项。</li></ul><h4 id="背景物理知识"><a href="#背景物理知识" class="headerlink" title="背景物理知识"></a>背景物理知识</h4><ul><li><p>反射定律：入射角等于反射角，而且反射光线、入射光线与法向量在同一平面上。<br><img src="1560480295590.png" alt="1560480295590"></p></li><li><p>折射定律：折射线在入射线与法线构成的平面上，折射角与入射角满足：$ \frac{\eta_1}{\eta_2} = \frac{sin \varphi}{sin \theta} $，参数是折射率和折射角</p><p><img src="1560480447843.png" alt="1560480447843"></p></li><li><p>能量守恒： $ I_i = I_d+I_s+I_t+I_v $，入射光强=漫反射光强+镜面反射光强+折射光强+吸收光强</p><ul><li>漫反射光：光线射到物体表面上后（比如泥塑物体的表面，没有一点镜面效果），光线会沿着不同的方向等量的散射出去的现象。漫反射光均匀向各方向传播，与视点无关，它是由表面的粗糙不平引起的。<br><img src="1560480565306.png" alt="1560480565306"></li><li>镜面反射光：一束光照射到一面镜子上或不绣钢的表面，光线会沿着反射光方向全部反射出去，这种叫镜面反射光。</li><li>折射光：比如水晶、玻璃等，光线会穿过去一直往前走。</li><li>吸收光：比如冬天晒太阳会感觉到温暖，这是因为吸收了太阳光。</li></ul></li></ul><h4 id="Phong光照模型"><a href="#Phong光照模型" class="headerlink" title="Phong光照模型"></a>Phong光照模型</h4><p>Phong光照模型 = 环境光+漫反射光+镜面反射光</p><p><img src="1560481251184.png" alt="1560481251184"></p><p>单一光源照射下Phong光照模型：$I = I_aK_a+I_pK_dcos\theta+I_pK_scos^n\alpha $</p><p>单一光源照射下Phong光照模型常用形式：$I = I_aK_a+I_pK_d(L·N)+ I_pK_s(R·V)^n $</p><ul><li><p>$I $ 是景物表面在被照射点处的光亮度，L是已知光源方向，V是视线的方向，R是反射光方向可计算出来，N是物体表面的法向可计算</p></li><li><p>环境光，$I_{\text{ambient}} = I_aK_a$，$I_a $环境光强度，$K_a$环境光反射系数<br>邻近各物体所产生的光的多次反射最终达到平衡时的一种光。可近似认为同一环境下的环境光，其光强分布是均匀的。</p></li><li><p>漫反射光，$I_{\text{diffuse}}=I_pK_d(L·N) ，cos\theta=L·N $，$I_p$点光源光强，$K_a$物体表面漫反射率<br>光照射到比较粗糙的物体表面，物体表面某点的明暗程度不随观测者的位置变化，这种等同地向各个方向散射的现象称为光的漫反射。漫反射光强近似服从Lambert定律</p></li><li><p>镜面反射光，$I_{\text{spec}} = I_pK_s(R·V)^n ，cos\alpha=R·V$，$I_p$点光源光强，$K_s$物体表面镜面反射率，$n$镜面高光指数，取值1-2000，反映光滑程度<br>光照射到相当光滑的物体表面，产生镜面反射光，其特点是在光滑表面会产生高光区域。</p></li></ul><p>结合RGB颜色模型后，$\begin{cases} I_r = I_{ar}K_{ar} +I_{pr}K_{dr}(L·N)+I_{pr}K_{sr}(R·V)^n \ I_g = I_{ag}K_{ag} +I_{pg}K_{dg}(L·N)+I_{pg}K_{sg}(R·V)^n \ I_b = I_{ab}K_{ab} +I_{pb}K_{db}(L·N)+I_{pb}K_{sb}(R·V)^n \end{cases} $</p><p>Phong模型扫描线算法：其中$(r,g,b) = k_a(r_{pa},g_{pa},b_{pa}) + \sum [ k_d(r_{pd},g_{pd},b_{pd})cos\theta+k_s(r_{ps},g_{ps},b_{ps})cos^n\alpha]$</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">for</span> 屏幕上每一条扫描线y <span class="hljs-keyword">do</span></span><br><span class="line">  begin</span><br><span class="line">  将数组Color初始化成为y扫描线的背景颜色值</span><br><span class="line">  <span class="hljs-keyword">for</span> y扫描线上的每一可见区间段s中的每个点(x,y) <span class="hljs-keyword">do</span></span><br><span class="line">    begin</span><br><span class="line">    设(x,y)对应的空间可见点为P</span><br><span class="line">    求出P点处的单位法向量N、P点的单位入射光向量L、单位视线向量V</span><br><span class="line">    求出L在P点的单位镜面反射向量R</span><br><span class="line">    (r,g,b) = 代码块外的那个公式</span><br><span class="line">    置Color(x,y) = (r,g,b)</span><br><span class="line">    end</span><br><span class="line">  显示Color</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p>Phong示例：</p><p><img src="1560482563690.png" alt="1560482563690"></p><p><img src="1560482585216.png" alt="1560482585216"></p><p><img src="1560482966395.png" alt="1560482966395"></p><p><img src="1560482998644.png" alt="1560482998644"></p><p><img src="1560483033546.png" alt="1560483033546"></p><p><img src="1560483210754.png" alt="1560483210754"></p><p>Phong总结：</p><ul><li>它是真实感图形学中提出的第一个有影响的光照明模型，生成图象的真实度已经达到可以接受的程度。</li><li>其模拟光从物体表面到观察者眼睛的反射。尽管这种方法符合一些基本的物理法则，但它更多的是基于对现象的观察，所以被看成是一种经验式的方法。</li><li>实际应用中，这个经验模型还有以下问题<ul><li>显示出的物体像塑料，无质感变化</li><li>没有考虑物体间相互反射光</li><li>镜面反射颜色与材质无关</li><li>镜面反射入射角大，会产生失真现象</li></ul></li></ul><h3 id="增量式光照模型"><a href="#增量式光照模型" class="headerlink" title="增量式光照模型"></a>增量式光照模型</h3><p>光暗处理的必要性：</p><ul><li>三维物体通常用多边形（三角形）来近似模拟。</li><li>由于每一个多边形的法向一致，因而多边形内部的象素颜色相同，而且在不同法向的多边形邻接处，光强突变，使具有不同光强的两个相邻区域之间的光强不连续性(马赫带效应)。</li></ul><p><img src="1560515708469.png" alt="1560515708469"></p><p><img src="1560518377316.png" alt="1560518377316"></p><p>明暗处理</p><ul><li>思想：每一个多边形的顶点处计算出光照强度或参数，然后在各个多边形内部进行均匀插值</li><li>方法<ul><li>Gouraud明暗处理（双线性光强插值算法）</li><li>Phong明暗处理（双线性法向插值算法）</li></ul></li></ul><h4 id="Gouraud明暗处理"><a href="#Gouraud明暗处理" class="headerlink" title="Gouraud明暗处理"></a>Gouraud明暗处理</h4><p>双线性光强插值</p><p>算法：</p><ol><li><p>计算多边形顶点的平均法向。<br>与某个顶点相邻的所有多边形的法向平均值近似作为该顶点的近似法向量，顶点A相邻的多边形有k个，它的法向量计算为：<br>$N_\alpha = \frac{1}{k} (N_1+N_2+\cdots +N_k)$</p></li><li><p>用Phong光照模型计算顶点的光强<br>Phong光照模型出现前，采用如下光照模型计算：<br>$I = I_aK_a+I_pK_d\frac{(L·N_\alpha)}{r+k} $</p></li></ol><p><img src="1560516640502.png" alt="1560516640502"></p><ol start="3"><li>插值计算离散边上个点的光强<br>$I_A = uI_1 +(1-u)I_2，u=\frac{AV_2}{V_1V_2} \ I_B = vI_1+(1-v)I_3，v=\frac{BV_3}{V_1V_3} $</li></ol><p><img src="1560516728563.png" alt="1560516728563"></p><ol start="4"><li>插值计算多边形内域中各点的光强<br>$I_p = tI_A + (1-t)I_B，t=\frac{PB}{AB} $<br>求任一点的光强需要进行两次插值计算</li></ol><p>扫描线增量思想的优化：<br><img src="1560517202379.png" alt="1560517202379"></p><ul><li>离散边上个点的光强<br>$I_{A,j+1} = I_{A,j} + \Delta I_A \ I_{B,j+1} = I_{B,j} + \Delta I_B \ \Delta I_A = \frac{I_1-I_2}{y_1-y_2} \ \Delta I_B = \frac{I_1-I_3}{y_1-y_3} $</li><li>扫描线内部<br>$I_{i+1, p} = I_{i,p} + \Delta I_p \ \Delta I_p = \frac{I_B-I_A}{x_B-x_A} $</li></ul><h4 id="Phong明暗处理"><a href="#Phong明暗处理" class="headerlink" title="Phong明暗处理"></a>Phong明暗处理</h4><p>Gouraud明暗处理的不足</p><ul><li>不能有镜面反射光（高光）</li><li>双线性插值是把能量往四周均匀，平均的结果就是光斑被扩大了，本来没光斑的地方插值后反而出现了光斑。</li></ul><p>Phong明暗处理以计算量、时间为代价，引入镜面反射，解决高光问题</p><p>算法：</p><ol><li>计算每个多边形顶点处的平均单位法矢量（与Gouraud明暗处理方法的第一步相同）</li><li>用双线性插值方法求得多边形内部各点的法矢量<br>$N_A $ 由 $N_1$ 和 $N_2 $ 线性插值而来<br>$N_B $ 由 $N_1$ 和 $N_3 $ 线性插值而来<br>$N_P $ 由 $N_A$ 和 $N_B $ 线性插值而来</li><li>按光照模型确定多边形内部各点的光强</li></ol><p><img src="1560517952742.png" alt="1560517952742"></p><p>两种增量式光照模型比较</p><table><thead><tr><th align="center">Phong方法</th><th align="center">Gouraud方法</th></tr></thead><tbody><tr><td align="center">产生的效果高光明显</td><td align="center">效果并不明显</td></tr><tr><td align="center">高光多位于多边形内部</td><td align="center">多边形内部无高光</td></tr><tr><td align="center">明暗变化缺乏层次感</td><td align="center">光强度变化均匀，与实际效果更接近</td></tr><tr><td align="center">计算量大</td><td align="center">计算量小</td></tr></tbody></table><p>增量式光照模型的不足</p><ul><li>物体边缘轮廓是折线段而非光滑曲线</li><li>等间距扫描线会产生不均匀效果</li><li>插值结果取决于插值方向</li></ul><h3 id="局部光照模型"><a href="#局部光照模型" class="headerlink" title="局部光照模型"></a>局部光照模型</h3><p>简单光照模型是一个比较粗糙的经验模型，不足之处在于镜面反射项与物体表面的材质无关</p><p><img src="1560521245280.png" alt="1560521245280"></p><p>局部光照模型</p><ul><li>仅处理光源直接照射物体表面，不处理物体间反射的影响</li><li>相对于简单光照模型的优点<ul><li>基于入射光能量导出的光辐射模型</li><li>反映表面的粗糙度对反射光强的影响</li><li>高光颜色与材料的物理性质有关</li><li>改进入射角很大时的失真现象</li><li>考虑了物体材质的影响，可以模拟磨光的金属光泽</li></ul></li></ul><h4 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h4><p>光的电磁理论</p><ul><li>光波是电磁波的一种，自然光照射到物体表面的反射光，其反射率系数 $\rho$ 可由 Fresnel 公式计算：<br>$\large \rho = \frac{1}{2}(\frac{tg^2(\theta - \psi)}{tg^2(\theta+\psi)} + \frac{sin^2(\theta - \psi)}{sin^2(\theta + \psi)}) $</li><li>$\theta $ 是入射角， $\psi $ 是折射角， $\eta_1，\eta_2 $是发生反射的物体表面两侧折射率，其中 $sin\psi = \frac{\eta_1}{\eta_2} sin\theta $</li><li>反射率 $\rho $ 与折射率有关，是波长的函数 $\rho (\theta, \lambda) $</li></ul><p>微平面理论</p><ul><li><p>将粗糙物体表面看成是由无数个微小的理想镜面组成，这些镜面朝向各异，随机分布，所以可用分布函数去描述</p></li><li><p>综合各种原因后，物体的反射率可以这样计算：</p><ul><li>$DG\rho(\theta, \lambda) $<br>D 为微平面法向的分布函数<br>G 为由于微平面的相互遮挡或屏蔽而使光产生的衰减因子</li></ul></li><li><p>Gauss分布函数模拟法向分布（Torrance和Sparrow两人用Gauss高斯分布来模拟，也可用Berkmann分布）</p><ul><li>$D = ke^{-(a/m)^2} $<br>k 为常系数<br>a 为微平面的法向与平均法向的夹角，即 $(N·H) $<br>m 为微平面斜率的均方根，表示表面的粗糙程度，$m =\sqrt{\frac{m_1^2+m_2^2+\cdots +m_n^2}{n}} $</li></ul></li><li><p>衰减因子 G 也可反映物体表面的粗糙程度</p><ul><li><p>$G =min(1, G_m, G_s) $<br>下图分别是无遮挡、反射光被遮挡、入射光被遮挡的情况</p><p><img src="1560520200771.png" alt="1560520200771"></p></li></ul></li></ul><h4 id="局部光照明模型"><a href="#局部光照明模型" class="headerlink" title="局部光照明模型"></a>局部光照明模型</h4><p>$I_r$ 反射光光强</p><p>$E_i$ 单位时间内单位面积上的入射光能量</p><p>$R_{bd} $ 物体表面对入射自然光的反射率系数，$R_{bd} = \frac{I_r}{E_i} $</p><p>又由于入射光能量 $E_i $ 可表示为 $E_i = I_i cos\theta · d\omega = I_i (N·L) d\omega $</p><p><img src="1560520636306.png" alt="1560520636306"></p><p>故，反射光光强：$I_r = R_{bd} I_i (N·L) d\omega $</p><p>反射率系数可表示为漫反射率和镜面反射率的代数和：$R_{bd} = K_d R_d + K_s R_s \ K_d+K_s =1 \ R_d = R_d(\lambda) \ R_s = \frac{DG\rho(\theta, \lambda)}{\pi (N·L)(N·V)} $</p><p>所以局部光照模型表示为：$ \Large I_r = I_a K_a + I_i (N·L) d \omega (K_dR_d + K_sR_s) $</p><h3 id="光透射模型"><a href="#光透射模型" class="headerlink" title="光透射模型"></a>光透射模型</h3><p>为什么考虑光透射模型：</p><ul><li>简单和局部光照模型没有考虑光的透射现象</li><li>其适用于场景中有透明或者半透明的物体的光照处理</li><li>早期用颜色调和法进行光透射模拟</li></ul><p>颜色调和法：</p><ul><li>$ I = t\times I_b +(1-t) \times I_a $</li><li>不考虑透明体对光的折射以及透明物体本身的厚度，光通过物体表面是不会改变方向的，可以模拟平面玻璃。</li></ul><p><img src="1560560948610.png" alt="1560560948610"></p><p>Whitted 光透射模型</p><ul><li>提出了第一个整体光照模型，并给出了一般光线跟踪算法的范例，综合考虑了光的反射、折射、透射和阴影等。被认为是计算机图形领域的一个里程碑。</li><li>即在简单光照明模型的基础上，加上透射光项、镜面反射光项</li><li>$\large I = I_a · K_a + I_p·K_d·(L·N)+I_p·K_s·(R·V)^n + I_t ‘ ·K_t ‘ +I_s ‘ · K_s ‘ $</li></ul><p><img src="1560561121374.png" alt="1560561121374"></p><h3 id="整体光照模型"><a href="#整体光照模型" class="headerlink" title="整体光照模型"></a>整体光照模型</h3><p>整体光照模型的诞生：</p><ul><li>简单和局部光照模型不能很好地模拟光的折射、反射和阴影等，也不能用来表示物体间的相互光照影响。</li><li>整体光照模型有光线跟踪、辐射度两种方法<br>光线跟踪效果图如下</li></ul><p><img src="1560562864127.png" alt="1560562864127"></p><p>光线跟踪基本过程：</p><ul><li>如图，点光源 L，透明体 $O_1, O_2$ ，不透明体 $O_3$</li><li>首先，视线 E 从视点出发，过视屏一个像素点，到达球体 $O_1 $ 交于点 $P_1$</li><li>交点：从 $P_1$ 向光源 $L $ 作一条阴影测试线 $S_1 $ ，发现期间没有遮挡的物体，用局部光照模型计算光源对 $P_1$ 在其视线 E 方向上的光强作为局部光强</li><li>在交点产生衍生的光线：<ul><li>反射光线 $R_1$ 方向，没有再与其他物体相交，设该方向的光强为 0，结束 $R_1$ 的跟踪</li><li>折射光线 $T_1$ 方向，与 $O_1$ 交于点 $P_2 $，由于点在物体内部，假设它的局部光强为 0<ul><li>反射光线 $R_2 $，可递归跟踪下去计算光强</li><li>看折射光线 $T_2$，与 $O_3$ 交于点 $P_3$，作阴影测试线 $S_3 $，无遮挡，计算该点局部光强。并且该点还产生了 $R_3$ 可以继续跟踪下去…</li></ul></li></ul></li></ul><p><img src="1560561607895.png" alt="1560561607895"></p><p>光线跟踪的停止：</p><ul><li>该光线未碰到任何物体</li><li>该光线碰到了背景</li><li>光线在经过许多次反射和折射以后，就会产生衰减，光线对于视点的光强贡献很小</li><li>光线反射或折射次数即跟踪深度大于一定值</li></ul><p>光线跟踪伪码：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RayTracing(start, direction, weight, ret_color)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span>(weight &lt; MinWeight) ret_color = BLACK;</span><br><span class="line">  <span class="hljs-keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    计算光线与所有物体的交点中离start最近的点;</span><br><span class="line">    <span class="hljs-keyword">if</span>(无交点) ret_color = BLACK;  </span><br><span class="line">    <span class="hljs-keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      I_local = 在交点处用局部光照模型计算出的光强;</span><br><span class="line">      计算反射方向R;</span><br><span class="line">      RayTracing(最近的交点, R, weight*W_r, I_r);</span><br><span class="line">      计算折射方向T;</span><br><span class="line">      RayTracing(最近的交点, T, weight*W_t, I_t);</span><br><span class="line">      ret_color = I_local + K_r * I_r + K_t * I_t;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>光线跟踪的加速（光线跟踪进行大量的求交运算，效率低）：</p><ul><li>提高求交速度：针对性的几何算法、…</li><li>减少求交次数：包围盒、空间索引、八叉树…<ul><li>包围盒求交测试<br><img src="1560562751334.png" alt="1560562751334"></li><li>层次包围盒求交测试<br><img src="1560562780137.png" alt="1560562780137"></li></ul></li><li>减少光线条数：颜色插值、自适应控制、…</li><li>采用广义光线和采用并行算法等</li></ul><h3 id="纹理映射和阴影处理"><a href="#纹理映射和阴影处理" class="headerlink" title="纹理映射和阴影处理"></a>纹理映射和阴影处理</h3><h4 id="纹理映射"><a href="#纹理映射" class="headerlink" title="纹理映射"></a>纹理映射</h4><p>纹理映射的作用：</p><ul><li>表面用纹理来代替，不用构造模型和材质细节，节省时间和资源</li><li>可用一个粗糙多边形和纹理来代替详细的几何构造模型，节省时间和资源</li><li>让用户做其他更重要的东西</li></ul><p><img src="1560563283932.png" alt="1560563283932"></p><p>纹理分类：</p><ul><li>颜色纹理：颜色或明暗度变化体现出来的表面细节，如刨光木材表面上的木纹。<br><img src="1560563325748.png" alt="1560563325748"></li><li>几何纹理：由不规则的细小凹凸体现出来的表面细节，如桔子皮表面的皱纹。<br><img src="1560563314392.png" alt="1560563314392"></li></ul><p>纹理定义：</p><ul><li>图象纹理：将二维纹理图案映射到三维物体表面，绘制物体表面上一点时，采用相应的纹理图案中相应点的颜色值</li><li>函数纹理：用数学函数定义简单的二维纹理图案，如方格地毯；或用数学函数定义随机高度场，生成表面粗糙纹理即几何纹理</li></ul><p><img src="1560563376530.png" alt="1560563376530"></p><p>纹理映射（Texture Mapping）：</p><ul><li><p>通过将数字化的纹理图像覆盖或投射到物体表面，而为物体表面增加表面细节的过程</p></li><li><p>寻找一种从纹理空间(u,v)到三维曲面(s, t)之间的映射关系，将点(u,v)对应的彩色参数值映射到相应的三维曲面(s, t)上，使三维曲面表面得到彩色图案</p></li><li><p>两种方法</p><ul><li>在绘制一个三角形时，为每个顶点指定纹理坐标，三角形内部点的纹理坐标由纹理三角形的对应点确定。即指定：$\begin{cases} (x_0,y_0,z_0) \rightarrow (u_0,v_0) \ (x_1,y_1,z_1) \rightarrow (u_1,v_1) \ (x_2,y_2,z_2) \rightarrow (u_2,v_2)\end{cases} $</li><li>指定映射关系，如 $\begin{cases} u=a_0x+a_1y+a_2z+a_3 \ v=b_0x+b_1y+b_2z+b_3 \end{cases}$</li></ul></li><li><p>扰动函数 $ P(u,v) $</p><ul><li>通过对景物表面各采样点的位置作微小扰动来改变表面的微观几何形状。</li><li>几何纹理使用一个称为扰动函数的数学函数进行定义。</li><li>设景物表面的参数方程 $ Q=Q(u,v) $ ，表面任一点的法线 $N = N(u,v) = \frac{Q_u(u,v) \times Q_v(u,v)}{|Q_u(u,v) \times Q_v(u,v)|} $</li><li>则扰动后的表面为 $Q ‘ = Q(u,v) + P(u,v)·N $</li></ul></li></ul><h4 id="阴影处理"><a href="#阴影处理" class="headerlink" title="阴影处理"></a>阴影处理</h4><p>阴影的定义：</p><ul><li>阴影是由于观察方向与光源方向不重合而造成的</li><li>阴影使人感到画面上景物的远近深浅，从而极大地增强画面的真实感</li></ul><p><img src="1560564211751.png" alt="1560564211751"></p><p><img src="1560564222633.png" alt="1560564222633"></p><p>阴影的概念：</p><ul><li>本影：不被任何光源所照到的区域Umbra。</li><li>半影：被部分光源所照到的区域Penumbra</li></ul><p><img src="1560564277586.png" alt="1560564277586"></p><ul><li>自身阴影：由于物体自身的遮挡而使光线照射不到它上面的某些面</li><li>投射阴影：由于物体遮挡光线，使场景中位于它后面的物体或区域受不到光照射而形成的。</li></ul><p>阴影算法——阴影体法（Shadow Volume）：</p><ul><li>由一个点光源和一个三角形可以生成一个无限大的阴影体。落在这个阴影体中的物体，就处于阴影中。</li><li>在对光线进行跟踪的过程中，若射线穿过了阴影体的一个正面（朝向视点的面），则计数器加1。若射线穿过了阴影体的一个背面（背向视点的面），则计数器减1。<br>最终计数器大于0，则说明这个像素处于阴影中，否则处于阴影之外。</li></ul><p><img src="1560564505259.png" alt="1560564505259"></p><p>阴影算法——阴影图法（Shadow Mapping）：</p><ul><li>思想是使用Z缓冲器算法，从投射阴影的光源位置对整个场景进行绘制。</li><li>对于Z缓冲器的每一个象素，它的z深度值包括了这个像素到距离光源最近点的物体的距离。一般将Z缓冲器中的整个内容称为阴影图（Shadow Map），有时候也称为阴影深度图。</li><li>从视点的角度来进行，对场景进行二次绘制。</li><li>在对每个图元进行绘制的时候，将它们的位置与阴影图进行比较，如果绘制点距离光源比阴影图中的数值还要远，那么这个点就在阴影中，否则就不在阴影中。</li></ul><p><img src="1560564946515.png" alt="1560564946515"></p><h3 id="绘制技术"><a href="#绘制技术" class="headerlink" title="绘制技术"></a>绘制技术</h3><h4 id="基于图像的绘制技术IBR"><a href="#基于图像的绘制技术IBR" class="headerlink" title="基于图像的绘制技术IBR"></a>基于图像的绘制技术IBR</h4><p>IBR，Image-Based Redering</p><p>传统图像绘制与IBR比较</p><p><img src="1560565365988.png" alt="1560565365988"></p><table><thead><tr><th align="center">传统图像绘制</th><th align="center">基于图像的绘制技术</th></tr></thead><tbody><tr><td align="center">建模复杂、困难</td><td align="center">建模简单</td></tr><tr><td align="center">计算和显示开销大，绘制速度慢</td><td align="center">显示速度快</td></tr><tr><td align="center">难以达到真实感效果</td><td align="center">真实感强</td></tr></tbody></table><p><img src="1560565401433.png" alt="1560565401433"></p><p>IBR的发展方向：</p><ul><li>与传统集合绘制方式有效结合</li><li>算法固化提高图像生成速度，达到实时绘制</li><li>分层绘制</li><li>提高Morphing中特征提取的效率和质量</li><li>图像拼接中的快速配准</li></ul><p>IBR的绘制过程：</p><p><img src="1560565443104.png" alt="1560565443104"></p><p>IBR绘制中的重要方法：</p><ul><li><p>几何和图像混合建模(Hybrid Geometry- and Image-based Approach [DTM96])</p><ul><li><p>特点</p><ul><li>可以通过拍摄的几张照片合成逼真的新视图，简单快捷</li><li>只能适用于普通建筑物等外形规整的景物</li></ul></li><li><p>过程</p><ul><li>a. 拍摄相片，交互指定建筑物边缘</li><li>b. 生成建筑物粗模型</li><li>c. 利用基于模型的立体视觉算法精化模型</li><li>d. 利用基于视点的纹理映射合成新视图</li></ul><p><img src="1560565533366.png" alt="1560565533366"></p></li></ul></li><li><p>视图插值和变形(View Interpolation[CW93] / View Morphing[SD96])</p><ul><li><p>特点</p><ul><li>简单方便，只要求几幅参考图像</li><li>漫游范围受限，只能在几幅参考图像的视点连线之间作有限运动</li><li>常用于加速图形学中的绘制速度</li></ul></li><li><p>视图插值方法(View Interpolation)：</p><p><img src="1560565677246.png" alt="1560565677246"></p><ul><li>要求新视点位于两参考图象视点所决定的直线(基线， baseline)上。由参考图线性插值产生新视图。</li><li>一般情况下不能产生正确的透视投影结果，而只生成近似的中间视图。</li></ul></li><li><p>视图变换方法(View Morphing)：</p><p><img src="1560565749103.png" alt="1560565749103"></p><ul><li>利用参考图像上像素点重投影生成新视图</li><li>利用投影知识决定的变形位置</li></ul></li></ul></li><li><p>全视函数(Plenoptic Function-based)</p><ul><li>$\mu = Plenoptic(\theta , \phi ,\lambda,V_x,V_y,V_z,t) $<br><img src="1560568775439.png" alt="1560568775439"></li></ul></li><li><p>基于光场的显示(Light Field Rendering[LH96] and Lumigraph [GGSC96])</p><ul><li>基于“自由空间中沿一条光线传递的辐射能不变” 的假设，把全视函数简化为描述离开或进入一封闭自由空间(如空立方体)的完全光流分布</li><li>由于只考虑视流信息，因此不必对反射属性作假设，不需要立体对应关系</li><li>数据量大，采样困难<br><img src="1560569404137.png" alt="1560569404137"></li></ul></li></ul><ul><li><p>图象拼接(mosaic)</p><ul><li><p>全景图(Panorama)</p><ul><li>在一个视点拍摄的几幅图像，通过整合拼接成一个视点周围的场景视图，投影在圆柱面或者球面上成为全景图。</li><li>只需在一个视点拍摄的几张照片，数据量小，采样方便。</li><li>视点不能移动，但是可以转动观察方向，通过放大缩小（zoomin/zoom out)进行近似的前后运动<br><img src="1560569467655.png" alt="1560569467655"></li></ul></li><li><p>同心拼接(Concentric Mosaic)<br><img src="1560569539684.png" alt="1560569539684"></p><ul><li><p>通过沿一系列同心圆切线方向拍摄的狭缝图像拼合成同心拼接</p><p><img src="1560569574287.png" alt="1560569574287"><br><img src="1560569612671.png" alt="1560569612671"><br><img src="1560569644061.png" alt="1560569644061"></p></li><li><p>特点：<br>只需在一个圆上拍摄的一系列图像，采样方便<br>视点可以在采样圆内做平面移动，生成场景真实感强<br>数据量较光场等全视函数方法为小<br>移动范围受限，基于狭缝图象的绘制：有场景畸变现象</p></li></ul></li><li><p>基于狭缝图象段的绘制</p><ul><li>将同心拼接中使用的狭缝图象进一步分为狭缝图象段</li><li>测定不同距离上对应狭缝图象段的伸缩比例</li><li>利用狭缝图象段的伸缩进行正确的绘制<br><img src="1560569714876.png" alt="1560569714876"></li></ul></li></ul></li><li><p>立体视觉(Stereo Vision)</p></li></ul><h4 id="基于点的建模与绘制"><a href="#基于点的建模与绘制" class="headerlink" title="基于点的建模与绘制"></a>基于点的建模与绘制</h4><p>Point based Rendering</p><p>随着模型多边形复杂度的剧增，点模型的优势越发明显。</p><p>点模型的数字几何处理流程：</p><ul><li>点的获取<ul><li>3D扫描仪（深度照相机生成的深度图和激光三维扫描仪等设备得到的大量空间三维点位置）</li><li>点模型的另一个来源是现有模型 ，大部分几何模型如多边形网格模型、隐式曲面等都能方便地转化为点模型</li></ul></li><li>点的处理<ul><li>配准<ul><li>机器配准：标签法</li><li>自动配准：特征提取法</li></ul></li><li>去噪<ul><li>移动最小二乘（MLS）曲面逼近原始点集模型</li><li>基于三维Meanshift过程的各向异性点模型去噪算法</li><li>MLS曲面重建方法</li><li>点模型的非局部去噪方法</li><li>基于采样保真性的点模型去噪算法</li></ul></li><li>修补<ul><li>基于上下文的点模型修复<br><img src="1560586117047.png" alt="1560586117047"></li></ul></li></ul></li><li>点的建模<ul><li>目标：从原始点云中构造出一个连续的表面模型</li><li>涉及的技术较多，曲面重建、曲面简化、几何属性分析、特征提取、重采样<br>点模型的后期处理则是对点模型作进一步的造型处理：编辑、变形、布尔运算</li><li>曲面重建技术<ul><li>指根据离散扫描点数据重建三维模型的过程</li><li>常用方法：<br>RBF(Radial Basis Function)曲面重建方法<br>MLS(Moving Least-Square)曲面</li></ul></li><li>曲面简化技术<ul><li>利用三维扫描仪获得的点模型通常具有很高的复杂度，为了使大规模数据模型符合几何处理和绘制，必须对数据模型进行简化</li></ul></li><li>点模型编辑技术<ul><li>对点模型的颜色、纹理等外观属性以及法向量的处理。例如下图是点模型的画刷着色效果图。<br><img src="1560586690511.png" alt="1560586690511"></li></ul></li><li>几何造型技术<ul><li>实体几何造型(CSG：Constructive Solid Geometry)<br>一种基于简单实体的布尔运算构造复杂模型的技术，即通过对多个简单的点模型进行布尔运算后生成复杂的点模型。<br><img src="1560586744373.png" alt="1560586744373"></li><li>自由变形<br>这种变形技术首先生成一个置换函数 d： $R^3\rightarrow R^3 $，然后对表面上的每个点 $P_i$ ，实施变换 $P_i \rightarrow d(P_i ) $</li><li>点模型动画(MFM：Mesh Free Method)<br>力学分析的新方法，近年来研究者将无网格方法和点模型相结合，提出了基于点的动画。例如： 模型形变<br><img src="1560586775433.png" alt="1560586775433"></li></ul></li><li>模型渐变(Morphing)技术<ul><li>点模型自身的特点决定了在模型渐变中，它比基于网格模型的渐变有明显的优势，但由于点模型没有提供表面的解析表达式和参数化信息，从另一方面又增加了它渐变的难度。<br><img src="1560587005820.png" alt="1560587005820"></li><li>基于物理的渐变<br>需要建立相关物理模型，中间过渡点模型根据能量方程求解，这种渐变在一定程度上模拟了真实的物理现象</li><li>基于几何的渐变<br>通过对源和目标模型进行几何变换来获得中间过渡模型，其计算量没有基于物理的渐变大</li></ul></li></ul></li><li>点模型的绘制，如Qsplat技术<ul><li>由斯坦福大学开发的具有代表性的点绘制技术。</li><li>它利用树状层次包围球数据结构，树中每个结点包含球的位置和半径、每点处的法向量、法锥面的宽度、颜色值。</li><li>在进行绘制时，层次树按深度优先方法递归遍历。<br>对每个中间结点，首先判断该球是否完全在屏幕外或者是完全背向的，以进行可见性选择。<br>如果该结点至少有一部分子结点是可见的，则将该结点在屏幕上的投影大小同一个阈值进行比较。<br>如果大于阈值，则继续向下递归；<br>如果小于阈值或者已经到达叶结点，则按该结点的球位置及半径确定的屏幕上的位置和大小绘制一个小区域。</li></ul></li></ul><p>基于点的建模与绘制的发展趋势：</p><ul><li>基于点的自然场景建模</li><li>基于点模型的动画</li><li>点模型的简化、压缩和传输</li><li>基于GPU的大规模点模型绘制</li></ul></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://zhangt.top/CS/Computer-Graphics-Study-Notes/">计算机图形学-学习笔记</a></li><li><strong>本文作者：</strong><a href="https://zhangt.top">ZhangT</a></li><li><strong>本文链接：</strong><a href="https://zhangt.top/CS/Computer-Graphics-Study-Notes/">https://zhangt.top/CS/Computer-Graphics-Study-Notes/</a></li><li><strong>发布时间：</strong>2019-05-02</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><hr style="height:1px;margin:1rem 0"><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><i class="fas fa-tags has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/tags/ComputerGraphics/">ComputerGraphics</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？投喂一下吧！ヾ(●´∀｀●)</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i> </span><span>支付宝</span><div class="qrcode"><img src="/images/alipay.jpg" alt="支付宝"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/CS/Computer-Vision-Study-Notes/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">计算机视觉-学习笔记</span></a></div><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/CS/Computer-Network-Study-Notes/"><span class="level-item">计算机网络-学习笔记</span> <i class="level-item fas fa-chevron-right"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"91f36240e98756fc091e",clientSecret:"20de2f4dadd54bc04ad8db6c1090fb00a9477ac4",id:"006f4f93dcafa7861d014e98a399ed52",repo:"zhangt2333.github.io",owner:"zhangt2333",admin:"zhangt2333",createIssueManually:!1,distractionFreeMode:!1});gitalk.render("comment-container")</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered"><div><img class="image is-96x96 has-mb-6" src="/images/avatar.png" alt="Zhang T"><p class="is-size-4 is-block">Zhang T</p><p class="is-size-6 is-block">感受我的感受</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Nanjing &lt;- Qingdao, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><div class="level-item has-text-centered is-marginless"><a href="/archives/"><p class="heading">文章</p><p class="title has-text-weight-normal">19</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/categories/"><p class="heading">分类</p><p class="title has-text-weight-normal">5</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/tags/"><p class="heading">标签</p><p class="title has-text-weight-normal">21</p></a></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/zhangt2333" target="_blank"><i class="fab fa-github"></i>&nbsp;&nbsp;关注我</a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu" style="max-height:750px;overflow:auto"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#第1章-绪论"><span class="has-mr-6">1</span> <span>第1章 绪论</span></a><ul class="menu-list"><li><a class="is-flex" href="#全书概述"><span class="has-mr-6">1.1</span> <span>全书概述</span></a></li><li><a class="is-flex" href="#计算机图形学定义"><span class="has-mr-6">1.2</span> <span>计算机图形学定义</span></a></li><li><a class="is-flex" href="#计算机图形学研究内容"><span class="has-mr-6">1.3</span> <span>计算机图形学研究内容</span></a></li><li><a class="is-flex" href="#计算机图形学的发展历史"><span class="has-mr-6">1.4</span> <span>计算机图形学的发展历史</span></a></li><li><a class="is-flex" href="#计算机图形学的应用领域"><span class="has-mr-6">1.5</span> <span>计算机图形学的应用领域</span></a></li><li><a class="is-flex" href="#图形显示设备"><span class="has-mr-6">1.6</span> <span>图形显示设备</span></a></li><li><a class="is-flex" href="#图形学相关概念"><span class="has-mr-6">1.7</span> <span>图形学相关概念</span></a></li><li><a class="is-flex" href="#图形图像的区别及存储格式"><span class="has-mr-6">1.8</span> <span>图形图像的区别及存储格式</span></a></li></ul></li><li><a class="is-flex" href="#第2章-光栅图形学"><span class="has-mr-6">2</span> <span>第2章 光栅图形学</span></a><ul class="menu-list"><li><a class="is-flex" href="#直线段的扫描转换"><span class="has-mr-6">2.1</span> <span>直线段的扫描转换</span></a><ul class="menu-list"><li><a class="is-flex" href="#数值微分法（DDA）"><span class="has-mr-6">2.1.1</span> <span>数值微分法（DDA）</span></a></li><li><a class="is-flex" href="#中点画线法"><span class="has-mr-6">2.1.2</span> <span>中点画线法</span></a></li><li><a class="is-flex" href="#Bresenham算法"><span class="has-mr-6">2.1.3</span> <span>Bresenham算法</span></a></li></ul></li><li><a class="is-flex" href="#圆弧的扫描转换"><span class="has-mr-6">2.2</span> <span>圆弧的扫描转换</span></a><ul class="menu-list"><li><a class="is-flex" href="#圆的八对称性"><span class="has-mr-6">2.2.1</span> <span>圆的八对称性</span></a></li><li><a class="is-flex" href="#中点画圆法"><span class="has-mr-6">2.2.2</span> <span>中点画圆法</span></a></li><li><a class="is-flex" href="#中点画椭圆法"><span class="has-mr-6">2.2.3</span> <span>中点画椭圆法</span></a></li></ul></li><li><a class="is-flex" href="#多边形的扫描转换"><span class="has-mr-6">2.3</span> <span>多边形的扫描转换</span></a><ul class="menu-list"><li><a class="is-flex" href="#X-扫描线算法-活性边表法"><span class="has-mr-6">2.3.1</span> <span>X-扫描线算法(活性边表法)</span></a></li><li><a class="is-flex" href="#边界标志算法"><span class="has-mr-6">2.3.2</span> <span>边界标志算法</span></a></li><li><a class="is-flex" href="#边缘填充算法"><span class="has-mr-6">2.3.3</span> <span>边缘填充算法</span></a></li><li><a class="is-flex" href="#栅栏填充算法"><span class="has-mr-6">2.3.4</span> <span>栅栏填充算法</span></a></li></ul></li><li><a class="is-flex" href="#多边形的区域填充"><span class="has-mr-6">2.4</span> <span>多边形的区域填充</span></a><ul class="menu-list"><li><a class="is-flex" href="#区域填充算法-泛滥填充算法"><span class="has-mr-6">2.4.1</span> <span>区域填充算法(泛滥填充算法)</span></a></li><li><a class="is-flex" href="#扫描线种子填充算法"><span class="has-mr-6">2.4.2</span> <span>扫描线种子填充算法</span></a></li><li><a class="is-flex" href="#扫描转换与区域填充的不同"><span class="has-mr-6">2.4.3</span> <span>扫描转换与区域填充的不同</span></a></li></ul></li><li><a class="is-flex" href="#反走样"><span class="has-mr-6">2.5</span> <span>反走样</span></a><ul class="menu-list"><li><a class="is-flex" href="#走样现象"><span class="has-mr-6">2.5.1</span> <span>走样现象</span></a></li><li><a class="is-flex" href="#反走样技术原理"><span class="has-mr-6">2.5.2</span> <span>反走样技术原理</span></a></li><li><a class="is-flex" href="#非加权区域采样方法"><span class="has-mr-6">2.5.3</span> <span>非加权区域采样方法</span></a></li><li><a class="is-flex" href="#加权区域采样方法"><span class="has-mr-6">2.5.4</span> <span>加权区域采样方法</span></a></li></ul></li><li><a class="is-flex" href="#直线裁剪算法"><span class="has-mr-6">2.6</span> <span>直线裁剪算法</span></a><ul class="menu-list"><li><a class="is-flex" href="#裁剪"><span class="has-mr-6">2.6.1</span> <span>裁剪</span></a></li><li><a class="is-flex" href="#Cohen-Sutherland算法"><span class="has-mr-6">2.6.2</span> <span>Cohen-Sutherland算法</span></a></li><li><a class="is-flex" href="#中点分割算法"><span class="has-mr-6">2.6.3</span> <span>中点分割算法</span></a></li><li><a class="is-flex" href="#Liang-Barsky算法"><span class="has-mr-6">2.6.4</span> <span>Liang-Barsky算法</span></a></li></ul></li><li><a class="is-flex" href="#多边形裁剪"><span class="has-mr-6">2.7</span> <span>多边形裁剪</span></a><ul class="menu-list"><li><a class="is-flex" href="#Sutherland-Hodgeman多边形裁剪"><span class="has-mr-6">2.7.1</span> <span>Sutherland-Hodgeman多边形裁剪</span></a></li></ul></li><li><a class="is-flex" href="#文字裁剪"><span class="has-mr-6">2.8</span> <span>文字裁剪</span></a></li><li><a class="is-flex" href="#消隐算法"><span class="has-mr-6">2.9</span> <span>消隐算法</span></a><ul class="menu-list"><li><a class="is-flex" href="#画家算法"><span class="has-mr-6">2.9.1</span> <span>画家算法</span></a></li><li><a class="is-flex" href="#Z缓冲区-Z-Buffer-算法"><span class="has-mr-6">2.9.2</span> <span>Z缓冲区(Z-Buffer)算法</span></a></li><li><a class="is-flex" href="#区间扫描线算法"><span class="has-mr-6">2.9.3</span> <span>区间扫描线算法</span></a></li><li><a class="is-flex" href="#Warnock消隐算法"><span class="has-mr-6">2.9.4</span> <span>Warnock消隐算法</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第3章-二维图形几何变换"><span class="has-mr-6">3</span> <span>第3章 二维图形几何变换</span></a><ul class="menu-list"><li><a class="is-flex" href="#向量基础"><span class="has-mr-6">3.1</span> <span>向量基础</span></a></li><li><a class="is-flex" href="#图形坐标系"><span class="has-mr-6">3.2</span> <span>图形坐标系</span></a></li><li><a class="is-flex" href="#二维图形变换原理"><span class="has-mr-6">3.3</span> <span>二维图形变换原理</span></a><ul class="menu-list"><li><a class="is-flex" href="#齐次坐标"><span class="has-mr-6">3.3.1</span> <span>齐次坐标</span></a></li><li><a class="is-flex" href="#平移变换"><span class="has-mr-6">3.3.2</span> <span>平移变换</span></a></li><li><a class="is-flex" href="#比例变换"><span class="has-mr-6">3.3.3</span> <span>比例变换</span></a></li><li><a class="is-flex" href="#对称变换"><span class="has-mr-6">3.3.4</span> <span>对称变换</span></a></li><li><a class="is-flex" href="#旋转变换"><span class="has-mr-6">3.3.5</span> <span>旋转变换</span></a></li><li><a class="is-flex" href="#错切变换"><span class="has-mr-6">3.3.6</span> <span>错切变换</span></a></li><li><a class="is-flex" href="#复合变换"><span class="has-mr-6">3.3.7</span> <span>复合变换</span></a></li><li><a class="is-flex" href="#坐标系变换"><span class="has-mr-6">3.3.8</span> <span>坐标系变换</span></a></li><li><a class="is-flex" href="#任意参考点的几何变换"><span class="has-mr-6">3.3.9</span> <span>任意参考点的几何变换</span></a></li><li><a class="is-flex" href="#二维变换矩阵"><span class="has-mr-6">3.3.10</span> <span>二维变换矩阵</span></a></li><li><a class="is-flex" href="#二维图形几何变换的计算"><span class="has-mr-6">3.3.11</span> <span>二维图形几何变换的计算</span></a></li></ul></li><li><a class="is-flex" href="#窗口、视图及变换"><span class="has-mr-6">3.4</span> <span>窗口、视图及变换</span></a><ul class="menu-list"><li><a class="is-flex" href="#窗口和视区"><span class="has-mr-6">3.4.1</span> <span>窗口和视区</span></a></li><li><a class="is-flex" href="#观察变换"><span class="has-mr-6">3.4.2</span> <span>观察变换</span></a></li><li><a class="is-flex" href="#窗口到视区的变换"><span class="has-mr-6">3.4.3</span> <span>窗口到视区的变换</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第4章-三维图形几何变换"><span class="has-mr-6">4</span> <span>第4章 三维图形几何变换</span></a><ul class="menu-list"><li><a class="is-flex" href="#三维几何变换"><span class="has-mr-6">4.1</span> <span>三维几何变换</span></a><ul class="menu-list"><li><a class="is-flex" href="#平移变换-1"><span class="has-mr-6">4.1.1</span> <span>平移变换</span></a></li><li><a class="is-flex" href="#比例变换-1"><span class="has-mr-6">4.1.2</span> <span>比例变换</span></a></li><li><a class="is-flex" href="#旋转变换-1"><span class="has-mr-6">4.1.3</span> <span>旋转变换</span></a></li><li><a class="is-flex" href="#对称变换-1"><span class="has-mr-6">4.1.4</span> <span>对称变换</span></a></li></ul></li><li><a class="is-flex" href="#三维投影变换"><span class="has-mr-6">4.2</span> <span>三维投影变换</span></a><ul class="menu-list"><li><a class="is-flex" href="#平行投影"><span class="has-mr-6">4.2.1</span> <span>平行投影</span></a></li><li><a class="is-flex" href="#中心投影-透视投影"><span class="has-mr-6">4.2.2</span> <span>中心投影(透视投影)</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第5章-曲线曲面"><span class="has-mr-6">5</span> <span>第5章 曲线曲面</span></a><ul class="menu-list"><li><a class="is-flex" href="#曲线曲面基础"><span class="has-mr-6">5.1</span> <span>曲线曲面基础</span></a><ul class="menu-list"><li><a class="is-flex" href="#曲线曲面的非参数表示"><span class="has-mr-6">5.1.1</span> <span>曲线曲面的非参数表示</span></a></li><li><a class="is-flex" href="#曲线曲面的参数表示"><span class="has-mr-6">5.1.2</span> <span>曲线曲面的参数表示</span></a></li><li><a class="is-flex" href="#参数曲线的相关概念"><span class="has-mr-6">5.1.3</span> <span>参数曲线的相关概念</span></a></li><li><a class="is-flex" href="#插值"><span class="has-mr-6">5.1.4</span> <span>插值</span></a></li><li><a class="is-flex" href="#拟合"><span class="has-mr-6">5.1.5</span> <span>拟合</span></a></li><li><a class="is-flex" href="#光顺"><span class="has-mr-6">5.1.6</span> <span>光顺</span></a></li><li><a class="is-flex" href="#连续性"><span class="has-mr-6">5.1.7</span> <span>连续性</span></a></li><li><a class="is-flex" href="#参数化"><span class="has-mr-6">5.1.8</span> <span>参数化</span></a></li><li><a class="is-flex" href="#参数曲线的代数形式和几何形式"><span class="has-mr-6">5.1.9</span> <span>参数曲线的代数形式和几何形式</span></a></li><li><a class="is-flex" href="#Hermit曲线的推导"><span class="has-mr-6">5.1.10</span> <span>Hermit曲线的推导</span></a></li></ul></li><li><a class="is-flex" href="#Bezier曲线与曲面"><span class="has-mr-6">5.2</span> <span>Bezier曲线与曲面</span></a><ul class="menu-list"><li><a class="is-flex" href="#Bezier曲线的背景"><span class="has-mr-6">5.2.1</span> <span>Bezier曲线的背景</span></a></li><li><a class="is-flex" href="#Bezier曲线的定义"><span class="has-mr-6">5.2.2</span> <span>Bezier曲线的定义</span></a></li><li><a class="is-flex" href="#Bernstein基函数的性质"><span class="has-mr-6">5.2.3</span> <span>Bernstein基函数的性质</span></a></li><li><a class="is-flex" href="#Bezier曲线的性质"><span class="has-mr-6">5.2.4</span> <span>Bezier曲线的性质</span></a></li><li><a class="is-flex" href="#Bezier曲线的生成"><span class="has-mr-6">5.2.5</span> <span>Bezier曲线的生成</span></a></li><li><a class="is-flex" href="#Bezier曲线的拼接"><span class="has-mr-6">5.2.6</span> <span>Bezier曲线的拼接</span></a></li><li><a class="is-flex" href="#Bezier曲线的升阶和降阶"><span class="has-mr-6">5.2.7</span> <span>Bezier曲线的升阶和降阶</span></a></li><li><a class="is-flex" href="#Bezier曲面"><span class="has-mr-6">5.2.8</span> <span>Bezier曲面</span></a></li></ul></li><li><a class="is-flex" href="#B样条曲线与曲面"><span class="has-mr-6">5.3</span> <span>B样条曲线与曲面</span></a><ul class="menu-list"><li><a class="is-flex" href="#B样条产生的背景"><span class="has-mr-6">5.3.1</span> <span>B样条产生的背景</span></a></li><li><a class="is-flex" href="#B样条的递推定义和性质"><span class="has-mr-6">5.3.2</span> <span>B样条的递推定义和性质</span></a></li><li><a class="is-flex" href="#B样条基函数定义区间及节点向量"><span class="has-mr-6">5.3.3</span> <span>B样条基函数定义区间及节点向量</span></a></li><li><a class="is-flex" href="#B样条基函数的主要性质"><span class="has-mr-6">5.3.4</span> <span>B样条基函数的主要性质</span></a></li><li><a class="is-flex" href="#B样条函数的主要性质"><span class="has-mr-6">5.3.5</span> <span>B样条函数的主要性质</span></a></li><li><a class="is-flex" href="#B样条曲线类型的划分"><span class="has-mr-6">5.3.6</span> <span>B样条曲线类型的划分</span></a></li><li><a class="is-flex" href="#B样条曲面"><span class="has-mr-6">5.3.7</span> <span>B样条曲面</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第6章-真实感图形学"><span class="has-mr-6">6</span> <span>第6章 真实感图形学</span></a><ul class="menu-list"><li><a class="is-flex" href="#颜色模型"><span class="has-mr-6">6.1</span> <span>颜色模型</span></a><ul class="menu-list"><li><a class="is-flex" href="#颜色"><span class="has-mr-6">6.1.1</span> <span>颜色</span></a></li><li><a class="is-flex" href="#颜色模型-1"><span class="has-mr-6">6.1.2</span> <span>颜色模型</span></a></li><li><a class="is-flex" href="#RGB颜色工业模型"><span class="has-mr-6">6.1.3</span> <span>RGB颜色工业模型</span></a></li><li><a class="is-flex" href="#其他颜色工业模型"><span class="has-mr-6">6.1.4</span> <span>其他颜色工业模型</span></a></li><li><a class="is-flex" href="#颜色视觉模型"><span class="has-mr-6">6.1.5</span> <span>颜色视觉模型</span></a></li><li><a class="is-flex" href="#其他颜色视觉模型"><span class="has-mr-6">6.1.6</span> <span>其他颜色视觉模型</span></a></li></ul></li><li><a class="is-flex" href="#简单光照模型"><span class="has-mr-6">6.2</span> <span>简单光照模型</span></a><ul class="menu-list"><li><a class="is-flex" href="#光照模型的发展"><span class="has-mr-6">6.2.1</span> <span>光照模型的发展</span></a></li><li><a class="is-flex" href="#背景物理知识"><span class="has-mr-6">6.2.2</span> <span>背景物理知识</span></a></li><li><a class="is-flex" href="#Phong光照模型"><span class="has-mr-6">6.2.3</span> <span>Phong光照模型</span></a></li></ul></li><li><a class="is-flex" href="#增量式光照模型"><span class="has-mr-6">6.3</span> <span>增量式光照模型</span></a><ul class="menu-list"><li><a class="is-flex" href="#Gouraud明暗处理"><span class="has-mr-6">6.3.1</span> <span>Gouraud明暗处理</span></a></li><li><a class="is-flex" href="#Phong明暗处理"><span class="has-mr-6">6.3.2</span> <span>Phong明暗处理</span></a></li></ul></li><li><a class="is-flex" href="#局部光照模型"><span class="has-mr-6">6.4</span> <span>局部光照模型</span></a><ul class="menu-list"><li><a class="is-flex" href="#理论基础"><span class="has-mr-6">6.4.1</span> <span>理论基础</span></a></li><li><a class="is-flex" href="#局部光照明模型"><span class="has-mr-6">6.4.2</span> <span>局部光照明模型</span></a></li></ul></li><li><a class="is-flex" href="#光透射模型"><span class="has-mr-6">6.5</span> <span>光透射模型</span></a></li><li><a class="is-flex" href="#整体光照模型"><span class="has-mr-6">6.6</span> <span>整体光照模型</span></a></li><li><a class="is-flex" href="#纹理映射和阴影处理"><span class="has-mr-6">6.7</span> <span>纹理映射和阴影处理</span></a><ul class="menu-list"><li><a class="is-flex" href="#纹理映射"><span class="has-mr-6">6.7.1</span> <span>纹理映射</span></a></li><li><a class="is-flex" href="#阴影处理"><span class="has-mr-6">6.7.2</span> <span>阴影处理</span></a></li></ul></li><li><a class="is-flex" href="#绘制技术"><span class="has-mr-6">6.8</span> <span>绘制技术</span></a><ul class="menu-list"><li><a class="is-flex" href="#基于图像的绘制技术IBR"><span class="has-mr-6">6.8.1</span> <span>基于图像的绘制技术IBR</span></a></li><li><a class="is-flex" href="#基于点的建模与绘制"><span class="has-mr-6">6.8.2</span> <span>基于点的建模与绘制</span></a></li></ul></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/">TTTT&#39;s Blog</a><p class="is-size-7">&copy; 2022 ZhangT&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},skipTags:["script","noscript","style","textarea","pre","code"],processEscapes:!0,tex2jax:{inlineMath:[["$","$"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>