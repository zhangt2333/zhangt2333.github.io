<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>JVM-学习笔记 - Zhang T&#39;s Blog</title><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><script async src="https://www.googletagmanager.com/gtag/js?id=G-9V6Z0KEP5K"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-9V6Z0KEP5K")</script><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/">TTTT&#39;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i> </a><a class="navbar-item" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-content article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>JVM-学习笔记</h1><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2021-01-14T16:00:00.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2021-01-15</time> <time class="level-item has-text-grey is-hidden-mobile" datetime="2021-03-21T12:20:00.000Z"><i class="far fa-calendar-check">&nbsp;</i>2021-03-21</time><div class="level-item"><i class="far fa-folder-open has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/categories/CS/">CS</a></div><span class="level-item has-text-grey"><i class="far fa-clock"></i>&nbsp; 3 小时 读完 (大约 23612 个字) </span><span class="level-item has-text-grey" id="busuanzi_container_page_pv"><i class="far fa-eye"></i> <span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p>Java Virtual Machine，So Fascinating.</p><a id="more"></a><p>学习参考资料：</p><ul><li>《深入理解 Java 虚拟机第 3 版》</li><li>宋红康 JVM 教程</li></ul><p>一些工具：</p><ul><li>IDEA Plugin：<code>jclasslib Bytecode viewer</code></li></ul><h2 id="内存与垃圾回收"><a href="#内存与垃圾回收" class="headerlink" title="内存与垃圾回收"></a>内存与垃圾回收</h2><h3 id="JVM-与-Java-体系结构"><a href="#JVM-与-Java-体系结构" class="headerlink" title="JVM 与 Java 体系结构"></a>JVM 与 Java 体系结构</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>The Java Virtual Machine is the cornerstone of the Java platform. It is the component of the technology responsible for its hardware- and operating system-independence, the small size of its compiled code, and its ability to protect users from malicious programs.</p><p>The Java Virtual Machine is an abstract computing machine. Like a real computing machine, it has an instruction set and manipulates various memory areas at run time. It is reasonably common to implement a programming language using a virtual machine.</p><img src="image-20210125124741474.png" style="zoom:50%"> <img src="image-20210125124710215.png" style="zoom:67%"> <img src="image-20210125131050949.png" style="zoom:67%"><p>For the sake of security, the Java Virtual Machine imposes strong syntactic and structural constraints on the code in a <code>class</code> file. However, any language with functionality that can be expressed in terms of a valid <code>class</code> file can be hosted by the Java Virtual Machine. Attracted by a generally available, machine-independent platform, implementors of other languages can turn to the Java Virtual Machine as a delivery vehicle for their languages.</p><h4 id="JVM-的整体结构"><a href="#JVM-的整体结构" class="headerlink" title="JVM 的整体结构"></a>JVM 的整体结构</h4><img src="image-20210125131434154.png" style="zoom:50%"><h4 id="Java-代码执行流程"><a href="#Java-代码执行流程" class="headerlink" title="Java 代码执行流程"></a>Java 代码执行流程</h4><img src="image-20210125131929376.png" style="zoom:50%"><h4 id="JVM-的架构模型"><a href="#JVM-的架构模型" class="headerlink" title="JVM 的架构模型"></a>JVM 的架构模型</h4><p>Java 编译器输入的指令流基本上是一种基于栈的指令集架构。</p><p>基于栈式架构的特点：</p><ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">int j = 3;</span><br><span class="line">int k = i + j;</span><br><span class="line">// 字节码</span><br><span class="line">iconst_2</span><br><span class="line">istore_1</span><br><span class="line">iconst_3</span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd</span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure><p>基于寄存器架构的特点：</p><ul><li>典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机。</li><li><strong>指令集架构则完全依赖硬件，可移植性差</strong></li><li><strong>性能优秀和执行更高效</strong></li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 2+3</span><br><span class="line">mov eax, 2</span><br><span class="line">add eax, 3</span><br></pre></td></tr></table></figure><p>反编译操作：<code>javap -v test.class</code></p><h4 id="JVM-的生命周期"><a href="#JVM-的生命周期" class="headerlink" title="JVM 的生命周期"></a>JVM 的生命周期</h4><ul><li><p>虚拟机启动</p><ul><li>JVM 启动通过引导类加载器 <code>bootstarp class loader</code> 创建一个初始类 <code>initial class</code> 来完成的，这个类由虚拟机的具体实现指定</li></ul></li><li><p>虚拟机执行</p><ul><li>一个运行中的 JVM 有一个清晰的任务：执行 Java 程序</li><li>执行一个所谓的 Java 程序，真真正正在执行的是一个叫做 JVM 的进程</li><li>打印 JVM 进程：<code>jps</code></li></ul></li><li><p>虚拟机退出</p><ul><li>程序正常执行结束</li><li>程序运行过程中遇异常/错误而异常中止</li><li>某线程调用 Runtime 或 System 的 exit/halt 方法，并且 Java 安全管理器也允许这次 exit/halt 操作</li><li>除此之外，JNI (Java Native Interface) 规范描述了用 JNI Invocation API 来加载/卸载 JVM 时，JVM 的退出情况</li></ul></li></ul><h4 id="JVM-的发展历程"><a href="#JVM-的发展历程" class="headerlink" title="JVM 的发展历程"></a>JVM 的发展历程</h4><ul><li><p>Sun Classic VM</p><ul><li>第一款商用 JVM</li><li>只提供解释器，解释器和 JIT 编译器（外挂的）无法同时配合</li><li>Hotspot 内置了此 VM</li></ul></li><li><p>Exact VM</p><ul><li>Exact Memory Management 准确式内存管理，也可叫 Non-Conservative/Accurate Memory Management。虚拟机可知内存中某个位置的数据具体是什么类似（变量/引用）</li><li>具备现代高性能 VM 的雏形：热点探测、编译器和解释器混合工作模式、</li><li>只在 Solaris 平台短暂使用，最终被 Hotspot 替换</li></ul></li><li><p>HotSpot VM</p><ul><li>绝对的市场地位</li><li>Oracle JDK / OpenJDK 默认虚拟机</li><li>热点代码探测技术<br>通过计数器找到最具编译价值代码，触发即时编译或栈上替换<br>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li><li><p>JRocket（EBA 公司，该公司 08 年被 Oracle 收购）</p><ul><li>专注于服务器端应用<br>不太关注程序启动速度，因此不包含解释器实现，全部代码靠即时编译器编译后执行</li><li>JRocket JVM 是目前世界上最快的 JVM。70% 性能提升和 50% 硬件减少</li><li>MissionControl 服务套件，以极低的开销来监控/管理/分析生产环境中的应用程序的工具</li></ul></li><li><p>IBM 的 J9</p><ul><li>市场定位于 HotSpot 接近</li><li>有影响力的三大商用虚拟机之一，号称世界上最快的 Java 虚拟机（在 IBM 机上）</li><li>17 年开源了 J9，为 OpenJ9，给 Eclipse 基金会</li></ul></li><li><p>KVM 和 CDC/CLDC Hotspot</p><ul><li>Oracle 在 Java ME 产品线上的两个虚拟机 CDC/CLDC HotSpot Implemention VM</li><li>运行塞班系统上的 Java 手机游戏</li></ul></li><li><p>TaobaoJVM</p><ul><li><p>基于 OpenJDK 开发的定制版本 AlibabaJDK</p></li><li><p>创新的 GCIH (GC invisible heap) 技术实现了 off-heap，即将生命周期较长的 Java 对象从 heap 中移 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的<br>GCIH 中的对象还能在多个 JVM 进程中共享<br>使用 crc32 志林实现 JVM intrinsic 降低 JNI 调用开销</p><p>PMU hardware 的 Java profiling tool 和诊断协助功能<br>针对大数据场景的 ZenGC</p></li><li><p>硬件严重依赖 intel CPU，损失了兼容性，但提高了性能</p></li></ul></li><li><p>Dalvik VM</p><ul><li>Google 开发，没有遵循 JVM 规范，应用于 Android，并在 Android 2.2 中提供了 JIT，发展迅猛</li><li>基于寄存器架构</li><li>执行的是编译以后的 dex (Dalvik Executable) 文件，效率高<br>dex 文件可通过 Class 文件转化而来，通过 Java 语法编写应用程序，可直接使用大部分 Java API</li><li>Android 5.0 使用支持提前编译（Ahead Of Time Compilation，AOT）的 ART VM 替换 Dalvik VM</li></ul></li><li><p>Graal VM</p><ul><li>18 年，Oracle Labs 公开，号称 “Run Programs Faster Anywhere”</li><li>跨语言全栈虚拟机，可作为任何语言的运行平台使用，包括 C++、Python、R、Ruby、JavaScript 等</li><li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</li><li>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被 Graal VM 接受的中间表示。提供了 Truffle 工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</li></ul></li><li><p>其他：Azul VM、Liquid VM、Apache Harmony、Microsoft JVM</p></li></ul><h3 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h3><p>类加载器子系统：</p><ul><li><p>加载字节码文件，使得其中的变量/方法等信息有组织地加载到内存</p></li><li><p>作用：负责从文件系统/网络中加载 Class 文件，只负责加载，至于是否可运行，由 Execution Engine 决定</p></li><li><p>三个阶段：</p><ul><li>加载阶段<ul><li>引导类加载器 BootStrap ClassLoader</li><li>扩展类加载器 Extension ClassLoader</li><li>系统类加载器 Application ClassLoader</li></ul></li><li>链接阶段<ul><li>验证 verify</li><li>准备 prepare</li><li>解析 resolve</li></ul></li><li>初始化阶段</li></ul></li><li><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中的常量池部分的映射）</p></li></ul><img src="image-20210125184038670.png" style="zoom:50%"><p>ClassLoader 角色</p><ul><li><p>class file 存在于本地硬盘行，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 中来。根据这个模板实例化出 n 个一模一样的实例</p></li><li><p>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区</p></li><li><p>在 <code>.class 文件</code> -&gt; <code>JVM</code> -&gt; <code>元数据模板</code> 过程中，ClassLoader 扮演快递员的角色</p><img src="image-20210127142626888.png" style="zoom:55%"></li></ul><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><img src="image-20210127150301468.png" style="zoom:50%"><ul><li><p>Loading</p><ul><li>通过一个类的全限定名获取定义此类的二进制字节流<ul><li>本地系统</li><li>网络，比如 Web Applet</li><li>zip 包（jar、war 格式的基础）</li><li>运行时计算生成，如动态代理</li><li>由其他文件生成，如 JSP</li><li>从专有数据库中提取 .class 文件，少见</li><li>从加密文件中获取，典型地防 Class 文件被反编译的措施</li></ul></li><li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li></ul></li><li><p>Linking</p><ul><li>验证 Verify<ul><li>目的在于确保 Class 文件的字节流中包含信息符合当前 VM 要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>文件格式验证/元数据验证/字节码验证/符号引用验证</li></ul></li><li>准备 Prepare<ul><li>为变量分配内存并且设置该类变量的默认初始值，即零值。initial 阶段才会给 static 变量设置值</li><li>不包含用 final 修饰的 static，final 在编译的时候就会分配了，准备阶段会显式初始化</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中</li></ul></li><li>解析 Resolve<ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行</li><li>符号引用就是一组符号用来描述所引用的目标。符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li><li>解析动作主要是针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 <code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code> 等。</li></ul></li></ul></li><li><p>Initial</p><ul><li><p>执行类构造器方法 <code>&lt;clinit&gt;()</code> class init 的过程</p><img src="image-20210127173517032.png" style="zoom:67%"></li><li><p>此方法不需定义，是 javac 编译器自动收集类中的<strong>所有类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并而来。如果没有静态变量和静态代码块的话就不生成 <code>&lt;clinit&gt;()</code></p><img src="image-20210127173721363.png" style="zoom:67%"></li><li><p>构造器方法中指令按语句在源文件中出现的顺序执行</p><p><img src="image-20210127174159542.png" alt="image-20210127174159542"></p></li><li><p><code>&lt;clinit&gt;()</code> 不同于类的构造器<br>关联：构造器是虚拟机视角下的 <code>&lt;init&gt;()</code></p></li><li><p>若该类具有父类，JVM 会保证子类的 <code>&lt;clinit&gt;()</code> 执行前，父类的 <code>&lt;clinit&gt;()</code> 已经执行完毕</p><img src="image-20210127175342138.png" style="zoom:50%"></li><li><p>虚拟机必须保证一个类的 <code>&lt;clinit&gt;()</code> 方法是并发安全的</p></li></ul></li></ul><img src="image-20210127180042340.png" style="zoom:50%"><h4 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h4><p>分类：</p><ul><li>JVM 支持两种类型的 ClassLoader<ul><li>引导类加载器 BootStrap ClassLoader</li><li>自定义类加载器 User-Defined ClassLoader<br>定义：所有派生于抽象类 ClassLoader 的类加载器都为自定义类加载器，并不是字面上的指开发人员自定义的 ClassLoader</li></ul></li><li>常见 ClassLoader 只有 3 个<ul><li>下图中的四者是<strong>包含关系</strong>，不是上下层/继承关系</li><li>BootStrap Class Loader 是 C/C++ 代码写的，其他是 Java</li></ul></li></ul><img src="image-20210127180604778.png" style="zoom:50%"><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 获取系统类加载器 sun.misc.Launcher$AppClassLoader</span></span><br><span class="line">ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"><span class="hljs-comment">// 获取其上层：扩展类加载器</span></span><br><span class="line">ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line"><span class="hljs-comment">// 获取其上层，null</span></span><br><span class="line">ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 对于用户自定义类来说，默认使用系统类加载器进行记载</span></span><br><span class="line">Test.class.getClassLoader(); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 系统核心类库的类加载器是引导类加载器加载的</span></span><br><span class="line">String.class.getClassLoader(); <span class="hljs-comment">// null</span></span><br></pre></td></tr></table></figure><p>虚拟机自带的加载器：</p><ul><li>BootStrap ClassLoader<ul><li>C/C++ 实现，嵌套于 JVM</li><li>用来加载 Java 核心库（<code>JAVA_HOME/jre/lib/rt.jar</code>、<code>resources.jar</code> 或 <code>sun.boot.class.path</code> 路径下的内容）</li><li>没有父加载器</li><li>加载扩展类和应用程序类加载器并制定为他们的父类加载器</li><li>安全考虑，Bootstrap ClassLoader 只加载报名为 java、javax、sun 等开头的类</li></ul></li><li>Extension ClassLoader<ul><li>Java 编写，由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现</li><li>派生于 ClassLoader 类</li><li>父类加载器为 BootStrap ClassLoader</li><li>从 <code>java.ext.dirs</code> 系统属性所制定的目录中加载类库，或从 JDK 的安装目录的 <code>jre/lib/ext</code> 子目录下加载类库。若用户的 jar 放在此目录下，也会由其加载</li></ul></li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 获取 BootStrapClassLoader 能够加载的 api 的路径</span></span><br><span class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="hljs-keyword">for</span> (URL element: urls) &#123;</span><br><span class="line">    System.out.println(element.toExternalForm());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 获取 ExtClassLoader 能够加载的类路径</span></span><br><span class="line"> System.getProperty(<span class="hljs-string">"java.ext.dirs"</span>);</span><br></pre></td></tr></table></figure><p>用户自定义类加载器：</p><ul><li><p>why?<br>隔离加载类<br>修改类加载的方式<br>拓展加载源<br>防止源码泄露</p></li><li><p>步骤</p><ul><li><p>继承 java.lang.ClassLoader</p></li><li><p>JDK1.2 之前要重写 loadClass() 方法，之后不建议重写 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findClass() 方法中</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="hljs-comment">// ...</span></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="hljs-comment">// 从自定义路径中加载指定类</span></span><br><span class="line">        <span class="hljs-comment">// 可以包含加密和解密的过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若没有太过复杂的需求，可直接继承 URLClassLoader，这样可避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</p></li></ul></li></ul><p>关于 ClassLoader：</p><img src="image-20210128182457337.png" style="zoom:50%"><p>获取 ClassLoader 的途径：</p><ul><li>获取当前类的 ClassLoader：<code>clazz.getClassLoader()</code></li><li>获取当前线程上下文的 ClassLoader：<code>Thread.currentThread().getContextClassLoader()</code></li><li>获取系统的 ClassLoader：<code>ClassLoader.getSystemClassLoader()</code></li><li>获取调用者的 ClassLoader：<code>DriverManger.getCallerClassLoader()</code></li></ul><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>JVM 对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，JVM 虚拟机采用的是双亲委派模式，即把请求交由父类处理。</p><p>工作原理：</p><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先加载，而是将请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其父类加载器，则进一步向上，请求最终到达顶层的 BootStrap ClassLoader</li><li>如果父类加载器可以完成类加载，则返回，或者子加载器才会尝试自己去加载</li></ul><img src="image-20210128210540957.png" style="zoom:67%"> <img src="image-20210128210946528.png" style="zoom:67%"><p>好处：</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心 API 被随意篡改<br><code>java.lang.SecurityException: Prohibited package name: java.lang</code></li></ul><p>沙箱安全机制：自定义一个 String 类，加载时会使用引导类加载器，加载过程中会先加载 JDK 的文件 <code>rt.jar 下的 java\lang\String.class</code> 此时自定义 String.class 的 main 方式就会找不到</p><p>JVM 视角中两个 class 对象为同一个类的条件：</p><ul><li>全限定类名相同</li><li>加载这个类的 ClassLoader 实例对象相同</li></ul><p>对类加载器的引用：</p><ul><li>JVM 必须知道一个类型是 BootStrap ClassLoader 加载还是自定义 ClassLoader 加载的。</li><li>如果一个类型是由用户类加载器加载，JVM 会讲这个类加载器的一个引用作为类型信息的一部分保存在方法区中</li><li>当解析一个类型到另一个类型的引用时，JVM 需要保证这两个类型的类加载器是相同的。</li></ul><p>类的主动使用（除了以下，其他都是被动使用，不会导致类的初始化）：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>JVM 启动时被标明为启动类的类</li><li>JDK7 开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle 实例的解析结果<br>RET_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类没有初始化</li></ul><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><h4 id="概述与线程"><a href="#概述与线程" class="headerlink" title="概述与线程"></a>概述与线程</h4><img src="image-20210129123358965.png" style="zoom:50%"><p>运行时数据区：</p><ul><li>红色部分（堆、堆外内存 (永久代或元空间、代码缓存)）：JVM 定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁</li><li>灰色部分（程序计数器、栈、本地栈）：则是与线程一一对应，随线程开始/结束而创建/销毁</li></ul><p>更细致的：</p><img src="image-20210129123052650.png" style="zoom:50%"> <img src="image-20210129123119868.png" style="zoom:67%"><p>线程：Java 线程与 OS 线程一一对应</p><p>JVM 系统线程：</p><ul><li>虚拟机线程：JVM 到达安全点才会出现。执行类型包含 “stop-the-world” 的垃圾收集，线程栈收集，线程挂起，以及偏向锁撤销</li><li>周期任务线程：这种线程是时间周期时间的体现（比如中断），他们一般用于周期性操作的调度执行</li><li>GC 线程：对在 JVM 里不同种类的垃圾收集行为提供了支持</li><li>编译线程：在运行时会将字节码编译成本地代码</li><li>信号调度线程：接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul><li>PC 寄存器用来存储指向下一条指令的地址，由 Execution Engine 读取下一条指令。</li><li>它是一块很小的内存，几乎可以忽略不计，也是运行速度最快的内存</li><li>JVM 规范中，每个线程都有它自己的 PC Register，是线程私有的，生命周期与线程的生命周期保持一致</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；若是在执行 native 方法，则是未指定值 undefined</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需执行的字节码指令</li><li>是唯一一个在 JVM 规范中没有规定任何 OOM 情况的区域</li><li>Stack Area 和 PC Registers 都没有 GC</li></ul><img src="image-20210129154014440.png" style="zoom:67%"> <img src="image-20210129213652842.png" style="zoom:67%"><h4 id="虚拟机栈-★"><a href="#虚拟机栈-★" class="headerlink" title="虚拟机栈 ★"></a>虚拟机栈 ★</h4><p>Java Virtual Machine Stack：</p><ul><li><p>起因：跨平台性设计，JVM 指令根据栈来设计。</p></li><li><p>每个线程创建时都会创建一个虚拟栈，其内部保存一个个的栈帧 Stack Frame，对应一次次的 Java Method Invoke</p></li><li><p>生命周期与线程一致</p></li><li><p>作用：保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回</p></li><li><p>JVM 直接对 Java 栈的操作：</p><ul><li>方法执行，伴随着压栈</li><li>执行结束后的弹栈</li></ul></li><li><p>不存在垃圾回收</p><p>栈中可能的异常：</p></li><li><p>JVM 规范允许 Java 栈的大小是动态的或者是固定不变的</p></li><li><p>若采用固定大小的 JVM 栈，那每个 Thread 的 JVM Stack 容量在创建时独立选定。若线程请求分配的栈容量超过 JVM 设置，则抛 StackOverflowError 异常</p></li><li><p>若采用动态扩展，在扩展时发现不足了则抛 OutOfMemoryError</p></li></ul><p><code>-Xss256k</code>、<code>-Xss1024k</code> 可以设置栈大小</p><p>栈帧的内部结构：</p><ul><li>局部变量表 LV, Local Variables</li><li>操作数栈 OS, Operand Stack</li><li>动态链接 DL, Dynami Linking，指向运行时常量池的方法引用</li><li>方法返回地址 RA, Return Address，方法退出的定义</li><li>一些附加信息</li></ul><p>局部变量表：</p><ul><li><p>也称为局部变量数组、本地变量表</p><img src="image-20210130141648702.png" style="zoom:50%"></li><li><p>定义为一个数字数组，主要存储方法 参数和定义在方法体内的局部变量，数据类型包括各类基本数据类型、Object Reference、returnAddress</p></li><li><p>是线程的私有数据，不存在数据安全问题</p></li><li><p>容量大小是编译器确定下来的，保存在方法的 Code 属性的 maximum local variables 数据项中。方法运行期间是不会改变局部变量表大小的。</p></li><li><p>最基本的存储单元：Slot（变量槽）</p><ul><li><p>参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1 的索引结束</p></li><li><p>32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64 位的类型（long/double）占用两个 slot</p><img src="image-20210130202337634.png" style="zoom:50%"></li><li><p>如果当前帧由构造方法或实例方法创建，那 this 变量会存放在 index=0 的 slot 处，其他参数按按照参数表顺序排列<br>[this, param, localVariable]</p></li><li><p>Slot 重复利用：<br>栈帧中的局部变量表中的槽位是可重用的，如果一个局部变量过了其作用域，那么在作用域后新声明的局部变量就可能复用过期局部变量的槽位</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        int a = 2;</span><br><span class="line">        System.out.println(2);</span><br><span class="line">    &#125;</span><br><span class="line">    int b = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>局部变量和静态变量对比</p><ul><li>静态变量有 2 次初始化机会，prepare 和 initial</li><li>局部变量表则不存在系统初始化过程，意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。<code>int i; System.out.println(i); // CE</code></li></ul></li></ul><p>操作数栈：</p><ul><li>方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即 push/pop。比如：执行 复制/交换/求和 等操作</li><li>保存计算过程中的中间结果，同时作为计算过程中变量的临时存储空间</li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</li></ul><p>栈顶缓存技术 Top-of-Stack Cashing：</p><ul><li>栈式结构的 JVM 所使用的零地址指令更加紧凑，完成一项操作伴随着很多的入栈和出栈操作，即意味着更多的指令分派 instruction dispatch 次数和内存读写次数。<br>HotSpot JVM 考虑将栈顶元素全部缓存到物理 CPU 的寄存器而不是内存中，以此降低对内存的读写次数，提高执行引擎的执行效率</li></ul><p>动态链接（指向运行时常量池的方法引用）：</p><ul><li>帧数据区：方法返回地址、动态链接、附加信息</li><li>每个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接 Dynamic Linking。比如 invokedynamic 指令</li><li>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用 Symbolic Reference 保存在 class 文件的常量池中。比如：描述一个方法调用其他方法时，就是通过常量池中指向方法的符号引用来表示的。</li><li>动态链接作用：将这些符号引用转换为调用方法的直接引用</li><li>使用体现：bytecode 里面的 <code>#1</code>、<code>#2</code> 之类的</li><li>常量池作用：提供一些符号和变量，便于指令的识别</li></ul><img src="image-20210207151012219.png" style="zoom:50%"><p>方法的调用（解析与分派）：</p><ul><li><p>JVM 中，符号引用转换为调用方法的直接引用与方法的绑定机制相关</p></li><li><p>静态链接：被调用的目标方法在编译期可知，且运行期保持不变时，将调用方法的符号引用转换为直接引用的过程 <code>invokespecial</code>、<code>invokestatic</code><br>动态链接：被调用方法在编译器无法确定，只能再运行时将调用方法的符号引用转换为直接引用 <code>invokevirtual</code>、<code>invokeinterface</code></p></li><li><p>推广一下 =&gt; 早期绑定 Early Binding、晚期绑定 Late Binding<br>绑定是一个字段、方法或类在符号引用被替换为直接引用的过程，仅发生一次</p></li><li><p>非虚方法（静态方法/私有方法/final方法/构造器/父类方法）与虚方法</p><ul><li>普通调用指令：<ul><li><code>invokespecial</code>（非虚方法）：调用静态方法，解析阶段确定唯一方法版本</li><li><code>invokestatic</code>（非虚方法）：调用<init>方法、私有及其父类方法，解析阶段确定唯一方法版本</init></li><li><code>invokevirtual</code>：调用所有虚方法</li><li><code>invokeinterface</code>：调用接口方法</li></ul></li><li>动态调用指令<ul><li><code>invokedynamic</code>：动态解析出需要调用的方法，然后执行<br>Java7 增加的指令，是 Java 为实现【动态类型语言】支持而做的一种改进（本质是对 JVM 规范的修改，最直接受益者是运行在 JVM 的动态语言的编译器），但在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 等工具，直到 Java8 中 Lambda 的出现。</li></ul></li></ul></li><li><p>动态语言和静态语言：</p><ul><li>区别在于对类型的检查是编译期还是运行期</li><li>静态类型语言是判断<strong>变量</strong>的类型信息，动态类型语言则是判断<strong>变量值</strong>的类型信息</li></ul></li><li><p>方法重写的本质（动态分派）：</p><ol><li>（调用之前，方法的对象/类在栈顶）找到操作数栈的栈顶元素所执行的对象的实际类型，记作 C</li><li>先在类型 C 中找到与常量中描述符合、简单名称符合的方法，并进行访问权限校验（通过则返回这方法的直接引用，不通过则返回 <code>java.lang.IllegalAccessError</code> 异常）</li><li>若没有找到符合的方法，则按照继承关系从下往上对 C 的各个父类依次执行操作 3</li><li>最终没找到合适方法，则抛出 <code>java.lang.AbstractMethodError</code> 异常</li></ol></li><li><p>虚方法表 virtual method table：</p><ul><li>OOP 中，动态分派的使用是很频繁的，为了提高性能，JVM 在类的方法区建立了一个虚方法表，使用索引代替查找，表中存放各个方法的实际入口</li><li>虚方法表会在类加载的 Linking 阶段被创建并开始初始化，类的变量初始值准备完成后，JVM 会把该类的方法表也初始化完毕 <img src="image-20210208163314493.png" style="zoom:45%"></li></ul></li></ul><p>方法返回地址：</p><ul><li><p>方法开始执行后，仅两种方式退出该方法</p></li><li><p>正常完成出口：执行引擎遇到任一个方法返回的字节码指令，将返回值传递给上层方法调用者</p><ul><li>ireturn (boolean、byte、char、short、int)</li><li>lreturn</li><li>freturn</li><li>dreturn</li><li>areturn</li><li>return (void、构造器、类和接口初始化)</li></ul></li><li><p>异常完成出口（没有返回值给上层调用者）：方法执行过程中遇到了异常，异常没有在方法内处理，导致方法退出<br>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表中，方便在发生异常时找到处理异常的代码，如下，PC: 4-&gt;8 范围发生的异常可以跳 PC=11</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception table:</span><br><span class="line">    from    to    target    type</span><br><span class="line">      4          8        11        Class java/io/IOException</span><br></pre></td></tr></table></figure></li><li><p>本质上，方法的退出即当前栈帧出栈的过程。此时需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈的操作数栈、设置 PC 等</p></li></ul><p>一些附加信息：</p><ul><li>栈帧中还允许携带与 JVM 实现相关的一些附加信息。例如对程序调试提供支持的信息</li></ul><h4 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h4><p>Native Method：</p><ul><li><p>一个 Java 调用非 Java 代码接口。很多 PL 都有这一机制，比如 C++ 中的 <code>extern &quot;C&quot;</code> 告知 C++ Compiler 去调 C 的函数。</p></li><li><p>融合不同的编程语言为 Java 所用，初衷是融合 C/C++ 程序</p></li><li><p>可与除 abstarct 外的关键字共用</p></li><li><p>why: 有些功能用 Java 实现不容易或效率不高</p></li><li><p>now: 目前使用的越来越少，除非是与硬件有关的应用</p></li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>Native Method Stack:</p><ul><li><p>线程私有</p></li><li><p>虚拟机栈管理 Java 方法调用，本地方法栈管理本地方法调用</p></li><li><p>某个线程调用一个本地方法时，它进入一个全新且不受 VM 限制的世界，和 VM 有同样的权限</p><ul><li>可通过本地方法接口来访问虚拟机内的运行时数据区</li><li>甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li><p>并不是所有 JVM 都支持 Native Method，因为 JVM 规范没明确要求 Native Method Stack 的使用语言、具体实现、数据结构等</p></li><li><p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</p></li></ul><h4 id="堆-★"><a href="#堆-★" class="headerlink" title="堆 ★"></a>堆 ★</h4><p>Heap 概述：</p><ul><li><p>一个 JVM 实例只存在一个堆内存，JVM 启动时创建并确定空间大小（可人为调节），是 Java 内存管理的核心区域，也是 JVM 管理的最大块内存空间</p></li><li><p>所有线程共享 Java 堆，在此还划分了线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）</p></li><li><p>《Java 虚拟机规范》：堆可处于物理上不连续的空间，但逻辑上是连续的</p></li><li><p>《Java 虚拟机规范》：（几乎）所有的对象实例以及数组都应当在运行时分配在堆上。（栈帧中保存其引用）<br>The heap is the run-time data area from which memory for all class instances and arrays is allocated</p></li><li><p>方法结束后，堆中的对象不会马上被移除，GC 时才会被移除</p></li></ul><p>内存细分：</p><ul><li><p>现代 GCer 大部分基于分代收集理论设计</p></li><li><p>Java 7 之前，堆内存逻辑上分为：</p><ul><li>新生区(代)，Young (New) Generation Space，又分为 Eden 区和 Survivor 区<br>存放生命周期较短的瞬时对象，这类对象的创建和消亡都很迅速（IBM 研究表明，新生代中 80% 的对象都是 “朝生夕死”）</li><li>养老区(代)，Tenure (Old) Generation Space<br>存放生命周期较长的对象（这些对象在某些极端情况还能与 JVM 生命周期一致） <img src="image-20210222162009136.png" style="zoom:50%"></li><li>永久区(代)，Permanent (Perm) Space</li></ul></li><li><p>Java 8 及之后，堆内存逻辑上分为：</p><ul><li>新生代，Young (New) Generation Space，又分为 Eden 区和 Survivor 区</li><li>老年代，Tenure (Old) Generation Space</li><li>元空代，Meta Space <img src="image-20210222153037450.png" style="zoom:50%"></li></ul></li></ul><p>设置堆空间：</p><ul><li><p><code>-Xms</code> 初始堆内存 （Young + Tenure 代）；<code>Runtime.getRuntime().totalMemory</code>；默认值：内存 / 64。</p></li><li><p><code>-Xmx</code> 堆区最大内存；<code>Runtime.getRuntime().maxMemory 会输出堆内存减 S0 或 S1 区的内存，因为这两个区只能选一个存，另一个是用来辅助 GC 的</code> ；默认值：内存 / 4</p></li><li><p><code>-XX:+PrintGCDetails</code> 打印 GC 详情，或者在命令行 <code>jstat -gc 进程号</code></p></li><li><p><code>-XX:NewRatio=2</code> 表示配置新生代和老年代的占比，此时是新生代占 1，老年代占 2（默认就是 2）</p></li><li><p><code>-XX:SurvivorRatio=8</code> 配置 Eden 和 Survivor 区比例，此时 Survivor 区是 1，Eden 区是 8</p></li><li><p><code>-XX:-UseAdaptiveSizePolicy</code>：关闭自适应内存分配策略<br><code>-XX:+UseAdaptiveSizePolicy</code>：打开自适应内存分配策略（默认）</p></li></ul><p>对象分配过程（内存分配和内存回收是严谨且相关的）：</p><ol><li>new 的对象先放伊甸园区，此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行 Minor GC，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到 Survivor 0 区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到 Survivor 0 区的，如果没有回收，就会放到 Survivor 1 区</li><li>如果再次经历垃圾回收，此时会重新放回 Survivor 0 区，接着再去 Survivor 1 区</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。 可 <code>-XX: MaxTenuringThreshold&lt;N&gt;</code>进行设置。</li><li>在养老区，相对悠闲。当养老区内存不足时，触发 Major GC，进行养老区的内 存清理</li><li>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM</li></ol><p>进度：72 -</p><h4 id="方法区-★"><a href="#方法区-★" class="headerlink" title="方法区 ★"></a>方法区 ★</h4><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><h3 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h3><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>垃圾回收概述</p><p>垃圾回收相关算法</p><p>垃圾回收相关概念</p><p>垃圾回收器</p><h2 id="字节码与类的加载"><a href="#字节码与类的加载" class="headerlink" title="字节码与类的加载"></a>字节码与类的加载</h2><h3 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h3><blockquote><p>重要的官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p></blockquote><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>Java 前端编译器：</p><ul><li>javac 是一种能够将 Java 源码编译为字节码的前端编译器。</li><li>HotSpot VM 并没强制要求前端编译器只能 javac。只要编译结果符合 JVM 规范即可。</li><li>除了 javac (全量式编译) 之外，还有内置在 Eclipse 中的 ECJ（Eclipse Compiler for Java）编译器，是一种增量式编译器。<ul><li>Ctrl+S 后，ECJ 编译器把未编译部分的源码逐行进行编译，而非每次都全量编译。</li><li>ECJ 不仅是 Eclipse 的默认内置前端编译器，在 Tomcat 中同样也是使用 ECJ 编译器来编译 jsp 文件。</li><li>ECJ 基于 GPLv2 开源。</li><li>默认情况下，Intellij IDEA使用 javac 编译器（可自己设置为 ajc）</li></ul></li><li>前端编译器并不会直接涉及编译优化等方面的技术，这些具体优化细节移交给 HotSpot 的 JIT 编译器负责。</li></ul><img src="image-20210222180118912.png" style="zoom:40%"><p>涉及字节码指令的代码细节举例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="hljs-comment">// Integer变量和int变量比较时，只要两个变量的值是相等的（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</span></span><br><span class="line">       Integer x = <span class="hljs-number">5</span>;</span><br><span class="line">       <span class="hljs-keyword">int</span> y = <span class="hljs-number">5</span>;</span><br><span class="line">       System.out.println(x == y); <span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 同上</span></span><br><span class="line">       Integer x2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">5</span>);</span><br><span class="line">       <span class="hljs-keyword">int</span> y2 = <span class="hljs-number">5</span>;</span><br><span class="line">       System.out.println(x2 == y2); <span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，进入 valueOf 代码里有一个 IntegerCache 数组</span></span><br><span class="line">       Integer a1 = <span class="hljs-number">1</span>;</span><br><span class="line">       Integer b1 = <span class="hljs-number">1</span>;</span><br><span class="line">       System.out.println(a1 == b1); <span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 同上</span></span><br><span class="line">       Integer a3 = <span class="hljs-number">128</span>;</span><br><span class="line">       Integer b3 = <span class="hljs-number">128</span>;</span><br><span class="line">       System.out.println(a3 == b3); <span class="hljs-comment">// false</span></span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false</span></span><br><span class="line">       <span class="hljs-comment">// 当变量值在-128~127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象</span></span><br><span class="line">       Integer a2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);</span><br><span class="line">       Integer b2 = <span class="hljs-number">1</span>;</span><br><span class="line">       System.out.println(a2 == b2); <span class="hljs-comment">// false</span></span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 两个通过new生成的Integer变量永远是不相等的</span></span><br><span class="line">       Integer a4 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);</span><br><span class="line">       Integer b5 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);</span><br><span class="line">       System.out.println(a4 == b5); <span class="hljs-comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class 类的本质：</p><ul><li>任一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，Class 文件实际并不一定以磁盘文件的形式存在。</li><li>Class 文件是一组以字节为单位的<strong>二进制流</strong></li></ul><p>Class 文件格式及其总体结构：</p><ul><li>Class 的结构不像 XML 等描述语言，它没有任何分隔符号，所以在其中的数据项都是严格限定的，字节的含义、长度、先后，都不允许改变。</li><li>Class 文件格式采用一种类似于 C 语言结构体的方式进行数据存储，这种结构中只有两种数据类型<ul><li>无符号数：基本的数据类型，以 u1、u2、u4、u8 来分别代表指定字节的无符号数<br>可用来描述 数字、索引引用、数量值、UTF-8 字符串值。</li><li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型<br>所有表都习惯性地以 <code>_info</code> 结尾。<br>用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。<br>表没有固定长度，所以通常会在其前面加上个数说明</li></ul></li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;                        <span class="hljs-comment">//  魔数</span></span><br><span class="line">    u2             minor_version;         <span class="hljs-comment">// 副版本号 </span></span><br><span class="line">    u2             major_version;         <span class="hljs-comment">// 主版本号</span></span><br><span class="line">    u2             constant_pool_count; <span class="hljs-comment">// 常量池计数器</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 常量池表, 首索引 0 没有分配，所以少 1 个字节</span></span><br><span class="line">    u2             access_flags;            <span class="hljs-comment">// 访问标识</span></span><br><span class="line">    u2             this_class;                  <span class="hljs-comment">// 类索引</span></span><br><span class="line">    u2             super_class;              <span class="hljs-comment">// 父类索引</span></span><br><span class="line">    u2             interfaces_count;     <span class="hljs-comment">// 接口计数器</span></span><br><span class="line">    u2             interfaces[interfaces_count]; <span class="hljs-comment">// 接口索引集合</span></span><br><span class="line">    u2             fields_count;                  <span class="hljs-comment">// 字段计数器</span></span><br><span class="line">    field_info     fields[fields_count]; <span class="hljs-comment">// 字段表</span></span><br><span class="line">    u2             methods_count;            <span class="hljs-comment">// 方法计数器</span></span><br><span class="line">    method_info    methods[methods_count]; <span class="hljs-comment">// 方法表 </span></span><br><span class="line">    u2             attributes_count;          <span class="hljs-comment">// 属性计数器</span></span><br><span class="line">    attribute_info attributes[attributes_count]; <span class="hljs-comment">// 属性表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><ul><li>每个 Class 文件开头的 4 个字节的无符号整数称为 Magic Number</li><li>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。<br>即：魔数是Class文件的标识符。</li><li>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。</li><li>魔数值固定为 0xCAFEBABE。不会改变。</li><li>如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：<br><code>Error: A JNI error has occurred, please check your installation and try again Exception in thread &quot;main&quot; java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file Test</code></li></ul><h4 id="Class-文件版本"><a href="#Class-文件版本" class="headerlink" title="Class 文件版本"></a>Class 文件版本</h4><ul><li>紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是4个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 minor_version，而第 7 个和第 8 个字节就是编译的主版本号 major_version。</li><li>它们共同构成了 class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。</li><li>向下兼容：高版本兼容低版本。低版本执行高版本则会抛 <code>java.lang.UnsupportedClassVersionError</code></li></ul><p>版本号与平台的对应：</p><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><h4 id="常量池-constant-pool"><a href="#常量池-constant-pool" class="headerlink" title="常量池 constant_pool"></a>常量池 constant_pool</h4><p>概述：</p><ul><li>常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用。</li><li>随着 JVM 的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个 Class 文件的基石。</li><li>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</li><li>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值（constant_pool_count）。与 <strong>Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的。</strong></li></ul><ul><li>常量池表项中，用于存放编译时期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在<strong>类加载后</strong>进入方法区的<strong>运行时常量池</strong>中存放。</li></ul><p>常量池计数器：</p><ul><li><p>u2 类型，2 个字节，constant_pool_count=1 时表示常量池有 0 个常量项（没有常量项）</p></li><li><p>若为 0x16 = 22，表示有 21 个常量项，索引范围是 <code>1-21</code></p></li><li><p>把第 0 项常量空出来，是为了适配一种情况：某些指向常量池的索引值要表达 “不引用任何一个常量池项目” 的语义。此时这种情况即可用索引值 0 来表示。</p></li></ul><p>常量池项类型及其结构细节：</p><ul><li><p>常量池主要存放两大类常量</p><ul><li>字面量（Literal）：文本字符串、final 的变量<br><code>String str=“atguigu”; final int NUM=10;</code></li><li>符号引用（Symbolic References）：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li></ul></li><li><p>术语</p><ul><li><p>全限定名<br><code>java/lang/String;</code></p></li><li><p>简单名称<br>指没有类型和参数修饰的方法或者字段名称，如 add() 方法和 num 字段的简单名称分别是 add 和 num</p></li><li><p><strong>描述符</strong><br>描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。具体如下：</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型 byte</td></tr><tr><td>C</td><td>基本数据类型 char</td></tr><tr><td>D</td><td>基本数据类型 double</td></tr><tr><td>F</td><td>基本数据类型 float</td></tr><tr><td>I</td><td>基本数据类型 int</td></tr><tr><td>J</td><td>基本数据类型 long</td></tr><tr><td>S</td><td>基本数据类型 short</td></tr><tr><td>Z</td><td>基本数据类型 boolean</td></tr><tr><td>V</td><td>代表 void 类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td>[</td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td></tr></tbody></table><p>用描述符描述方法：<code>toString()</code> 方法的描述符 <code>() Ljava/lang/String;</code>；<code>int abc(int[] x, int y)</code> 方法的描述符为 <code>([II) I</code></p></li></ul></li><li><p>常量池里的每个项都符合以下某种类型及其细节（第 1 个字节 tag 作为类型标记，用于确定该项是以下的哪个）</p></li></ul><img src="image-20210223174808364.png" style="zoom:80%"><p>一个例子：</p><img src="image-20210223181211946.png" style="zoom:50%"><p>总结：</p><ul><li>final 常量直接显示值，没用指向索引</li><li>byte,short,char,boolean 标志为 3 的 CONSTANT_Integer_info 常量</li><li>在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息</li><li>常量池可以理解为 class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用 Class 文件空间最大的数据项目之一</li></ul><p>常量池中为什么要包含这些内容：</p><ul><li>Java 代码在进行 Javac 编译的时候，并不像 C/C++ 那样有链接这一步骤，而是在虚拟机加载 Class 文件的时候进行动态链接</li><li>也就是说，Class 文件不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</li></ul><h4 id="访问标志-access-flag"><a href="#访问标志-access-flag" class="headerlink" title="访问标志 access_flag"></a>访问标志 access_flag</h4><ul><li>2 个字节，用于识别一些类或者接口层次的访问信息，包括：<ul><li>Class 是类还是接口</li><li>是否定义为 public 类型</li><li>是否定义为 abstract 类型</li><li>类的话，是否为 final</li></ul></li><li>类的各个访问权限为 ACC_ 开头的常量，位与的运算结构作为 access_flag<br>比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL</li></ul><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）；使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记。</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><p>补充说明：</p><ul><li>带有 ACC_INTERFACE 标志的 class 文件表示的是接口而个是类，反之则表示的是类而个是接口<ol><li>如果一个 class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志</li><li>如果没有设置 ACC_INTERFACE 标志，那么这个 class 文件可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不得同时设置。(注解是 @interface)</li></ol></li><li>ACC_SUPER 用于确定类/接口里面的 invokespecial 指令使用的是哪一种执行语义。针对 JVM 指令集的编译器都应当设置这个标志。对于 JavaSE8 及后续版本来说，无论 class 文件中这个标志的实际值是什么，也不管 class 文件的版本号是多少，Java 虚拟机都认为每个 class 文件均设置了 ACC_SUPER 标志。<ul><li>ACC_SUPER 是为了向后兼容由旧 Java 编译器所编译的代码而设计的。目前的 ACC_SUPER 标志在由 JDK1.0.2 之前的编译器所生成的 access flags 中是没有确定含义的，如果设置了该标志，那么 Oracle的Java 虚拟机实现会将其忽略</li></ul></li><li>ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的</li><li>注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_ INTERFACE 标志。(注解是 @interface)</li><li>ACC_ENUM 标志表明该类或其父类为枚举类型</li></ul><h4 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h4><ul><li>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;                  <span class="hljs-comment">// 类索引</span></span><br><span class="line">u2             super_class;              <span class="hljs-comment">// 父类索引</span></span><br><span class="line">u2             interfaces_count;     <span class="hljs-comment">// 接口计数器</span></span><br><span class="line">u2             interfaces[interfaces_count]; <span class="hljs-comment">// 接口索引集合</span></span><br></pre></td></tr></table></figure><ul><li>类索引 this_class<ul><li>字节无符号整数，指向常量池的索引</li></ul></li><li>父类索引 super_class<ul><li>2 字节无符号整数，指向常量池的索引<br>若没有继承类，其默认继承的是 java/lang/Object 类</li><li>superclass 指向的父类不能是 final</li></ul></li><li>接口计数器 interfaces_count</li><li>接口索引集合 interfaces[]<ul><li>interfaces[] 中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。每个成员 interfaces[i] 必须为 CONSTANT_Class_info 结构，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样</li></ul></li></ul><h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p>fields：</p><ul><li>用于描述接口或类中声明的变量。包括类级变量以及实例级变量，但是不包括 local variables</li><li>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</li><li><strong>它指向常量池索引集合，它描述了每个字段的完整信息</strong>。<br>比如字段的标识符、访问修饰符、static 修饰符、final修饰符等</li></ul><p>注意：</p><ul><li><strong>字段表集合中不会列出从父类或者实现的接口中继承而来的字段</strong><br>但可能列出原本 Java 代码不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</li><li>在 Java 中字段无法重载，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称<br>但是于字节码来讲，若两个字段的描述符不一，那字段重名合法。</li></ul><p>字段表：</p><ul><li><p>fields 表中的每个成员都必须是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述</p></li><li><p>一个字段的信息包括如下这些信息，各个修饰符都是布尔值</p><ul><li>作用域（public、private、protected 修饰符）</li><li>实例变量还是类变量（static 修饰符）</li><li>可变性（final）</li><li>并发可见性（volatile 修饰符，是否强制从主内存读写）</li><li>可否序列化（transient 修饰符）</li><li>字段数据类型（基本数据类型、对象、数组）</li><li>字段名称</li></ul></li><li><p><strong>结构</strong></p><ul><li><p>u2，access_flags，访问标志</p></li><li><p>u2，name_index，字段名索引</p></li><li><p>u2，descriptor_index，描述符索引</p></li><li><p>u2，attributes_count，属性计数器</p></li><li><p>attribute_info，attributes[attributes_count]，属性表集合</p><ul><li><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count 中，属性具体内容存放在 attributes 数组中。<br>以常量属性为例（更多的属性下文会统一提及），结构为：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">    u2 attribute_name_index；</span><br><span class="line">    u4 attribute_length；               <span class="hljs-comment">// 对于常量属性而言，attribute_length=2</span></span><br><span class="line">    u2 constantvalue_index；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>字段表访问标志：</p><table><thead><tr><th>Flag Name</th><th>Value</th><th>Interpretation</th></tr></thead><tbody><tr><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>Declared <code>public</code>; may be accessed from outside its package.</td></tr><tr><td><code>ACC_PRIVATE</code></td><td>0x0002</td><td>Declared <code>private</code>; usable only within the defining class.</td></tr><tr><td><code>ACC_PROTECTED</code></td><td>0x0004</td><td>Declared <code>protected</code>; may be accessed within subclasses.</td></tr><tr><td><code>ACC_STATIC</code></td><td>0x0008</td><td>Declared <code>static</code>.</td></tr><tr><td><code>ACC_FINAL</code></td><td>0x0010</td><td>Declared <code>final</code>; never directly assigned to after object construction (JLS §17.5).</td></tr><tr><td><code>ACC_VOLATILE</code></td><td>0x0040</td><td>Declared <code>volatile</code>; cannot be cached.</td></tr><tr><td><code>ACC_TRANSIENT</code></td><td>0x0080</td><td>Declared <code>transient</code>; not written or read by a persistent object manager.</td></tr><tr><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>Declared synthetic; not present in the source code.</td></tr><tr><td><code>ACC_ENUM</code></td><td>0x4000</td><td>Declared as an element of an <code>enum</code>.</td></tr></tbody></table><h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>methods：</p><ul><li>指向常量池索引集合，它完整描述了每个方法的签名。</li></ul><ul><li>在字节码文件中，<strong>每一个 method_info 项都对应着一个类或者接口中的方法信息</strong><br>比如方法的访问修饰符（public、private 或 protected），方法的返回值类型以及方法的参数信息等。</li><li>如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来。</li><li>methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法</li><li>methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息<br>比如：类/接口初始化方法和实例初始化方法</li><li>方法签名一样返回值不一样的方法，java不允许。但 class 文件允许</li></ul><p>方法表：</p><ul><li>methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。<br>如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。</li><li>method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</li><li><strong>结构</strong>：跟字段表一样，即<ul><li>u2，access_flags，访问标志</li><li>u2，name_index，字段名索引</li><li>u2，descriptor_index，描述符索引</li><li>u2，attributes_count，属性计数器</li><li>attribute_info，attributes[attributes_count]，属性表集合</li></ul></li></ul><p>方法表访问标志：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>Declared <code>public</code>; may be accessed from outside its package.</td></tr><tr><td><code>ACC_PRIVATE</code></td><td>0x0002</td><td>Declared <code>private</code>; accessible only within the defining class.</td></tr><tr><td><code>ACC_PROTECTED</code></td><td>0x0004</td><td>Declared <code>protected</code>; may be accessed within subclasses.</td></tr><tr><td><code>ACC_STATIC</code></td><td>0x0008</td><td>Declared <code>static</code>.</td></tr><tr><td><code>ACC_FINAL</code></td><td>0x0010</td><td>Declared <code>final</code>; must not be overridden (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.5" target="_blank" rel="noopener">§5.4.5</a>).</td></tr><tr><td><code>ACC_SYNCHRONIZED</code></td><td>0x0020</td><td>Declared <code>synchronized</code>; invocation is wrapped by a monitor use.</td></tr><tr><td><code>ACC_BRIDGE</code></td><td>0x0040</td><td>A bridge method, generated by the compiler.</td></tr><tr><td><code>ACC_VARARGS</code></td><td>0x0080</td><td>Declared with variable number of arguments.</td></tr><tr><td><code>ACC_NATIVE</code></td><td>0x0100</td><td>Declared <code>native</code>; implemented in a language other than Java.</td></tr><tr><td><code>ACC_ABSTRACT</code></td><td>0x0400</td><td>Declared <code>abstract</code>; no implementation is provided.</td></tr><tr><td><code>ACC_STRICT</code></td><td>0x0800</td><td>Declared <code>strictfp</code>; floating-point mode is FP-strict.</td></tr><tr><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>Declared synthetic; not present in the source code.</td></tr></tbody></table><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>附加属性：</p><ul><li>紧随于方法表之后的 Class 字节码结构项，描述类的属性<br>是 class 文件所携带的辅助信息<br>比如该 class 文件的源文件名、以及任何带有 RetentionPolicy.CLASS 或 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 JVM 的验证和运行，以及 Java 程序的调试，一般无须深入了解</li></ul><p>属性概述：</p><ul><li>字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息</li><li>属性表集合的限制没有那么严格，不要求各个属性具有严格的顺序，只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性。</li></ul><p>属性的通用结构（所有的属性都可以抽象成以下 3 部分，由属性名索引区别具体的属性）：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index; <span class="hljs-comment">// 属性名索引</span></span><br><span class="line">    u4 attribute_length;            <span class="hljs-comment">// 属性长度</span></span><br><span class="line">    u1 info[attribute_length];  <span class="hljs-comment">// 具体信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM 预定义的属性举例（Java 8 定义了 23 种）：</p><table><thead><tr><th align="left">属性名</th><th>存在于</th><th>解释</th></tr></thead><tbody><tr><td align="left">Code</td><td>方法表</td><td>Java 代码编译成的字节码指令</td></tr><tr><td align="left">ConstantValue</td><td>字段表</td><td>final 关键字定义的常量池</td></tr><tr><td align="left">Deprecated</td><td>类, 方法, 字段表</td><td>被声明为 deprecated 的方法和字段</td></tr><tr><td align="left">Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td align="left">EnclosingMethod</td><td>类</td><td>仅当一个类为局部类或者匿名类时次有这个属性，用于标识这个类所在的外围方法</td></tr><tr><td align="left">InnerClass</td><td>类</td><td>内部类列表</td></tr><tr><td align="left">LineNumberTable</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td align="left">LocalVariableTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td align="left">StackMapTable</td><td>Code属性</td><td>JDK1.6 中新增的属性，供新的类型检查校验器检查和处理目标方法的局部变量和操作数所需要的类是否匹配</td></tr><tr><td align="left">Signature</td><td>类, 方法表, 字段表</td><td>用于支持泛型情况下的方法签名</td></tr><tr><td align="left">SourceFile</td><td>类</td><td>记录源文件名称</td></tr><tr><td align="left">SourceDebugExtension</td><td>类</td><td>用于存储额外的调试信息</td></tr><tr><td align="left">Synthetic</td><td>类, 方法表, 字段表</td><td>标志方法或字段为编译器自动生成</td></tr><tr><td align="left">LocalVariableTypeTable</td><td>类</td><td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td align="left">RuntimeVisibleAnntations</td><td>类, 方法表, 字段表</td><td>为动态注解提供支持</td></tr></tbody></table><p>Code 属性：</p><ul><li>存放方法体里面的代码。但并非所有方法表都有 Code 属性（比如接口方法/抽象方法）</li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;  <span class="hljs-comment">// 属性名索引</span></span><br><span class="line">    u4 attribute_length;             <span class="hljs-comment">// 属性长度</span></span><br><span class="line">    u2 max_stack;                       <span class="hljs-comment">// 操作数栈深度的最大值</span></span><br><span class="line">    u2 max_locals;                      <span class="hljs-comment">// 局部变量表所需的存储空间</span></span><br><span class="line">    u4 code_length;                    <span class="hljs-comment">// 字节码指令的长度</span></span><br><span class="line">    u1 code[code_length];         <span class="hljs-comment">// 字节码指令，二进制形式，具体有哪些指令，下文再提</span></span><br><span class="line">    u2 exception_table_length;<span class="hljs-comment">// 异常表长度</span></span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length]; <span class="hljs-comment">// 异常表</span></span><br><span class="line">    u2 attributes_count;                <span class="hljs-comment">// 属性集合计数器</span></span><br><span class="line">    attribute_info attributes[attributes_count]; <span class="hljs-comment">// 属性集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Code 属性类的属性集合，一般是 LineNumberTable、LocalVariableTable</span></span><br><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 line_number;	</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一些工具使用"><a href="#一些工具使用" class="headerlink" title="一些工具使用"></a>一些工具使用</h4><p>javac：</p><ul><li><code>javac -g Main.java</code> 会产生 LocalVariableTable 等调试信息</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\TTTT&gt;javac</span><br><span class="line">用法: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -g                         生成所有调试信息</span><br><span class="line">  -g:none                    不生成任何调试信息</span><br><span class="line">  -g:&#123;lines,vars,source&#125;     只生成某些调试信息</span><br><span class="line">  -nowarn                    不生成任何警告</span><br><span class="line">  -verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="line">  -deprecation               输出使用已过时的 API 的源位置</span><br><span class="line">  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置</span><br><span class="line">  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置</span><br><span class="line">  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置</span><br><span class="line">  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置</span><br><span class="line">  -proc:&#123;none,only&#125;          控制是否执行注释处理和/或编译。</span><br><span class="line">  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程</span><br><span class="line">  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置</span><br><span class="line">  -parameters                生成元数据以用于方法参数的反射</span><br><span class="line">  -d &lt;目录&gt;                    指定放置生成的类文件的位置</span><br><span class="line">  -s &lt;目录&gt;                    指定放置生成的源文件的位置</span><br><span class="line">  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置</span><br><span class="line">  -implicit:&#123;none,class&#125;     指定是否为隐式引用文件生成类文件</span><br><span class="line">  -encoding &lt;编码&gt;             指定源文件使用的字符编码</span><br><span class="line">  -source &lt;发行版&gt;              提供与指定发行版的源兼容性</span><br><span class="line">  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</span><br><span class="line">  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用</span><br><span class="line">  -version                   版本信息</span><br><span class="line">  -help                      输出标准选项的提要</span><br><span class="line">  -A关键字[=值]                  传递给注释处理程序的选项</span><br><span class="line">  -X                         输出非标准选项的提要</span><br><span class="line">  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统</span><br><span class="line">  -Werror                    出现警告时终止编译</span><br><span class="line">  @&lt;文件名&gt;                     从文件读取选项和文件名</span><br></pre></td></tr></table></figure><p>javap：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\TTTT&gt;javap</span><br><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><blockquote><p>重要的官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></p></blockquote><h4 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h4><ul><li>Java 字节码对于虚拟机，就好像汇编语言对于计算机，属于基本执行指令。</li><li>Java 虚拟机的指令：Opcode ( 1 Byte ) + Operands ( 0~ Bytes)<br>由于 JVM 采用面向操作数栈的结构，所以大多数的指令都不包含操作数，只有一个操作码。</li><li>操作码是 1 字节，故总数不可能超过 256 条</li></ul><p>执行模型：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">do</span> &#123;</span><br><span class="line">	PC ++;</span><br><span class="line">	根据 PC ，从字节码流中取出操作码;</span><br><span class="line">	<span class="hljs-keyword">if</span> (操作码对应指令存在操作数) 从字节码流中取出操作数;</span><br><span class="line">	执行操作码所定义的操作;</span><br><span class="line">&#125; <span class="hljs-keyword">while</span> ( 字节码长度 &gt; <span class="hljs-number">0</span> )；</span><br></pre></td></tr></table></figure><p>字节码与数据类型：</p><ul><li><p>在 JVM 指令集中，大多数的指令都包含了其操作所对应的数据类型信息。<br>例如，<code>iload</code>、<code>fload</code> 分别用于从局部变量表中加载 int、float 型的数据到操作数栈中<br>一般开头的字母是助记符标志操作码的操作类型：i -&gt; int，l -&gt; long，s -&gt; short，b -&gt; byte，c -&gt; char，f -&gt; float，d -&gt; double</p></li><li><p><strong>也有一些指令的助记符中没有明确地指明操作类型的字母</strong><br>如 <code>arraylength</code> 指令，没代表数据类型的特殊字符，但操作数只能是一个数组类型的对象</p></li><li><p>还有另外一些指令，与数据类型无关<br>如无条件跳转指令 <code>goto</code></p></li><li><p>大部分的指令都没有支持整数类型 byte、char 和 short，甚至没有任何指令支持 boolean 类型。<br>编译器会在编译期/运行期将 byte、short 类型数据带符号扩展（Sign-Extend）为相应 int 类型数据；将boolean、char 类型数据零位扩展（Zero-Extend）为相应的 int 类型数据。</p><ul><li>byte b1=12; short s1=10; int i = b1+s1;</li></ul></li><li><p>将 JVM 中的字节码指令集按用途大致分成 9 类</p><ul><li>加载与存储指令</li><li>算术指令</li><li>类型转换指令</li><li>对象的创建与访问指令</li><li>方法调用与返回指令</li><li>操作数栈管理指令</li><li>比较控制指令</li><li>异常处理指令</li><li>同步控制指令</li></ul></li><li><p>在做值相关操作时：</p><ul><li>一个指令，可以从局部变量表、常量池、堆中对象、方法调用、系统调用中等取得数据，这些数据（可能是值，可能是对象的引用）被压入操作数栈</li><li>一个指令，也可以从操作数栈中取出一到多个值（pop多次），完成赋值、加减乘除、方法传参、系统调用等等操作</li></ul></li></ul><h4 id="加载与存储指令"><a href="#加载与存储指令" class="headerlink" title="加载与存储指令"></a>加载与存储指令</h4><p>局部变量压栈指令：</p><ul><li><strong>将给定的局部变量表中的数据压入操作数栈</strong>。</li><li>这类指令大体可以分为：<ul><li><code>xload_&lt;n&gt;</code>（x 为 i、l、f、d、a；n 为 0 到 3），表示将索引 n 开始的局部变量压栈。<br>如 <code>iload_3</code> 和 <code>iload 3</code> 是等效的，不过前者所占字节数少。当索引大于 3，就要用下面这个指令了</li><li><code>xload index</code>（x 为 i、l、f、d、a；index 为单字节操作数，需要双字节需要搭配 <code>wide</code> 使用），表示将索引 index 开始的局部变量压栈</li><li>x 的取值表示数据类型</li></ul></li></ul><p>常量入栈指令：</p><ul><li><p>将常数压入操作数栈，根据<strong>数据类型</strong>和<strong>入栈内容</strong>的不同，分 3 类系列</p></li><li><p>const 系列：</p><ul><li>用于对特定的常量入栈，入栈的常量隐含在指令本身里</li><li><code>iconst_&lt;i&gt;</code>（ i 从 -1 到 5 ）<br>如 <code>iconst_m1</code> 将 -1 压栈，<code>iconst_5</code> 将 5 压栈</li><li><code>lconst_&lt;l&gt;</code>（l 从 0 到 1）</li><li><code>fconst_&lt;f&gt;</code>（f 从 0 到 2）</li><li><code>dconst_&lt;d&gt;</code>（d 从 0 到 1）</li><li><code>aconst_null</code></li></ul></li><li><p>push 系列：</p><ul><li><code>bipush</code>，接受 8 位整数作为操作数</li><li><code>sipush</code>，接受 16 位整数作为操作数</li></ul></li><li><p>ldc 系列：</p><ul><li><code>ldc</code>，接受 8 位操作数，其指向常量池中的 int、float 或 String 的索引，将制定内容压栈</li><li><code>ldc_w</code>，接受 2 个 8 为操作数，较 <code>ldc</code> 索引范围更大</li><li><code>ldc2_w</code>，接受 2 个 8 为操作数，取的是 long 或 double 的数据压栈</li></ul></li></ul><p>弹栈装入局部变量表指令：</p><ul><li><code>xstore_&lt;n&gt;</code> （x 为 i、l、f、d、a；n 为 0 至 3）</li><li><code>xstore index</code> （x 为 i、l、f、d、a；index 为单字节操作数），表示栈顶弹出存入局部变量表索引 index 开始的位置</li></ul><h4 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h4><p>运算时的溢出：JVM 规范并无明确规定过整型数据溢出的具体结果，仅规定了在处理整型数据时，只有除法指令以及求余指令中当出现除数为 0 时会导致虚拟机抛出异常 ArithmeticException</p><p>运算模式：</p><ul><li>向最接近数舍入模式：JVM 要求在进行浮点数计算时，所有的运算结果都必须舍入到适当的精度，非精确结果必须舍入为可被表示的最接近的精确值，如果有两种可表示的形式与该值一样接近，将优先选择最低有效位为零的；(类似四舍五入)</li><li>向零舍入模式：将浮点数转换为整数时，采用该模式，该模式将在目标数值类型中选择一个最接近但是不大于原值的数字作为最精确的舍入结果；(类似取整)</li></ul><p>NaN 值使用：当一个操作产生溢出时，将会使用有符号的 Infinity 表示，如果某个操作结果没有明确的数学定义的话，将会使用 NaN （Not a number）来表示</p><p>所有的算术指令包括：</p><ul><li><p>加法指令：<code>iadd</code>、<code>ladd</code>、<code>fadd</code>、<code>dadd</code></p></li><li><p>减法指令：<code>isub</code>、<code>lsub</code>、<code>fsub</code>、<code>dsub</code></p></li><li><p>乘法指令：<code>imul、``lmul</code>、<code>fmul</code>、<code>dmul</code></p></li><li><p>除法指令：<code>idiv</code>、<code>ldiv</code>、<code>fdiv</code>、<code>ddiv</code></p></li><li><p>求余指令：<code>irem</code>、<code>lrem</code>、<code>frem</code>、<code>drem</code></p></li><li><p>取反指令：<code>ineg</code>、<code>lneg</code>、<code>fneg</code>、<code>dneg</code></p></li><li><p>自增指令：<code>iinc</code></p><ul><li><p>如果没有后续操作 <code>i++</code> 和 <code>++i</code> 等效</p></li><li><p><code>int a = i++</code></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iload_1</span><br><span class="line">iinc 1 by 1</span><br><span class="line">istore_2</span><br></pre></td></tr></table></figure></li><li><p><code>int a = ++i</code></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iinc 1 by 1</span><br><span class="line">iload_1</span><br><span class="line">istore_2</span><br></pre></td></tr></table></figure></li></ul></li><li><p>比较指令：<code>dcmpg</code>、<code>dcmpl</code>、<code>fcmpg</code>、<code>fcmpl</code>、<code>lcmp</code></p><ul><li><p>指令 fcmpg 和 fcmpl 都从栈中弹出两个操作数，并将它们做比较<br>设栈顶的元素为 v2，栈顶顺位第 2 位的元素为 v1<br>若 v1=v2，则压入 0；若 v1&gt;v2 则压入1；若 v1&lt;v2 则压入 -1</p><p>两个指令的不同之处在于，如果遇到 NaN 值，fcmpg 会压入 1，而 fcmpl 会压入 -1</p><p>左边/底部更大压栈进入 1</p></li></ul></li><li><p>位运算指令，又可分为：</p><ul><li>位移指令：<code>ishl</code>、<code>ishr</code>、<code>iushr</code>、<code>lshl</code>、<code>lshr</code>、<code>lushr</code></li><li>按位或指令：<code>ior</code>、<code>lor</code></li><li>按位与指令：<code>iand</code>、<code>land</code></li><li>按位异或指令：<code>ixor</code>、<code>lxor</code></li></ul></li></ul><h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><p>宽化类型转换 Widening Numeric Conversion</p><ul><li><strong>小范围类型向大范围类型</strong>的安全转换</li></ul><ul><li>i2l、i2f、i2d</li><li>l2f、l2d</li><li>f2d</li></ul><p>窄化类型转换 Narrowing Numeric Conversion</p><ul><li>i2b、i2s、i2c</li><li>l2i</li><li>f2i、f2l</li><li>d2i、d2l、d2f</li></ul><p>会有精度损失滴</p><h4 id="对象的创建与访问指令"><a href="#对象的创建与访问指令" class="headerlink" title="对象的创建与访问指令"></a>对象的创建与访问指令</h4><p>创建指令：</p><ul><li><code>new</code>，创建类实例的指令，接收一个操作数（常量池的索引），表示要创建的类型，创建对象的引用压栈</li></ul><ul><li><code>newarray</code>，创建基本类型数组</li><li><code>anewarray</code>，创建引用类型数组</li><li><code>multianewarray</code>，创建多维数组</li></ul><p>字段访问指令：</p><ul><li><code>getstatic</code>、<code>putstatic</code>，访问类字段（static字段，或者称为类变量）的指令</li><li><code>getfield</code>、<code>putfield</code>，访问类实例字段（非static字段，或者称为实例变量）的指令</li></ul><p>数组操作指令：</p><ul><li><code>xaload arrayref, index -&gt;</code> 把一个数组元素加载到操作数栈的指令<br><code>xastore arrayref, index, value -&gt;</code> 将一个操作数栈的值存储到数组中<ul><li>byte(boolean)：<code>baload</code>、<code>bastore</code></li><li>char：<code>caload</code>、<code>castore</code></li><li>short：<code>saload</code>、<code>sastore</code></li><li>int：<code>iaload</code>，<code>iastore</code></li><li>long：<code>laload</code>、<code>lastore</code></li><li>float：<code>faload</code>、<code>fastore</code></li><li>double：<code>daload</code>、<code>dastore</code></li><li>reference：<code>aaload</code>、<code>aastore</code></li></ul></li></ul><ul><li><code>arraylength</code>，弹出栈顶的数组，获取数组的长度，长度入栈</li></ul><p>类型检查指令：</p><ul><li><code>checkcast</code>，检查类型强制转换是否可以进行。<br>如果可以进行，那不会改变操作数栈，否则会抛出 ClassCastException 异常</li><li><code>instanceof</code>，用来判断给定对象是否是某一个类的实例，将判断结果压栈</li></ul><h4 id="方法调用与返回指令"><a href="#方法调用与返回指令" class="headerlink" title="方法调用与返回指令"></a>方法调用与返回指令</h4><p>方法调用指令：</p><ul><li><code>invokevirtual</code>，调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派），支持多态。这也是Java语言中<strong>最常见的方法分派方式</strong></li><li><code>invokeinterface</code>，<strong>调用接口方法</strong>，它会在运行时搜索由特定对象所实现的这个接口方法，并找出适合的方法进行调用</li><li><code>invokespecial</code>，调用一些需要特殊处理的实例方法，包括<strong>实例初始化方法（构造器）</strong>、<strong>私有方法</strong>和<strong>父类方法</strong>。这些方法都是<strong>静态类型绑定</strong>的，不会在调用时进行动态分派</li><li><code>invokestatic</code>，调用命名类中的类方法。<strong>静态绑定</strong>。若一个类方法是私有的，也是用 <code>invokestatic</code></li><li><code>invokedynamic</code>：调用动态绑定的方法，这个是 JDK1.7 后新加入的指令。用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前面 4 条调用指令的分派逻辑都固化在 java 虚拟机内部，而 invokedynamic 指令的分派逻辑是由用户所设定的引导方法决定的</li></ul><p>返回指令：</p><ul><li><code>ireturn</code>（返回值是 boolean、byte、char、short 和 int）</li><li><code>lreturn</code></li><li><code>freturn</code></li><li><code>dreturn</code></li><li><code>areturn</code></li><li><code>return</code> ，声明为 void 的方法实现</li><li>将当前函数操作数栈的顶层元素弹出，并将这个元素压入调用者函数的操作数栈中（因为调用者非常关心函数的返回值），所有在当前函数操作数栈中的其他元素都会被丢弃</li><li>如果当前返回的是 synchronized 方法，那么还会执行一个隐含的 monitorexit 指令，退出临界区</li></ul><h4 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h4><ul><li>操作数栈管理指令<ul><li><code>pop</code>，<code>pop2</code>：将栈顶的 1、2 个 slot 出栈</li><li><code>dup</code>，<code>dup2</code>：复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：</li><li>``dup_x1<code>，</code>dup2_x1<code>，</code>dup_x2<code>，</code>dup2_x2<code>：带</code>_x` 的指令是复制栈顶数据并插入栈顶以下的某个位置<ul><li><code>dup_x1</code> 插入位置 1+1=2，即栈顶 2 个 Slot 下面</li><li><code>dup_x2</code> 插入位置 1+2=3，即栈顶 3 个 Slot 下面</li><li><code>dup2_x1</code> 插入位置 2+1=3，即栈顶 3 个 Slot 下面</li><li><code>dup2_x2</code> 插入位置 2+2=4，即栈顶 4 个 Slot 下面</li></ul></li><li><code>swap</code>：将栈最顶端的两个 slot 数值位置交换：JVM 没提供交换两个 64 位数据类型的指令。</li><li><code>nop</code>：一个非常特殊的指令，它的字节码为 0x00。和汇编语言中的 nop一样，表示什么都不做。一般可用于调试、占位等。</li></ul></li></ul><h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><ul><li><p>比较指令<code>dcmpg</code>、<code>dcmpl</code>、<code>fcmpg</code>、<code>fcmpl</code>、<code>lcmp</code></p><ul><li>在 算术指令 中涉及</li></ul></li><li><p>条件跳转指令</p><ul><li>条件跳转指令通常和比较指令结合使用。在条件跳转指令执行前，一般可以先用比较指令进行栈顶元素的准备，然后进行条件跳转。</li><li><code>ifeq</code>，<code>iflt</code>，<code>ifle</code>，<code>ifne</code>，<code>ifgt</code>，<code>ifge</code>，<code>ifnull</code>，<code>ifnonnull</code>，弹出栈顶元素，测试它是否满足某一条件，如果满足条件，则跳转到给定位置。和 0 比较、判 null<br>接收两个字节的操作数，用于计算跳转的位置（16 位符号整数作为当前位置的 offset）</li></ul></li><li><p>比较条件跳转指令</p><ul><li>类似于比较指令和条件跳转指令的结合体</li><li><code>if_icmpeq</code>、<code>if_icmpne</code>、<code>if_icmplt</code>、<code>if_icmpgt</code>、<code>if_icmple</code>、<code>if_icmpge</code>、<code>if_acmpeq</code> 、<code>if_acmpne</code><br>以字符“i”开头的指令针对 int 型（包括 short 和 byte ）操作，以字符 “a” 开头的指令表示对象引用的比较，<strong>比较 次栈顶 和 栈顶</strong><br>接收两个字节的操作数作为参数，用于计算跳转的位置。</li></ul></li><li><p>多条件分支跳转指令</p><ul><li><p>专为 switch-case 语句设计，主要有 <code>tableswitch</code> 和 <code>lookupswitch</code>，从助记符上看，两者都是 switch 语句的实现，区别如下</p></li><li><p><code>tableswitch</code> 要求多个<strong>条件分支值是连续的</strong>，它内部只存放起始值和终止值，以及若干个跳转偏移量，通过给定的操作数 index，可以立即定位到跳转偏移量位置，因此<strong>效率比较高</strong></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">switch</span> (select) &#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:</span><br><span class="line">        num = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:</span><br><span class="line">        num = <span class="hljs-number">20</span>;</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:</span><br><span class="line">        num = <span class="hljs-number">30</span>;</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">default</span>:</span><br><span class="line">        num = <span class="hljs-number">40</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="hljs-comment">// 字节码如下：</span></span><br><span class="line"><span class="hljs-comment">// 1 tableswitch 1 to 3	1:  28 (+27)</span></span><br><span class="line"><span class="hljs-comment">//	                                   2:  34 (+33)</span></span><br><span class="line"><span class="hljs-comment">//	                                   3:  37 (+36)</span></span><br><span class="line"><span class="hljs-comment">//	                                   default:  43 (+42)</span></span><br><span class="line"><span class="hljs-comment">//34 bipush 20</span></span><br><span class="line"><span class="hljs-comment">//36 istore_2</span></span><br><span class="line"><span class="hljs-comment">//37 bipush 30</span></span><br><span class="line"><span class="hljs-comment">//39 istore_2</span></span><br><span class="line"><span class="hljs-comment">//40 goto 46 (+6)</span></span><br></pre></td></tr></table></figure></li><li><p><code>lookupswitch</code> 内部<strong>存放着各个离散的 case-offset 对</strong>，每次执行都要搜索全部的case-offset 对（根据 case 排序好的），找到匹配的 case 值，并根据对应的 offset 计算跳转地址，因此<strong>效率较低</strong>。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">switch</span> (select) &#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-number">100</span>:</span><br><span class="line">        num = <span class="hljs-number">10</span>;</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-number">500</span>:</span><br><span class="line">        num = <span class="hljs-number">20</span>;</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-number">200</span>:</span><br><span class="line">        num = <span class="hljs-number">30</span>;</span><br><span class="line">        <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">default</span>:</span><br><span class="line">        num = <span class="hljs-number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 字节码如下：</span></span><br><span class="line"><span class="hljs-comment">//  1 lookupswitch 3</span></span><br><span class="line"><span class="hljs-comment">//	                              100:  36 (+35)</span></span><br><span class="line"><span class="hljs-comment">//	                              200:  48 (+47)</span></span><br><span class="line"><span class="hljs-comment">//	                              500:  42 (+41)</span></span><br><span class="line"><span class="hljs-comment">//	                              default:  54 (+53)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// JDK7，switch 支持 String，即先 hashCode 对比，再 equals 对比</span></span><br><span class="line"><span class="hljs-keyword">switch</span> (season) &#123;</span><br><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-string">"SPRING"</span>: <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-string">"SUMMER"</span>: <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-string">"AUTUMN"</span>: <span class="hljs-keyword">break</span>;</span><br><span class="line">    <span class="hljs-keyword">case</span> <span class="hljs-string">"WINTER"</span>:  <span class="hljs-keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">//  5 invokevirtual #8 &lt;java/lang/String.hashCode&gt;       这里先求 hashCode</span></span><br><span class="line"><span class="hljs-comment">//  8 lookupswitch 4</span></span><br><span class="line"><span class="hljs-comment">//	                              -1842350579:  52 (+44)</span></span><br><span class="line"><span class="hljs-comment">//	                              -1837878353:  66 (+58)</span></span><br><span class="line"><span class="hljs-comment">//	                              -1734407483:  94 (+86)</span></span><br><span class="line"><span class="hljs-comment">//	                                1941980694:  80 (+72)</span></span><br><span class="line"><span class="hljs-comment">//	                                default:  105 (+97)</span></span><br><span class="line"><span class="hljs-comment">// 52 aload_2</span></span><br><span class="line"><span class="hljs-comment">// 53 ldc #9 &lt;SPRING&gt;</span></span><br><span class="line"><span class="hljs-comment">// 55 invokevirtual #10 &lt;java/lang/String.equals&gt;             这里调 equal</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>无条件跳转指令<ul><li><code>goto</code>，接收 2 个字节的带符号整数</li><li><code>goto_w</code>，接收 4 个字节的带符号整数</li><li>指令 jsr、jsr_w、ret 虽然也是无条件跳转的，已经被虚拟机逐渐废弃（原主要用于 try-finally 语句，现在 try-finally 用异常表来实现），故不在这里介绍</li></ul></li></ul><h4 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><p><code>athrow</code> 指令：</p><ul><li><p>Java 程序中显式抛异常的操作的实现</p></li><li><p>除了使用 throw 语句抛异常情况外，<strong>JVM 规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动抛出</strong><br>例如，当除数为零时，虚拟机会在 <code>idiv</code> 或 <code>ldiv</code> 中自动抛出 ArithmeticException 异常</p></li><li><p>正常情况下，操作数栈的压入弹出都是一条条指令完成的。唯一的例外情况是：<br>抛异常时，JVM 会清除操作数栈上的所有内容，后将异常实例压入调用者操作数栈上。</p></li></ul><p>异常表：</p><ul><li>JVM 处理异常（catch语句）不是由字节码指令来实现（早期使用 jsr、ret 指令），而是<strong>采用异常表</strong>来完成的。</li></ul><ul><li>如果一个方法定义了一个 try-catch 或者 try-finally 的异常处理，就会创建一个异常表。它包含了每个异常处理或者 finally 块的信息。异常表保存了每个异常处理信息。比如：<ul><li>起始位置-结束位置</li><li>程序计数器记录的代码处理的偏移地址</li><li>被捕获的异常类在常量池中的索引</li></ul></li><li>当一个异常被抛出时，JVM 会在当前的方法里寻一个匹配的处理，如果没找到，这个方法会强制结束并弹出当前栈帧，并且异常会重新抛给上层调用的方法（在调用方法栈帧）。<br>如果在所有栈帧弹出前仍然没有找到合适的异常处理，这个线程将终止。如果这个异常在最后一个非守护线程里抛出，将会导致 JVM 自己终止，比如这个线程是个 main 线程。</li><li>不管什么时候抛出异常，如果异常处理最终匹配了所有异常类型，代码就会继续执行。在这种情况下，如果方法结束后没有抛出异常，仍然执行 finally 块，在 return 前，它直接跳到 finally 块来完成目标</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 思考：如下方法返回结果为多少？"hello2" 会被输出吗？返回 "hello"、会</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    String str = <span class="hljs-string">"hello"</span>;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> str;</span><br><span class="line">    &#125; <span class="hljs-keyword">finally</span> &#123;</span><br><span class="line">        str = <span class="hljs-string">"hello2"</span>;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 字节码</span></span><br><span class="line">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> java.lang.<span class="hljs-function">String <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       0: ldc           #7                  // String hello</span><br><span class="line">       <span class="hljs-number">2</span>: astore_0</span><br><span class="line">           </span><br><span class="line">       <span class="hljs-number">3</span>: aload_0</span><br><span class="line">       <span class="hljs-number">4</span>: astore_1</span><br><span class="line">           </span><br><span class="line">       5: ldc           #8                  // String hello2</span><br><span class="line">       <span class="hljs-number">7</span>: astore_0</span><br><span class="line">       8: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="hljs-number">11</span>: aload_0</span><br><span class="line">      12: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="hljs-number">15</span>: aload_1</span><br><span class="line">      <span class="hljs-number">16</span>: areturn</span><br><span class="line">          </span><br><span class="line">      <span class="hljs-number">17</span>: astore_2                       <span class="hljs-comment">// 只有发生异常才来这，先把 exception 实例存起来</span></span><br><span class="line">      18: ldc           #8                  // String hello2</span><br><span class="line">      <span class="hljs-number">20</span>: astore_0</span><br><span class="line">      21: getstatic     #9                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">      <span class="hljs-number">24</span>: aload_0</span><br><span class="line">      25: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">      <span class="hljs-number">28</span>: aload_2                         <span class="hljs-comment">// 载入 exception 实例到栈上</span></span><br><span class="line">      <span class="hljs-number">29</span>: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="hljs-number">3</span>     <span class="hljs-number">5</span>    <span class="hljs-number">17</span>   any          <span class="hljs-comment">// [from, to) 区间发生异常跳 17</span></span><br></pre></td></tr></table></figure><h4 id="同步控制指令"><a href="#同步控制指令" class="headerlink" title="同步控制指令"></a>同步控制指令</h4><p>JVM 支持两种同步结构：方法级的同步和方法内部一段指令序列的同步，这两种同步都是使用monitor 来支持的。</p><p>方法级的同步：</p><ul><li>是隐式的，即无须通过字节码指令来控制，它实现在方法调用和返回操作之中。<br>虚拟机可以从方法常量池的方法表结构中的 <code>ACC_SYNCHRONIZED</code> 访问标志得知一个方法是否声明为同步方法</li><li>当调用方法时，调用指令将会检查方法的 <code>ACC_SYNCHRONIZED</code> 访问标志是否设置<ul><li>若设置了，执行线程将先持有同步锁，然后执行方法。最后在方法完成（无论是正常完成还是非正常完成）时释放同步锁</li><li>在方法执行期间，执行线程持有了同步锁，其他任何线程都无法再获得同一个锁</li><li>如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的锁将在异常抛到同步方法之外时自动释放</li></ul></li></ul><p>方法内指定指令序列的同步：</p><ul><li>同步一段指令集序列： 通常是由 java 中的 synchronized 语句块来表示的</li><li>jvm 的指令集有 <code>monitorenter</code> 和 <code>monitorexit</code> 两条指令来支持 synchronized 关键字的语义</li><li>当一个线程进入同步代码块时，它使用 <code>monitorenter</code> 指令请求进入。<br>如果当前对象的监视器计数器为 0，则它会被准许进入，若为 1，则判断持有当前监视器的线程是否为自己，如果是，则进入，否则进行等待，直到对象的监视器计数器为 0，才会被允许进入同步块</li><li>当线程退出同步块时，需要使用 <code>monitorexit</code> 声明退出。在 JVM 中，任何对象都有一个监视器与之相关联，用来判断对象是否被锁定，当监视器被持有后，对象处于锁定状态</li><li>指令 <code>monitorenter</code> 和 <code>monitorexit</code> 在执行时，都需要在操作数栈顶压入对象，之后<code>monitorenter</code> 和 <code>monitorexit</code> 的锁定和释放都是针对这个对象的监视器进行的</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">private</span> Object obj = <span class="hljs-keyword">new</span> Object();</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subtract</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (obj) &#123;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 字节码</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">subtract</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="hljs-number">0</span>: aload_0</span><br><span class="line">       1: getfield      #4                  // Field obj:Ljava/lang/Object;</span><br><span class="line">       <span class="hljs-number">4</span>: dup</span><br><span class="line">       <span class="hljs-number">5</span>: astore_1</span><br><span class="line">       <span class="hljs-number">6</span>: monitorenter</span><br><span class="line">           </span><br><span class="line">       <span class="hljs-number">7</span>: aload_0</span><br><span class="line">       <span class="hljs-number">8</span>: dup</span><br><span class="line">       9: getfield      #2                  // Field i:I</span><br><span class="line">      <span class="hljs-number">12</span>: iconst_1</span><br><span class="line">      <span class="hljs-number">13</span>: isub</span><br><span class="line">      14: putfield      #2                  // Field i:I</span><br><span class="line">      <span class="hljs-number">17</span>: aload_1</span><br><span class="line">      <span class="hljs-number">18</span>: monitorexit</span><br><span class="line">          </span><br><span class="line">      <span class="hljs-number">19</span>: goto          <span class="hljs-number">27</span></span><br><span class="line">                               <span class="hljs-comment">// 下面这一段结合异常表，当同步代码块抛异常也要先 monitorexit 再抛</span></span><br><span class="line">      <span class="hljs-number">22</span>: astore_2</span><br><span class="line">      <span class="hljs-number">23</span>: aload_1</span><br><span class="line">      <span class="hljs-number">24</span>: monitorexit</span><br><span class="line">      <span class="hljs-number">25</span>: aload_2</span><br><span class="line">      <span class="hljs-number">26</span>: athrow</span><br><span class="line">      <span class="hljs-number">27</span>: <span class="hljs-keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="hljs-number">7</span>    <span class="hljs-number">19</span>    <span class="hljs-number">22</span>   any</span><br><span class="line">          <span class="hljs-number">22</span>    <span class="hljs-number">25</span>    <span class="hljs-number">22</span>   any</span><br></pre></td></tr></table></figure><h3 id="类的加载过程-1"><a href="#类的加载过程-1" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><ul><li>在 Java 中数据类型分为基本数据类型和引用数据类型。<br>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</li><li>按照 JVM 规范，从 class 文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下 7 个阶段<ul><li>加载 Loading</li><li>链接 Linking<ul><li>验证 Verification</li><li>准备 Preparation</li><li>解析 Resolution</li></ul></li><li>初始化 Initialization</li><li>使用 Using</li><li>卸载 Unloading</li></ul></li></ul><img src="image-20210127150301468.png" style="zoom:50%"><h4 id="过程一：Loading"><a href="#过程一：Loading" class="headerlink" title="过程一：Loading"></a>过程一：Loading</h4><p>加载的理解：</p><ul><li>所谓加载，简而言之就是将 Java 类的字节码文件加载到机器内存中，并在内存中构建出 Java 类的原型 —— 类模板对象。<br>所谓类模板对象，其实就是 Java 类在 JVM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，如此 JVM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用</li><li>反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射</li></ul><p>加载完成的操作：</p><ul><li>查找并加载类的二进制数据，生成 Class 的实例。</li><li>在加载类时，JVM 必须完成以下 3 件事情：<ul><li>通过类的全限定类名，获取类的二进制数据流。</li><li>解析类的二进制数据流为方法区内的数据结构（Java 类模型）</li><li>创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</li></ul></li></ul><p>二进制流的获取方式：</p><ul><li>对于类的二进制数据流，虚拟机可通过多种途径产生或获得（只要字节码符合 JVM 规范）<ul><li>本地系统</li><li>网络，比如 Web Applet</li><li>zip 包（jar、war 格式的基础）</li><li>运行时计算生成，如动态代理</li><li>由其他文件生成，如 JSP</li><li>从专有数据库中提取 .class 文件，少见</li><li>从加密文件中获取，典型地防 Class 文件被反编译的措施</li></ul></li><li>在获取到类的二进制信息后，JVM 就会处理这些数据，并最终转为一个 java.lang.Class 的实例</li><li>如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError</li></ul><p>类模型与 Class 实例的位置：</p><ul><li><p>类模型的位置：加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区<br>（JDK8 之前：永久代；JDK8及之后：元空间）</p></li><li><p>Class 实例的位置：类将 <code>.class</code> 文件加载至元空间后，会在堆中创建一个 Java.lang.Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象</p><ul><li>Class 类的构造方法是私有的，只有 JVM 能够创建。</li><li>java.lang.Class 实例是访问类型元数据的接口，也是实现反射的关键入口<br>通过class类提供的接口，可以获得目标类所关联的 .class 文件中具体的数据结构：方法、字段等信息</li><li>三种获取方式：<code>Class.forName(类的全路径)</code>、<code>实例对象.class(属性)</code>、<code>实例对象.getClass()</code></li></ul></li></ul><img src="image-20210319201457263.png" style="zoom:50%"><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/**</span></span><br><span class="line"><span class="hljs-comment"> * 通过cLass类，获得了java.Lang.string类的所有方法信息，并打印方法访问标识符、描述符</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadingTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(<span class="hljs-string">"java.lang.String"</span>);</span><br><span class="line">            <span class="hljs-comment">//获取当前运行时类声明的所有方法</span></span><br><span class="line">            Method[] ms = clazz.getDeclaredMethods();</span><br><span class="line">            <span class="hljs-keyword">for</span> (Method m : ms) &#123;</span><br><span class="line">                <span class="hljs-comment">//获取方法的修饰符</span></span><br><span class="line">                String mod = Modifier.toString(m.getModifiers());</span><br><span class="line">                System.out.print(mod + <span class="hljs-string">""</span>);</span><br><span class="line">                <span class="hljs-comment">//获取方法的返回值类型</span></span><br><span class="line">                String returnType = (m.getReturnType()).getSimpleName();</span><br><span class="line">                System.out.print(returnType + <span class="hljs-string">""</span>);</span><br><span class="line">                <span class="hljs-comment">//获取方法名</span></span><br><span class="line">                System.out.print(m.getName() + <span class="hljs-string">"("</span>);</span><br><span class="line">                <span class="hljs-comment">//获取方法的参数列表</span></span><br><span class="line">                Class&lt;?&gt;[] ps = m.getParameterTypes();</span><br><span class="line">                <span class="hljs-keyword">if</span> (ps.length == <span class="hljs-number">0</span>) System.out.print(<span class="hljs-string">')'</span>);</span><br><span class="line">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; ps.length; i++) &#123;</span><br><span class="line">                    <span class="hljs-keyword">char</span> end = (i == ps.length - <span class="hljs-number">1</span>) ? <span class="hljs-string">')'</span> : <span class="hljs-string">','</span>;</span><br><span class="line">                    <span class="hljs-comment">//获取参教的类型</span></span><br><span class="line">                    System.out.print(ps[i].getSimpleName() + end);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组类的加载：</p><ul><li>创建数组类稍有特殊，因为数组类本身并非由类加载器负责，而是由 JVM 在运行时根据需要而直接创建，但数组的元素类型仍然需要依靠类加载器去创建</li><li>创建数组类 A 的过程：<ul><li>若元素类型是引用类型，那遵循定义的加载过程递归加载和创建 A 元素类型（int[] 则不用加载基本类型 int）</li><li>JVM 使用 A 元素类型、数组维度来创建新的数组类</li></ul></li><li>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为 public</li></ul><h4 id="过程二：Linking"><a href="#过程二：Linking" class="headerlink" title="过程二：Linking"></a>过程二：Linking</h4><h5 id="环节一：Verification"><a href="#环节一：Verification" class="headerlink" title="环节一：Verification"></a>环节一：Verification</h5><p>目的：保证加载的字节码是合法、合理并符合规范</p><p>验证的步骤较复杂，实际要验证的项目也很繁多，大体上如下：</p><ul><li><strong>格式检查</strong><ul><li>和 <strong>Loading 阶段</strong> 一起执行，虽拖慢了加载速度，但避免在字节码运行时做检查。<br>验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中</li><li>MagicNumber 检查、版本检查、长度检查（数据中每一个项是否有正确的长度）</li></ul></li><li><strong>语义检查</strong><ul><li>是否所有的类都有父类的存在</li><li>是否一些被定义为 final 的方法或者类被重写或继承</li><li>非抽象类是否实现了所有抽象方法/接口方法</li></ul></li><li><strong>字节码验证</strong>（验证过程中最为复杂的过程。试图通过对字节码流分析，判断字节码是否可被正确执行）<ul><li>字节码执行过程中，是否会跳到一条不存在的指令</li><li>函数的调用是否传递了正确类型的参数</li><li>变量的赋值是不是给了正确的数据类型</li><li><strong>栈映射帧 (StackMapTable) 就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型</strong>。<br>但遗憾，100% 准确地判断一段字节码是否可被安全执行是无法实现的，因此，该过程只是尽可能检查出可预知的明显问题。<br>若在此阶段无法通过检查，虚拟机也不会正确装载该类。但若通过了这个阶段的检查，也不能说明该类完全没有问题。</li></ul></li><li><strong>符号引用验证</strong>（验证符号引用的直接引用是否存在）<ul><li>Class 文件在其常量池会通过字符串记录自己将要使用的其他类/方法。<br>因此，在验证阶段，虚拟机就会检查这些类或者方法确实是存在的，并且当前类有权限访问这些数据，如果一个需要类无法在系统中找到，则会抛出 NoClassDefFoundError<br>如果一个方法无法被找到，则会抛出 NoSuchMethodError。<br>此阶段在解析环节才会执行</li></ul></li></ul><h5 id="环节二：Preparation"><a href="#环节二：Preparation" class="headerlink" title="环节二：Preparation"></a>环节二：Preparation</h5><p>为类的静态变量分配内存，并设置默认初始值</p><ul><li>byte，(byte)0</li><li>short，(short)0</li><li>int，0</li><li>long，0L</li><li>float，0.0f</li><li>double，0.0</li><li>char，<code>\u0000</code></li><li>boolean，false</li><li>reference，null</li></ul><p>不会为实例变量分配初始化，<strong>类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆</strong></p><p><strong>这个阶段并不会像初始化阶段中那样会有初始化或代码被执行</strong></p><p>基本数据类型：</p><ul><li>非 final 修饰，在准备环节设置默认初始值 ，Initialization 阶段里的 <code>&lt;clinit&gt;</code> 进行初始化</li><li>final 修饰，编译时分配到常量池，在准备环节直接显式赋值</li></ul><p>引用类型 String:</p><ul><li><code>static final String s1 = &quot;const&quot;</code>，如果使用字面量的方式定义一个 final String 的话，也是在准备环节直接进行显式赋值</li><li><code>static final String s2 = new String(&quot;const&quot;)</code>，Initialization 阶段里的 <code>&lt;clinit&gt;</code> 进行初始化</li></ul><h5 id="环节三：Resolution"><a href="#环节三：Resolution" class="headerlink" title="环节三：Resolution"></a>环节三：Resolution</h5><ul><li><p>将类、接口、字段、方法的<strong>符号引用转为直接引用</strong>（类/字段/方法在内存中的指针/偏移量）</p><ul><li>符号引用就是一些字面量的引用，和虚拟机的内部数据结构、内存布局无关。在 Class 类文件中，通过常量池进行了大量的符号引用。</li><li>但在程序实际运行时，只有符号引用是不够的，比如当如下 <code>println()</code> 方法被调用时，系统需要明确知道该方法的位置<br>操作 <code>System.out.println()</code> 对应的字节码：<code>invokevirtual #24 &lt;java/io/PrintStream.println&gt;</code> <img src="image-20210320195454191.png" style="zoom:43%"></li></ul></li><li><p>以<strong>方法</strong>为例，JVM 为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类方法时，只要知道这个方法在方法表中的偏移量就可直接调用该方法。<br>通过 Resolution，符号引用就可转变为目标方法在类中方法表的位置，从而使得方法被成功调用</p></li></ul><h4 id="过程三：Initialization"><a href="#过程三：Initialization" class="headerlink" title="过程三：Initialization"></a>过程三：Initialization</h4><p>概述：</p><ul><li>初始化什么？ —— 类中的静态变量</li></ul><ul><li>类的初始化是类装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利装载到系统中。<br>此时，类才会开始执行 Java 字节码（即：到了初始化阶段，才真正开始执行类中定义的 Java 程序代码）</li><li>初始化阶段的重要工作是执行类的初始化方法：<code>&lt;clinit&gt;()</code><ul><li>由<strong>类静态成员的赋值语句</strong>以及 <strong>static 语句块</strong>合并产生</li><li>该方法仅能由 Java 编译器生成并由 JVM 调用，程序开发者无法自定义一个同名的方法，更无法直接在Java 程序中调用该方法，虽然该方法也是由字节码指令所组成。</li></ul></li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitializationTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> id = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> number;</span><br><span class="line">    <span class="hljs-keyword">static</span> &#123;</span><br><span class="line">        number = <span class="hljs-number">2</span>;</span><br><span class="line">        System.out.println(<span class="hljs-string">"father static(&#125;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// clinit方法：</span></span><br><span class="line"><span class="hljs-comment">// 0 iconst_1</span></span><br><span class="line"><span class="hljs-comment">// 1 putstatic #2 &lt;T1/InitializationTest.id&gt;</span></span><br><span class="line"><span class="hljs-comment">// 4 iconst_2</span></span><br><span class="line"><span class="hljs-comment">// 5 putstatic #3 &lt;T1/InitializationTest.number&gt;</span></span><br><span class="line"><span class="hljs-comment">// 8 getstatic #4 &lt;java/lang/System.out&gt;</span></span><br><span class="line"><span class="hljs-comment">//11 ldc #5 &lt;father static(&#125;&gt;</span></span><br><span class="line"><span class="hljs-comment">//13 invokevirtual #6 &lt;java/io/PrintStream.println&gt;</span></span><br><span class="line"><span class="hljs-comment">//16 return</span></span><br></pre></td></tr></table></figure><ul><li>在加载一个类前，JVM 总会试图加载该类的父类，因此父类的 <code>&lt;clinit&gt;</code> 总是在子类 <code>&lt;clinit&gt;</code> 之前被调用。也即是说，父类的static块优先级高于子类。</li></ul><p>Java 编译器不会产生 <code>&lt;clinit&gt;()</code> 情况：</p><ul><li>类中没声明任何的静态变量，也无静态代码块</li><li>类中声明静态变量，但是没有明确使用类变量的初始化语句或静态代码块来执行初始化操作</li><li>类中包含 static final 修饰的基本数据类型的字段，这些类字段初始化语句采用编译时常量表达式</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitializationTest1</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">//场景1：对应非静态的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;</span><br><span class="line">    <span class="hljs-comment">//场景2：静态的字段，没有显式的赋值，不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> numl;</span><br><span class="line">    <span class="hljs-comment">//场景3：比如对于声明为static final的基本数据类型的字段，不管是否进行了显式赋值，都不会生成&lt;clinit&gt;()方法</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> num2 = <span class="hljs-number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linking-Preparation 环节 和 Initialization 环节的区别：</p><ul><li>所有非 final 的 static 都是在初始化 <code>&lt;clini&gt;()</code> 显示赋值。<br>不涉及符号引用，就直接在链接阶段的准备环节显示赋值</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InitializationTest2</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>; <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INT_CONSTANT = <span class="hljs-number">10</span>;     <span class="hljs-comment">// 在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer INTEGER_CONSTANT1 = Integer.valueOf(<span class="hljs-number">100</span>);     <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer INTEGER_CONSTANT2 = Integer.valueOf(<span class="hljs-number">100</span>);     <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中概值</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String se = <span class="hljs-string">"helloworlde"</span>;     <span class="hljs-comment">// 在链接阶段的准备环节赋值</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"helloworld1"</span>);   <span class="hljs-comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NUM1 = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">10</span>); <span class="hljs-comment">// 在初始化阶段clinit&gt;()中赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;clinit&gt;()</code> 的线程安全性：</p><ul><li><code>&lt;clinit&gt;()</code> 调用，JVM 会在内部确保其多线程环境中的安全性</li><li>虚拟机会保证一个类的 <code>&lt;clinit&gt;()</code> 在多线程环境中被正确地加锁、同步。</li><li>正因为 <code>&lt;clinit&gt;()</code> 线程安全，因此，若在类的 <code>&lt;clinit&gt;()</code> 方法中有耗时很长的操作，就可能造成多线程阻塞，引发死锁。<br>且这种死锁很难发现，因为它们看起来并没有可用的锁信息。</li><li>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行 <code>&lt;clinit&gt;()</code> 方法了。<br>在需要使用这个类时，虚拟机会直接返回给它已准备好的信息。</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// clinit 死锁 demo</span></span><br><span class="line"><span class="hljs-keyword">package</span> T1;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticA</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="hljs-number">100</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="hljs-string">"T1.StaticB"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="hljs-string">"staticA init Ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticB</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="hljs-number">100</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="hljs-string">"T1.StaticA"</span>);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="hljs-string">"staticB init Ok"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticDeadLockMain</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StaticDeadLockMain</span><span class="hljs-params">(<span class="hljs-keyword">char</span> flag)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.flag = flag;</span><br><span class="line">        <span class="hljs-keyword">this</span>.setName(<span class="hljs-string">"Thread"</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="hljs-string">"T1.Static"</span> + flag);</span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName() + <span class="hljs-string">"over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, InterruptedException </span>&#123;</span><br><span class="line">        StaticDeadLockMain loadA = <span class="hljs-keyword">new</span> StaticDeadLockMain(<span class="hljs-string">'A'</span>);</span><br><span class="line">        loadA.start();</span><br><span class="line">        StaticDeadLockMain loadB = <span class="hljs-keyword">new</span> StaticDeadLockMain(<span class="hljs-string">'B'</span>);</span><br><span class="line">        loadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Java 对类的 <strong>主动使用</strong>、<strong>被动使用</strong>：</p><ul><li>主动使用才会调用 <code>&lt;clinit&gt;</code>，被动使用不会引起类的初始化</li><li>被动使用不会引起类的初始化，但有可能只是加载了没进行初始化<br>比如调用类的 final+static 的字段，有加载能输出字段，但没经历初始化</li></ul><p>主动使用：Class 只有在必须要首次使用的时候才会被装载，JVM 不会无条件地装载 Class。<br>JVM 规定，一个类/接口在初次使用（指主动使用）前，必须要进行初始化。</p><ol><li>创建类实例时，如：new、反射、克隆、反序列化</li><li>调用类静态方法，即使用 <code>invokestatic</code></li><li>使用类/接口的静态字段（final 修饰则特殊考虑），如：用 <code>getstatic</code>、<code>putstatic</code></li><li>用 <code>java.lang.reflect</code> 包中的方法反射类的方法时。如：<code>Class.forName(&quot;com.atguigu.java.Test&quot;)</code></li><li>初始化子类时，发现其父类还未初始化，则需先触发其父类初始化<ul><li>当 JVM 初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。<ul><li>在初始化一个类时，并不会先初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li><li>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。<br>只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化。</li></ul></li></ul></li><li>接口定义 default 方法，初始直接/间接实现该接口的类，该接口要在其之前被初始化</li><li>虚拟机启动时，先初始化用户指定的某个主类<ul><li>VM 启动时通过引导类加载器加载一个初始类。<br>这个类在调用 <code>public static void main(String[])</code> 方法前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</li></ul></li><li>初次调用 <code>MethodHandle</code> 实例时，初始化该 <code>MethodHandle</code> 指向的方法所在的类<br>（涉及解析 REF getStatic、REF_putStatic、REF invokeStatic 方法句柄对应的类）</li></ol><blockquote><p>-XX:+TraceClassLoading ，可打印出类的加载顺序，用来排查 class 的冲突问题</p></blockquote><h4 id="过程四：Using"><a href="#过程四：Using" class="headerlink" title="过程四：Using"></a>过程四：Using</h4><h4 id="过程五：Unloading"><a href="#过程五：Unloading" class="headerlink" title="过程五：Unloading"></a>过程五：Unloading</h4><h3 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h3><h2 id="性能监控与调优"><a href="#性能监控与调优" class="headerlink" title="性能监控与调优"></a>性能监控与调优</h2></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://zhangt.top/CS/JVM-Study-Notes/">JVM-学习笔记</a></li><li><strong>本文作者：</strong><a href="https://zhangt.top">ZhangT</a></li><li><strong>本文链接：</strong><a href="https://zhangt.top/CS/JVM-Study-Notes/">https://zhangt.top/CS/JVM-Study-Notes/</a></li><li><strong>发布时间：</strong>2021-01-15</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><hr style="height:1px;margin:1rem 0"><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><i class="fas fa-tags has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/tags/JAVA/">JAVA</a>,&nbsp;<a class="has-link-grey -link" href="/tags/PROGRAMMING/">PROGRAMMING</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？投喂一下吧！ヾ(●´∀｀●)</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i> </span><span>支付宝</span><div class="qrcode"><img src="/images/alipay.jpg" alt="支付宝"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/Life/Thoughts-In-Avalon-Game/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">关于阿瓦隆桌游（类狼人杀游戏）的碎碎念</span></a></div><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/LIFE/Internship-Guide-In-The-Spring/"><span class="level-item">春招实习指南</span> <i class="level-item fas fa-chevron-right"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"91f36240e98756fc091e",clientSecret:"20de2f4dadd54bc04ad8db6c1090fb00a9477ac4",id:"ff8a2f990aa24b0aec2190a2f43e5b47",repo:"zhangt2333.github.io",owner:"zhangt2333",admin:"zhangt2333",createIssueManually:!1,distractionFreeMode:!1});gitalk.render("comment-container")</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered"><div><img class="image is-96x96 has-mb-6" src="/images/avatar.png" alt="Zhang T"><p class="is-size-4 is-block">Zhang T</p><p class="is-size-6 is-block">感受我的感受</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Nanjing &lt;- Qingdao, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><div class="level-item has-text-centered is-marginless"><a href="/archives/"><p class="heading">文章</p><p class="title has-text-weight-normal">19</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/categories/"><p class="heading">分类</p><p class="title has-text-weight-normal">5</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/tags/"><p class="heading">标签</p><p class="title has-text-weight-normal">21</p></a></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/zhangt2333" target="_blank"><i class="fab fa-github"></i>&nbsp;&nbsp;关注我</a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu" style="max-height:750px;overflow:auto"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#内存与垃圾回收"><span class="has-mr-6">1</span> <span>内存与垃圾回收</span></a><ul class="menu-list"><li><a class="is-flex" href="#JVM-与-Java-体系结构"><span class="has-mr-6">1.1</span> <span>JVM 与 Java 体系结构</span></a><ul class="menu-list"><li><a class="is-flex" href="#前言"><span class="has-mr-6">1.1.1</span> <span>前言</span></a></li><li><a class="is-flex" href="#JVM-的整体结构"><span class="has-mr-6">1.1.2</span> <span>JVM 的整体结构</span></a></li><li><a class="is-flex" href="#Java-代码执行流程"><span class="has-mr-6">1.1.3</span> <span>Java 代码执行流程</span></a></li><li><a class="is-flex" href="#JVM-的架构模型"><span class="has-mr-6">1.1.4</span> <span>JVM 的架构模型</span></a></li><li><a class="is-flex" href="#JVM-的生命周期"><span class="has-mr-6">1.1.5</span> <span>JVM 的生命周期</span></a></li><li><a class="is-flex" href="#JVM-的发展历程"><span class="has-mr-6">1.1.6</span> <span>JVM 的发展历程</span></a></li></ul></li><li><a class="is-flex" href="#类加载子系统"><span class="has-mr-6">1.2</span> <span>类加载子系统</span></a><ul class="menu-list"><li><a class="is-flex" href="#类的加载过程"><span class="has-mr-6">1.2.1</span> <span>类的加载过程</span></a></li><li><a class="is-flex" href="#类加载器的分类"><span class="has-mr-6">1.2.2</span> <span>类加载器的分类</span></a></li><li><a class="is-flex" href="#双亲委派机制"><span class="has-mr-6">1.2.3</span> <span>双亲委派机制</span></a></li></ul></li><li><a class="is-flex" href="#运行时数据区"><span class="has-mr-6">1.3</span> <span>运行时数据区</span></a><ul class="menu-list"><li><a class="is-flex" href="#概述与线程"><span class="has-mr-6">1.3.1</span> <span>概述与线程</span></a></li><li><a class="is-flex" href="#程序计数器"><span class="has-mr-6">1.3.2</span> <span>程序计数器</span></a></li><li><a class="is-flex" href="#虚拟机栈-★"><span class="has-mr-6">1.3.3</span> <span>虚拟机栈 ★</span></a></li><li><a class="is-flex" href="#本地方法接口"><span class="has-mr-6">1.3.4</span> <span>本地方法接口</span></a></li><li><a class="is-flex" href="#本地方法栈"><span class="has-mr-6">1.3.5</span> <span>本地方法栈</span></a></li><li><a class="is-flex" href="#堆-★"><span class="has-mr-6">1.3.6</span> <span>堆 ★</span></a></li><li><a class="is-flex" href="#方法区-★"><span class="has-mr-6">1.3.7</span> <span>方法区 ★</span></a></li><li><a class="is-flex" href="#直接内存"><span class="has-mr-6">1.3.8</span> <span>直接内存</span></a></li></ul></li><li><a class="is-flex" href="#执行引擎"><span class="has-mr-6">1.4</span> <span>执行引擎</span></a></li><li><a class="is-flex" href="#StringTable"><span class="has-mr-6">1.5</span> <span>StringTable</span></a></li><li><a class="is-flex" href="#垃圾回收"><span class="has-mr-6">1.6</span> <span>垃圾回收</span></a></li></ul></li><li><a class="is-flex" href="#字节码与类的加载"><span class="has-mr-6">2</span> <span>字节码与类的加载</span></a><ul class="menu-list"><li><a class="is-flex" href="#Class-文件结构"><span class="has-mr-6">2.1</span> <span>Class 文件结构</span></a><ul class="menu-list"><li><a class="is-flex" href="#前置知识"><span class="has-mr-6">2.1.1</span> <span>前置知识</span></a></li><li><a class="is-flex" href="#魔数"><span class="has-mr-6">2.1.2</span> <span>魔数</span></a></li><li><a class="is-flex" href="#Class-文件版本"><span class="has-mr-6">2.1.3</span> <span>Class 文件版本</span></a></li><li><a class="is-flex" href="#常量池-constant-pool"><span class="has-mr-6">2.1.4</span> <span>常量池 constant_pool</span></a></li><li><a class="is-flex" href="#访问标志-access-flag"><span class="has-mr-6">2.1.5</span> <span>访问标志 access_flag</span></a></li><li><a class="is-flex" href="#类索引、父类索引、接口索引集合"><span class="has-mr-6">2.1.6</span> <span>类索引、父类索引、接口索引集合</span></a></li><li><a class="is-flex" href="#字段表集合"><span class="has-mr-6">2.1.7</span> <span>字段表集合</span></a></li><li><a class="is-flex" href="#方法表集合"><span class="has-mr-6">2.1.8</span> <span>方法表集合</span></a></li><li><a class="is-flex" href="#属性表集合"><span class="has-mr-6">2.1.9</span> <span>属性表集合</span></a></li><li><a class="is-flex" href="#一些工具使用"><span class="has-mr-6">2.1.10</span> <span>一些工具使用</span></a></li></ul></li><li><a class="is-flex" href="#字节码指令"><span class="has-mr-6">2.2</span> <span>字节码指令</span></a><ul class="menu-list"><li><a class="is-flex" href="#引言"><span class="has-mr-6">2.2.1</span> <span>引言</span></a></li><li><a class="is-flex" href="#加载与存储指令"><span class="has-mr-6">2.2.2</span> <span>加载与存储指令</span></a></li><li><a class="is-flex" href="#算术指令"><span class="has-mr-6">2.2.3</span> <span>算术指令</span></a></li><li><a class="is-flex" href="#类型转换指令"><span class="has-mr-6">2.2.4</span> <span>类型转换指令</span></a></li><li><a class="is-flex" href="#对象的创建与访问指令"><span class="has-mr-6">2.2.5</span> <span>对象的创建与访问指令</span></a></li><li><a class="is-flex" href="#方法调用与返回指令"><span class="has-mr-6">2.2.6</span> <span>方法调用与返回指令</span></a></li><li><a class="is-flex" href="#操作数栈管理指令"><span class="has-mr-6">2.2.7</span> <span>操作数栈管理指令</span></a></li><li><a class="is-flex" href="#控制转移指令"><span class="has-mr-6">2.2.8</span> <span>控制转移指令</span></a></li><li><a class="is-flex" href="#异常处理指令"><span class="has-mr-6">2.2.9</span> <span>异常处理指令</span></a></li><li><a class="is-flex" href="#同步控制指令"><span class="has-mr-6">2.2.10</span> <span>同步控制指令</span></a></li></ul></li><li><a class="is-flex" href="#类的加载过程-1"><span class="has-mr-6">2.3</span> <span>类的加载过程</span></a><ul class="menu-list"><li><a class="is-flex" href="#过程一：Loading"><span class="has-mr-6">2.3.1</span> <span>过程一：Loading</span></a></li><li><a class="is-flex" href="#过程二：Linking"><span class="has-mr-6">2.3.2</span> <span>过程二：Linking</span></a></li><li><a class="is-flex" href="#过程三：Initialization"><span class="has-mr-6">2.3.3</span> <span>过程三：Initialization</span></a></li><li><a class="is-flex" href="#过程四：Using"><span class="has-mr-6">2.3.4</span> <span>过程四：Using</span></a></li><li><a class="is-flex" href="#过程五：Unloading"><span class="has-mr-6">2.3.5</span> <span>过程五：Unloading</span></a></li></ul></li><li><a class="is-flex" href="#类的加载器"><span class="has-mr-6">2.4</span> <span>类的加载器</span></a></li></ul></li><li><a class="is-flex" href="#性能监控与调优"><span class="has-mr-6">3</span> <span>性能监控与调优</span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/">TTTT&#39;s Blog</a><p class="is-size-7">&copy; 2021 ZhangT&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},skipTags:["script","noscript","style","textarea","pre","code"],processEscapes:!0,tex2jax:{inlineMath:[["$","$"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>