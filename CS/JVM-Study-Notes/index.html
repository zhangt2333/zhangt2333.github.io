<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>JVM-学习笔记 - Zhang T&#39;s Blog</title><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/">TTTT&#39;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i> </a><a class="navbar-item" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-content article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>JVM-学习笔记</h1><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2021-01-14T16:00:00.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2021-01-15</time> <time class="level-item has-text-grey is-hidden-mobile" datetime="2021-03-05T12:20:00.000Z"><i class="far fa-calendar-check">&nbsp;</i>2021-03-05</time><div class="level-item"><i class="far fa-folder-open has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/categories/CS/">CS</a></div><span class="level-item has-text-grey"><i class="far fa-clock"></i>&nbsp; 2 小时 读完 (大约 14943 个字) </span><span class="level-item has-text-grey" id="busuanzi_container_page_pv"><i class="far fa-eye"></i> <span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p>Java Virtual Machine，So Fascinating.</p><a id="more"></a><p>学习参考资料：</p><ul><li>《深入理解 Java 虚拟机第 3 版》</li><li>宋红康 JVM 教程</li></ul><p>一些工具：</p><ul><li>IDEA Plugin：<code>jclasslib Bytecode viewer</code></li></ul><h1 id="内存与垃圾回收"><a href="#内存与垃圾回收" class="headerlink" title="内存与垃圾回收"></a>内存与垃圾回收</h1><h3 id="JVM-与-Java-体系结构"><a href="#JVM-与-Java-体系结构" class="headerlink" title="JVM 与 Java 体系结构"></a>JVM 与 Java 体系结构</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>The Java Virtual Machine is the cornerstone of the Java platform. It is the component of the technology responsible for its hardware- and operating system-independence, the small size of its compiled code, and its ability to protect users from malicious programs.</p><p>The Java Virtual Machine is an abstract computing machine. Like a real computing machine, it has an instruction set and manipulates various memory areas at run time. It is reasonably common to implement a programming language using a virtual machine.</p><img src="image-20210125124741474.png" style="zoom:50%"> <img src="image-20210125124710215.png" style="zoom:67%"> <img src="image-20210125131050949.png" style="zoom:67%"><p>For the sake of security, the Java Virtual Machine imposes strong syntactic and structural constraints on the code in a <code>class</code> file. However, any language with functionality that can be expressed in terms of a valid <code>class</code> file can be hosted by the Java Virtual Machine. Attracted by a generally available, machine-independent platform, implementors of other languages can turn to the Java Virtual Machine as a delivery vehicle for their languages.</p><h4 id="JVM-的整体结构"><a href="#JVM-的整体结构" class="headerlink" title="JVM 的整体结构"></a>JVM 的整体结构</h4><img src="image-20210125131434154.png" style="zoom:50%"><h4 id="Java-代码执行流程"><a href="#Java-代码执行流程" class="headerlink" title="Java 代码执行流程"></a>Java 代码执行流程</h4><img src="image-20210125131929376.png" style="zoom:50%"><h4 id="JVM-的架构模型"><a href="#JVM-的架构模型" class="headerlink" title="JVM 的架构模型"></a>JVM 的架构模型</h4><p>Java 编译器输入的指令流基本上是一种基于栈的指令集架构。</p><p>基于栈式架构的特点：</p><ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int i = 2;</span><br><span class="line">int j = 3;</span><br><span class="line">int k = i + j;</span><br><span class="line">// 字节码</span><br><span class="line">iconst_2</span><br><span class="line">istore_1</span><br><span class="line">iconst_3</span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd</span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure><p>基于寄存器架构的特点：</p><ul><li>典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机。</li><li><strong>指令集架构则完全依赖硬件，可移植性差</strong></li><li><strong>性能优秀和执行更高效</strong></li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 2+3</span><br><span class="line">mov eax, 2</span><br><span class="line">add eax, 3</span><br></pre></td></tr></table></figure><p>反编译操作：<code>javap -v test.class</code></p><h4 id="JVM-的生命周期"><a href="#JVM-的生命周期" class="headerlink" title="JVM 的生命周期"></a>JVM 的生命周期</h4><ul><li><p>虚拟机启动</p><ul><li>JVM 启动通过引导类加载器 <code>bootstarp class loader</code> 创建一个初始类 <code>initial class</code> 来完成的，这个类由虚拟机的具体实现指定</li></ul></li><li><p>虚拟机执行</p><ul><li>一个运行中的 JVM 有一个清晰的任务：执行 Java 程序</li><li>执行一个所谓的 Java 程序，真真正正在执行的是一个叫做 JVM 的进程</li><li>打印 JVM 进程：<code>jps</code></li></ul></li><li><p>虚拟机退出</p><ul><li>程序正常执行结束</li><li>程序运行过程中遇异常/错误而异常中止</li><li>某线程调用 Runtime 或 System 的 exit/halt 方法，并且 Java 安全管理器也允许这次 exit/halt 操作</li><li>除此之外，JNI (Java Native Interface) 规范描述了用 JNI Invocation API 来加载/卸载 JVM 时，JVM 的退出情况</li></ul></li></ul><h4 id="JVM-的发展历程"><a href="#JVM-的发展历程" class="headerlink" title="JVM 的发展历程"></a>JVM 的发展历程</h4><ul><li><p>Sun Classic VM</p><ul><li>第一款商用 JVM</li><li>只提供解释器，解释器和 JIT 编译器（外挂的）无法同时配合</li><li>Hotspot 内置了此 VM</li></ul></li><li><p>Exact VM</p><ul><li>Exact Memory Management 准确式内存管理，也可叫 Non-Conservative/Accurate Memory Management。虚拟机可知内存中某个位置的数据具体是什么类似（变量/引用）</li><li>具备现代高性能 VM 的雏形：热点探测、编译器和解释器混合工作模式、</li><li>只在 Solaris 平台短暂使用，最终被 Hotspot 替换</li></ul></li><li><p>HotSpot VM</p><ul><li>绝对的市场地位</li><li>Oracle JDK / OpenJDK 默认虚拟机</li><li>热点代码探测技术<br>通过计数器找到最具编译价值代码，触发即时编译或栈上替换<br>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li><li><p>JRocket（EBA 公司，该公司 08 年被 Oracle 收购）</p><ul><li>专注于服务器端应用<br>不太关注程序启动速度，因此不包含解释器实现，全部代码靠即时编译器编译后执行</li><li>JRocket JVM 是目前世界上最快的 JVM。70% 性能提升和 50% 硬件减少</li><li>MissionControl 服务套件，以极低的开销来监控/管理/分析生产环境中的应用程序的工具</li></ul></li><li><p>IBM 的 J9</p><ul><li>市场定位于 HotSpot 接近</li><li>有影响力的三大商用虚拟机之一，号称世界上最快的 Java 虚拟机（在 IBM 机上）</li><li>17 年开源了 J9，为 OpenJ9，给 Eclipse 基金会</li></ul></li><li><p>KVM 和 CDC/CLDC Hotspot</p><ul><li>Oracle 在 Java ME 产品线上的两个虚拟机 CDC/CLDC HotSpot Implemention VM</li><li>运行塞班系统上的 Java 手机游戏</li></ul></li><li><p>TaobaoJVM</p><ul><li><p>基于 OpenJDK 开发的定制版本 AlibabaJDK</p></li><li><p>创新的 GCIH (GC invisible heap) 技术实现了 off-heap，即将生命周期较长的 Java 对象从 heap 中移 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的<br>GCIH 中的对象还能在多个 JVM 进程中共享<br>使用 crc32 志林实现 JVM intrinsic 降低 JNI 调用开销</p><p>PMU hardware 的 Java profiling tool 和诊断协助功能<br>针对大数据场景的 ZenGC</p></li><li><p>硬件严重依赖 intel CPU，损失了兼容性，但提高了性能</p></li></ul></li><li><p>Dalvik VM</p><ul><li>Google 开发，没有遵循 JVM 规范，应用于 Android，并在 Android 2.2 中提供了 JIT，发展迅猛</li><li>基于寄存器架构</li><li>执行的是编译以后的 dex (Dalvik Executable) 文件，效率高<br>dex 文件可通过 Class 文件转化而来，通过 Java 语法编写应用程序，可直接使用大部分 Java API</li><li>Android 5.0 使用支持提前编译（Ahead Of Time Compilation，AOT）的 ART VM 替换 Dalvik VM</li></ul></li><li><p>Graal VM</p><ul><li>18 年，Oracle Labs 公开，号称 “Run Programs Faster Anywhere”</li><li>跨语言全栈虚拟机，可作为任何语言的运行平台使用，包括 C++、Python、R、Ruby、JavaScript 等</li><li>支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件</li><li>工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被 Graal VM 接受的中间表示。提供了 Truffle 工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。</li></ul></li><li><p>其他：Azul VM、Liquid VM、Apache Harmony、Microsoft JVM</p></li></ul><h3 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h3><p>类加载器子系统：</p><ul><li><p>加载字节码文件，使得其中的变量/方法等信息有组织地加载到内存</p></li><li><p>作用：负责从文件系统/网络中加载 Class 文件，只负责加载，至于是否可运行，由 Execution Engine 决定</p></li><li><p>三个阶段：</p><ul><li>加载阶段<ul><li>引导类加载器 BootStrap ClassLoader</li><li>扩展类加载器 Extension ClassLoader</li><li>系统类加载器 Application ClassLoader</li></ul></li><li>链接阶段<ul><li>验证 verify</li><li>准备 prepare</li><li>解析 resolve</li></ul></li><li>初始化阶段</li></ul></li><li><p>加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中的常量池部分的映射）</p></li></ul><img src="image-20210125184038670.png" style="zoom:50%"><p>ClassLoader 角色</p><ul><li><p>class file 存在于本地硬盘行，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 中来。根据这个模板实例化出 n 个一模一样的实例</p></li><li><p>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区</p></li><li><p>在 <code>.class 文件</code> -&gt; <code>JVM</code> -&gt; <code>元数据模板</code> 过程中，ClassLoader 扮演快递员的角色</p><img src="image-20210127142626888.png" style="zoom:55%"></li></ul><h4 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h4><img src="image-20210127150301468.png" style="zoom:50%"><ul><li><p>Loading</p><ul><li>通过一个类的全限定名获取定义此类的二进制字节流<ul><li>本地系统</li><li>网络，比如 Web Applet</li><li>zip 包（jar、war 格式的基础）</li><li>运行时计算生成，如动态代理</li><li>由其他文件生成，如 JSP</li><li>从专有数据库中提取 .class 文件，少见</li><li>从加密文件中获取，典型地防 Class 文件被反编译的 措施</li></ul></li><li>将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li></ul></li><li><p>Linking</p><ul><li>验证 Verify<ul><li>目的在于确保 Class 文件的字节流中包含信息符合当前 VM 要求，保证被加载类的正确性，不会危害虚拟机自身安全</li><li>文件格式验证/元数据验证/字节码验证/符号引用验证</li></ul></li><li>准备 Prepare<ul><li>为变量分配内存并且设置该类变量的默认初始值，即零值。initial 阶段才会给 static 变量设置值</li><li>不包含用 final 修饰的 static，final 在编译的时候就会分配了，准备阶段会显式初始化</li><li>这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中</li></ul></li><li>解析 Resolve<ul><li>将常量池内的符号引用转换为直接引用的过程</li><li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行</li><li>符号引用就是一组符号用来描述所引用的目标。符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄</li><li>解析动作主要是针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 <code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code> 等。</li></ul></li></ul></li><li><p>Initial</p><ul><li><p>执行类构造器方法 <code>&lt;clinit&gt;()</code> class init 的过程</p><img src="image-20210127173517032.png" style="zoom:67%"></li><li><p>此方法不需定义，是 javac 编译器自动收集类中的<strong>所有类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并而来。如果没有静态变量和静态代码块的话就不生成 <code>&lt;clinit&gt;()</code></p><img src="image-20210127173721363.png" style="zoom:67%"></li><li><p>构造器方法中指令按语句在源文件中出现的顺序执行</p><p><img src="JVM-Study-Notes/image-20210127174159542.png" alt="image-20210127174159542"></p></li><li><p><code>&lt;clinit&gt;()</code> 不同于类的构造器<br>关联：构造器是虚拟机视角下的 <code>&lt;init&gt;()</code></p></li></ul></li><li><p>若该类具有父类，JVM 会保证子类的 <code>&lt;clinit&gt;()</code> 执行前，父类的 <code>&lt;clinit&gt;()</code> 已经执行完毕</p></li></ul><img src="image-20210127175342138.png" style="zoom:67%"><pre><code>* 虚拟机必须保证一个类的 `&lt;clinit&gt;()`  方法是并发安全的

&lt;img src=&quot;image-20210127180042340.png&quot; style=&quot;zoom:67%;&quot; /&gt;</code></pre><h4 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h4><p>分类：</p><ul><li>JVM 支持两种类型的 ClassLoader<ul><li>引导类加载器 BootStrap ClassLoader</li><li>自定义类加载器 User-Defined ClassLoader<br>定义：所有派生于抽象类 ClassLoader 的类加载器都为自定义类加载器，并不是字面上的指开发人员自定义的 ClassLoader</li></ul></li><li>常见 ClassLoader 只有 3 个<ul><li>下图中的四者是<strong>包含关系</strong>，不是上下层/继承关系</li><li>BootStrap Class Loader 是 C/C++ 代码写的，其他是 Java</li></ul></li></ul><img src="image-20210127180604778.png" style="zoom:50%"><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 获取系统类加载器 sun.misc.Launcher$AppClassLoader</span></span><br><span class="line">ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"><span class="hljs-comment">// 获取其上层：扩展类加载器</span></span><br><span class="line">ClassLoader extClassLoader = systemClassLoader.getParent();</span><br><span class="line"><span class="hljs-comment">// 获取其上层，null</span></span><br><span class="line">ClassLoader bootstrapClassLoader = extClassLoader.getParent();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 对于用户自定义类来说，默认使用系统类加载器进行记载</span></span><br><span class="line">Test.class.getClassLoader(); <span class="hljs-comment">// sun.misc.Launcher$AppClassLoader</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 系统核心类库的类加载器是引导类加载器加载的</span></span><br><span class="line">String.class.getClassLoader(); <span class="hljs-comment">// null</span></span><br></pre></td></tr></table></figure><p>虚拟机自带的加载器：</p><ul><li>BootStrap ClassLoader<ul><li>C/C++ 实现，嵌套于 JVM</li><li>用来加载 Java 核心库（<code>JAVA_HOME/jre/lib/rt.jar</code>、<code>resources.jar</code> 或 <code>sun.boot.class.path</code> 路径下的内容）</li><li>没有父加载器</li><li>加载扩展类和应用程序类加载器并制定为他们的父类加载器</li><li>安全考虑，Bootstrap ClassLoader 只加载报名为 java、javax、sun 等开头的类</li></ul></li><li>Extension ClassLoader<ul><li>Java 编写，由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现</li><li>派生于 ClassLoader 类</li><li>父类加载器为 BootStrap ClassLoader</li><li>从 <code>java.ext.dirs</code> 系统属性所制定的目录中加载类库，或从 JDK 的安装目录的 <code>jre/lib/ext</code> 子目录下加载类库。若用户的 jar 放在此目录下，也会由其加载</li></ul></li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 获取 BootStrapClassLoader 能够加载的 api 的路径</span></span><br><span class="line">URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();</span><br><span class="line"><span class="hljs-keyword">for</span> (URL element: urls) &#123;</span><br><span class="line">    System.out.println(element.toExternalForm());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 获取 ExtClassLoader 能够加载的类路径</span></span><br><span class="line"> System.getProperty(<span class="hljs-string">"java.ext.dirs"</span>);</span><br></pre></td></tr></table></figure><p>用户自定义类加载器：</p><ul><li><p>why?<br>隔离加载类<br>修改类加载的方式<br>拓展加载源<br>防止源码泄露</p></li><li><p>步骤</p><ul><li><p>继承 java.lang.ClassLoader</p></li><li><p>JDK1.2 之前要重写 loadClass() 方法，之后不建议重写 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findClass() 方法中</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">byte</span>[] result = getClassFromCustomPath(name);</span><br><span class="line">            <span class="hljs-comment">// ...</span></span><br><span class="line">        &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] getClassFromCustomPath(String name) &#123;</span><br><span class="line">        <span class="hljs-comment">// 从自定义路径中加载指定类</span></span><br><span class="line">        <span class="hljs-comment">// 可以包含加密和解密的过程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若没有太过复杂的需求，可直接继承 URLClassLoader，这样可避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁</p></li></ul></li></ul><p>关于 ClassLoader：</p><img src="image-20210128182457337.png" style="zoom:50%"><p>获取 ClassLoader 的途径：</p><ul><li>获取当前类的 ClassLoader：<code>clazz.getClassLoader()</code></li><li>获取当前线程上下文的 ClassLoader：<code>Thread.currentThread().getContextClassLoader()</code></li><li>获取系统的 ClassLoader：<code>ClassLoader.getSystemClassLoader()</code></li><li>获取调用者的 ClassLoader：<code>DriverManger.getCallerClassLoader()</code></li></ul><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>JVM 对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，JVM 虚拟机采用的是双亲委派模式，即把请求交由父类处理。</p><p>工作原理：</p><ul><li>如果一个类加载器收到了类加载请求，它并不会自己先加载，而是将请求委托给父类的加载器去执行</li><li>如果父类加载器还存在其父类加载器，则进一步向上，请求最终到达顶层的 BootStrap ClassLoader</li><li>如果父类加载器可以完成类加载，则返回，或者子加载器才会尝试自己去加载</li></ul><img src="image-20210128210540957.png" style="zoom:67%"> <img src="image-20210128210946528.png" style="zoom:67%"><p>好处：</p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心 API 被随意篡改<br><code>java.lang.SecurityException: Prohibited package name: java.lang</code></li></ul><p>沙箱安全机制：自定义一个 String 类，加载时会使用引导类加载器，加载过程中会先加载 JDK 的文件 <code>rt.jar 下的 java\lang\String.class</code> 此时自定义 String.class 的 main 方式就会找不到</p><p>JVM 视角中两个 class 对象为同一个类的条件：</p><ul><li>全限定类名相同</li><li>加载这个类的 ClassLoader 实例对象相同</li></ul><p>对类加载器的引用：</p><ul><li>JVM 必须知道一个类型是 BootStrap ClassLoader 加载还是自定义 ClassLoader 加载的。</li><li>如果一个类型是由用户类加载器加载，JVM 会讲这个类加载器的一个引用作为类型信息的一部分保存在方法区中</li><li>当解析一个类型到另一个类型的引用时，JVM 需要保证这两个类型的类加载器是相同的。</li></ul><p>类的主动使用（除了以下，其他都是被动使用，不会导致类的初始化）：</p><ul><li>创建类的实例</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值</li><li>调用类的静态方法</li><li>反射</li><li>初始化一个类的子类</li><li>JVM 启动时被标明为启动类的类</li><li>JDK7 开始提供的动态语言支持：<br>java.lang.invoke.MethodHandle 实例的解析结果<br>RET_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类没有初始化</li></ul><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><h4 id="概述与线程"><a href="#概述与线程" class="headerlink" title="概述与线程"></a>概述与线程</h4><img src="image-20210129123358965.png" style="zoom:50%"><p>运行时数据区：</p><ul><li>红色部分（堆、堆外内存 (永久代或元空间、代码缓存)）：JVM 定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁</li><li>灰色部分（程序计数器、栈、本地栈）：则是与线程一一对应，随线程开始/结束而创建/销毁</li></ul><p>更细致的：</p><img src="image-20210129123052650.png" style="zoom:67%"> <img src="image-20210129123119868.png" style="zoom:67%"><p>线程：Java 线程与 OS 线程一一对应</p><p>JVM 系统线程：</p><ul><li>虚拟机线程：JVM 到达安全点才会出现。执行类型包含 “stop-the-world” 的垃圾收集，线程栈收集，线程挂起，以及偏向锁撤销</li><li>周期任务线程：这种线程是时间周期时间的体现（比如中断），他们一般用于周期性操作的调度执行</li><li>GC 线程：对在 JVM 里不同种类的垃圾收集行为提供了支持</li><li>编译线程：在运行时会将字节码编译成本地代码</li><li>信号调度线程：接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><ul><li>PC 寄存器用来存储指向下一条指令的地址，由 Execution Engine 读取下一条指令。</li><li>它是一块很小的内存，几乎可以忽略不计，也是运行速度最快的内存</li><li>JVM 规范中，每个线程都有它自己的 PC Register，是线程私有的，生命周期与线程的生命周期保持一致</li><li>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；若是在执行 native 方法，则是未指定值 undefined</li><li>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它</li><li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需执行的字节码指令</li><li>是唯一一个在 JVM 规范中没有规定任何 OOM 情况的区域</li><li>Stack Area 和 PC Registers 都没有 GC</li></ul><img src="image-20210129154014440.png" style="zoom:67%"> <img src="image-20210129213652842.png" style="zoom:67%"><h4 id="虚拟机栈-★"><a href="#虚拟机栈-★" class="headerlink" title="虚拟机栈 ★"></a>虚拟机栈 ★</h4><p>Java Virtual Machine Stack：</p><ul><li><p>起因：跨平台性设计，JVM 指令根据栈来设计。</p></li><li><p>每个线程创建时都会创建一个虚拟栈，其内部保存一个个的栈帧 Stack Frame，对应一次次的 Java Method Invoke</p></li><li><p>生命周期与线程一致</p></li><li><p>作用：保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回</p></li><li><p>JVM 直接对 Java 栈的操作：</p><ul><li>方法执行，伴随着压栈</li><li>执行结束后的弹栈</li></ul></li><li><p>不存在垃圾回收</p><p>栈中可能的异常：</p></li><li><p>JVM 规范允许 Java 栈的大小是动态的或者是固定不变的</p></li><li><p>若采用固定大小的 JVM 栈，那每个 Thread 的 JVM Stack 容量在创建时独立选定。若线程请求分配的栈容量超过 JVM 设置，则抛 StackOverflowError 异常</p></li><li><p>若采用动态扩展，在扩展时发现不足了则抛 OutOfMemoryError</p></li></ul><p><code>-Xss256k</code>、<code>-Xss1024k</code> 可以设置栈大小</p><p>栈帧的内部结构：</p><ul><li>局部变量表 LV, Local Variables</li><li>操作数栈 OS, Operand Stack</li><li>动态链接 DL, Dynami Linking，指向运行时常量池的方法引用</li><li>方法返回地址 RA, Return Address，方法退出的定义</li><li>一些附加信息</li></ul><p>局部变量表：</p><ul><li><p>也称为局部变量数组、本地变量表</p><img src="image-20210130141648702.png" style="zoom:50%"></li><li><p>定义为一个数字数组，主要存储方法 参数和定义在方法体内的局部变量，数据类型包括各类基本数据类型、Object Reference、returnAddress</p></li><li><p>是线程的私有数据，不存在数据安全问题</p></li><li><p>容量大小是编译器确定下来的，保存在方法的 Code 属性的 maximum local variables 数据项中。方法运行期间是不会改变局部变量表大小的。</p></li><li><p>最基本的存储单元：Slot（变量槽）</p><ul><li><p>参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1 的索引结束</p></li><li><p>32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64 位的类型（long/double）占用两个 slot</p><img src="image-20210130202337634.png" style="zoom:50%"></li><li><p>如果当前帧由构造方法或实例方法创建，那 this 变量会存放在 index=0 的 slot 处，其他参数按按照参数表顺序排列<br>[this, param, localVariable]</p></li><li><p>Slot 重复利用：<br>栈帧中的局部变量表中的槽位是可重用的，如果一个局部变量过了其作用域，那么在作用域后新声明的局部变量就可能复用过期局部变量的槽位</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void test() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        int a = 2;</span><br><span class="line">        System.out.println(2);</span><br><span class="line">    &#125;</span><br><span class="line">    int b = 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>局部变量和静态变量对比</p><ul><li>静态变量有 2 次初始化机会，prepare 和 initial</li><li>局部变量表则不存在系统初始化过程，意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。<code>int i; System.out.println(i); // CE</code></li></ul></li></ul><p>操作数栈：</p><ul><li>方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即 push/pop。比如：执行 复制/交换/求和 等操作</li><li>保存计算过程中的中间结果，同时作为计算过程中变量的临时存储空间</li><li>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</li></ul><p>栈顶缓存技术 Top-of-Stack Cashing：</p><ul><li>栈式结构的 JVM 所使用的零地址指令更加紧凑，完成一项操作伴随着很多的入栈和出栈操作，即意味着更多的指令分派 instruction dispatch 次数和内存读写次数。<br>HotSpot JVM 考虑将栈顶元素全部缓存到物理 CPU 的寄存器而不是内存中，以此降低对内存的读写次数，提高执行引擎的执行效率</li></ul><p>动态链接（指向运行时常量池的方法引用）：</p><ul><li>帧数据区：方法返回地址、动态链接、附加信息</li><li>每个栈帧内部都包含一个指向<strong>运行时常量池</strong>中<strong>该栈帧所属方法的引用</strong>，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接 Dynamic Linking。比如 invokedynamic 指令</li><li>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用 Symbolic Reference 保存在 class 文件的常量池中。比如：描述一个方法调用其他方法时，就是通过常量池中指向方法的符号引用来表示的。</li><li>动态链接作用：将这些符号引用转换为调用方法的直接引用</li><li>使用体现：bytecode 里面的 <code>#1</code>、<code>#2</code> 之类的</li><li>常量池作用：提供一些符号和变量，便于指令的识别</li></ul><img src="image-20210207151012219.png" style="zoom:50%"><p>方法的调用（解析与分派）：</p><ul><li><p>JVM 中，符号引用转换为调用方法的直接引用与方法的绑定机制相关</p></li><li><p>静态链接：被调用的目标方法在编译期可知，且运行期保持不变时，将调用方法的符号引用转换为直接引用的过程 <code>invokespecial</code>、<code>invokestatic</code><br>动态链接：被调用方法在编译器无法确定，只能再运行时将调用方法的符号引用转换为直接引用 <code>invokevirtual</code>、<code>invokeinterface</code></p></li><li><p>推广一下 =&gt; 早期绑定 Early Binding、晚期绑定 Late Binding<br>绑定是一个字段、方法或类在符号引用被替换为直接引用的过程，仅发生一次</p></li><li><p>非虚方法（静态方法/私有方法/final方法/构造器/父类方法）与虚方法</p><ul><li>普通调用指令：<ul><li><code>invokespecial</code>（非虚方法）：调用静态方法，解析阶段确定唯一方法版本</li><li><code>invokestatic</code>（非虚方法）：调用<init>方法、私有及其父类方法，解析阶段确定唯一方法版本</init></li><li><code>invokevirtual</code>：调用所有虚方法</li><li><code>invokeinterface</code>：调用接口方法</li></ul></li><li>动态调用指令<ul><li><code>invokedynamic</code>：动态解析出需要调用的方法，然后执行<br>Java7 增加的指令，是 Java 为实现【动态类型语言】支持而做的一种改进（本质是对 JVM 规范的修改，最直接受益者是运行在 JVM 的动态语言的编译器），但在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 等工具，直到 Java8 中 Lambda 的出现。</li></ul></li></ul></li><li><p>动态语言和静态语言：</p><ul><li>区别在于对类型的检查是编译期还是运行期</li><li>静态类型语言是判断<strong>变量</strong>的类型信息，动态类型语言则是判断<strong>变量值</strong>的类型信息</li></ul></li><li><p>方法重写的本质（动态分派）：</p><ol><li>（调用之前，方法的对象/类在栈顶）找到操作数栈的栈顶元素所执行的对象的实际类型，记作 C</li><li>先在类型 C 中找到与常量中描述符合、简单名称符合的方法，并进行访问权限校验（通过则返回这方法的直接引用，不通过则返回 <code>java.lang.IllegalAccessError</code> 异常）</li><li>若没有找到符合的方法，则按照继承关系从下往上对 C 的各个父类依次执行操作 3</li><li>最终没找到合适方法，则抛出 <code>java.lang.AbstractMethodError</code> 异常</li></ol></li><li><p>虚方法表 virtual method table：</p><ul><li>OOP 中，动态分派的使用是很频繁的，为了提高性能，JVM 在类的方法区建立了一个虚方法表，使用索引代替查找，表中存放各个方法的实际入口</li><li>虚方法表会在类加载的 Linking 阶段被创建并开始初始化，类的变量初始值准备完成后，JVM 会把该类的方法表也初始化完毕 <img src="image-20210208163314493.png" style="zoom:45%"></li></ul></li></ul><p>方法返回地址：</p><ul><li><p>方法开始执行后，仅两种方式退出该方法</p></li><li><p>正常完成出口：执行引擎遇到任一个方法返回的字节码指令，将返回值传递给上层方法调用者</p><ul><li>ireturn (boolean、byte、char、short、int)</li><li>lreturn</li><li>freturn</li><li>dreturn</li><li>areturn</li><li>return (void、构造器、类和接口初始化)</li></ul></li><li><p>异常完成出口（没有返回值给上层调用者）：方法执行过程中遇到了异常，异常没有在方法内处理，导致方法退出<br>方法执行过程中抛出异常时的异常处理，存储在一个异常处理表中，方便在发生异常时找到处理异常的代码，如下，PC: 4-&gt;8 范围发生的异常可以跳 PC=11</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception table:</span><br><span class="line">    from    to    target    type</span><br><span class="line">      4          8        11        Class java/io/IOException</span><br></pre></td></tr></table></figure></li><li><p>本质上，方法的退出即当前栈帧出栈的过程。此时需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈的操作数栈、设置 PC 等</p></li></ul><p>一些附加信息：</p><ul><li>栈帧中还允许携带与 JVM 实现相关的一些附加信息。例如对程序调试提供支持的信息</li></ul><h4 id="本地方法接口"><a href="#本地方法接口" class="headerlink" title="本地方法接口"></a>本地方法接口</h4><p>Native Method：</p><ul><li><p>一个 Java 调用非 Java 代码接口。很多 PL 都有这一机制，比如 C++ 中的 <code>extern &quot;C&quot;</code> 告知 C++ Compiler 去调 C 的函数。</p></li><li><p>融合不同的编程语言为 Java 所用，初衷是融合 C/C++ 程序</p></li><li><p>可与除 abstarct 外的关键字共用</p></li><li><p>why: 有些功能用 Java 实现不容易或效率不高</p></li><li><p>now: 目前使用的越来越少，除非是与硬件有关的应用</p></li></ul><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>Native Method Stack:</p><ul><li><p>线程私有</p></li><li><p>虚拟机栈管理 Java 方法调用，本地方法栈管理本地方法调用</p></li><li><p>某个线程调用一个本地方法时，它进入一个全新且不受 VM 限制的世界，和 VM 有同样的权限</p><ul><li>可通过本地方法接口来访问虚拟机内的运行时数据区</li><li>甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存</li></ul></li><li><p>并不是所有 JVM 都支持 Native Method，因为 JVM 规范没明确要求 Native Method Stack 的使用语言、具体实现、数据结构等</p></li><li><p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一</p></li></ul><h4 id="堆-★"><a href="#堆-★" class="headerlink" title="堆 ★"></a>堆 ★</h4><p>Heap 概述：</p><ul><li><p>一个 JVM 实例只存在一个堆内存，JVM 启动时创建并确定空间大小（可人为调节），是 Java 内存管理的核心区域，也是 JVM 管理的最大块内存空间</p></li><li><p>所有线程共享 Java 堆，在此还划分了线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）</p></li><li><p>《Java 虚拟机规范》：堆可处于物理上不连续的空间，但逻辑上是连续的</p></li><li><p>《Java 虚拟机规范》：（几乎）所有的对象实例以及数组都应当在运行时分配在堆上。（栈帧中保存其引用）<br>The heap is the run-time data area from which memory for all class instances and arrays is allocated</p></li><li><p>方法结束后，堆中的对象不会马上被移除，GC 时才会被移除</p></li></ul><p>内存细分：</p><ul><li><p>现代 GCer 大部分基于分代收集理论设计</p></li><li><p>Java 7 之前，堆内存逻辑上分为：</p><ul><li>新生区(代)，Young (New) Generation Space，又分为 Eden 区和 Survivor 区<br>存放生命周期较短的瞬时对象，这类对象的创建和消亡都很迅速（IBM 研究表明，新生代中 80% 的对象都是 “朝生夕死”）</li><li>养老区(代)，Tenure (Old) Generation Space<br>存放生命周期较长的对象（这些对象在某些极端情况还能与 JVM 生命周期一致） <img src="image-20210222162009136.png" style="zoom:50%"></li><li>永久区(代)，Permanent (Perm) Space</li></ul></li><li><p>Java 8 及之后，堆内存逻辑上分为：</p><ul><li>新生代，Young (New) Generation Space，又分为 Eden 区和 Survivor 区</li><li>老年代，Tenure (Old) Generation Space</li><li>元空代，Meta Space <img src="image-20210222153037450.png" style="zoom:50%"></li></ul></li></ul><p>设置堆空间：</p><ul><li><p><code>-Xms</code> 初始堆内存 （Young + Tenure 代）；<code>Runtime.getRuntime().totalMemory</code>；默认值：内存 / 64。</p></li><li><p><code>-Xmx</code> 堆区最大内存；<code>Runtime.getRuntime().maxMemory 会输出堆内存减 S0 或 S1 区的内存，因为这两个区只能选一个存，另一个是用来辅助 GC 的</code> ；默认值：内存 / 4</p></li><li><p><code>-XX:+PrintGCDetails</code> 打印 GC 详情，或者在命令行 <code>jstat -gc 进程号</code></p></li><li><p><code>-XX:NewRatio=2</code> 表示配置新生代和老年代的占比，此时是新生代占 1，老年代占 2（默认就是 2）</p></li><li><p><code>-XX:SurvivorRatio=8</code> 配置 Eden 和 Survivor 区比例，此时 Survivor 区是 1，Eden 区是 8</p></li><li><p><code>-XX:-UseAdaptiveSizePolicy</code>：关闭自适应内存分配策略<br><code>-XX:+UseAdaptiveSizePolicy</code>：打开自适应内存分配策略（默认）</p></li></ul><p>对象分配过程（内存分配和内存回收是严谨且相关的）：</p><ol><li>new 的对象先放伊甸园区，此区有大小限制。</li><li>当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行 Minor GC，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</li><li>然后将伊甸园中的剩余对象移动到 Survivor 0 区。</li><li>如果再次触发垃圾回收，此时上次幸存下来的放到 Survivor 0 区的，如果没有回收，就会放到 Survivor 1 区</li><li>如果再次经历垃圾回收，此时会重新放回 Survivor 0 区，接着再去 Survivor 1 区</li><li>啥时候能去养老区呢？可以设置次数。默认是15次。 可 <code>-XX: MaxTenuringThreshold&lt;N&gt;</code>进行设置。</li><li>在养老区，相对悠闲。当养老区内存不足时，触发 Major GC，进行养老区的内 存清理</li><li>若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM</li></ol><p>进度：72 -</p><h4 id="方法区-★"><a href="#方法区-★" class="headerlink" title="方法区 ★"></a>方法区 ★</h4><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><h3 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h3><h3 id="StringTable"><a href="#StringTable" class="headerlink" title="StringTable"></a>StringTable</h3><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>垃圾回收概述</p><p>垃圾回收相关算法</p><p>垃圾回收相关概念</p><p>垃圾回收器</p><h2 id="字节码与类的加载"><a href="#字节码与类的加载" class="headerlink" title="字节码与类的加载"></a>字节码与类的加载</h2><h3 id="Class-文件结构"><a href="#Class-文件结构" class="headerlink" title="Class 文件结构"></a>Class 文件结构</h3><blockquote><p>重要的官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p></blockquote><h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>Java 前端编译器：</p><ul><li>javac 是一种能够将 Java 源码编译为字节码的前端编译器。</li><li>HotSpot VM 并没强制要求前端编译器只能 javac。只要编译结果符合 JVM 规范即可。</li><li>除了 javac (全量式编译) 之外，还有内置在 Eclipse 中的 ECJ（Eclipse Compiler for Java）编译器，是一种增量式编译器。<ul><li>Ctrl+S 后，ECJ 编译器把未编译部分的源码逐行进行编译，而非每次都全量编译。</li><li>ECJ 不仅是 Eclipse 的默认内置前端编译器，在 Tomcat 中同样也是使用 ECJ 编译器来编译 jsp 文件。</li><li>ECJ 基于 GPLv2 开源。</li><li>默认情况下，Intellij IDEA使用 javac 编译器（可自己设置为 ajc）</li></ul></li><li>前端编译器并不会直接涉及编译优化等方面的技术，这些具体优化细节移交给 HotSpot 的 JIT 编译器负责。</li></ul><img src="image-20210222180118912.png" style="zoom:40%"><p>涉及字节码指令的代码细节举例：</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerTest</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="hljs-comment">// Integer变量和int变量比较时，只要两个变量的值是相等的（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较）</span></span><br><span class="line">       Integer x = <span class="hljs-number">5</span>;</span><br><span class="line">       <span class="hljs-keyword">int</span> y = <span class="hljs-number">5</span>;</span><br><span class="line">       System.out.println(x == y); <span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 同上</span></span><br><span class="line">       Integer x2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">5</span>);</span><br><span class="line">       <span class="hljs-keyword">int</span> y2 = <span class="hljs-number">5</span>;</span><br><span class="line">       System.out.println(x2 == y2); <span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，进入 valueOf 代码里有一个 IntegerCache 数组</span></span><br><span class="line">       Integer a1 = <span class="hljs-number">1</span>;</span><br><span class="line">       Integer b1 = <span class="hljs-number">1</span>;</span><br><span class="line">       System.out.println(a1 == b1); <span class="hljs-comment">// true</span></span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 同上</span></span><br><span class="line">       Integer a3 = <span class="hljs-number">128</span>;</span><br><span class="line">       Integer b3 = <span class="hljs-number">128</span>;</span><br><span class="line">       System.out.println(a3 == b3); <span class="hljs-comment">// false</span></span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false</span></span><br><span class="line">       <span class="hljs-comment">// 当变量值在-128~127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象</span></span><br><span class="line">       Integer a2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);</span><br><span class="line">       Integer b2 = <span class="hljs-number">1</span>;</span><br><span class="line">       System.out.println(a2 == b2); <span class="hljs-comment">// false</span></span><br><span class="line"></span><br><span class="line">       <span class="hljs-comment">// 两个通过new生成的Integer变量永远是不相等的</span></span><br><span class="line">       Integer a4 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);</span><br><span class="line">       Integer b5 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">1</span>);</span><br><span class="line">       System.out.println(a4 == b5); <span class="hljs-comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Class 类的本质：</p><ul><li>任一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，Class 文件实际并不一定以磁盘文件的形式存在。</li><li>Class 文件是一组以字节为单位的<strong>二进制流</strong></li></ul><p>Class 文件格式及其总体结构：</p><ul><li>Class 的结构不像 XML 等描述语言，它没有任何分隔符号，所以在其中的数据项都是严格限定的，字节的含义、长度、先后，都不允许改变。</li><li>Class 文件格式采用一种类似于 C 语言结构体的方式进行数据存储，这种结构中只有两种数据类型<ul><li>无符号数：基本的数据类型，以 u1、u2、u4、u8 来分别代表指定字节的无符号数<br>可用来描述 数字、索引引用、数量值、UTF-8 字符串值。</li><li>表：由多个无符号数或者其他表作为数据项构成的复合数据类型<br>所有表都习惯性地以 <code>_info</code> 结尾。<br>用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。<br>表没有固定长度，所以通常会在其前面加上个数说明</li></ul></li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">    u4             magic;                        <span class="hljs-comment">//  魔数</span></span><br><span class="line">    u2             minor_version;         <span class="hljs-comment">// 副版本号 </span></span><br><span class="line">    u2             major_version;         <span class="hljs-comment">// 主版本号</span></span><br><span class="line">    u2             constant_pool_count; <span class="hljs-comment">// 常量池计数器</span></span><br><span class="line">    cp_info        constant_pool[constant_pool_count<span class="hljs-number">-1</span>]; <span class="hljs-comment">// 常量池表, 首索引 0 没有分配，所以少 1 个字节</span></span><br><span class="line">    u2             access_flags;            <span class="hljs-comment">// 访问标识</span></span><br><span class="line">    u2             this_class;                  <span class="hljs-comment">// 类索引</span></span><br><span class="line">    u2             super_class;              <span class="hljs-comment">// 父类索引</span></span><br><span class="line">    u2             interfaces_count;     <span class="hljs-comment">// 接口计数器</span></span><br><span class="line">    u2             interfaces[interfaces_count]; <span class="hljs-comment">// 接口索引集合</span></span><br><span class="line">    u2             fields_count;                  <span class="hljs-comment">// 字段计数器</span></span><br><span class="line">    field_info     fields[fields_count]; <span class="hljs-comment">// 字段表</span></span><br><span class="line">    u2             methods_count;            <span class="hljs-comment">// 方法计数器</span></span><br><span class="line">    method_info    methods[methods_count]; <span class="hljs-comment">// 方法表 </span></span><br><span class="line">    u2             attributes_count;          <span class="hljs-comment">// 属性计数器</span></span><br><span class="line">    attribute_info attributes[attributes_count]; <span class="hljs-comment">// 属性表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><ul><li>每个 Class 文件开头的 4 个字节的无符号整数称为 Magic Number</li><li>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。<br>即：魔数是Class文件的标识符。</li><li>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。</li><li>魔数值固定为 0xCAFEBABE。不会改变。</li><li>如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：<br><code>Error: A JNI error has occurred, please check your installation and try again Exception in thread &quot;main&quot; java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file Test</code></li></ul><h4 id="Class-文件版本"><a href="#Class-文件版本" class="headerlink" title="Class 文件版本"></a>Class 文件版本</h4><ul><li>紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是4个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 minor_version，而第 7 个和第 8 个字节就是编译的主版本号 major_version。</li><li>它们共同构成了 class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。</li><li>向下兼容：高版本兼容低版本。低版本执行高版本则会抛 <code>java.lang.UnsupportedClassVersionError</code></li></ul><p>版本号与平台的对应：</p><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><h4 id="常量池-constant-pool"><a href="#常量池-constant-pool" class="headerlink" title="常量池 constant_pool"></a>常量池 constant_pool</h4><p>概述：</p><ul><li>常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用。</li><li>随着 JVM 的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个 Class 文件的基石。</li><li>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</li><li>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值（constant_pool_count）。与 <strong>Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的。</strong></li></ul><ul><li>常量池表项中，用于存放编译时期生成的各种<strong>字面量</strong>和<strong>符号引用</strong>，这部分内容将在<strong>类加载后</strong>进入方法区的<strong>运行时常量池</strong>中存放。</li></ul><p>常量池计数器：</p><ul><li><p>u2 类型，2 个字节，constant_pool_count=1 时表示常量池有 0 个常量项（没有常量项）</p></li><li><p>若为 0x16 = 22，表示有 21 个常量项，索引范围是 <code>1-21</code></p></li><li><p>把第 0 项常量空出来，是为了适配一种情况：某些指向常量池的索引值要表达 “不引用任何一个常量池项目” 的语义。此时这种情况即可用索引值 0 来表示。</p></li></ul><p>常量池项类型及其结构细节：</p><ul><li><p>常量池主要存放两大类常量</p><ul><li>字面量（Literal）：文本字符串、final 的变量<br><code>String str=“atguigu”; final int NUM=10;</code></li><li>符号引用（Symbolic References）：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li></ul></li><li><p>术语</p><ul><li><p>全限定名<br><code>java/lang/String;</code></p></li><li><p>简单名称<br>指没有类型和参数修饰的方法或者字段名称，如 add() 方法和 num 字段的简单名称分别是 add 和 num</p></li><li><p><strong>描述符</strong><br>描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。具体如下：</p><table><thead><tr><th>标志符</th><th>含义</th></tr></thead><tbody><tr><td>B</td><td>基本数据类型 byte</td></tr><tr><td>C</td><td>基本数据类型 char</td></tr><tr><td>D</td><td>基本数据类型 double</td></tr><tr><td>F</td><td>基本数据类型 float</td></tr><tr><td>I</td><td>基本数据类型 int</td></tr><tr><td>J</td><td>基本数据类型 long</td></tr><tr><td>S</td><td>基本数据类型 short</td></tr><tr><td>Z</td><td>基本数据类型 boolean</td></tr><tr><td>V</td><td>代表 void 类型</td></tr><tr><td>L</td><td>对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td>[</td><td>数组类型，代表一维数组。比如：<code>double[][][] is [[[D</code></td></tr></tbody></table><p>用描述符描述方法：<code>toString()</code> 方法的描述符 <code>() Ljava/lang/String;</code>；<code>int abc(int[] x, int y)</code> 方法的描述符为 <code>([II) I</code></p></li></ul></li><li><p>常量池里的每个项都符合以下某种类型及其细节（第 1 个字节 tag 作为类型标记，用于确定该项是以下的哪个）</p></li></ul><img src="image-20210223174808364.png" style="zoom:80%"><p>一个例子：</p><img src="image-20210223181211946.png" style="zoom:50%"><p>总结：</p><ul><li>final 常量直接显示值，没用指向索引</li><li>byte,short,char,boolean 标志为 3 的 CONSTANT_Integer_info 常量</li><li>在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息</li><li>常量池可以理解为 class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用 Class 文件空间最大的数据项目之一</li></ul><p>常量池中为什么要包含这些内容：</p><ul><li>Java 代码在进行 Javac 编译的时候，并不像 C/C++ 那样有链接这一步骤，而是在虚拟机加载 Class 文件的时候进行动态链接</li><li>也就是说，Class 文件不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</li></ul><h4 id="访问标志-access-flag"><a href="#访问标志-access-flag" class="headerlink" title="访问标志 access_flag"></a>访问标志 access_flag</h4><ul><li>2 个字节，用于识别一些类或者接口层次的访问信息，包括：<ul><li>Class 是类还是接口</li><li>是否定义为 public 类型</li><li>是否定义为 abstract 类型</li><li>类的话，是否为 final</li></ul></li><li>类的各个访问权限为 ACC_ 开头的常量，位与的运算结构作为 access_flag<br>比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL</li></ul><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td>ACC_PUBLIC</td><td>0x0001</td><td>标志为public类型</td></tr><tr><td>ACC_FINAL</td><td>0x0010</td><td>标志被声明为final，只有类可以设置</td></tr><tr><td>ACC_SUPER</td><td>0x0020</td><td>标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）；使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记。</td></tr><tr><td>ACC_INTERFACE</td><td>0x0200</td><td>标志这是一个接口</td></tr><tr><td>ACC_ABSTRACT</td><td>0x0400</td><td>是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td>ACC_SYNTHETIC</td><td>0x1000</td><td>标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td>ACC_ANNOTATION</td><td>0x2000</td><td>标志这是一个注解</td></tr><tr><td>ACC_ENUM</td><td>0x4000</td><td>标志这是一个枚举</td></tr></tbody></table><p>补充说明：</p><ul><li>带有 ACC_INTERFACE 标志的 class 文件表示的是接口而个是类，反之则表示的是类而个是接口<ol><li>如果一个 class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志</li><li>如果没有设置 ACC_INTERFACE 标志，那么这个 class 文件可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不得同时设置。(注解是 @interface)</li></ol></li><li>ACC_SUPER 用于确定类/接口里面的 invokespecial 指令使用的是哪一种执行语义。针对 JVM 指令集的编译器都应当设置这个标志。对于 JavaSE8 及后续版本来说，无论 class 文件中这个标志的实际值是什么，也不管 class 文件的版本号是多少，Java 虚拟机都认为每个 class 文件均设置了 ACC_SUPER 标志。<ul><li>ACC_SUPER 是为了向后兼容由旧 Java 编译器所编译的代码而设计的。目前的 ACC_SUPER 标志在由 JDK1.0.2 之前的编译器所生成的 access flags 中是没有确定含义的，如果设置了该标志，那么 Oracle的Java 虚拟机实现会将其忽略</li></ul></li><li>ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的</li><li>注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_ INTERFACE 标志。(注解是 @interface)</li><li>ACC_ENUM 标志表明该类或其父类为枚举类型</li></ul><h4 id="类索引、父类索引、接口索引集合"><a href="#类索引、父类索引、接口索引集合" class="headerlink" title="类索引、父类索引、接口索引集合"></a>类索引、父类索引、接口索引集合</h4><ul><li>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u2             this_class;                  <span class="hljs-comment">// 类索引</span></span><br><span class="line">u2             super_class;              <span class="hljs-comment">// 父类索引</span></span><br><span class="line">u2             interfaces_count;     <span class="hljs-comment">// 接口计数器</span></span><br><span class="line">u2             interfaces[interfaces_count]; <span class="hljs-comment">// 接口索引集合</span></span><br></pre></td></tr></table></figure><ul><li>类索引 this_class<ul><li>字节无符号整数，指向常量池的索引</li></ul></li><li>父类索引 super_class<ul><li>2 字节无符号整数，指向常量池的索引<br>若没有继承类，其默认继承的是 java/lang/Object 类</li><li>superclass 指向的父类不能是 final</li></ul></li><li>接口计数器 interfaces_count</li><li>接口索引集合 interfaces[]<ul><li>interfaces[] 中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。每个成员 interfaces[i] 必须为 CONSTANT_Class_info 结构，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样</li></ul></li></ul><h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><p>fields：</p><ul><li>用于描述接口或类中声明的变量。包括类级变量以及实例级变量，但是不包括 local variables</li><li>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</li><li><strong>它指向常量池索引集合，它描述了每个字段的完整信息</strong>。<br>比如字段的标识符、访问修饰符、static 修饰符、final修饰符等</li></ul><p>注意：</p><ul><li><strong>字段表集合中不会列出从父类或者实现的接口中继承而来的字段</strong><br>但可能列出原本 Java 代码不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</li><li>在 Java 中字段无法重载，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称<br>但是于字节码来讲，若两个字段的描述符不一，那字段重名合法。</li></ul><p>字段表：</p><ul><li><p>fields 表中的每个成员都必须是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述</p></li><li><p>一个字段的信息包括如下这些信息，各个修饰符都是布尔值</p><ul><li>作用域（public、private、protected 修饰符）</li><li>实例变量还是类变量（static 修饰符）</li><li>可变性（final）</li><li>并发可见性（volatile 修饰符，是否强制从主内存读写）</li><li>可否序列化（transient 修饰符）</li><li>字段数据类型（基本数据类型、对象、数组）</li><li>字段名称</li></ul></li><li><p>字段表结构</p><ul><li><p>u2，access_flags，访问标志</p></li><li><p>u2，name_index，字段名索引</p></li><li><p>u2，descriptor_index，描述符索引</p></li><li><p>u2，attributes_count，属性计数器</p></li><li><p>attribute_info，attributes[attributes_count]，属性表集合</p><ul><li><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count 中，属性具体内容存放在 attributes 数组中。<br>以常量属性为例（更多的属性下文会统一提及），结构为：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute&#123;</span><br><span class="line">    u2 attribute_name_index；</span><br><span class="line">    u4 attribute_length；               <span class="hljs-comment">// 对于常量属性而言，attribute_length=2</span></span><br><span class="line">    u2 constantvalue_index；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><p>字段表访问标志：</p><table><thead><tr><th>Flag Name</th><th>Value</th><th>Interpretation</th></tr></thead><tbody><tr><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>Declared <code>public</code>; may be accessed from outside its package.</td></tr><tr><td><code>ACC_PRIVATE</code></td><td>0x0002</td><td>Declared <code>private</code>; usable only within the defining class.</td></tr><tr><td><code>ACC_PROTECTED</code></td><td>0x0004</td><td>Declared <code>protected</code>; may be accessed within subclasses.</td></tr><tr><td><code>ACC_STATIC</code></td><td>0x0008</td><td>Declared <code>static</code>.</td></tr><tr><td><code>ACC_FINAL</code></td><td>0x0010</td><td>Declared <code>final</code>; never directly assigned to after object construction (JLS §17.5).</td></tr><tr><td><code>ACC_VOLATILE</code></td><td>0x0040</td><td>Declared <code>volatile</code>; cannot be cached.</td></tr><tr><td><code>ACC_TRANSIENT</code></td><td>0x0080</td><td>Declared <code>transient</code>; not written or read by a persistent object manager.</td></tr><tr><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>Declared synthetic; not present in the source code.</td></tr><tr><td><code>ACC_ENUM</code></td><td>0x4000</td><td>Declared as an element of an <code>enum</code>.</td></tr></tbody></table><h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><p>methods：</p><ul><li>指向常量池索引集合，它完整描述了每个方法的签名。</li></ul><ul><li>在字节码文件中，<strong>每一个 method_info 项都对应着一个类或者接口中的方法信息</strong><br>比如方法的访问修饰符（public、private 或 protected），方法的返回值类型以及方法的参数信息等。</li><li>如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来。</li><li>methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法</li><li>methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息<br>比如：类/接口初始化方法和实例初始化方法</li><li>方法签名一样返回值不一样的方法，java不允许。但 class 文件允许</li></ul><p>方法表：</p><ul><li>methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。<br>如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。</li><li>method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</li><li>方法表的结构实际跟字段表是一样的，即<ul><li>u2，access_flags，访问标志</li><li>u2，name_index，字段名索引</li><li>u2，descriptor_index，描述符索引</li><li>u2，attributes_count，属性计数器</li><li>attribute_info，attributes[attributes_count]，属性表集合</li></ul></li></ul><p>方法表访问标志：</p><table><thead><tr><th>标志名称</th><th>标志值</th><th>含义</th></tr></thead><tbody><tr><td><code>ACC_PUBLIC</code></td><td>0x0001</td><td>Declared <code>public</code>; may be accessed from outside its package.</td></tr><tr><td><code>ACC_PRIVATE</code></td><td>0x0002</td><td>Declared <code>private</code>; accessible only within the defining class.</td></tr><tr><td><code>ACC_PROTECTED</code></td><td>0x0004</td><td>Declared <code>protected</code>; may be accessed within subclasses.</td></tr><tr><td><code>ACC_STATIC</code></td><td>0x0008</td><td>Declared <code>static</code>.</td></tr><tr><td><code>ACC_FINAL</code></td><td>0x0010</td><td>Declared <code>final</code>; must not be overridden (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.4.5" target="_blank" rel="noopener">§5.4.5</a>).</td></tr><tr><td><code>ACC_SYNCHRONIZED</code></td><td>0x0020</td><td>Declared <code>synchronized</code>; invocation is wrapped by a monitor use.</td></tr><tr><td><code>ACC_BRIDGE</code></td><td>0x0040</td><td>A bridge method, generated by the compiler.</td></tr><tr><td><code>ACC_VARARGS</code></td><td>0x0080</td><td>Declared with variable number of arguments.</td></tr><tr><td><code>ACC_NATIVE</code></td><td>0x0100</td><td>Declared <code>native</code>; implemented in a language other than Java.</td></tr><tr><td><code>ACC_ABSTRACT</code></td><td>0x0400</td><td>Declared <code>abstract</code>; no implementation is provided.</td></tr><tr><td><code>ACC_STRICT</code></td><td>0x0800</td><td>Declared <code>strictfp</code>; floating-point mode is FP-strict.</td></tr><tr><td><code>ACC_SYNTHETIC</code></td><td>0x1000</td><td>Declared synthetic; not present in the source code.</td></tr></tbody></table><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>附加属性：</p><ul><li>紧随于方法表之后的 Class 字节码结构项，描述类的属性<br>是 class 文件所携带的辅助信息<br>比如该 class 文件的源文件名、以及任何带有 RetentionPolicy.CLASS 或 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 JVM 的验证和运行，以及 Java 程序的调试，一般无须深入了解</li></ul><p>属性概述：</p><ul><li>字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息</li><li>属性表集合的限制没有那么严格，不要求各个属性具有严格的顺序，只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性。</li></ul><p>属性的通用结构（所有的属性都可以抽象成以下 3 部分，由属性名索引区别具体的属性）：</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index; <span class="hljs-comment">// 属性名索引</span></span><br><span class="line">    u4 attribute_length;            <span class="hljs-comment">// 属性长度</span></span><br><span class="line">    u1 info[attribute_length];  <span class="hljs-comment">// 具体信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JVM 预定义的属性举例（Java 8 定义了 23 种）：</p><table><thead><tr><th align="left">属性名</th><th>存在于</th><th>解释</th></tr></thead><tbody><tr><td align="left">Code</td><td>方法表</td><td>Java 代码编译成的字节码指令</td></tr><tr><td align="left">ConstantValue</td><td>字段表</td><td>final 关键字定义的常量池</td></tr><tr><td align="left">Deprecated</td><td>类, 方法, 字段表</td><td>被声明为 deprecated 的方法和字段</td></tr><tr><td align="left">Exceptions</td><td>方法表</td><td>方法抛出的异常</td></tr><tr><td align="left">EnclosingMethod</td><td>类</td><td>仅当一个类为局部类或者匿名类时次有这个属性，用于标识这个类所在的外围方法</td></tr><tr><td align="left">InnerClass</td><td>类</td><td>内部类列表</td></tr><tr><td align="left">LineNumberTable</td><td>Code属性</td><td>Java源码的行号与字节码指令的对应关系</td></tr><tr><td align="left">LocalVariableTable</td><td>Code属性</td><td>方法的局部变量描述</td></tr><tr><td align="left">StackMapTable</td><td>Code属性</td><td>JDK1.6 中新增的属性，供新的类型检查校验器检查和处理目标方法的局部变量和操作数所需要的类是否匹配</td></tr><tr><td align="left">Signature</td><td>类, 方法表, 字段表</td><td>用于支持泛型情况下的方法签名</td></tr><tr><td align="left">SourceFile</td><td>类</td><td>记录源文件名称</td></tr><tr><td align="left">SourceDebugExtension</td><td>类</td><td>用于存储额外的调试信息</td></tr><tr><td align="left">Synthetic</td><td>类, 方法表, 字段表</td><td>标志方法或字段为编译器自动生成</td></tr><tr><td align="left">LocalVariableTypeTable</td><td>类</td><td>使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td align="left">RuntimeVisibleAnntations</td><td>类, 方法表, 字段表</td><td>为动态注解提供支持</td></tr></tbody></table><p>Code 属性：</p><ul><li>存放方法体里面的代码。但并非所有方法表都有 Code 属性（比如接口方法/抽象方法）</li></ul><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;  <span class="hljs-comment">// 属性名索引</span></span><br><span class="line">    u4 attribute_length;             <span class="hljs-comment">// 属性长度</span></span><br><span class="line">    u2 max_stack;                       <span class="hljs-comment">// 操作数栈深度的最大值</span></span><br><span class="line">    u2 max_locals;                      <span class="hljs-comment">// 局部变量表所需的存储空间</span></span><br><span class="line">    u4 code_length;                    <span class="hljs-comment">// 字节码指令的长度</span></span><br><span class="line">    u1 code[code_length];         <span class="hljs-comment">// 字节码指令，二进制形式，具体有哪些指令，下文再提</span></span><br><span class="line">    u2 exception_table_length;<span class="hljs-comment">// 异常表长度</span></span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length]; <span class="hljs-comment">// 异常表</span></span><br><span class="line">    u2 attributes_count;                <span class="hljs-comment">// 属性集合计数器</span></span><br><span class="line">    attribute_info attributes[attributes_count]; <span class="hljs-comment">// 属性集合</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Code 属性类的属性集合，一般是 LineNumberTable、LocalVariableTable</span></span><br><span class="line">LineNumberTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 line_number;	</span><br><span class="line">    &#125; line_number_table[line_number_table_length];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LocalVariableTable_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    &#125; local_variable_table[local_variable_table_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一些工具使用"><a href="#一些工具使用" class="headerlink" title="一些工具使用"></a>一些工具使用</h4><p>javac：</p><ul><li><code>javac -g Main.java</code> 会产生 LocalVariableTable 等调试信息</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\TTTT&gt;javac</span><br><span class="line">用法: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -g                         生成所有调试信息</span><br><span class="line">  -g:none                    不生成任何调试信息</span><br><span class="line">  -g:&#123;lines,vars,source&#125;     只生成某些调试信息</span><br><span class="line">  -nowarn                    不生成任何警告</span><br><span class="line">  -verbose                   输出有关编译器正在执行的操作的消息</span><br><span class="line">  -deprecation               输出使用已过时的 API 的源位置</span><br><span class="line">  -classpath &lt;路径&gt;            指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -cp &lt;路径&gt;                   指定查找用户类文件和注释处理程序的位置</span><br><span class="line">  -sourcepath &lt;路径&gt;           指定查找输入源文件的位置</span><br><span class="line">  -bootclasspath &lt;路径&gt;        覆盖引导类文件的位置</span><br><span class="line">  -extdirs &lt;目录&gt;              覆盖所安装扩展的位置</span><br><span class="line">  -endorseddirs &lt;目录&gt;         覆盖签名的标准路径的位置</span><br><span class="line">  -proc:&#123;none,only&#125;          控制是否执行注释处理和/或编译。</span><br><span class="line">  -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程</span><br><span class="line">  -processorpath &lt;路径&gt;        指定查找注释处理程序的位置</span><br><span class="line">  -parameters                生成元数据以用于方法参数的反射</span><br><span class="line">  -d &lt;目录&gt;                    指定放置生成的类文件的位置</span><br><span class="line">  -s &lt;目录&gt;                    指定放置生成的源文件的位置</span><br><span class="line">  -h &lt;目录&gt;                    指定放置生成的本机标头文件的位置</span><br><span class="line">  -implicit:&#123;none,class&#125;     指定是否为隐式引用文件生成类文件</span><br><span class="line">  -encoding &lt;编码&gt;             指定源文件使用的字符编码</span><br><span class="line">  -source &lt;发行版&gt;              提供与指定发行版的源兼容性</span><br><span class="line">  -target &lt;发行版&gt;              生成特定 VM 版本的类文件</span><br><span class="line">  -profile &lt;配置文件&gt;            请确保使用的 API 在指定的配置文件中可用</span><br><span class="line">  -version                   版本信息</span><br><span class="line">  -help                      输出标准选项的提要</span><br><span class="line">  -A关键字[=值]                  传递给注释处理程序的选项</span><br><span class="line">  -X                         输出非标准选项的提要</span><br><span class="line">  -J&lt;标记&gt;                     直接将 &lt;标记&gt; 传递给运行时系统</span><br><span class="line">  -Werror                    出现警告时终止编译</span><br><span class="line">  @&lt;文件名&gt;                     从文件读取选项和文件名</span><br></pre></td></tr></table></figure><p>javap：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\TTTT&gt;javap</span><br><span class="line">用法: javap &lt;options&gt; &lt;classes&gt;</span><br><span class="line">其中, 可能的选项包括:</span><br><span class="line">  -help  --help  -?        输出此用法消息</span><br><span class="line">  -version                 版本信息</span><br><span class="line">  -v  -verbose             输出附加信息</span><br><span class="line">  -l                       输出行号和本地变量表</span><br><span class="line">  -public                  仅显示公共类和成员</span><br><span class="line">  -protected               显示受保护的/公共类和成员</span><br><span class="line">  -package                 显示程序包/受保护的/公共类和成员 (默认)</span><br><span class="line">  -p  -private             显示所有类和成员</span><br><span class="line">  -c                       对代码进行反汇编</span><br><span class="line">  -s                       输出内部类型签名</span><br><span class="line">  -sysinfo                 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列)</span><br><span class="line">  -constants               显示最终常量</span><br><span class="line">  -classpath &lt;path&gt;        指定查找用户类文件的位置</span><br><span class="line">  -cp &lt;path&gt;               指定查找用户类文件的位置</span><br><span class="line">  -bootclasspath &lt;path&gt;    覆盖引导类文件的位置</span><br></pre></td></tr></table></figure><h3 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h3><blockquote><p>重要的官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html</a></p></blockquote><h3 id="类的加载过程-1"><a href="#类的加载过程-1" class="headerlink" title="类的加载过程"></a>类的加载过程</h3><h3 id="类的加载器"><a href="#类的加载器" class="headerlink" title="类的加载器"></a>类的加载器</h3><h2 id="性能监控与调优"><a href="#性能监控与调优" class="headerlink" title="性能监控与调优"></a>性能监控与调优</h2></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://zhangt.top/CS/JVM-Study-Notes/">JVM-学习笔记</a></li><li><strong>本文作者：</strong><a href="https://zhangt.top">ZhangT</a></li><li><strong>本文链接：</strong><a href="https://zhangt.top/CS/JVM-Study-Notes/">https://zhangt.top/CS/JVM-Study-Notes/</a></li><li><strong>发布时间：</strong>2021-01-15</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><hr style="height:1px;margin:1rem 0"><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><i class="fas fa-tags has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/tags/JAVA/">JAVA</a>,&nbsp;<a class="has-link-grey -link" href="/tags/PROGRAMMING/">PROGRAMMING</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？投喂一下吧！ヾ(●´∀｀●)</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i> </span><span>支付宝</span><div class="qrcode"><img src="/images/alipay.jpg" alt="支付宝"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/Life/Thoughts-In-Avalon-Game/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">关于阿瓦隆桌游（类狼人杀游戏）的碎碎念</span></a></div><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/LIFE/Internship-Guide-In-The-Spring/"><span class="level-item">春招实习指南</span> <i class="level-item fas fa-chevron-right"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"91f36240e98756fc091e",clientSecret:"20de2f4dadd54bc04ad8db6c1090fb00a9477ac4",id:"ff8a2f990aa24b0aec2190a2f43e5b47",repo:"zhangt2333.github.io",owner:"zhangt2333",admin:"zhangt2333",createIssueManually:!1,distractionFreeMode:!1});gitalk.render("comment-container")</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered"><div><img class="image is-96x96 has-mb-6" src="/images/avatar.png" alt="Zhang T"><p class="is-size-4 is-block">Zhang T</p><p class="is-size-6 is-block">感受我的感受</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Qingdao, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><div class="level-item has-text-centered is-marginless"><a href="/archives/"><p class="heading">文章</p><p class="title has-text-weight-normal">18</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/categories/"><p class="heading">分类</p><p class="title has-text-weight-normal">5</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/tags/"><p class="heading">标签</p><p class="title has-text-weight-normal">20</p></a></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/zhangt2333" target="_blank"><i class="fab fa-github"></i>&nbsp;&nbsp;关注我</a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu" style="max-height:750px;overflow:auto"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#内存与垃圾回收"><span class="has-mr-6">1</span> <span>内存与垃圾回收</span></a><ul class="menu-list"><ul class="menu-list"><li><a class="is-flex" href="#JVM-与-Java-体系结构"><span class="has-mr-6">1.1.1</span> <span>JVM 与 Java 体系结构</span></a></li><li><a class="is-flex" href="#类加载子系统"><span class="has-mr-6">1.1.2</span> <span>类加载子系统</span></a></li><li><a class="is-flex" href="#运行时数据区"><span class="has-mr-6">1.1.3</span> <span>运行时数据区</span></a></li><li><a class="is-flex" href="#执行引擎"><span class="has-mr-6">1.1.4</span> <span>执行引擎</span></a></li><li><a class="is-flex" href="#StringTable"><span class="has-mr-6">1.1.5</span> <span>StringTable</span></a></li><li><a class="is-flex" href="#垃圾回收"><span class="has-mr-6">1.1.6</span> <span>垃圾回收</span></a></li></ul><li><a class="is-flex" href="#字节码与类的加载"><span class="has-mr-6">1.2</span> <span>字节码与类的加载</span></a><ul class="menu-list"><li><a class="is-flex" href="#Class-文件结构"><span class="has-mr-6">1.2.1</span> <span>Class 文件结构</span></a></li><li><a class="is-flex" href="#字节码指令"><span class="has-mr-6">1.2.2</span> <span>字节码指令</span></a></li><li><a class="is-flex" href="#类的加载过程-1"><span class="has-mr-6">1.2.3</span> <span>类的加载过程</span></a></li><li><a class="is-flex" href="#类的加载器"><span class="has-mr-6">1.2.4</span> <span>类的加载器</span></a></li></ul></li><li><a class="is-flex" href="#性能监控与调优"><span class="has-mr-6">1.3</span> <span>性能监控与调优</span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/">TTTT&#39;s Blog</a><p class="is-size-7">&copy; 2021 ZhangT&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},skipTags:["script","noscript","style","textarea","pre","code"],processEscapes:!0,tex2jax:{inlineMath:[["$","$"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>