<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>汇编语言-学习笔记 - Zhang T&#39;s Blog</title><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/">TTTT&#39;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i> </a><a class="navbar-item" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-image"><span class="image is-7by1"><img class="thumbnail" src="/thumbnails/Assembly-Language-Study-Notes.jpg" alt="汇编语言-学习笔记"></span></div><div class="card-content article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>汇编语言-学习笔记</h1><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2019-10-01T13:01:00.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-10-01</time> <time class="level-item has-text-grey is-hidden-mobile" datetime="2021-03-05T12:35:06.994Z"><i class="far fa-calendar-check">&nbsp;</i>2021-03-05</time><div class="level-item"><i class="far fa-folder-open has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/categories/CS/">CS</a></div><span class="level-item has-text-grey"><i class="far fa-clock"></i>&nbsp; 1 小时 读完 (大约 10278 个字) </span><span class="level-item has-text-grey" id="busuanzi_container_page_pv"><i class="far fa-eye"></i> <span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><h2 id="第-1-章-预备知识"><a href="#第-1-章-预备知识" class="headerlink" title="第 1 章 预备知识"></a>第 1 章 预备知识</h2><h3 id="什么是汇编"><a href="#什么是汇编" class="headerlink" title="什么是汇编"></a>什么是汇编</h3><p>好处：</p><ul><li>解密程序、逆向工程、病毒木马分析和防止的唯一</li><li>理解 C 语言程序的最好途径</li><li>了解操作系统运行细节的最佳方式</li><li>特定场合下编写程序的必然选择</li><li>了解计算机工作原理和后继课程学习的基础</li></ul><a id="more"></a><p>目标：</p><ul><li>掌握语法：指令格式 （关键：寻址方式）</li><li>掌握语义：指令功能 （关键：分类记忆）</li><li>灵活应用：阅读、编程 （关键：实践）</li></ul><p>伪指令：</p><ul><li>由汇编程序在汇编过程中执行的指令</li></ul><p>指令：</p><ul><li>告诉 CPU 要执行的操作（一般还要指出操作数地址），在程序运行时执行</li></ul><h3 id="Intel-80X86-寄存器组"><a href="#Intel-80X86-寄存器组" class="headerlink" title="Intel 80X86 寄存器组"></a>Intel 80X86 寄存器组</h3><p>8 个 32 位寄存器 （通用寄存器）分为两组：数据寄存器组、指示器变址寄存器组</p><h4 id="数组寄存器组"><a href="#数组寄存器组" class="headerlink" title="数组寄存器组"></a>数组寄存器组</h4><table><thead><tr><th align="center">Register</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">EAX</td><td align="center">累加器</td><td align="center">Accumulator</td></tr><tr><td align="center">EBX</td><td align="center">基址寄存器</td><td align="center">Base</td></tr><tr><td align="center">ECX</td><td align="center">计数器</td><td align="center">Count</td></tr><tr><td align="center">EDX</td><td align="center">数据寄存器</td><td align="center">Data</td></tr></tbody></table><p>EAX 可以看成某个存储单元的地址<br>(EAX) 则表示 EAX 单元中的内容</p><p>寄存器划分：</p><ul><li>低 16 位组 —— AX, BX, CX, DX</li><li>低 8 位组 —— AL, BL, CL, DL</li><li>高 8 位组 —— AH, BH, CH, DH</li><li>(AX) = (AH, AL) , …</li></ul><table><thead><tr><th align="center">Register</th><th align="center">31-16位</th><th align="center">15-8位</th><th align="center">7-0位</th></tr></thead><tbody><tr><td align="center">EAX</td><td align="center"></td><td align="center">AH</td><td align="center">AL</td></tr><tr><td align="center">EBX</td><td align="center"></td><td align="center">BH</td><td align="center">BL</td></tr><tr><td align="center">ECX</td><td align="center"></td><td align="center">CH</td><td align="center">CL</td></tr><tr><td align="center">EDX</td><td align="center"></td><td align="center">DH</td><td align="center">DL</td></tr></tbody></table><p>将 EAX 的低 16 位置 0：<code>MOV AX, 0</code></p><p>将 EAX 的低 8~15 位置 1：<code>MOV AH, 0FFH</code></p><h4 id="变址寄存器组"><a href="#变址寄存器组" class="headerlink" title="变址寄存器组"></a>变址寄存器组</h4><table><thead><tr><th align="center">Register</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">ESI</td><td align="center">源变址寄存器</td><td align="center">Source Index</td></tr><tr><td align="center">EDI</td><td align="center">基址寄寄存器</td><td align="center">Destination Index</td></tr><tr><td align="center">ESP</td><td align="center">堆栈指示器</td><td align="center">Stack Pointer</td></tr><tr><td align="center">EBP</td><td align="center">堆栈基址寄存器</td><td align="center">Base Pointer</td></tr></tbody></table><p>寄存器划分：</p><ul><li>ESI、EDI、ESP、EBP 都是 32 位寄存器</li><li>低 16 位作 16 位寄存器用，SI、DI、SP、BP</li><li>一般用作指示器或变址寄存器<br>可作为数据寄存器用</li><li>ESP, SP 一般不作数据寄存器使用</li></ul><table><thead><tr><th align="center">Register</th><th align="center">31-16位</th><th align="center">15-0位</th></tr></thead><tbody><tr><td align="center">ESI</td><td align="center"></td><td align="center">SI</td></tr><tr><td align="center">EDI</td><td align="center"></td><td align="center">DI</td></tr><tr><td align="center">ESP</td><td align="center"></td><td align="center">BP</td></tr><tr><td align="center">EBP</td><td align="center"></td><td align="center">SP</td></tr></tbody></table><h4 id="指令预取部件和指令译码部件"><a href="#指令预取部件和指令译码部件" class="headerlink" title="指令预取部件和指令译码部件"></a>指令预取部件和指令译码部件</h4><p>指令预取部件：将要执行的指令从主存中取出，送入指令排队机构中排队</p><p>指令译码部件：从指令预取队列中读出指令并译码，再送入译码指令队列排队供执行部件使用</p><p>指令的提取、译码、执行重叠进行，形成了指令流水线。</p><p>指令指示器：</p><ul><li>EIP/IP：保存下一条要被 CPU 执行的指令的偏移地址 EA。由微处理器硬件自动设置</li><li>EIP/IP 不能由指令直接访问，执行转移指令、子程序调用指令等可使其改变</li></ul><table><thead><tr><th align="center">Register</th><th align="center">31-16位</th><th align="center">15-0位</th></tr></thead><tbody><tr><td align="center">IP</td><td align="center"></td><td align="center">IP</td></tr></tbody></table><h4 id="分段部件和分页部件"><a href="#分段部件和分页部件" class="headerlink" title="分段部件和分页部件"></a>分段部件和分页部件</h4><p>$ 虚拟存储空间 \xrightarrow{分段部件} 一维线性地址 \xrightarrow{分页部件} 物理存储空间 $</p><ul><li>虚拟存储地址是一种概念性的逻辑地址，并非实际空间地址</li><li>程序员编写程序时不用考虑物理存储器大小</li><li>存储管理单元 MMU 进行虚地址到是地址的自动变换</li><li>地址变换对应用程序是透明的</li></ul><p>分段部件中 6 个 16 位的段寄存器：</p><table><thead><tr><th align="center">Register</th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">CS</td><td align="center">代码段寄存器</td><td align="center">Code Segment</td></tr><tr><td align="center">DS</td><td align="center">数据段寄存器</td><td align="center">Data Segment</td></tr><tr><td align="center">SS</td><td align="center">堆栈段寄存器</td><td align="center">Stack Segment</td></tr><tr><td align="center">ES</td><td align="center">附加数据段寄存器</td><td align="center"></td></tr><tr><td align="center">FS</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">GS</td><td align="center"></td><td align="center"></td></tr></tbody></table><h4 id="80x86-微处理器结构"><a href="#80x86-微处理器结构" class="headerlink" title="80x86 微处理器结构"></a>80x86 微处理器结构</h4><p><img src="1569237958957.png" alt="1569237958957"></p><h4 id="80x86-的三种工作方式"><a href="#80x86-的三种工作方式" class="headerlink" title="80x86 的三种工作方式"></a>80x86 的三种工作方式</h4><ul><li><p>实方式 （实地址方式）</p><ul><li>相当于 8086</li><li>CPU 32 位、16 位数据总线、20 位地址总线</li></ul></li><li><p>保护方式 （虚地址）</p><ul><li>支持多任务环境的工作方式，建立保护机制存储区采用分段、分页的存储管理机制</li><li>为每个任务提供一台虚拟处理器</li></ul></li><li><p>虚拟 8086 方式</p><ul><li>保护方式下所提供的同时模拟多个 8086 处理器</li><li>例如 Windows 的 CMD</li></ul></li></ul><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><p>内存：用来存放程序和数据的装置</p><p>字节 Byte：最小的寻址单位</p><p>字 Word：两个相邻的字节组成一个字</p><ul><li>低 8 位在低字节（低地址）</li><li>高 8 位在相邻的高字节</li><li>上述是小端模式，即低字节在低地址</li></ul><p>双字 DoubleWord：四个连续的字节，地址是四个字节中最低的地址</p><p>实验-地址类型转换：</p><ul><li>“1234567”，在内存中存为 31H、32H、…、37H，从上到下</li></ul><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">char</span> s[<span class="hljs-number">10</span>];</span><br><span class="line">    <span class="hljs-built_in">strcpy</span>(s, <span class="hljs-string">"1234567"</span>);</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%ld\n"</span>, *(<span class="hljs-keyword">long</span> *)(s+<span class="hljs-number">2</span>)); <span class="hljs-comment">// 输出 909456435 =(36353433)_16 </span></span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%ld\n"</span>, *(<span class="hljs-keyword">short</span> *)(s+<span class="hljs-number">2</span>));<span class="hljs-comment">// 输出 13363 = (3433)_16</span></span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, *(<span class="hljs-keyword">char</span> *)(s+<span class="hljs-number">2</span>));  <span class="hljs-comment">// 输出 51 = (33)_16</span></span><br><span class="line">    *(<span class="hljs-keyword">int</span> *)(s+<span class="hljs-number">1</span>)=<span class="hljs-number">16706</span>;<span class="hljs-comment">// 16706=(00004142)_16              </span></span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%s\n"</span>, s);               <span class="hljs-comment">// 输出 1BA</span></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h4><p>堆栈的建立：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">; 建立一个 16 位段，地址形式是16位段地址, 16位偏移, 使用16位寄存器SP指向栈顶</span><br><span class="line">MY_S_NAME SEGMENT USE16 STACK</span><br><span class="line">          DB 200 DUP(0)</span><br><span class="line">MY_S_NAME ENDS</span><br></pre></td></tr></table></figure><p><img src="1569240163289.png" alt="1569240163289"></p><p>进栈指令：</p><ul><li><p><code>PUSH OPS</code>，OP 指操作，S 指源</p><ul><li>单字进栈： (SP)-2 → SP; 字数据 → [sp];<br>记为 (OPS) → ↓ (sp)</li><li>双字进栈：(SP)-4 -&gt; SP; …</li></ul></li><li><p>功能：将立即数、寄存器、段寄存器、存储器中的一个字/ 双字数据压入堆栈</p><p><img src="1569240381187.png" alt="1569240381187"></p></li></ul><p>出栈指令：</p><ul><li><p><code>POP OPD</code>，OP 指操作，D 指目的</p><ul><li>([SP]) → OPD; (SP+2) → SP<br>记为 ↑ (SP) → OPD</li></ul></li><li><p>功能：将栈顶元素弹出送至某一寄存器、段寄存器 (CS除外)、存储器中</p></li></ul><p>8 个 16 位寄存器内容顺序存入指令：</p><ul><li><code>PUSHA</code></li><li>功能：将 8 个 16 位寄存器按 AX, CX, DX, BX, SP, BP, SI, DI顺序入堆栈</li><li>说明：入栈的 SP 是执行 PUSHA 之前的 SP 值</li><li>依次送出 DI, SI, BP, SP, BX, DX, CX, AS 的 <code>POPA</code> 指令</li></ul><p>8 个 32 位寄存器内容顺序存入指令：</p><ul><li><code>PUSHAD</code></li><li>功能：将 8 个 32 位寄存器按 EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI顺序入堆栈</li><li>说明：入栈的 SP 是执行 PUSHAD 之前的 SP 值</li></ul><ul><li>依次送出 EDI, ESI, EBP, ESP, EBX, EDX, ECX, EAS 的 <code>POPAD</code> 指令</li></ul><h4 id="物理地址的形成"><a href="#物理地址的形成" class="headerlink" title="物理地址的形成"></a>物理地址的形成</h4><p>程序中单元 (如变量等) 的相对位置、逻辑地址已定。</p><p>两段程序的位置如下：</p><ul><li>确定了白线条的位置，其他线条的位置可它们之间的相对位置关系计算</li></ul><p><img src="1569241216644.png" alt="1569241216644"></p><ul><li><p>段的开始地址要能被 16 整除，16 = 10H = 10000B</p></li><li><p>段址：段开始单元的物理地址(段首址) / 16</p></li><li><p>偏移地址：距离段首址的距离</p></li><li><p>物理地址 = 段址 * 16 + 偏移地址</p></li><li><p>“段首地址 : 偏移地址”：这样为二维的逻辑地址</p></li><li><p>一个段最大为 64 KB ( $2^{16}$ )</p></li><li><p>1 M 内存至少有 16 个段</p></li><li><p>一个段内可同时访问 4 个段寄存器 CS, DS, ES, SS</p></li></ul><p><strong>在代码段中取指令时</strong>：</p><ul><li>指令的物理地址 PA = (CS) 左移4位 + (IP)，注意不是 EIP</li></ul><p><strong>在数据段中读/写数据时</strong>：</p><ul><li>数据的物理地址 PA = (DS或ES) 左移4位 + 16位偏址 （偏址由寻址方式确定）</li></ul><p><strong>在堆栈操作时</strong>：</p><ul><li>栈顶的物理地址 PA = (SS) 左移四位 + (SP)</li></ul><p>8086 CPU 在运行一个程序时，如何确定 CS, DS, ES, SS 中的值呢？</p><ul><li>在将一个程序装入内存，准备运行时，由操作系统确定程序中定义的各个段在什么位置。</li><li>对于代码段，系统自动将代码段首址送到 CS 中 ，并设置 IP 为第一条要执行指令的偏移地址（C 语言的 MAIN ）。</li><li>对于堆栈段，系统将自动把堆栈段首址送到 SS中，并根据定义的堆栈段的大小，设置 SP 的值。</li></ul><h5 id="实方式物理地址的形成"><a href="#实方式物理地址的形成" class="headerlink" title="实方式物理地址的形成"></a>实方式物理地址的形成</h5><ul><li><p>32 位 CPU 与 8086 一样只能寻址 1M 物理存储空间</p></li><li><p>可以访问 6 个段 CS, DS, SS, ES, FS, GS，每个段至多 64K</p></li><li><p>物理地址 = (段寄存器) 左移 4 位 + 偏移地址</p></li><li><p>C 语言变量和指令写在一起，没有分段的概念，而机器语言层次上是要分段的，为什么？</p><ul><li>变量也需要存储空间存放，而 cpu 执行的执行代码，全部为 01 程序，因此需要堆栈段、数据段、代码段分开，使 cpu 执行代码时可以区分变量和指令。</li></ul></li></ul><h5 id="保护方式下物理地址的形成"><a href="#保护方式下物理地址的形成" class="headerlink" title="保护方式下物理地址的形成"></a>保护方式下物理地址的形成</h5><p>80386 中寄存器 32 位，地址线 32 根。</p><ul><li>在多任务环境下，系统中有多个程序在运行，程序之间要隔离</li><li>分段是存储管理的一种方式，为保护提供基础</li><li>不同程序在不同段中，一个程序可包含多个段</li><li>段用于封闭具有共同属性的存储区域</li></ul><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> c[<span class="hljs-number">10</span>];</span><br><span class="line">    <span class="hljs-keyword">int</span> y = <span class="hljs-number">10</span>;</span><br><span class="line">    c[<span class="hljs-number">-1</span>] = <span class="hljs-number">48</span>;</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, y); <span class="hljs-comment">// 输出 48</span></span><br><span class="line">    <span class="hljs-comment">// c[-10000] = 48 会报错，这是分段保护（超出段范围）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>描述符</strong>，8Byte —— 保护一个段所需的信息及其存放 ：</p><ul><li><p>段的起始位置（段基地址）</p></li><li><p>段的大小（段界限）</p></li><li><p>段的特权级</p></li><li><p>段的属性（是代码段，数据段，还是堆栈段？数据段是否可写？代码段是否可读出？）</p></li><li><p>段的位置（在内存还是在磁盘？）</p></li><li><p>段的类型（在系统段还是用户段？）</p></li><li><p>段的使用（段被访问过，还是没有？）</p></li><li><p>分段</p></li></ul><p><img src="1569298216883.png" alt="1569298216883"></p><p>描述符表 Local Description Table—— 描述符的集合：</p><ul><li>一个 LDT，是一个<strong>系统段</strong>，最大可为 64KB，最多可存放 8192 个描述符</li></ul><p><img src="1569298386648.png" alt="1569298386648"></p><ul><li><p>全局描述符表，只有一个 GDT，最大可为 64KB，存放 8192个描述符。<br>包括：操作系统所使用的段的描述符、各个 LDT 段的描述</p><p><img src="1569298526903.png" alt="1569298526903"></p></li><li><p>全局描述符表，在 GDTR 这个 48 位寄存器，存放其地址。还有一个 LDTR，表示全局描述符中 LDT 的偏址</p><p><img src="1569298802680.png" alt="1569298802680"></p></li></ul><p>“xxxx : yyyyyyyy” 从虚拟地址到线性地址的映射：</p><p><img src="1569298951858.png" alt="1569298951858"></p><ul><li>xxxx 不是段开始的地址，而是指出栈相应段描述符的方式。称之为 段选择符</li><li>TI = 0<ul><li>从 GDTR 寄存器取 GDT 表的基址</li><li>在 GDT 表中，以 xxxx 的高 13 位作为偏址，取出描述符 A</li><li>描述符 A 中的段基址 + yyyyyyyy，即为要访问单元的线性地址</li></ul></li><li>TI = 1<ul><li>从 GDTR 寄存器取 GDT 表的基址</li><li>在 GDT 表中，以 LDTR 寄存器的高 13 位作偏址，取出描述符 A</li><li>描述符 A 描述的段为一个 LDT 段 (如 LDT_A)</li><li>用 xxxx 的高 13 位作偏址，在 LDT_A 段中找到描述符 P_A</li><li>P_A 描述段的基址 + yyyyyyyy 为线性地址</li></ul></li></ul><p>从线性地址到物理地址：</p><p><img src="1569299732649.png" alt="1569299732649"></p><h3 id="标识寄存器"><a href="#标识寄存器" class="headerlink" title="标识寄存器"></a>标识寄存器</h3><ul><li><p>保存一条指令执行之后，CPU 所处状态的信息及运算结果的特征</p></li><li><p>16 位 CPU 中的标志寄存器是 16 位，称 FLAGS</p></li><li><p>32 位 CPU 中的标志寄存器是 32 位，称 EFLAGS</p></li><li><p>32 位的 EFLAGS 包含了 16 位 FLAGS 的全部标识</p></li></ul><h4 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h4><p><img src="1569300269809.png" alt="1569300269809"></p><ul><li><p>条件标志位<br>Overflow Flag 溢出<br>Sign Flag 符号<br>Zero Flag 零<br>Carry Flag 进位</p></li><li><p>符号标志 SF，最高位为 1，则 SF=1</p></li><li><p>零标志 ZF，运算结果为 0，则 ZF=1</p></li><li><p>溢出标志 OF，若两个加数最高位相同，且结果最高位相反，则溢出 OF=1</p></li><li><p>进位标志 CF，若运算从最高位向前产生进位 (或借位)，则 CF=1</p></li></ul><h4 id="标志寄存器操作指令"><a href="#标志寄存器操作指令" class="headerlink" title="标志寄存器操作指令"></a>标志寄存器操作指令</h4><p>LAHF (Load AH From Flags)：</p><ul><li>功能：将标志寄存器的低 8 位送入 <strong>AH</strong> 中，对标志位无影响。</li></ul><p>SAHF (Store AH into Flags)：</p><ul><li>功能：将 <strong>AH</strong> 中的内容送入标志寄存器的低 8 位中，而高位保持不变。</li></ul><p>标志寄存器堆栈指令：</p><ul><li>低 16 位：PUSHF、POPF</li><li>32 位标志寄存器：PUSHFD、POPFD</li></ul><h3 id="汇编源程序举例"><a href="#汇编源程序举例" class="headerlink" title="汇编源程序举例"></a>汇编源程序举例</h3><p>for 语句</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">; AX=0; for(BX=1;BX&lt;100;BX+=2) AX+=BX;</span><br><span class="line">MOV AX, 0</span><br><span class="line">MOV BX, 1</span><br><span class="line">MAINP: CMP BX, 100</span><br><span class="line">       JGE EXIT</span><br><span class="line">       ADD AX, BX</span><br><span class="line">       ADD BX, 2</span><br><span class="line">       JMP MAINP</span><br><span class="line">EXIT:</span><br></pre></td></tr></table></figure><p>dowhile语句</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; AX=0; BX=1; do&#123;AX+=BX;BX+=2;&#125;while(BX&lt;100);</span><br><span class="line">MOV AX, 0</span><br><span class="line">MOV BX, 1</span><br><span class="line">MAINP: ADD AX, BX</span><br><span class="line">       ADD BX, 2</span><br><span class="line">       CMP BX, 100</span><br><span class="line">       JL MAINP</span><br><span class="line">EXIT:</span><br></pre></td></tr></table></figure><h2 id="第-2-章-寻址方式"><a href="#第-2-章-寻址方式" class="headerlink" title="第 2 章 寻址方式"></a>第 2 章 寻址方式</h2><ul><li><p>内存中，何处找操作数</p></li><li><p>CPU 如何知道操作数地址</p></li><li><p>C 语言中地址的寻找</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> i, j;</span><br><span class="line"><span class="hljs-keyword">int</span> A[<span class="hljs-number">10</span>];</span><br><span class="line"><span class="hljs-keyword">int</span> *p;</span><br><span class="line"><span class="hljs-keyword">int</span> B[<span class="hljs-number">20</span>][<span class="hljs-number">10</span>];</span><br><span class="line">A[i] = <span class="hljs-number">5</span>;</span><br><span class="line">B[i][j] = <span class="hljs-number">10</span>;</span><br></pre></td></tr></table></figure></li></ul><p>一条指令，关注：</p><ul><li>操作码 —— 执行什么操作</li><li>操作数在哪<ul><li>CPU 寄存器</li><li>主存，操作数在主存时，关注段址/段选择符、段内偏移</li><li>IO 设备端口</li></ul></li><li>操作数类型</li></ul><p>双操作数的指令格式：</p><ul><li><p><code>操作符 OPD, OPS</code></p></li><li><p><code>ADD AX, BX</code>，AX 是目的操作数地址，BX 是源操作数地址</p></li><li><p>(OPD) + (OPS) → OPD</p></li></ul><h3 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h3><p>格式：<code>R</code></p><p>功能：寄存器 R 中的内容即操作数（除个别指令外，R 可为任意寄存器）</p><p><strong>操作数在寄存器</strong>（操作数地址就是符号地址），操作数类型是字节</p><p>例如：</p><ul><li><p><code>DEC BL</code></p></li><li><p><code>ADD AX, BX</code></p></li><li><p><code>MOV AX, BX</code></p></li><li><p><code>ADD EAX, EDX</code></p></li><li><p><del><code>MOV AX, BH</code></del>，注意两个的字节数</p></li></ul><h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="寄存器间接寻址"></a>寄存器间接寻址</h3><p>格式：<code>[R]</code></p><p>功能：<strong>操作数在内存中</strong>，操作数的偏址在寄存器 R 中，即 (R) 为操作数的偏址</p><p><img src="1569307692100.png" alt="1569307692100"></p><p>R 可以是：</p><ul><li>8 个 32 位通用寄存器中任一：EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP</li><li>4 个 16 位通用寄存器中任一：BX, SI, DI, BP （向下兼容的遗留问题）</li></ul><p>操作数所在段是：</p><ul><li>R 为 BP、EBP、ESP，系统默认操作数在堆栈中，等同于 SS:[R]</li><li>其他情况，默认操作数在 DS 所指示的段中</li></ul><p>操作数类型：<strong>未知</strong></p><p>例：</p><ul><li><p><code>MOV AX, [SI]</code><br>执行前 (AX)=0005H, (SI)=(0020H), DS:(20H)=1234H，执行后 (AX)=1234H, (SI)=0020H。<br>该指令中目的操作数是寄存器寻址，源操作数是寄存器间接寻址<br>若指令是 <code>MOV AL, [SI]</code>，则 (AL)=34H，目的操作数暗示操作数类型</p></li><li><p><code>MOV EAX, -1 MOV [ESP], EAX POP EBX</code> ，结果 (EBX)=-1</p></li><li><p><del><code>MOV AX, [CX]</code></del>，不能用这个 16 位寄存器</p></li><li><p><code>MOV AX, BX</code> 和 <code>MOV AX, [BX]</code> 差别很大，前者是值存在 BX 中，后者存的是偏址，还要根据偏址找到值</p></li></ul><p>C -&gt; 汇编实例</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; 寄存器间接寻址实现 strcpy(buf2, buf1, ...)</span><br><span class="line">    MOV SI, OFFSET BUF1</span><br><span class="line">    MOV DI, OFFSET BUF2</span><br><span class="line">    MOV CX, 5</span><br><span class="line">MAINP: </span><br><span class="line">    MOV AL, [SI]</span><br><span class="line">    MOV [DI], AL</span><br><span class="line">    INC SI</span><br><span class="line">    INC DI</span><br><span class="line">    DEC CX</span><br><span class="line">    JNZ MAINP</span><br><span class="line">EXIT:</span><br></pre></td></tr></table></figure><h3 id="变址寻址"><a href="#变址寻址" class="headerlink" title="变址寻址"></a>变址寻址</h3><p>格式：</p><ul><li><code>[R×F + V]</code></li><li><code>[R×F] + V</code></li><li><code>V[R×F]</code></li></ul><p>功能：<strong>操作数在内存</strong>。R 中的内容 × F + V 为操作数的偏址</p><p><img src="1569307758547.png" alt="1569307758547"></p><p>R 可以是：</p><ul><li>8 个 32 位通用寄存器中任一：EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP</li><li>4 个 16 位通用寄存器中任一：BX, SI, DI, BP （向下兼容的遗留问题）</li></ul><p>F (比例因子) 可以是：1、2 (字)、4 (双字)、8</p><ul><li>当 R 为 16 位寄存器时，F = 1</li></ul><p>V 与操作数所在：</p><ul><li>当 V 为数值常量，是二进制补码表示的有符号数。<br>若 R 为 BP、EBP、ESP，则系统默认操作数在堆栈中，等同于 SS:[R]；<br>其他情况默认操作数在 DS 所指示的段中</li><li>当 V 为变量时，取该变量对应单元的有效地址参与运算。即系统默认操作数在该变量或标号所在的段中（除非显式指明形如 CS:[BX]）。</li></ul><p>例：</p><ul><li><code>MOV AL, [EBX*2]+5</code><ul><li>执行前 (AL)=18H, (EBX)=1100H, DS:(2205H)=55H</li><li>执行后 (AL)=55H, 其他不变</li></ul></li></ul><p>C -&gt; 汇编实例</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">; 变址寻址实现 for(i=0;i&lt;5;i++) result+=buf[i];</span><br><span class="line">.386</span><br><span class="line">STACK SEGMENT USE16 STACK</span><br><span class="line">      DB 200 DUP(0)</span><br><span class="line">STACK ENDS</span><br><span class="line"></span><br><span class="line">SEG1 SEGMENT USE16</span><br><span class="line">BUF  DD 10,20,30,40,50</span><br><span class="line">RES  DD ?</span><br><span class="line">SEG1 ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT USE16 ASSUME CS:CODE, DS:SEG1,SS:STACK</span><br><span class="line"></span><br><span class="line">START:</span><br><span class="line">    MOV AX, SEG1</span><br><span class="line">    MOV DS, AX</span><br><span class="line">    MOV EBX, 0</span><br><span class="line">    MOV EAX, 0</span><br><span class="line">LP:</span><br><span class="line">    CMP EBX, 5</span><br><span class="line">    JGE EXIT</span><br><span class="line">    ADD EAX, BUF[EBX*4] ; DD 定义双字</span><br><span class="line">    INC EBX</span><br><span class="line">    JMP LP</span><br><span class="line">EXIT:</span><br><span class="line">    MOV RES, EAX</span><br><span class="line">    MOV AX, 4C00H</span><br><span class="line">    INT 21H</span><br><span class="line">CODE ENDS END START</span><br></pre></td></tr></table></figure><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">; 变址寻址实现 strcpy(buf2, buf1, ...)</span><br><span class="line">    MOV EBX, 0</span><br><span class="line">MAINP:</span><br><span class="line">    CMP EBX, 5</span><br><span class="line">    JGE EXIT</span><br><span class="line">    MOV AL, BUF1[EBX*4]</span><br><span class="line">    MOV BUF2[EBX*4], AL</span><br><span class="line">    INC EBX</span><br><span class="line">    JMP MAINP</span><br><span class="line">EXIT:</span><br></pre></td></tr></table></figure><h3 id="基址加变址寻址"><a href="#基址加变址寻址" class="headerlink" title="基址加变址寻址"></a>基址加变址寻址</h3><p>格式：</p><ul><li><code>[BR + IR×F + V]</code></li><li><code>V[BR][IR×F]</code></li><li><code>V[IR×F][BR]</code></li><li><code>V[BR + IR×F]</code></li></ul><p>功能：</p><ul><li>操作数的偏移 = 变址寄存器 IR 中的内容 × 比例因子F + 位移量V + 基址寄存器 BR 的内容<br><code>EA = (IR)*F + V + (BR)</code></li></ul><p>使用 16 位寄存器时：</p><ul><li>BR ∈ {BX, BP}<br>为 BX 默认操作数在 DS 所指示的段<br>为 BP 默认操作数在 SS 所指示的段</li><li>IR ∈ {SI, DI}</li><li>F = 1</li></ul><p>使用 32 位寄存器时：</p><ul><li>BR 可是 8 个通用寄存器中任一</li><li>IR 可是除 ESP 外任一</li><li>没有比例因子时，写在前面的寄存器是 BR</li><li>当 BR 为 ESP、EBP，默认段是 SS</li></ul><p>操作数的类型：</p><ul><li>当 V 为变量，则操作数类型为变量的类型</li><li>当 V 为常量，类型位置</li></ul><p>例：</p><ul><li><code>MOV AX, 8[BX][SI]</code><ul><li>执行前 (AX)=45H, (BX)=30H, (SI)=20H, DS:(0058H)=99H</li><li>执行后 (AX)=99H，其他不变</li></ul></li></ul><h3 id="立即寻址"><a href="#立即寻址" class="headerlink" title="立即寻址"></a>立即寻址</h3><p>格式：<code>n</code></p><ul><li>操作数直接放在指令中，在指令的操作码后</li><li>操作数是指令的一部分，位于代码段中</li><li>指令中的操作数是 8 位、 16 位或 32 位二进制数</li><li>只能作源操作数</li><li><strong>立即数不能直接送段寄存器</strong></li></ul><h3 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h3><p>格式：</p><ul><li><code>段寄存器名 : [n]</code></li><li><code>变量</code></li><li><code>变量+常量</code></li></ul><p>功能：操作码的下一个字/双字单元的内容为操作数的偏址 EA</p><ul><li>操作数在内存中。操作数的偏址 EA 紧跟在指令操作码后</li></ul><p>操作数所在的段：</p><ul><li>由段寄存器名指示，或是变量所在的段</li></ul><p>操作数的类型：</p><ul><li>若有变量，则是定义变量的类型</li><li>若无，未知</li></ul><p>例：</p><ul><li><code>MOV AX, DS:[2000H]</code><ul><li>执行前 (AX)=1, DS:(2000H)=976</li><li>执行后 (AX)=976</li></ul></li></ul><h3 id="有关问题"><a href="#有关问题" class="headerlink" title="有关问题"></a>有关问题</h3><p>寻址方式 6 种，根据操作数的存放位置可归 3 类：</p><ul><li>寄存器方式</li><li>立即方式</li><li>存储器方式<ul><li>寄存器间接寻址</li><li>变址寻址</li><li>基址加变址寻址</li><li>直接寻址</li></ul></li></ul><p>双操作数寻址方式的规定：</p><ul><li>一条指令的源操作数和目的操作数<strong>不能同时用存储器方式</strong></li></ul><p>操作数的类型：</p><ul><li>寄存器寻址方式中，操作数类型由寄存器定</li><li>立即数没有类型</li><li>含变量的寻址方式所表示的操作数类型为变量的类型</li><li>不含变量的存储器方式所表示的操作数类型未知<ul><li><code>MOV [BX], 0</code> 两个操作数类型都不明确</li><li>属性定义算符 PTR<br><code>MOV BYTE PTR[BX], 0</code><br><code>MOV WORD PTR[BX], 0</code><br><code>MOV DWORD PTR[BX], 0</code></li></ul></li></ul><p>双操作数的类型规定：</p><ul><li>双操作数中至少应有一个的类型是明确的</li><li>若两个操作数的类型都明确，则两个的类型应相同</li></ul><h2 id="第-3-章-宏汇编语言"><a href="#第-3-章-宏汇编语言" class="headerlink" title="第 3 章 宏汇编语言"></a>第 3 章 宏汇编语言</h2><p>目标：</p><ul><li>正确而熟练地使用地址表达式和数值表达式</li><li>熟悉常用的机器指令的使用格式、功能</li><li>区别机器指令语句和伪指令语句</li><li>常用的伪指令功能、使用方法</li><li>熟练掌握常用的 DOS 系统功能调用 （1, 2, 9, 10 号调用）</li></ul><h3 id="宏汇编语言表达式"><a href="#宏汇编语言表达式" class="headerlink" title="宏汇编语言表达式"></a>宏汇编语言表达式</h3><p>常量：</p><ul><li><p>便于程序修改、阅读，在</p></li><li><p><code>MOV CX, 10</code> 中 10 为数值常量</p></li><li><p><code>MOV CX, AA</code> 中 AA 为符号常量。汇编时编译器会将其换为常量</p></li></ul><p>数值表达式：</p><ul><li><p>由常量和运算符组成的有意义的式子</p></li><li><p>一个常量是一个数值表达式；</p><p>由数值表达式通过运算符和括号连接起来是数值表达式</p></li><li><p>算术运算：<code>+、-、&amp;、/、MOD、SHR、SHL</code></p></li><li><p>关系运算：<code>EQ、NE、LT，GT、LE、GE</code></p></li><li><p>逻辑运算：<code>AND、OR、XOR、NOT</code></p></li></ul><p>变量：</p><ul><li>一个数据存储单元的名字</li><li>存储单元的属性：段属性、偏移地址、单元的类型、单元中的内容</li><li>变量定义、变量定义伪指令、表达式[, …]<br>DB 字节<br>DW 字<br>DD 双字<br>DF 三字<br>DQ 四字<br>DT 十字</li><li>表达式有五种<ul><li>数值表达式：<code>X DB 10</code></li><li>字符串 （如果串长超过 2 个字符定义伪指令只能用 DB）：<code>Z DW &#39;12&#39;</code>、<code>Y DB &#39;12&#39;</code>、<code>X DB &#39;abcd&#39;</code>，前两者在内存中情况相反</li><li>地址表达式（不能出现带寄存器符号，数据定义伪指令只能用 DW、DD，用 DD 的时候包含段首址）。<br>有点像指针，面向对象汇编后的代码中大量使用。<br><img src="1569414743376.png" alt="1569414743376"></li><li>? （就是一个问号），表示定义的变量无确定的初值</li><li>重复字句 n DUP (表达式[,…])<ul><li><code>X DB 3, DUP(2)</code> 等价于 <code>X DB 2,2,2</code></li><li><code>X DB 3, DUP(1,2)</code> 等价于 <code>X DB 1,2,1,2,1,2</code></li></ul></li></ul></li></ul><img src="1569415286144.png" alt="1569415286144" style="zoom:40%"><p>标号：</p><ul><li>机器指令存放地址的符号表示</li><li>三个属性<ul><li>段属性</li><li>偏址</li><li>类型：NEAR, FAR</li></ul></li></ul><p><strong>地址表达式</strong>：</p><ul><li>类型运算符 PTR<br>BYTE WORD DWORD FWORD NEAR FAR<ul><li><code>MOV BYTE PTR DS:[2000],2</code></li><li><code>BUF DB 1,2</code>、<code>MOV AX WORD PTR BUF</code>，结果是 0201H。<br>因为 BUF 在内存中从上到下是 01H 02H，取字后就是 0201H</li></ul></li></ul><ul><li>跨段前缀<br>段寄存器名：地址表达式<pre><code>段名：地址表达式</code></pre></li><li>属性分离算符<br>段属性、偏移地址、类型的分离`<ul><li><code>SEG 变量或标号</code>，如 <code>MOV AX, SEG BUF</code></li><li><code>OFFSET 变量或标号</code>，如 <code>MOV AX, OFFSET BUF</code></li><li><code>TYPE 变量或标号</code>，如 <code>MOV AX, TYPE BUF</code></li></ul></li></ul><h3 id="常用机器指令语句"><a href="#常用机器指令语句" class="headerlink" title="常用机器指令语句"></a>常用机器指令语句</h3><p>指令的共同要求：</p><ul><li>双操作数的操作数类型必须匹配</li><li>目的操作数一定不能是立即操作数</li><li>目的操作数和源操作数不能同时为存储器操作数。<br>如果一个操作数在数据存储单元中 ，另一个一定要是立即数或寄存器操作数</li></ul><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><p>一般传送指令：</p><ul><li><p>MOV 指令</p><ul><li><p><code>MOV OPD, OPS</code></p></li><li><p><strong>立即数不能送段寄存器；</strong></p></li><li><p><strong>不能用 MOV 指令改变 CS；</strong></p><p><img src="1569416356167.png" alt="1569416356167"></p></li></ul></li><li><p>有符号数传送指令</p><ul><li><code>MOVSX OPD, OPS</code>，”S” 指 Signed （386指令）</li><li>功能：将源操作数的<strong>符号向前拓展</strong>（符号位是 1 拓展全为 1，符号位是 0 拓展全为 0）成与目的操作数相同的数据类型</li><li>OPS 不能为立即数</li><li>OPD 必须为 16/32 位寄存器</li></ul></li></ul><ul><li>无符号数传送指令<ul><li><code>MOVZX OPD, OPS</code>，”Z” 指 Zero （386指令）</li><li>功能：将源操作数的符号<strong>高位补零</strong>成与目的操作数相同的数据类型</li><li>OPS 不能为立即数</li><li>OPD 必须为 16/32 位寄存器</li></ul></li></ul><p>一般数据交换指令：</p><ul><li><p>XCHG 指令</p><ul><li><code>XCHG OPD, OPS</code>，将源、目的地址指明的单元中内容互换</li><li>不能使用段寄存器 <del><code>XCHG DS, AX</code></del></li></ul></li><li><p>查表转换指令</p><ul><li><p><code>XLAT</code>。([BX+AL]) → AL，或 ([EBX+AL]) → AL</p></li><li><p>功能：将 (BX) 或 (EBX) 为首址，(AL) 为偏移量的字节存储单元中的数据传送给 AL<br>XLAT 可用来对文本数据进行编码和译码，从而实现简单的加密和解密。</p></li><li><p>用 BX 还是 EBX 取决于 16 位段还是 32 位段</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">; 设有一个 16 进制数码（ 0 ～ 9 ， A~F) 在(AL) 中，现请将该数码转换为对应的 ASCII </span><br><span class="line">; 简单的方法是分类讨论 (AL) 是否小于等于9</span><br><span class="line">; 现在用查表实现</span><br><span class="line"></span><br><span class="line">MYTAB DB &apos;0123456789ABCDEF&apos; </span><br><span class="line"></span><br><span class="line">MOV  BX, OFFSET MYTAB</span><br><span class="line">XLAT</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>地址传送指令：</p><ul><li><p>传送偏移地址指令</p><ul><li><code>LEA OPD, OPS</code>，Load effective address</li><li>功能：计算 OPS 的偏址，并将其送入 OPD 中</li><li><strong>OPD 一定是一个 16/32 位的通用寄存器；</strong></li><li><strong>OPS 所提供的一定是一个存储器地址；</strong></li><li>如果偏址是 32 位，而 OPD 为 16 位，则取低 16 位<br>如果偏址是 16 位，而 OPD 为 32 位，则高 16 位补 0</li><li><code>MOV SI, OFFSET NUM</code> 与 <code>LEA SI, NUM</code> 等效</li><li>没有与 <code>LEA DI, [SI+4]</code> 等效的 MOV 语句</li><li>没有与 <code>MOV POIN, OFFSET BUF</code> 等效的 LEA 语句</li></ul></li><li><p>传送偏址和数据段首址指令</p><ul><li><code>LDS OPD, OPS</code>，Load data segment</li><li>功能：(OPS) → OPD，(OPS+2或4) → DS</li><li><strong>OPD 一定是一个 16/32 位的通用寄存器；</strong></li><li><strong>OPS 所提供的一定是一个存储器地址，类型为 DWORD/FWORD；</strong></li></ul></li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">DATA1 SEGMENT USE16 </span><br><span class="line">T1    DW -50H</span><br><span class="line">T2    DD F</span><br><span class="line">T3    DB &apos;1234567&apos;</span><br><span class="line">DATA1  ENDS</span><br><span class="line"></span><br><span class="line">DATA2 SEGMENT USE16</span><br><span class="line">BUF   DB &apos;ABCDEF&apos;</span><br><span class="line">F     DW 70H</span><br><span class="line">DATA2 ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT USE16</span><br><span class="line">     ASSUME CS:CODE, DS:DATA1</span><br><span class="line"></span><br><span class="line">START: </span><br><span class="line">    MOV AX, DATA1</span><br><span class="line">    MOV DS, AX</span><br><span class="line">    MOV SI, 6</span><br><span class="line">    MOV AX, [SI]      ; (AX)=3231H</span><br><span class="line">    </span><br><span class="line">    MOV AX, T1        ; (AX)=0FFB0H</span><br><span class="line">    LDS SI, T2</span><br><span class="line">    MOV AX, [SI]      ; (AX)=0070H</span><br><span class="line">    </span><br><span class="line">    MOV AX, T1        ; (AX)=4241H, 因为此时段首址变成了DATA2</span><br><span class="line">    </span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">END START</span><br></pre></td></tr></table></figure><h4 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h4><p>一般对标志位都有影响</p><p>加法指令：</p><ul><li><p>加 1 指令</p><ul><li><code>INC OPD</code></li></ul></li><li><p>加指令</p></li><li><p><code>ADD OPD, OPS</code></p></li><li><p>带进位加指令</p><ul><li><p><code>ADC OPD, OPS</code></p></li><li><p>计算 1234 F00FH +1234 80F0H，只允许使用 16 位寄存器</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">data segment use16</span><br><span class="line">dn1  dw 0f00fh, 1234h</span><br><span class="line">dn2  dw 80f0h, 1234h</span><br><span class="line">dsum dw 0, 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">     assume cs:code, ds:data</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    mov ax, data</span><br><span class="line">    mov ds, ax</span><br><span class="line">    mov ax, dn1</span><br><span class="line">    add ax, dn2</span><br><span class="line">    mov dsum, ax    ; 不影响标志位</span><br><span class="line">    mov ax, dn1+2   ; 不影响标志位</span><br><span class="line">    adc ax, dn2+2   ; 标志位中低位的影响加到当前加法</span><br><span class="line">    mov dsum+2, ax</span><br><span class="line">    mov ah, 4ch</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>减法指令：</p><ul><li><p><code>DEC</code> 对 OF、SF、ZF、PF、AF 有影响，其他指令对 CF、OF、SF、ZF、PF、AF 有影响</p></li><li><p>减 1 指令</p><ul><li><code>DEC OPD</code></li></ul></li><li><p>求补指令</p><ul><li><code>NEG OPD</code></li><li>功能：求反加一</li></ul></li><li><p>减指令</p><ul><li><code>SUB OPD, OPS</code></li></ul></li><li><p>带借位减指令</p><ul><li><code>SBB OPD, OPS</code></li></ul></li><li><p>比较指令</p><ul><li><code>CMP OPD, OPS</code></li><li>(OPD) - (OPS) 的标志位</li></ul></li></ul><p>乘法指令：</p><ul><li><p>有符号乘法 - 双操作数有符号乘</p><ul><li><code>IMUL OPD, OPS</code></li><li>功能：(OPD) * (OPS) → OPD，OPD 为 16/32 位寄存器，OPS 为同类型寄存器、存储器操作数或立即数</li><li>例：<br><code>IMUL AX, BX</code><br><code>IMUL EAX, DWORD PTR[SI]</code><br><code>IMUL AX, 3</code></li></ul></li><li><p>有符号乘法 - 三操作数有符号乘</p><ul><li><code>IMUL OPD, OPS, n</code></li><li>功能：(OPS) * n → OPD</li></ul></li><li><p>有符号乘法 - 单操作数有符号乘</p><ul><li><code>IMUL OPS</code></li><li>看 OPS 类型选：<br>字节乘法：(AL) * (OPS) → AX<pre><code>字乘法：(AX) * (OPS) → DX, AX（为什么不是 EAX ？）</code></pre>双字乘法：(EAX) * (OPS) → EDX, EAX</li><li>OPS 不能是立即数<br>若乘积的高位 不是 低位的符号拓展，而是包含有效位（溢出），则 CF=1, OF=1</li></ul></li><li><p>无符号乘法</p><ul><li><code>MUL OPS</code></li><li>看 OPS 类型选：字节乘法、字乘法、双字乘法</li></ul></li></ul><p>除法指令：</p><ul><li><p>有符号除法</p><ul><li><code>IDIV OPS</code></li><li>看 OPS 类型选：<br>字节除法：(AX) / (OPS) → AH(余), AL(商)<pre><code>字除法：(DX, AX) / (OPS) → DX(余), AX(商)</code></pre>双字除法：(EDX, EAX) / (OPS) → EDX(余), EAX(商)</li></ul></li><li><p>无符号除法</p><ul><li><code>DIV OPS</code></li><li>同理，看 OPS 类型</li></ul></li></ul><p>符号拓展指令：</p><ul><li><p>将字节转换成字</p><ul><li><code>CBW</code></li><li>功能：将 AL 中的符号拓展到 AH 中</li></ul></li><li><p>将字节转换成字</p><ul><li><code>CWD</code></li><li>功能：将 AX 中的符号拓展到 DX 中</li></ul></li><li><p>将 AX 中的有符号数拓展为 32 位送 EAX</p><ul><li><code>CWDE</code></li></ul></li><li><p>将 EAX 中的有符号数拓展为 64 位送 EDX, EAX</p><ul><li><code>CDQ</code></li></ul></li></ul><h4 id="位操作指令"><a href="#位操作指令" class="headerlink" title="位操作指令"></a>位操作指令</h4><p>逻辑运算指令：</p><ul><li><p><code>NOT OPD</code>：(OPD) 求反 → OPD</p></li><li><p><code>AND OPD, OPS</code>：(OPD)&amp;(OPS) → OPD</p></li><li><p><code>OR OPD, OPS</code>：(OPD)|(OPS) → OPD</p></li><li><p><code>XOR OPD, OPS</code>：(OPD)^(OPS) → OPD</p></li><li><p>测试指令：<code>TEST OPD, OPS</code></p><ul><li>功能：依据 (OPD)^(OPS) 设置标志位，(OPD)、(OPS) 不变</li><li>CF=0, OF=0, ZF、SF、PF 依结果而定。AND、OR、XOR 亦是如此</li></ul></li></ul><p>移位指令：</p><ul><li>算术左移 SAL Shift Arithmetic Left<br>逻辑左移 SHL SHift Logical Left<br>逻辑右移 SHR SHift Logical Right<br>算术右移 SAR Shift Arithmetic Right<br>循环左移 ROL Rotate Left<br>循环右移 ROR Rotate Right<br>带进位的循环左移 RCL Rotate Left through Carry<ul><li>格式：<code>操作符 OPD, n 或 CL</code></li><li>功能：将 (OPD) 中的所有位按操作符规定的方式移动，结果存在 OPD 对应的单元中</li><li>特别说明：OPD 可是寄存器或地址表达式；在 8086 中 n 只能是 1，其他要用 CL</li></ul></li></ul><p><img src="1569588107378.png" alt="1569588107378"></p><h4 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h4><h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><p>第4章 分支程序设计中涉及</p><h4 id="处理机控制指令"><a href="#处理机控制指令" class="headerlink" title="处理机控制指令"></a>处理机控制指令</h4><h3 id="伪指令语句"><a href="#伪指令语句" class="headerlink" title="伪指令语句"></a>伪指令语句</h3><p>处理器选择伪指令：</p><ul><li>告诉汇编程序选择何种 CPU 所支持的指令系统</li></ul><table><thead><tr><th align="center">伪指令</th><th align="center">功能</th><th align="center">伪指令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">.8086</td><td align="center">接受8086指令（缺省方式）</td><td align="center">.586</td><td align="center">接受 Pentium 指令（除特权指令）</td></tr><tr><td align="center">.386</td><td align="center">接受80386指令（除特权指令）</td><td align="center">.586P</td><td align="center">接受全部 Pentium 指令</td></tr><tr><td align="center">.386P</td><td align="center">接受所有80386指令</td><td align="center">.686</td><td align="center">接受 Pentium Pro 指令（除特权指令）</td></tr><tr><td align="center">.486</td><td align="center">接受80486指令（除特权指令）</td><td align="center">.686P</td><td align="center">接受全部 Pentium Pro 指令</td></tr><tr><td align="center">.486P</td><td align="center">接受所有80486指令</td><td align="center">.MMX</td><td align="center">接受 MMX 指令</td></tr></tbody></table><ul><li><p><code>.386</code></p></li><li><p>MASM 不同版本支持的指令系统不同</p></li></ul><p>数据定义伪指令：</p><ul><li><p>格式：<code>[变量名] 数据定义伪指令 表达式 [, ...]</code></p></li><li><p>功能：定义一数据存储区，其类型由所使用的数据定位伪指令指定</p></li><li><p>表达式 5 种：数值表达式、字符串、地址表达式、?、重复字句</p></li><li><p>具体查看本章 “宏汇编语言表达式” 部分 -&gt; 变量相关</p></li></ul><p>符号定义伪指令：</p><ul><li>格式： <code>符号名 EQU 表达式</code></li><li>功能：为常量、表达式及其他符号定义一个等价的符号名</li><li>说明：符号名不可省。数据定义中变量名可省。变量占用存储单元，但符号名不占用存储单元。</li></ul><p>段定义伪指令：</p><ul><li><p>段定义伪指令：</p><ul><li>格式：<code>段名 SEGMENT [使用类型] [定位方式] [组合方式] [&#39;类别&#39;] ...... 段名 ENDS</code></li><li>“使用类型”：<code>USE16</code>，16 位段，段的最大长度为 64KB，地址的形式是 16 位段地址和 16 位偏移地址，寻址方式为 16 位寻址方式；<code>USE32</code>，.386 默认使用 32 位段。</li><li>使用了伪指令 <code>.386</code> （或以上），”使用类型” 才起作用</li></ul></li><li><p>假定伪指令：</p><ul><li>格式：<code>ASSUME 段寄存器名:段名 [, ...]</code></li><li>功能：用来设定段寄存器与段之间的对应关系</li><li>目标程序运行时才能给段寄存器置值</li><li>CS 和 SS 的内容将由操作系统自动设置</li><li><strong>DS 和 ES 的内容须由程序指令设置，且一定要做，这才能保证正确地产生数据存储单元的物理地址</strong></li><li>在程序启动时，DS 中的值是<br>程序段前缀 Program Segment Prefix （PSP）</li></ul></li><li><p>置汇编地址计数器伪指令</p><ul><li><p>汇编地址计数器：＄</p></li><li><p>汇编程序在翻译程序时，每遇到一个新段，就将汇编地址计数器置 0 。</p></li><li><p>在分配存储单元后（变量定义、机器指令），汇编地址计数器累加其分配的单元长度。</p></li><li><p>＄用来记录正在被汇编程序翻译的语句的地址。</p></li><li><p>标号和变量的偏移地址就是准备翻译该语句时当前汇编地址计数器＄的值。</p></li><li><p>汇编地址计数器符号＄可出现在表达式中。</p><p><img src="1569760391036.png" alt="1569760391036"></p></li><li><p><code>ORG 数值表达式</code></p></li><li><p>功能：将 $ 设置成数值表达式的值。数值表达式的值应为非负的整数，其值可在 0 ～ 65535 之间（16 位段）或 0 ～4G 之间（ 32 位段）</p><img src="1569760578294.png" alt="1569760578294" style="zoom:50%"></li></ul></li></ul><p>源程序结束伪指令：</p><ul><li><code>END [表达式]</code></li><li>功能：遇到该语句是，汇编工作停止</li><li>如果有表达式，指出第一条被执行指令的地址。</li><li>如果无表达式，则说明该程序不能单独运行，这时，它作为一个子模块供其他程序调用。</li><li>不可将 END 语句错误地安排在程序中间。</li></ul><h3 id="常用-DOS-系统功能调用"><a href="#常用-DOS-系统功能调用" class="headerlink" title="常用 DOS 系统功能调用"></a>常用 DOS 系统功能调用</h3><p>调用操作系统提供的功能：设备管理、文件管理、目录管理等</p><p>一般过程：</p><ul><li>调用号放入 AH 中</li><li>置好入口参数</li><li><code>INT 21H</code></li><li>调用结束，分析出口参数</li></ul><p>键盘输入 1 个字符 —— 1 号：</p><ul><li><code>MOV AH, 1</code><br><code>INT 21H</code></li><li>功能：<br>等待从键盘输入一个字符;<br>将输入字符的ASCII 码 → AL;<br>将该字符送显示器显示。</li></ul><p>显示输出 1 个字符 —— 2 号：</p><ul><li><code>MOV AH, 2</code><br><code>MOV DL, 带显示字符的 ASCII</code><br><code>INT 21H</code></li><li>功能：将 DL 中的字符送显示器显示</li></ul><p>显示输出字符串 —— 9 号：</p><ul><li><code>LEA DX, 字符串首偏移地址</code><br><code>MOV AH, 9</code><br><code>INT 21H</code></li><li>功能：从 DS：DX 所指向的单元开始，依次显示字符，直到遇到 ‘$‘ 为止。</li><li>若字符串本身包含 ‘$‘ 就用 2 号调用循环输出吧</li></ul><p>键盘输入字符串 —— 10 号：</p><ul><li><code>LEA DX, 缓冲区首偏移地址</code><br><code>MOV AH, 10</code><br><code>INT 21H</code></li><li>功能：从 DS：DX 所指的输入缓冲区输入字符串并送显示器显示</li></ul><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">STACK SEGMENT STACK</span><br><span class="line">      DB 200 DUP(0)</span><br><span class="line">STACK ENDS</span><br><span class="line"></span><br><span class="line">DATA SEGMENT</span><br><span class="line">BUF  DB 11        ; 表示至多 10 个字符</span><br><span class="line">     DB ?         ; 放实际输入字符个数</span><br><span class="line">     DB 11 DUP(0) ; 字符串最后一字符是 0DH</span><br><span class="line">DATA ENDS</span><br><span class="line"></span><br><span class="line">CODE SEGMENT</span><br><span class="line">     ASSUME CS:CODE, DS:DATA, SS:STACK</span><br><span class="line">     </span><br><span class="line">START:</span><br><span class="line">    MOV AX, DATA</span><br><span class="line">    MOV DS, AX</span><br><span class="line">    </span><br><span class="line">    LEA DX, BUF</span><br><span class="line">    MOV AH, 10</span><br><span class="line">    INT 21H</span><br><span class="line">    </span><br><span class="line">;    LEA DX, BUF</span><br><span class="line">;    MOV AH, 9</span><br><span class="line">;    INT 21H</span><br><span class="line">    </span><br><span class="line">    MOV AH, 4CH</span><br><span class="line">    INT 21H</span><br><span class="line">CODE ENDS</span><br><span class="line">    END START</span><br></pre></td></tr></table></figure><h2 id="第-4-章-程序设计方法"><a href="#第-4-章-程序设计方法" class="headerlink" title="第 4 章 程序设计方法"></a>第 4 章 程序设计方法</h2><h3 id="分支程序设计"><a href="#分支程序设计" class="headerlink" title="分支程序设计"></a>分支程序设计</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;if(x==y) statements1</span><br><span class="line">;else statements2</span><br><span class="line">    MOV AX, X</span><br><span class="line">    CMP AX, Y</span><br><span class="line">    JNE L1</span><br><span class="line">    statements1</span><br><span class="line">    JMP L2</span><br><span class="line">L1:</span><br><span class="line">    statements2</span><br><span class="line">L2:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>转移指令：</p><ul><li>条件转移<ul><li>简单条件转移 10 条</li><li>无符号数条件转移 4 条</li><li>有符号数条件转移 4 条</li></ul></li><li>无条件转移 JMP<ul><li>段内直接、段间直接</li><li>段内间接、段间间接</li></ul></li></ul><h4 id="条件转移"><a href="#条件转移" class="headerlink" title="条件转移"></a>条件转移</h4><p>简单条件转移：</p><table><thead><tr><th align="center">指令</th><th align="center">条件</th></tr></thead><tbody><tr><td align="center">JZ / JE</td><td align="center">ZF=1</td></tr><tr><td align="center">JNZ / JNE</td><td align="center">ZF=0</td></tr><tr><td align="center">JS</td><td align="center">SF=1</td></tr><tr><td align="center">JNS</td><td align="center">SF=0</td></tr><tr><td align="center">JO</td><td align="center">OF=1</td></tr><tr><td align="center">JNO</td><td align="center">OF=0</td></tr><tr><td align="center">JC</td><td align="center">CF=1</td></tr><tr><td align="center">JNC</td><td align="center">CF=0</td></tr><tr><td align="center">JP / JPE</td><td align="center">PF=1</td></tr><tr><td align="center">JNP / JPO</td><td align="center">PF=0</td></tr></tbody></table><p>无符号数条件转移指令：</p><table><thead><tr><th align="center">指令</th><th align="center">条件</th></tr></thead><tbody><tr><td align="center">JA / JNBE</td><td align="center">CF=0 且 ZF=0</td></tr><tr><td align="center">JAE / JNB</td><td align="center">CF=0 或 ZF=1</td></tr><tr><td align="center">JB / JNAE</td><td align="center">CF=1 且 ZF=0</td></tr><tr><td align="center">JBE / JNA</td><td align="center">CF=1 或 ZF=1</td></tr></tbody></table><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">	CMP	AX, BX</span><br><span class="line">	JA 	L1</span><br><span class="line">	...</span><br><span class="line">L1:</span><br><span class="line">	...</span><br><span class="line">; 将 (AX), (BX) 当成无符号数，执行(AX)-(BX)，若(AX)&gt;(BX)，则CF一定会为0，ZF=0，转移到L1处</span><br></pre></td></tr></table></figure><p>有符号数条件转移指令：</p><table><thead><tr><th align="center">指令</th><th align="center">条件</th></tr></thead><tbody><tr><td align="center">JG / JNLE</td><td align="center">SF=OF 且 ZF=0</td></tr><tr><td align="center">JGE / JNL</td><td align="center">SF=OF 或 ZF=1</td></tr><tr><td align="center">JL / JNGE</td><td align="center">SF != OF 且 ZF=0</td></tr><tr><td align="center">JLE / JNG</td><td align="center">SF != OF 或 ZF=1</td></tr></tbody></table><p>例子：根据输入的数字，显示对应的串。如 0 -&gt; ‘zero’, 1 -&gt; ‘first’, …，<strong>对于不同的输入，输出的串长度不同。</strong></p><p>程序的关键：如何根据输入，将对应的待显示的串首址送 DX</p><p>打表的写法：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">STR0 DB &apos;zero&apos;, &apos;$&apos;</span><br><span class="line">STR1 DB &apos;one&apos;, &apos;$&apos;</span><br><span class="line">...</span><br><span class="line">TAB DW STR0, STR1, STR2, ...</span><br><span class="line">; 使用如下</span><br><span class="line">MOV DX, TAB[BX]</span><br></pre></td></tr></table></figure><h4 id="无条件转移"><a href="#无条件转移" class="headerlink" title="无条件转移"></a>无条件转移</h4><table><thead><tr><th align="center">格式</th><th align="center">名称</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">JMP 标号</td><td align="center">段内直接</td><td align="center">(IP/EIP)+位移量 → IP/EIP</td></tr><tr><td align="center">JMP OPD</td><td align="center">段内间接</td><td align="center">(OPD) → IP/EIP</td></tr><tr><td align="center">JMP 标号</td><td align="center">段间直接</td><td align="center">标号的EA → IP/EIP<br>段首址 → CS</td></tr><tr><td align="center">JMP OPD</td><td align="center">段间间接</td><td align="center">(OPD) → IP/EIP<br>(OPD+2或4) → CS</td></tr></tbody></table><p>例子：根据不同输入，跳到不同程序段。1-&gt;LP1, 2-&gt;LP2, …</p><p>朴素的写法：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">... 判1</span><br><span class="line">JMP	LP1</span><br><span class="line">... 判2</span><br><span class="line">JMP LP2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>打表的写法：把指令地址列表构造好，直接 <code>JMP TAB[BX]</code>。（swtich-case 和 面向对象时大量采用）</p><p><strong>条件控制流伪指令</strong>，知道有就行了，本课不推荐使用。我们深入底层。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">data segment USE16</span><br><span class="line">x	 db	-5</span><br><span class="line">bufp db &apos;positive &gt; 0 $&apos;</span><br><span class="line">bufn db &apos; &lt; 0 $&apos;</span><br><span class="line">zero db &apos;zero $&apos;</span><br><span class="line">data ends</span><br><span class="line">code segment USE16</span><br><span class="line"> ...</span><br><span class="line">.if x==0</span><br><span class="line"> lea dx, zero</span><br><span class="line">.elseif x&gt;0</span><br><span class="line"> lea dx, bufp</span><br><span class="line">.else </span><br><span class="line"> lea dx, bufn</span><br><span class="line">.endif</span><br><span class="line"> mov ah, 9</span><br><span class="line"> int 21h</span><br><span class="line"> </span><br><span class="line">; 出错，理由如下</span><br><span class="line">X DB -5 ; 可能会当成无符号数</span><br><span class="line">X SBYTE -5 ; 定义位有符号数</span><br><span class="line">; 类似的还有 SWORD SDWORD</span><br></pre></td></tr></table></figure><h3 id="循环程序设计"><a href="#循环程序设计" class="headerlink" title="循环程序设计"></a>循环程序设计</h3><p>例：设以 BUF 为首址的一片单元中，存放了 N 个有符号字节数据，找出其中的最大数，存放到 AL中。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BUF DB 1,-10,20,-25, 25,50, …</span><br><span class="line">N = $ - BUF ; 如果是DW就再除2 </span><br><span class="line">; ...</span><br></pre></td></tr></table></figure><p>80x86 提供四种计数控制循环转移指令：</p><ul><li><p><code>LOOP 标号</code></p><ul><li>功能：(CX / ECX) - 1 → CX / ECX<br>若 (CX / ECX) 不为 0，则转标号处执行。</li><li>基本等价于 <code>DEC CX/ECX JNZ 标号</code>，因为 LOOP 指令对标志位无影响</li></ul></li><li><p><code>LOOPE / LOOPZ 标号</code></p><ul><li><p>功能：(CX / ECX) - 1 → CX / ECX<br>若 (CX / ECX) 不为 0，且 ZF=1，则转标号处执行。</p></li><li><p>等于 0 转移指令，本指令对标志位无影响</p></li><li><p>例子：判断以 BUF 为首址的 10 个字节中是否有非 0 字节。有，则置 ZF 为 0, 否则 ZF 置为 1 。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  MOV CX, 10</span><br><span class="line">  MOV BX, OFFSET BUF -1</span><br><span class="line">L3:  </span><br><span class="line">  INC BX</span><br><span class="line">  CMP BYTE PTR [BX], 0     LOOPE L3</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>LOOPNE / LOOPNZ 标号</code></p><ul><li>功能：(CX / ECX) - 1 → CX / ECX<br>若 (CX / ECX) != 0，且 ZF=0，则转标号处执行。</li><li>例子：判断以 BUF 为首址的 10 个字节中是否有空格字节。</li></ul></li><li><p><code>JCXZ / JECXZ 标号</code></p><ul><li>若 (CX/ECX) 为 0，则转移</li></ul></li></ul><h3 id="子程序设计"><a href="#子程序设计" class="headerlink" title="子程序设计"></a>子程序设计</h3><p>子程序格式：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">子程序名 PROC [类型]</span><br><span class="line">    过程体</span><br><span class="line">子程序名 ENDP</span><br><span class="line">; 类型：FAR 和 NEAR (缺省)</span><br><span class="line">; NEAR 为段内调用，即主子程序在同一个代码段内。FAR 类型为段间调用，被另外代码段调用的过程可定义为FAR</span><br></pre></td></tr></table></figure><h4 id="子程序的调用和返回（CALL-和-RET）"><a href="#子程序的调用和返回（CALL-和-RET）" class="headerlink" title="子程序的调用和返回（CALL 和 RET）"></a>子程序的调用和返回（CALL 和 RET）</h4><table><thead><tr><th align="center">名称</th><th align="center">JMP 格式</th><th>CALL 格式</th></tr></thead><tbody><tr><td align="center">段内直接</td><td align="center">JMP 标号</td><td>CALL 标号</td></tr><tr><td align="center">段间直接</td><td align="center">JMP 标号 (FAR)</td><td>CALL 标号 (FAR)</td></tr></tbody></table><ul><li><p>直接调用</p><ul><li>段内直接调用<ul><li>格式：<code>CALL 子程序名</code></li><li>功能：<br>(IP/EIP) -&gt; (SP/ESP)<br>目的地址 EA -&gt; IP/EIP</li></ul></li><li>段间直接调用<ul><li>格式：<code>CALL FAR PTR 子程序名</code></li><li>功能：<br>a.(CS)→↓(SP/ESP)<br>b.(IP/EIP)→↓(SP/ESP)<br>c.目的地址的段首址→ CS<br>d.目的地址的EA→IP/EIP</li></ul></li></ul></li><li><p>间接调用</p><ul><li>段内间接调用<ul><li>格式：<code>CALL WORD PTR OPD(16位段)</code><br><code>CALL DWORD PTR OPD(32位段)</code></li><li>功能：(IP/EIP)→↓(SP/ESP）<br>(OPD)→IP/EIP</li></ul></li><li>段间间接调用<ul><li>格式：<code>CALL DWORD PTR OPD(16位段)</code><br><code>CALL FWORD PTR OPD(32 位段)</code></li><li>功能：<br>a.(CS)→↓(SP/ESP)<br>b.(IP/EIP)→↓(SP/ESP)<br>c.(OPD)→IP/EIP<br>d.(OPD+2/4)→CS</li><li>注：OPD寻址方式与JMP类似<br>①段内间接调用可用除立即方式以外的其它寻址方式；<br>②段间间接调用可用除立即方式和寄存器寻址方式以外的其它寻址方式；<br>间接调用时，子程序的入口地址可由寻址方式得到。</li><li>应用：多个子程序入口地址组成地址表时，可用寻址方式确定转入子程序的入口地址。</li></ul></li></ul></li><li><p>返回指令 RET</p><ul><li>格式：<code>RET / RET n</code></li><li>功能：<br>a. 段内返回: ↑(SP)→IP/EIP<br>b. 段间返回: ↑(SP)→IP/EIP, ↑(SP)→CS</li></ul></li></ul><h4 id="子程序调用现场的保护方法"><a href="#子程序调用现场的保护方法" class="headerlink" title="子程序调用现场的保护方法"></a>子程序调用现场的保护方法</h4><p>调用现场的保护与恢复：</p><ul><li>保护现场：主要指调用子程序时，主程序中使用的寄存器的值不因子程序的调用而被破坏。</li><li>可在主程序做，也能在子程序做</li></ul><p>主程序与子程序的参数传递：</p><ul><li><p>参数传递 : 主程序为子程序提供入口参数，子程序返回结果给主程序</p></li><li><p>寄存器法: 将所需参数放在寄存器中带入子程序。适合于参数少的情况。</p><ul><li>优点：传递信息快，编程简单方便，节省存贮单元，但参数不能太多，要避免出错。</li><li>注意的问题：出口参数是子程序交给主程序的处理结果，没有必要将其列在需要保护的现场寄存器之中。而入口参数是否要保护，可依实际情况事先约定。</li></ul></li><li><p>堆栈法：堆栈法指将传递的参数放在堆栈中，进入子程序或返回主程序后，再将参数从堆栈中一一取出送入指定的寄存器。</p><ul><li>当参数个数较多时，一般用堆栈法传递参数，在使用堆栈时要特别注意栈顶的变化，要收回堆栈中传递参数的单元。</li></ul></li><li><p>约定单元法：将数据与运行好的结果放入事先规定好的存贮单元中。</p></li></ul><p>例子：子程序RADIX，将EAX中的32位无符号二进制数转换为(EBX)所指定进制的ASCII码送入(SI)所指定的偏移地址为首地址的存储区中</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">; 寄存器法</span><br><span class="line">.386</span><br><span class="line">RADIX PROC</span><br><span class="line">	PUSH CX</span><br><span class="line">	PUSH EDX</span><br><span class="line">	MOV CX, 0</span><br><span class="line">LOP1: </span><br><span class="line">	MOV EDX, 0</span><br><span class="line">	DIV EBX</span><br><span class="line">	PUSH DX</span><br><span class="line">	INC CX</span><br><span class="line">	OR EAX, EAX</span><br><span class="line">	JNE LOP1</span><br><span class="line">NEXT:</span><br><span class="line">	POP AX</span><br><span class="line">	CMP AX, 10</span><br><span class="line">	JB L2</span><br><span class="line">	ADD AL, 7</span><br><span class="line">L2: </span><br><span class="line">	ADD AL, 30H ；</span><br><span class="line">	MOV [SI], AL</span><br><span class="line">	INC SI</span><br><span class="line">	LOOP NEXT</span><br><span class="line">	POP EDX</span><br><span class="line">	POP CX</span><br><span class="line">	RET</span><br><span class="line">RADIX ENDP</span><br><span class="line"></span><br><span class="line">; 约定单元法</span><br><span class="line">RADIX PROC</span><br><span class="line">	PUSH CX</span><br><span class="line">	PUSH EDX</span><br><span class="line">    PUSH EBX</span><br><span class="line">    PUSH EAX</span><br><span class="line">    PUSH SI</span><br><span class="line">    MOVZX EBX，NUM</span><br><span class="line">	MOV EAX，NUM1</span><br><span class="line">	MOV SI ， NUM+2</span><br><span class="line">	MOV CX, 0</span><br><span class="line">L1:</span><br><span class="line">	MOV EDX, 0</span><br><span class="line">	DIV EBX</span><br><span class="line">	PUSH DX</span><br><span class="line">	INC CX</span><br><span class="line">	OR AX,AX</span><br><span class="line">	JNE L1</span><br><span class="line">NEXT:</span><br><span class="line">	POP AX</span><br><span class="line">	CMP AX, 10</span><br><span class="line">	JB L2</span><br><span class="line">	ADD AL, 7</span><br><span class="line">L2:</span><br><span class="line">	ADD AL, 30H</span><br><span class="line">    MOV [SI], AL</span><br><span class="line">    INC SI</span><br><span class="line">    LOOP NEXT</span><br><span class="line">    MOV NUM+4 ， SI</span><br><span class="line">    POP SI</span><br><span class="line">    POP EAX</span><br><span class="line">    POP EBX</span><br><span class="line">    POP EDX</span><br><span class="line">    POP CX</span><br><span class="line">    RET</span><br><span class="line">RADIX ENDP</span><br><span class="line"></span><br><span class="line">; 堆栈法</span><br><span class="line">RADIX PROC</span><br><span class="line">    PUSH CX</span><br><span class="line">    PUSH EDX</span><br><span class="line">    PUSH EAX</span><br><span class="line">    PUSH EBX</span><br><span class="line">    PUSH BP</span><br><span class="line">    MOV BP, SP</span><br><span class="line">    MOV SI, 18[BP]</span><br><span class="line">    MOV EAX,20[BP]</span><br><span class="line">    MOV EBX,24[BP]</span><br><span class="line">    MOV CX,0    ; -----(1)</span><br><span class="line">L1: </span><br><span class="line">    MOV EDX,0</span><br><span class="line">    DIV EBX</span><br><span class="line">    PUSH DX</span><br><span class="line">    INC CX</span><br><span class="line">    OR AX, AX</span><br><span class="line">    JNE L1</span><br><span class="line">NEXT:</span><br><span class="line">    POP AX      ; ---(2)</span><br><span class="line">    CMP AX,10</span><br><span class="line">    JB L2</span><br><span class="line">    ADD AL,7</span><br><span class="line">L2:</span><br><span class="line">    ADD AL, 30H</span><br><span class="line">    MOV [SI],AL</span><br><span class="line">    INC SI</span><br><span class="line">    LOOP NEXT</span><br><span class="line">    POP BP</span><br><span class="line">    POP EBX</span><br><span class="line">    POP EAX</span><br><span class="line">    POP EDX</span><br><span class="line">    POP CX</span><br><span class="line">	RET 10      ; ----(3) 把栈内10个字节的空间都释放</span><br><span class="line">RADIX ENDP</span><br></pre></td></tr></table></figure><h2 id="第-5-章-程序设计的其他方法和技术"><a href="#第-5-章-程序设计的其他方法和技术" class="headerlink" title="第 5 章 程序设计的其他方法和技术"></a>第 5 章 程序设计的其他方法和技术</h2><h3 id="宏指令的定义与调用"><a href="#宏指令的定义与调用" class="headerlink" title="宏指令的定义与调用"></a>宏指令的定义与调用</h3><h3 id="模块化程序设计方法及连接技术"><a href="#模块化程序设计方法及连接技术" class="headerlink" title="模块化程序设计方法及连接技术"></a>模块化程序设计方法及连接技术</h3></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://zhangt.top/CS/Assembly-Language-Study-Notes/">汇编语言-学习笔记</a></li><li><strong>本文作者：</strong><a href="https://zhangt.top">ZhangT</a></li><li><strong>本文链接：</strong><a href="https://zhangt.top/CS/Assembly-Language-Study-Notes/">https://zhangt.top/CS/Assembly-Language-Study-Notes/</a></li><li><strong>发布时间：</strong>2019-10-01</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><hr style="height:1px;margin:1rem 0"><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><i class="fas fa-tags has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/tags/Assembly/">Assembly</a>,&nbsp;<a class="has-link-grey -link" href="/tags/Language/">Language</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？投喂一下吧！ヾ(●´∀｀●)</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i> </span><span>支付宝</span><div class="qrcode"><img src="/images/alipay.jpg" alt="支付宝"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/CS/Information-Retrieval-Study-Notes/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">信息检索技术-学习笔记</span></a></div><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/CS/Operating-System-Study-Notes/"><span class="level-item">操作系统-学习笔记</span> <i class="level-item fas fa-chevron-right"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"91f36240e98756fc091e",clientSecret:"20de2f4dadd54bc04ad8db6c1090fb00a9477ac4",id:"b149ba71c24a257db559b23200de68ed",repo:"zhangt2333.github.io",owner:"zhangt2333",admin:"zhangt2333",createIssueManually:!1,distractionFreeMode:!1});gitalk.render("comment-container")</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered"><div><img class="image is-96x96 has-mb-6" src="/images/avatar.png" alt="Zhang T"><p class="is-size-4 is-block">Zhang T</p><p class="is-size-6 is-block">感受我的感受</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Qingdao, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><div class="level-item has-text-centered is-marginless"><a href="/archives/"><p class="heading">文章</p><p class="title has-text-weight-normal">17</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/categories/"><p class="heading">分类</p><p class="title has-text-weight-normal">4</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/tags/"><p class="heading">标签</p><p class="title has-text-weight-normal">19</p></a></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/zhangt2333" target="_blank"><i class="fab fa-github"></i>&nbsp;&nbsp;关注我</a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu" style="max-height:750px;overflow:auto"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#第-1-章-预备知识"><span class="has-mr-6">1</span> <span>第 1 章 预备知识</span></a><ul class="menu-list"><li><a class="is-flex" href="#什么是汇编"><span class="has-mr-6">1.1</span> <span>什么是汇编</span></a></li><li><a class="is-flex" href="#Intel-80X86-寄存器组"><span class="has-mr-6">1.2</span> <span>Intel 80X86 寄存器组</span></a><ul class="menu-list"><li><a class="is-flex" href="#数组寄存器组"><span class="has-mr-6">1.2.1</span> <span>数组寄存器组</span></a></li><li><a class="is-flex" href="#变址寄存器组"><span class="has-mr-6">1.2.2</span> <span>变址寄存器组</span></a></li><li><a class="is-flex" href="#指令预取部件和指令译码部件"><span class="has-mr-6">1.2.3</span> <span>指令预取部件和指令译码部件</span></a></li><li><a class="is-flex" href="#分段部件和分页部件"><span class="has-mr-6">1.2.4</span> <span>分段部件和分页部件</span></a></li><li><a class="is-flex" href="#80x86-微处理器结构"><span class="has-mr-6">1.2.5</span> <span>80x86 微处理器结构</span></a></li><li><a class="is-flex" href="#80x86-的三种工作方式"><span class="has-mr-6">1.2.6</span> <span>80x86 的三种工作方式</span></a></li></ul></li><li><a class="is-flex" href="#主存储器"><span class="has-mr-6">1.3</span> <span>主存储器</span></a><ul class="menu-list"><li><a class="is-flex" href="#堆栈"><span class="has-mr-6">1.3.1</span> <span>堆栈</span></a></li><li><a class="is-flex" href="#物理地址的形成"><span class="has-mr-6">1.3.2</span> <span>物理地址的形成</span></a></li></ul></li><li><a class="is-flex" href="#标识寄存器"><span class="has-mr-6">1.4</span> <span>标识寄存器</span></a><ul class="menu-list"><li><a class="is-flex" href="#标志位"><span class="has-mr-6">1.4.1</span> <span>标志位</span></a></li><li><a class="is-flex" href="#标志寄存器操作指令"><span class="has-mr-6">1.4.2</span> <span>标志寄存器操作指令</span></a></li></ul></li><li><a class="is-flex" href="#汇编源程序举例"><span class="has-mr-6">1.5</span> <span>汇编源程序举例</span></a></li></ul></li><li><a class="is-flex" href="#第-2-章-寻址方式"><span class="has-mr-6">2</span> <span>第 2 章 寻址方式</span></a><ul class="menu-list"><li><a class="is-flex" href="#寄存器寻址"><span class="has-mr-6">2.1</span> <span>寄存器寻址</span></a></li><li><a class="is-flex" href="#寄存器间接寻址"><span class="has-mr-6">2.2</span> <span>寄存器间接寻址</span></a></li><li><a class="is-flex" href="#变址寻址"><span class="has-mr-6">2.3</span> <span>变址寻址</span></a></li><li><a class="is-flex" href="#基址加变址寻址"><span class="has-mr-6">2.4</span> <span>基址加变址寻址</span></a></li><li><a class="is-flex" href="#立即寻址"><span class="has-mr-6">2.5</span> <span>立即寻址</span></a></li><li><a class="is-flex" href="#直接寻址"><span class="has-mr-6">2.6</span> <span>直接寻址</span></a></li><li><a class="is-flex" href="#有关问题"><span class="has-mr-6">2.7</span> <span>有关问题</span></a></li></ul></li><li><a class="is-flex" href="#第-3-章-宏汇编语言"><span class="has-mr-6">3</span> <span>第 3 章 宏汇编语言</span></a><ul class="menu-list"><li><a class="is-flex" href="#宏汇编语言表达式"><span class="has-mr-6">3.1</span> <span>宏汇编语言表达式</span></a></li><li><a class="is-flex" href="#常用机器指令语句"><span class="has-mr-6">3.2</span> <span>常用机器指令语句</span></a><ul class="menu-list"><li><a class="is-flex" href="#数据传送指令"><span class="has-mr-6">3.2.1</span> <span>数据传送指令</span></a></li><li><a class="is-flex" href="#算术运算指令"><span class="has-mr-6">3.2.2</span> <span>算术运算指令</span></a></li><li><a class="is-flex" href="#位操作指令"><span class="has-mr-6">3.2.3</span> <span>位操作指令</span></a></li><li><a class="is-flex" href="#串操作指令"><span class="has-mr-6">3.2.4</span> <span>串操作指令</span></a></li><li><a class="is-flex" href="#控制转移指令"><span class="has-mr-6">3.2.5</span> <span>控制转移指令</span></a></li><li><a class="is-flex" href="#处理机控制指令"><span class="has-mr-6">3.2.6</span> <span>处理机控制指令</span></a></li></ul></li><li><a class="is-flex" href="#伪指令语句"><span class="has-mr-6">3.3</span> <span>伪指令语句</span></a></li><li><a class="is-flex" href="#常用-DOS-系统功能调用"><span class="has-mr-6">3.4</span> <span>常用 DOS 系统功能调用</span></a></li></ul></li><li><a class="is-flex" href="#第-4-章-程序设计方法"><span class="has-mr-6">4</span> <span>第 4 章 程序设计方法</span></a><ul class="menu-list"><li><a class="is-flex" href="#分支程序设计"><span class="has-mr-6">4.1</span> <span>分支程序设计</span></a><ul class="menu-list"><li><a class="is-flex" href="#条件转移"><span class="has-mr-6">4.1.1</span> <span>条件转移</span></a></li><li><a class="is-flex" href="#无条件转移"><span class="has-mr-6">4.1.2</span> <span>无条件转移</span></a></li></ul></li><li><a class="is-flex" href="#循环程序设计"><span class="has-mr-6">4.2</span> <span>循环程序设计</span></a></li><li><a class="is-flex" href="#子程序设计"><span class="has-mr-6">4.3</span> <span>子程序设计</span></a><ul class="menu-list"><li><a class="is-flex" href="#子程序的调用和返回（CALL-和-RET）"><span class="has-mr-6">4.3.1</span> <span>子程序的调用和返回（CALL 和 RET）</span></a></li><li><a class="is-flex" href="#子程序调用现场的保护方法"><span class="has-mr-6">4.3.2</span> <span>子程序调用现场的保护方法</span></a></li></ul></li></ul></li><li><a class="is-flex" href="#第-5-章-程序设计的其他方法和技术"><span class="has-mr-6">5</span> <span>第 5 章 程序设计的其他方法和技术</span></a><ul class="menu-list"><li><a class="is-flex" href="#宏指令的定义与调用"><span class="has-mr-6">5.1</span> <span>宏指令的定义与调用</span></a></li><li><a class="is-flex" href="#模块化程序设计方法及连接技术"><span class="has-mr-6">5.2</span> <span>模块化程序设计方法及连接技术</span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/">TTTT&#39;s Blog</a><p class="is-size-7">&copy; 2021 ZhangT&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},skipTags:["script","noscript","style","textarea","pre","code"],processEscapes:!0,tex2jax:{inlineMath:[["$","$"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>