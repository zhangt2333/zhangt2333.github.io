<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>程序设计语言的形式语义-学习笔记 - Zhang T&#39;s Blog</title><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-212316117-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-212316117-1")</script><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/">TTTT&#39;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i> </a><a class="navbar-item" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-content article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>程序设计语言的形式语义-学习笔记</h1><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2021-09-30T17:00:00.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2021-10-01</time> <time class="level-item has-text-grey is-hidden-mobile" datetime="2021-12-29T02:00:00.000Z"><i class="far fa-calendar-check">&nbsp;</i>2021-12-29</time><div class="level-item"><i class="far fa-folder-open has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/categories/CS/">CS</a></div><span class="level-item has-text-grey"><i class="far fa-clock"></i>&nbsp; 2 小时 读完 (大约 20659 个字) </span><span class="level-item has-text-grey" id="busuanzi_container_page_pv"><i class="far fa-eye"></i> <span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p>程序设计语言的形式语义，学习笔记</p><a id="more"></a><h1 id="程序设计语言的形式语义"><a href="#程序设计语言的形式语义" class="headerlink" title="程序设计语言的形式语义"></a>程序设计语言的形式语义</h1><blockquote><p>Formal Semantics of Programming Languages</p><p><a href="https://cs.nju.edu.cn/hongjin/teaching/semantics/" target="_blank" rel="noopener">https://cs.nju.edu.cn/hongjin/teaching/semantics/</a></p></blockquote><h2 id="Introdution"><a href="#Introdution" class="headerlink" title="Introdution"></a>Introdution</h2><p>Formal Semantics:</p><ul><li>To assign <em>mathematica</em> meanings to language contructs &amp; programs</li><li>A <em>scientific</em> way to study PL and programming<ul><li>“<em>developing general abstractions</em>”</li><li>“<em>considers software behavior in a rigorous and general way</em>”<ul><li>More than testing</li></ul></li></ul></li></ul><h2 id="Mathematical-backgroud"><a href="#Mathematical-backgroud" class="headerlink" title="Mathematical backgroud"></a>Mathematical backgroud</h2><h3 id="Sets-★"><a href="#Sets-★" class="headerlink" title="Sets ★"></a>Sets ★</h3><p>基本概念 Basic Notations:</p><ul><li>$x \in S$，membership</li><li>$S \subseteq T$，subset</li><li>$S \subset T$，proper subset 真子集</li><li>$S \subseteq^{\text{fin}} T$，finite subset</li><li>$S=T$，equivalence</li><li>$\emptyset$，the empty set</li><li>$\mathrm{N}$，natural numbers</li><li>$\mathrm{Z}$，intergers</li><li>$\mathrm{B}$，$ { true, false } $</li><li>$S\cap T \overset{def}{=} { x \mid x \in S \text { and } x \in T } $，intersection</li><li>$S \cup T \overset{def}{=} { x \mid x \in S \text { or } x \in T } $， union</li><li>$S-T \overset{def}{=} { x \mid x \in S \text { and } x \notin T } $，difference</li><li>$\mathcal{P}(S) \overset{def}{=} { T \mid T \subseteq S } $，powerset</li><li>$ [m, n] \overset{def}{=} { x \mid m \leq x \leq n } $，integer range</li></ul><p>广义并集 generalized unions:</p><ul><li>$\bigcup \mathcal{S}\stackrel{\text { def }}{=} { x \mid \exists T \in \mathcal{S} . x \in T } $<ul><li>Here $S$ is a set of sets</li><li>带量词的逻辑判断：$\exists T. T \in S \wedge x \in T$</li><li>$\Rightarrow \bigcup \empty = \empty$</li></ul></li><li>$\bigcup\limits_{i \in I} S(i) \stackrel{\text { def }}{=} \bigcup { S(i) \mid i \in I } $<br>$\bigcup\limits_{i=m}^{n} S(i) \stackrel{\text { def }}{=} \bigcup\limits_{i \in[m, n]} S(i)$<ul><li>$S(i)$ 是一个依赖 i 来定义的集合，比如 $S(i)= { x \mid x&gt;i+3 } $</li></ul></li><li>例子：证明 $A\cup B=\bigcup { A,B } $</li><li>例子：$S(i)=[i,i+1], I= { j^2 \mid j \in [1,3] } $ 得 $\bigcup\limits_{i\in I} S(i)= { 1,2,4,5,9,10 } $</li></ul><p>广义交集 generalized intersections:</p><ul><li>$\bigcap \mathcal{S} \stackrel{\text { def }}{=} { x \mid \forall T \in \mathcal{S} . x \in T } $<ul><li>Here $S$ is a set of sets</li><li>带量词的逻辑判断：$\forall T. T \in S \Rightarrow x \in T$</li><li>代入 $S=\empty \Rightarrow { x \mid \forall T.T\in S \Rightarrow x\in T } $ 其中 $T\in S$ 为假，则推论 $x\in T$ 永远为真<br>$\Rightarrow \bigcup \empty = \text{meaningless}$<ul><li>这是罗素悖论 Russell’s paradox<ul><li>定义 $A: \text{set of everything}$</li><li>构造集合 $B= { x \mid x \in A \and x \not\in x } $</li><li>由于 A 的定义得 $B\in A$，现在问 $B\in B$ ？</li><li>如果 $B\in B$，由 B 的定义得知 $B\notin B$<br>如果 $B\notin B$，由 B 的定义得知 $B\in B$</li></ul></li></ul></li></ul></li><li>$\bigcap\limits_{i \in I} S(i) \stackrel{\text { def }}{=} \bigcap { S(i) \mid i \in I } $<br>$\bigcap\limits_{i=m}^{n} S(i) \stackrel{\text { def }}{=} \bigcap\limits_{i \in[m, n]} S(i)$</li></ul><h3 id="Relations"><a href="#Relations" class="headerlink" title="Relations"></a>Relations</h3><p>笛卡尔积 Cartesian product：</p><ul><li>$A\times B = { (x,y) \mid x\in A\ and\ y \in B } $<ul><li>(x, y) 是 pair</li><li>projections over pairs: $\pi_0(x,y)=x$、$\pi_1(x,y)=y$</li></ul></li><li>如果 $\rho \subseteq A\times B$ or $\rho \in \mathcal{P}(A\times B)$，$\rho$ 是一个 A to B 的关系<ul><li>特殊地，$\rho \subseteq S\times S$，则说 $\rho$ 是 S 上的关系</li></ul></li><li>$(x,y)\in \rho$，即 $\rho $ 关联 x 和 y，也写作 $x\ \rho\ y$</li><li>自反关系；$\forall(x,y)\in\rho.x=y$</li></ul><p>基本概念 Basic Notations：</p><ul><li>$\text{Id}_{S} \stackrel{\text { def }}{=} { (x, x) \mid x \in S } $，the identity on S</li><li>$\text{dom}(\rho) \stackrel{\text { def }}{=} { x \mid \exists y .(x, y) \in \rho } $，the domain of $\rho$</li><li>$\text{ran}(\rho) \stackrel{\text { def }}{=} { y \mid \exists x .(x, y) \in \rho } $，the range of $\rho$</li><li>$\rho^{\prime} \circ \rho \stackrel{\text { def }}{=} { (x, z) \mid \exists y.(x, y) \in \rho \and (y, z) \in \rho^{\prime} } $，composition of $\rho$ and $\rho^{\prime}$</li><li>$\rho^{-1} \stackrel{\text { def }}{=} { (y, x) \mid(x, y) \in \rho } $，inverse of $\rho$</li></ul><p>性质和例子：<br>$$<br>\begin{equation}<br>\begin{gathered}<br>\left(\rho_{3} \circ \rho_{2}\right) \circ \rho_{1}=\rho_{3} \circ\left(\rho_{2} \circ \rho_{1}\right) \<br>\rho \circ \mathrm{ld}<em>{S}=\rho=\operatorname{ld}</em>{T} \circ \rho, \text { if } \rho \subseteq S \times T \<br>\operatorname{dom}\left(\mathrm{Id}<em>{S}\right)=S=\operatorname{ran}\left(\mathrm{Id}</em>{S}\right) \<br>\mathrm{Id}<em>{T} \circ \mathrm{ld}</em>{S}=\operatorname{ld}<em>{T \cap S} \<br>\mathrm{ld}</em>{S}{ }^{-1}=\mathrm{Id}<em>{S} \<br>\left(\rho^{-1}\right)^{-1}=\rho \<br>\left(\rho</em>{2} \circ \rho_{1}\right)^{-1}=\rho_{1}{ }^{-1} \circ \rho_{2}{ }^{-1} \<br>\rho \circ \emptyset=\emptyset=\emptyset \circ \rho \<br>\mid \mathrm{d}<em>{\emptyset}=\emptyset=\emptyset^{-1} \<br>\operatorname{dom}(\rho)=\emptyset \Longleftrightarrow \rho=\emptyset \ \<br>&lt;\subseteq \leq \<br>&lt;\cup Id</em>{\mathrm{N}}=\leq \<br>\leq \cap \geq =\mathrm{Id}_{\mathrm{N}} \<br>&lt;\cap \geq =\emptyset \<br>&lt;\circ \leq =&lt;\<br>\leq 0 \leq =\leq \<br>\geq =\leq^{-1}<br>\end{gathered}<br>\end{equation}<br>$$<br>等价关系 Equivalence Relations：</p><ul><li>自反 Reflexivity: $Id_S \subseteq \rho$</li><li>对称 Symmetry: $\rho^{-1}=\rho$</li><li>传递 Transitivity: $\rho \circ \rho \subseteq \rho$</li></ul><h3 id="Functions-★"><a href="#Functions-★" class="headerlink" title="Functions ★"></a>Functions ★</h3><p>定义：</p><ul><li><p>函数是一种特殊的关系，满足 $\forall x, y,y’.(x,y)\in\rho \and (x,y’)\in\rho \quad\Rightarrow\quad y=y’ $</p></li><li><p>Function application $f(x)$ 可写为 $f\ x$</p></li><li><p>$\empty $ 和 $Id_S$ 也是函数</p></li><li><p>如果 $f,g$ 是函数，$g \circ f$ 也是函数：$(g\circ f)\ x = g(f\ x)$，$f^{-1}$ 不一定是函数除非 $f$ 是单射</p></li><li><p>单射 injection、满射 surjection、双射 bijection</p><img src="image-20210922155408481.png" style="zoom:50%"></li></ul><p>Denoted by Typed Lambda Expressions，通过带类型的 Lambda 表达式来表示函数：</p><ul><li>$\lambda x\in S.E$：表示函数 f 在定义域 S 上的元素有 $f(x)=E$</li><li>例子：$\lambda x\in \mathrm{N}.x+3$ 表示 $ { (x, x+3) \mid x \in \mathbf{N} } $</li></ul><p>Variation：</p><ul><li>单点修改：$f { x \rightsquigarrow n } \stackrel{\text { def }}{=} \lambda z. \begin{cases}f z &amp; \text { if } z \neq x \ n &amp; \text { if } z=x\end{cases} $</li><li>此时的定义域和值域：$\begin{aligned}<br>&amp;\operatorname{dom}(f { x \rightsquigarrow n } )=\operatorname{dom}(f) \cup { x } \<br>&amp;\operatorname{ran}(f { x \rightsquigarrow n } )=\operatorname{ran}\left(f-\left { \left(x, n^{\prime}\right) \mid\left(x, n^{\prime}\right) \in f\right } \right) \cup { n }<br>\end{aligned}$</li><li>例子：$(\lambda x \in[0 . .2] .x+1) { 2 \rightsquigarrow 7 } = { (0,1),(1,2),(2,7) } \ (\lambda x \in[0 . .1] . x+1) { 2 \rightsquigarrow 7 } = { (0,1),(1,2),(2,7) } $</li></ul><p><strong>Function Type 函数类型：</strong></p><ul><li>$A\rightarrow B$：表示 A to B 上的所有 total function 的集合（没有特别说明都默认是 total function）<ul><li>$A \rightharpoonup B$：表示 A to B 上的所有 partial function 的集合</li></ul></li><li>$\rightarrow $ 是右相关：$A\rightarrow B\rightarrow C=A\rightarrow (B\rightarrow C)$</li><li>如果 $f \in A\rightarrow B\rightarrow C$、$a\in A \and b\in B$，有 $f\ a\ b = (f(a))b\in C$</li></ul><p>Functions with multiple arguments：</p><ul><li>$$<br>\begin{aligned}<br>&amp;f \in A_{1} \times A_{2} \times \cdots \times A_{n} \rightarrow A \<br>&amp;f=\lambda x \in A_{1} \times A_{2} \times \cdots \times A_{n} \cdot E \<br>&amp;f\left(a_{1}, a_{2}, \ldots, a_{n}\right)<br>\end{aligned}<br>$$</li><li>Currying it gives us a function<br>$$<br>\begin{aligned}<br>&amp;g \in A_{1} \rightarrow A_{2} \rightarrow \cdots \rightarrow A_{n} \rightarrow A \<br>&amp;g=\lambda x_{1} \in A_{1} . \lambda x_{2} \in A_{2} \ldots \lambda x_{n} \in A_{n} .E \<br>&amp;g a_{1} a_{2} \ldots a_{n}<br>\end{aligned}<br>$$</li></ul><h3 id="Products"><a href="#Products" class="headerlink" title="Products"></a>Products</h3><p>将笛卡尔积推广到 n sets：</p><ul><li>$S_{0} \times S_{1} \times \cdots \times S_{n-1}=\left { \left(x_{0}, \ldots, x_{n-1}\right) \mid \forall i \in[0, n-1] \cdot x_{i} \in S_{i}\right } $</li><li>此时 $\left(x_{0}, \ldots, x_{n-1}\right)$ 是一个 n-tuple，有 $\pi_i(x_0,…,x_{n-1})=x_i$</li></ul><p>将 Tuples 作为函数：</p><ul><li><p>我们可以将 (x, y) 视为一个函数：$\lambda i \in \mathbf{2} . \begin{cases}x &amp; \text { if } i=0 \ y &amp; \text { if } i=1\end{cases} ，\mathbf{2} = { 0,1 } $</p><ul><li>此时相当于 re-define $A \times B \stackrel{\text { def }}{=} { f \mid \operatorname{dom}(f)=2, \text { and } f\ 0 \in A \text { and } f\ 1 \in B } $</li></ul></li><li><p>相似地，$\lambda i \in \mathbf{n} . \begin{cases}x_{0} &amp; \text { if } i=0 \ \cdots &amp; \ldots \ x_{n-1} &amp; \text { if } i=n-1\end{cases} ，\mathbf{n}= { 0,1, \ldots, n-1 } $</p><ul><li>$S_{0} \times \cdots \times S_{n-1} \stackrel{\text { def }}{=}\left { f \mid \operatorname{dom}(f)=\mathbf{n}, \text { and } \forall i \in \mathbf{n} . f\ i \in S_{i}\right } $</li></ul></li></ul><p>广义乘：</p><ul><li><p>$\prod\limits_{i \in I} S(i) \stackrel{\text { def }}{=} { f \mid \operatorname{dom}(f)=I, \text { and } \forall i \in I . f\ i \in S(i) } $<br>$\prod\limits_{i=m}^{n} S(i) \stackrel{\text { def }}{=} \prod\limits_{i \in[m, n]} S(i) $</p></li><li><p>令 $\theta $ 是一个从 a set of indices 到 a set of sets 的函数，定义 $\sqcap\theta$，如下：<br>$$<br>\sqcap \theta \stackrel{\text { def }}{=} { f \mid \operatorname{dom}(f)=\operatorname{dom}(\theta), \text { and } \forall i \in \operatorname{dom}(\theta) . f i \in \theta i }<br>$$</p></li><li><p>例子：令 $\theta=\lambda i\in I.S(i)$，有 $\sqcap\theta =\prod\limits_{i\in I}S(i) $</p></li><li><p>例子：令 $\theta=\lambda i\in \mathbf{2.B}$，有 $\sqcap\theta = \begin{aligned} { &amp; { (0,true),(1,true) } , \ &amp; { (0,true),(1,false) } , \&amp; { (0,false),(1,true) } , \&amp; { (0,false),(1,false) } } \end{aligned} $，即 $\sqcap\theta = \mathbf{B}\times \mathbf{B} $ （此时 × 的定义是 $A \times B \stackrel{\text { def }}{=} { f \mid \operatorname{dom}(f)=2, \text { and } f\ 0 \in A \text { and } f\ 1 \in B } $ ）</p></li><li><p>例子：$\sqcap\empty= { \empty } $</p></li><li><p>例子：$\exists i\in dom(\theta).\theta\ i=\empty\quad \Rightarrow\quad \sqcap\theta=\empty $</p></li></ul><p>幂次 Exponentiation：</p><ul><li><p>由于 $\prod_\limits{x \in T} S(x)=\sqcap \lambda x \in T . S(x) $，若 $S$ 与 x 无关，则记：<br>$$<br>\begin{aligned}<br>S^{T} &amp;=\prod_{x \in T} S=\sqcap \lambda x \in T . S \<br>&amp;= { f \mid \operatorname{dom}(f)=T\ \text { and }\ \forall x \in T . f\ x \in S } \&amp;=(T \rightarrow S)<br>\end{aligned}<br>$$</p></li><li><p>例子：$\mathbf2^S = (S \rightarrow \mathbf2)$<br>此时 $\forall T.T\subseteq S$，可以定义 $f=\lambda x \in S . \begin{cases}1 &amp; \text { if } x \in T \ 0 &amp; \text { if } x \in S-T\end{cases}$，故有 $f\in(S \rightarrow \mathbf2) $</p></li></ul><h3 id="Sums-or-Disjoint-Unions"><a href="#Sums-or-Disjoint-Unions" class="headerlink" title="Sums (or Disjoint Unions)"></a>Sums (or Disjoint Unions)</h3><p>引入：</p><ul><li>let $A= { 1,2,3 } , B= { 2,3 } $，we index the elements according to which set they originated in, to define the disjoint union 不相交并集：</li></ul><p>$$<br>\begin{aligned}<br>A^{\prime} &amp;= { (0,1),(0,2),(0,3) } \<br>B^{\prime} &amp;= { (1,2),(1,3) } \<br>A+B &amp;=A^{\prime} \cup B^{\prime}<br>\end{aligned}<br>$$</p><p>概念：<br>$$<br>A+B \stackrel{\text { def }}{=} { (i, x) \mid i=0 \text { and } x \in A, \text { or } i=1 \text { and } x \in B } \<br>$$<br>投影操作：</p><ul><li>$\iota_{A+B}^{0} \in A \rightarrow A+B $</li><li>$\iota_{A+B}^{1} \in B \rightarrow A+B $</li></ul><p>推广到 n 个集合：<br>$$<br>S_{0}+S_{1}+\cdots+S_{n-1} \stackrel{\text { def }}{=}\left { (i, x) \mid i \in \mathbf{n} \text { and } x \in S_{i}\right }<br>$$</p><p>广义和：</p><ul><li><p>推广到无限集上：<br>$$<br>\begin{aligned}<br>&amp;\sum_{i \in I} S(i) \stackrel{\text { def }}{=} { (i, x) \mid i \in I \text { and } x \in S(i) } \<br>&amp;\sum_{i=m}^{n} S(i) \stackrel{\text { def }}{=} \sum_{i \in[m, n]} S(i) \<br>&amp; \sum_{i \in I} S(i)=\sum \lambda i \in I . S(i)<br>\end{aligned}<br>$$</p></li><li><p>令 $\theta $ 是一个从 a set of indices 到 a set of sets 的函数，定义 $\sum\theta$ 如下：</p></li></ul><p>$$<br>\Sigma \theta \stackrel{\text { def }}{=} { (i, x) \mid i \in \operatorname{dom}(\theta) \text { and } x \in \theta i }<br>$$</p><ul><li><p>例子：$\sum\limits_{i \in \mathbf{n}} S(i)=\Sigma \lambda i \in \mathbf{n} . S(i)= { (i, x) \mid i \in \mathbf{n}\ and\ x \in S(i) } $</p></li><li><p>例子：令 $\theta=\lambda i \in \mathbf{2}.\mathbf{B}$，<br>有 $\Sigma \theta= { (0, \text {true}),(0, \text {false}),(1, \text {true}),(1,\text {false}) } $，<br>即是说 $\Sigma \theta=2 \times \mathbf{B}$</p></li><li><p>例子：$\sum\empty=\empty$</p></li><li><p>例子：如果 $\forall i \in \operatorname{dom}(\theta) . \theta i=\emptyset$,，则有 $\Sigma \theta=\emptyset$</p></li><li><p>例子：令 $\theta=\lambda i \in 2.\begin{cases}\mathbf{B} &amp; \text { if } i=0 \ \emptyset &amp; \text { if } i=1\end{cases}$，有 $\sum \theta= { (0, true),(0, false) } $</p></li><li><p>若 $\sum\limits_{i \in I} S(i)=\sum \lambda i \in I . S(i)$ 中 S 独立于 i ，则 $\begin{aligned}<br>\sum_{x \in T} S &amp;=\Sigma \lambda x \in T . S \<br>&amp;= { (x, y) \mid x \in T \text { and } y \in S } \ &amp;=(T \times S)<br>\end{aligned}$</p></li></ul><h2 id="Coq-相关"><a href="#Coq-相关" class="headerlink" title="Coq 相关"></a>Coq 相关</h2><p>略</p><h2 id="Lambda-Calculus-λ-calculus"><a href="#Lambda-Calculus-λ-calculus" class="headerlink" title="Lambda Calculus (λ-calculus)"></a>Lambda Calculus (λ-calculus)</h2><p>概念：</p><ul><li>一种 PL</li><li>Model for computation</li></ul><p>为什么要学：</p><ul><li><p>foundations of functional programming (like Lisp, ML, Haskell)</p></li><li><p>used as a core language to study language theories</p><ul><li><p>type system</p></li><li><p>scope and binding</p></li><li><p>higher-order funcitons</p></li><li><p>denotational semantics</p></li><li><p>program equivalence</p></li><li><p>…</p></li><li><p>例子：</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123; x++; &#125;</span><br><span class="line">x = <span class="hljs-string">"abcd"</span>; <span class="hljs-comment">// bug (mistype)</span></span><br><span class="line">i++; <span class="hljs-comment">// bug (out scope)</span></span><br></pre></td></tr></table></figure><p>如何形式化定义和描述出上述 bug</p></li></ul></li></ul><p>Overview：</p><ul><li><p>Syntax 语法</p></li><li><p>Semantics 语义</p></li><li><p>其他（type system, model theory）</p></li></ul><h3 id="Syntax"><a href="#Syntax" class="headerlink" title="Syntax"></a>Syntax</h3><ul><li>λ terms or λ expressions：<pre><code>`(Terms) M, N    ::=    x  |  λx.M  |  M N`</code></pre><ul><li>使用 BNF 范式定义，回忆编译中表达式的定义：<code>(Exp) e ::= n | x | e+e | .....</code></li><li>Lambda abstraction (λx.M): 匿名函数<br><code>int f(int x) { return x;}</code> 可以写成 λx.x</li><li>Lambda application (M N):<br><code>(λx.x) 3 = 3</code></li><li>pure λ-calculus</li></ul></li><li>Add extra operations and data types</li></ul><p>惯例 conventions：</p><ul><li><p>Body of λ extends as far to the right as possible 右结合</p><ul><li>比如 <code>λx.M N</code> 表示 <code>λx. (M N)</code> 而不是 <del><code>(λx. M) N</code></del></li><li><code>λx. f x = λx. (f x)</code></li><li><code>λx. λf. f x = λx. (λf. f x)</code></li></ul></li><li><p>Function applications are left-associative 左相关</p><ul><li>比如 <code>M N P</code> 表示 <code>(M N) P</code> 而不是 <del><code>M (N P)</code></del></li><li><code>(λx. λy. x-y) 5 3 = ((λx. λy. x-y) 5) 3</code></li><li><code>(λf. λx. f x) (λx. x+1) 2 = ( (λf. λx. f x) (λx. x+1) ) 2</code></li></ul></li></ul><p>Higher-order functions：</p><ul><li><p>functions can be returned as return values</p><ul><li><code>λx. λy. x-y</code></li></ul></li><li><p>functions can be passed as arguments</p></li><li><p><code>(λf. λx. f x) (λx. x+1) 2</code></p></li><li><p>given function <code>f</code>, return function <code>f ○ f</code></p><ul><li><p><code>λf. λx. f (f x)</code></p></li><li><p>(λf. λx. f (f x)) (λy. y+1) 5</p><p>= (λx. (λy. y+1) ((λy. y+1) x)) 5</p><p>= (λx. (λy. y+1) (x+1)) 5</p><p>= (λx. (x+1)+1) 5</p><p>= 5+1+1 = 7</p></li></ul></li><li><p>柯里化方法 Curried functions</p><ul><li><code>λx. λy. x-y</code> 和 <code>int f(int x,int y){ return x-y; }</code> 不一样，λ abstraction 是一个单参数的函数，虽然计算上是一样的。而且它们可以相互转换</li><li>curry: <del><code>λ(x, y). x-y</code> (不合法)</del> 转为 <code>λx. λy. x-y</code></li><li>uncurry: curry 的逆过程</li></ul></li></ul><p>Free and bound variables：</p><ul><li><p><code>λx. x+y</code></p><ul><li><p>x: bound variable（可以随时 renamed，它就是一个 placeholder，改完之后两个表达式是 α-equivalence）</p></li><li><p>y: free variable（不能 rename）</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int y;</span><br><span class="line">...</span><br><span class="line">int add(int x) &#123; return x+y; &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>(λ<font color="blue">x</font>. <font color="blue">x</font>+y) (<font color="red">x</font>+1): x has both a <font color="red">free</font> and a <font color="blue">bound</font> occurrence</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x = 10;</span><br><span class="line">int add(int x) &#123; return x+y; &#125;</span><br><span class="line">add(x+1);</span><br></pre></td></tr></table></figure><p>Formal definitions about Free and bound variables：</p></li><li><p>回忆：<code>M, N ::= x | λx.M | M N</code></p></li><li><p><code>fv(M)</code>: the set of free variables in M</p><ul><li>$\text{fv}(x) \overset{def}{=} { x } $</li><li>$\text{fv}(\lambda x.\text{M}) \overset{def}{=} \text{fv}(\text{M})\ \backslash\ { x } $</li><li>$\text{fv}(\text{M}\ \text{N}) \overset{def}{=} \text{fv}(\text{M}) \cup\text{fv}(\text{N}) $</li></ul></li><li><p>例子：</p><ul><li><code>fv((λx. x) x) = {x}</code></li><li><code>fv((λx. x + y) x) = {x, y}</code></li></ul></li><li><p>bould variable 定义无意义</p></li><li><p><font color="red">α-equivalence</font>：``λx. M = λy. M[y/x]<code>，注意 y 是新符号，</code>M[y/x]` 表示把 M 中的 x 都换成 y</p></li></ul><h3 id="Semantics"><a href="#Semantics" class="headerlink" title="Semantics"></a>Semantics</h3><p>基本规则 —— β-reduction 贝塔规约：</p><ul><li><code>(λx. M) N</code> → <code>M[N/x]</code></li></ul><p>替换 Substitution：</p><ul><li><p><code>M[N/x]</code>：将 M 中的 x 都换成 N<br>（下面定义考试也会给，不用背）</p><ol><li><p>x[N/x] $\overset{def}{=}$ N</p></li><li><p>y[N/x] $\overset{def}{=}$ y</p></li><li><p>(M P)[N/x] $\overset{def}{=}$ (M[N/x]) (P[N/x])</p></li><li><p>(λx.M)[N/x] $\overset{def}{=}$ λx.M（只换自由变量）</p></li><li><p>(λy.M)[N/x] $\overset{def}{=}$ λy.(M[N/x]), if y ∉ fv(N)</p></li><li><p>(λy.M)[N/x] $\overset{def}{=}$​ λz.(M[z/y][N/x]), if y ∈ fv(N) and z fresh（下面将讨论命名捕获）</p></li></ol></li><li><p>避免命名捕获 avoid name capture</p><ul><li>name capture：<code>(λx. x-y)[x/y]</code>，如果替换则得到 <code>λx. x-x</code></li><li>避免方案：在 substitution 之前 rename bound variable</li></ul></li><li><p>例子：</p><pre><code>(λx. (λy. y z) (λw. w) z x) [y/z]</code></pre><p>= λx. (((λy. y z) (λw. w) z)[y/z] x[y/z])，用的是上面的定义<br>…<br>= λx. ( (λy. y z)[y/z] (λw. w)[y/z] z[y/z] x[y/z] )，用定义 3<br>= λx. ( (λu. (u z)[u/y][y/z]) (λw. w)[y/z] z[y/z] x[y/z] )，用定义 6<br>= …</p></li><li><p>例子：(λx. (λy. y y) z x)[(f x)/z]</p></li></ul><p>规约规则 Reduction rules：</p><ul><li><p>$$<br>\frac{}{(\lambda x.M)N \rightarrow M[N/x]} \quad (\beta) \\quad \</p><p>\frac{M \rightarrow M^{\prime}}{M N \rightarrow M^{\prime} N} \\quad \</p><p>\frac{N \rightarrow N^{\prime}}{M N \rightarrow M N^{\prime}} \\quad \</p><p>\frac{M \rightarrow M^{\prime}}{\lambda x . M \rightarrow \lambda x . M^{\prime}}<br>$$</p></li><li><p>“分子” 是前提，”分母” 是结论</p></li><li><p>→ 不是等号，是一种 relation，如 “M -&gt; M’” 表示 M 可规约一步到 M’<br><font color="red">subsitution 用等号，reduction 用箭头</font></p></li><li><p>例子：</p><pre><code>(λf. f x) (λy. y) </code></pre><p>→ (f x)[(λy. y)/f] // 用 β<br>= (λy. y) x // 用定义 3、1、2<br>→ y[x/y] // 用 β<br>= x</p></li><li><p>例子：</p><pre><code>(λy. λx. x - y) x </code></pre><p>→ (λx. x - y)[x/y]<br>= λz. ((x - y)[z/x][x/y])<br>= λz. ((z - y)[x/y])<br>= λz. z - x</p></li><li><p>例子：λx. (λy. y+1) x<br>有 (λy. y+1) x → (y+1)[x/y] = x+1<br>用 4th rule 得 λx. (λy. y+1) x → λx. x+1</p></li><li><p>例子：(λf. λz. f (f z)) (λy. y+x) // apply (β)<br>→ λz. (λy. y+x) ((λy. y+x) z) // apply (β) and the 3rd &amp;4th rules<br>→ λz. (λy. y+x) (z+x) // apply (β) and the 4th rule<br>→ λz. z+x+x</p></li></ul><p>Normal form：</p><ul><li>β-redes：一个形式为 <code>(λx. M) N</code> 的 term</li><li>β-normal form：一个不含 β-redex 的项<ul><li>stopping point：不能再用 β-reduction 规则</li></ul></li><li>例子：<br>(λf. λx. f (f x)) (λy. y+1) 2<br>→ ( λx. (λy. y+1) ((λy. y+1) x) ) 2<br>→ ( λx. (λy. y+1) (x+1) ) 2<br>→ ( λx. x+1+1 ) 2<br>→ 2+1+1</li></ul><p>Confluence 合流性（Church-Rosser Property）：</p><ul><li><p>无论用怎样的策略去 reduction，这个 term 最终达到同一个结果（如果有的话）</p></li><li><p>把合流性形式化表达（Formalizing Confluence Theorem）</p><ul><li><p>定义：$M \rightarrow^* M’$ 为 zero-or-more steps of → 使得 M 到 M’</p></li><li><p>归纳法定义 inductive definition 如下：</p><p>$\begin{aligned}&amp;M \rightarrow^0 M’ &amp; \text{iff}&amp; \quad M=M’ \&amp; M \rightarrow^{k+1} M’ &amp; \text{iff}&amp;\quad \exists M’’.M\rightarrow M’’ \and M’’ \rightarrow^k M’ \ &amp; M \rightarrow^*M’ &amp; \text{iff}&amp;\quad \exists k.M\rightarrow^k M’ \end{aligned}$</p></li><li><p>Confluence Theorem</p><ul><li>M → M1 → M’<pre><code>↘ M2 ↗</code></pre></li><li>若 $M\rightarrow^* M_1，M \rightarrow^* M_2$ ，则存在 M’，满足 $M_1\rightarrow^* M’，M_2 \rightarrow^* M’$</li></ul></li></ul></li><li><p>推论：</p><ul><li><p>由于 α-equivalence，每个 term 最多有一个 normal form</p></li><li><p>提问：如果一个 term 有多个 β-redex，哪个会被选择来规约</p><ul><li>good news：无论哪个被选，至多一个 normal form</li><li>bad news：一些规约策略可能无法找到 normal form<ul><li>Non-terminating reduction 例子<ul><li>(λx. x x) (λx. x x)<br>→ (λx. x x) (λx. x x)<br>→ …</li><li>(λx. x x y) (λx. x x y)<br>→ (λx. x x y) (λx. x x y) y<br>→ …</li><li>(λx. f (x x)) (λx. f (x x))<br>→ f ((λx. f (x x)) (λx. f (x x)))<br>→ …</li></ul></li><li>同时有 Non-terminating 和 terminating reduction 的例子<ul><li>例子：<br>(λu. λv. v) ((λx. x x)(λx. x x))<br>→ λv. v</li><li>例子：<br>(λu. λv. v) ((λx. x x)(λx. x x))<br>→ (λu. λv. v) ((λx. x x)(λx. x x))<br>→ …</li></ul></li></ul></li></ul><p>Reduction strategies：</p></li><li><p>Normal-order reduction：优先选 left-most、outer-most 的 redex</p><ul><li>left-most: whose lambda is left to any other<br>outer-most: not contained in any other<br>inner-most: not contain any other <img src="image-20210928150207115.png" style="zoom:50%"></li><li>在函数并没有用到 bound variable 时会使得 reduction 更快</li><li>例子：<br>(λx. x x) ((λy. y) (λz. z))<br>→ ((λy. y) (λz. z)) ((λy. y) (λz. z))<br>→ (λz. z) ((λy. y) (λz. z))<br>→ (λy. y) (λz. z)<br>→ λz. z</li></ul></li><li><p>Applicative-order reduction: 优先选 left-most、inner-most redex</p><ul><li>有时候会使得 reduction 次数变少（ 原理比如 (λx. M)(N) 优先将 N 化简，这样避免了代入 M 后还要多次化简）</li><li>例子：<br>(λx. x x) ((λy. y) (λz. z))<br>→ (λx. x x) (λz. z)<br>→ (λz. z) (λz. z)<br>→ λz. z</li></ul></li></ul></li></ul><p>Evaluation strategies：</p><ul><li><p>reduction vs. evaluation（将 reduction 类比编程语言里的求值策略 evaluation strategies）</p><ul><li>Call-by-name (类似 normal-order)，实参不急着求值，而是代入到函数体里<ul><li>ALGOL 60</li></ul></li><li>Call-by-need（缓存版的 call-by-name），也称 “lazy evaluation”<ul><li>Haskell，R，…</li></ul></li><li>Call-by-value（类似 applicative-order），也称 “eager evaluation”<ul><li>C，…</li></ul></li></ul></li><li><p>二者的细微区别 subtle difference</p><ul><li>Normal-order (or applicative-order) reduces under lambda<ul><li>允许函数体内的优化</li><li>并不是期望的</li><li>λx. ((λy. y y) (λy. y y))<br>→ λx. ((λy. y y) (λy. y y))<br>→ …</li></ul></li><li>Evaluation strategies：不会 reduces under lambda</li></ul></li><li><p>Evaluation 并不总是都能规约到 normal form</p><ul><li><p>会停在包含 canonical form（比如一个 lambda abstraction）时</p><p>$\begin{aligned}<br>&amp; (\lambda x . x(\lambda y . x y y) x)(\lambda z . \lambda w . z) \ &amp; \rightarrow(\lambda z . \lambda w . z)(\lambda y .(\lambda z . \lambda w . z) y y)(\lambda z . \lambda w . z) \<br>&amp; \rightarrow(\lambda w . \lambda y .(\lambda z . \lambda w . z) y y)(\lambda z . \lambda w . z) \<br>&amp; \rightarrow \lambda y .(\lambda z . \lambda w . z) y y \quad \quad （evaluation 会停在这）\<br>&amp; \rightarrow \lambda y .(\lambda w . y) y \<br>&amp; \rightarrow \lambda y . y<br>\end{aligned} $​</p></li></ul></li><li><p>Evaluation 只对 closed term 求值</p><ul><li>closed term：没有自由变量</li><li>closed normal term 一定是 canonical form，但并不是每一个 closed canonical form 都是 normal form</li></ul></li><li><p>如果 normal-order reduction 中止，在规约过程中一定包含一个 first cononical form</p></li><li><p>例子：<br>(λx. λy. x y) (λx. x)<br>→ λy. (λx. x) y （evaluation 中止在此）<br>→ λy. y</p></li><li><p>例子：<br>(λx. λy. x x) (λx. x x)<br>→ λy. (λx. x x) (λx. x x) （evaluation 中止在此）</p></li><li><p>例子：<br>(λx. x x) (λx. x x)<br>→ (λx. x x) (λx. x x)<br>→ … （reduction 和 evaluation 都不中止）</p></li><li><p>Normal-order evaluation rules：<br>$$<br>\frac{}{\lambda x . M \Rightarrow \lambda x . M} \quad (Term)<br>\\quad\<br>\frac{M \Rightarrow \lambda x . M^{\prime} \quad\quad M^{\prime}[N / x] \Rightarrow P}{M N \Rightarrow P}\quad (\beta)<br>$$</p><ul><li><p>例子：</p><img src="image-20210928173152452.png" style="zoom:50%"></li><li><p>small-step 版规则（注意下面是单箭头不是双箭头）：<br>$$<br>\frac{}{(\lambda x.M)N \rightarrow M[N/x]} \quad (\beta) \\quad \</p><p>\frac{M \rightarrow M^{\prime}}{M N \rightarrow M^{\prime} N} \\quad<br>$$<br>比起 reduction rules 少了两个规则，因为 normal-order 并不想优先对 N-&gt;N’ 和 M-&gt;M’ 做化简，只要 evaluation 到了 canonical form 就会停止</p></li></ul></li><li><p><font color="red">Eager evaluation</font> rules：</p><ul><li><p>Postpone 延迟 the substitution until the argument is a canonical form.<br>No need to reduce many copies of the argument separately.<br>$$<br>\frac{}{\lambda x.M \Rightarrow_{E} \lambda x.M} \quad\quad (Term) \\frac{M \Rightarrow_{E} \lambda x.M^{\prime} \quad\quad N \Rightarrow_{E} N^{\prime} \quad\quad M^{\prime}\left[N^{\prime} / x\right] \Rightarrow_{E} P}{M N \Rightarrow_{E} P} \quad\quad (\beta)<br>$$</p></li><li><p>例子：</p><pre><code>&lt;img src=&quot;image-20210928174113312.png&quot; style=&quot;zoom: 60%;&quot; /&gt;</code></pre></li><li><p>small-step 版规则（注意下面是单箭头不是双箭头）：<br>思想是，当 M 已经到达 Canonical form 后（用了第2个规则），现在还需要对 N 做 evaluation，当 N 已经有 Canonical form（用了第3个规则），之后就可以做 β 替换了。<br>$$<br>\frac{}{(\lambda x.M)(\lambda y.N) \rightarrow M[(\lambda y.N)/x]} \quad (\beta) \\quad \ \frac{M \rightarrow M^{\prime}}{M N \rightarrow M^{\prime} N} \\quad \ \frac{N \rightarrow N^{\prime}}{(\lambda x.M) N \rightarrow (\lambda x.M) N^{\prime}}<br>$$</p><h3 id="Programming-in-λ-calculus"><a href="#Programming-in-λ-calculus" class="headerlink" title="Programming in λ-calculus"></a>Programming in λ-calculus</h3></li></ul></li></ul><p>Boolean（encoding boolean values and operators）：</p><ul><li><code>True ≡ λx. λy. x</code></li><li><code>False ≡ λx. λy. y</code></li><li><code>not ≡ λb. b False True</code><ul><li>not True<br>= (λb. b False True) True<br>→ True False True<br>= (λx. λy. x) False True<br>→ (λy. False) True<br>→ False</li><li>not False<br>→ False False True<br>→ True</li></ul></li><li><code>and ≡ λb. λb’. b b’ False</code></li><li><code>or ≡ λb. λb’. b True b’</code></li><li><code>if b then M else N ≡ b M N</code></li><li><code>not’ ≡ λb. λx. λy. b y x</code></li></ul><p>Church Numerals（Church 是个人名）：</p><ul><li>$\underline{0}$ ≡ λf. λx. x</li><li>$\underline{1}$ ≡ λf. λx. f x</li><li>$\underline{2}$ ≡ λf. λx. f (f x)</li><li>$\underline{n}$ ≡ λf. λx. fn x</li><li><code>succ ≡ λn. λf. λx. f (n f x)</code><ul><li>succ $\underline{n}$<br>→ λf. λx. f (n f x)<br>= λf. λx. f ((λf. λx. $f^n$ x) f x)<br>→ λf. λx. f ($f^n$ x)<br>= λf. λx. $f^{n+1}$ x<br>= $\underline{n+1}$</li></ul></li><li><code>iszero ≡ λn. λx. λy. n (λz. y) x</code><ul><li>iszero 0<br>→ λx. λy. 0 (λz. y) x<br>= λx. λy. (λf. λx. x) (λz. y) x<br>→ λx. λy. (λx. x) x<br>→ λx. λy. x = True</li><li>iszero 1<br>→ λx. λy. 1 (λz. y) x<br>= λx. λy. (λf. λx. f x) (λz. y) x<br>→ λx. λy. (λx. (λz. y) x) x<br>→ λx. λy. ((λz. y) x)<br>→ λx. λy. y = False</li><li>iszero (succ n) →* False</li></ul></li><li><code>add ≡ λn. λm. λf. λx. n f (m f x)</code></li><li><code>mult ≡ λn. λm. λf. n (m f)</code></li></ul><p>Pairs：</p><ul><li>$(M, N) \equiv \lambda f . f\ \mathrm{M}\ N$</li></ul><ul><li>$\pi_{0} \equiv \lambda p \cdot p(\lambda x . \lambda y \cdot x)$</li><li>$\pi_{1} \equiv \lambda p \cdot p(\lambda x \cdot \lambda y \cdot y)$</li></ul><p>Tuples：</p><ul><li>$\left(M_{1}, \ldots, M_{n}\right) \equiv \lambda f_{.} f\left(M_{1} \ldots M_{n}\right.$</li><li>$\pi_{\mathrm{i}} \equiv \lambda \mathrm{p} . \mathrm{p}\left(\lambda \mathrm{x}<em>{1} …. \lambda \mathrm{x}</em>{\mathrm{n}}. \mathrm{x}_{\mathrm{i}}\right)$</li></ul><p>Recursive functions：</p><ul><li><p>我们要 encode <code>fact(n) = if (n==0) then 1 else n*fact(n-1)</code> 这个递归函数</p></li><li><p>先引入 fixpoint</p><ul><li><p>数学上的不动点 fixpoint in arithmetic：f(x)=x，此时 x 是 f 的不动点</p></li><li><p><code>fact</code> 是函数的不动点，证明：</p><ul><li><code>fact(n) = if (n == 0) then 1 else n * fact(n-1)</code></li><li><code>fact = λn. if (n == 0) then 1 else n * fact(n-1)</code></li><li><code>fact = (λf. λn. if (n == 0) then 1 else n * f(n-1)) fact</code></li><li>令 <code>F = λf. λn. if (n == 0) then 1 else n * f(n-1)</code>，<br>有 <code>fact = F fact</code>，类似 <code>x=f(x)</code> 符合上面数学不动点的公式，得证。</li></ul></li><li><p>在 λ-calculus 每个 term 都有一个不动点</p></li><li><p><font color="red">Fixpoint combinator</font>：一个高阶函数 h，使得对所有的 f，(h f) 是一个不动点，即 <code>h f = f (h f)</code></p><ul><li><p>Turing’s fixpoint combinator <code>Θ</code> ：令 <code>A = λx. λy. y (x x y)</code>，则 <code>Θ = A A</code></p><p>证明：对于所有的 f，<code>Θ f = f (Θ f)</code>（其中等号意味着 $\rightarrow^* \and \leftarrow ^* $，即左右可以相互 reduce 得到）<br>$\begin{aligned}\Theta f &amp;= A A f \ &amp;=(\lambda x.\lambda y. y( x x y)) A f \&amp;\rightarrow (\lambda y. y(AAy)) f \ &amp;\rightarrow f(AA f) \&amp;= f(\Theta f) \end{aligned}$</p></li><li><p>Church’s fixpoint combinator <strong>Y</strong>：<code>Y = λf. (λx. f (x x)) (λx. f (x x))</code></p></li></ul></li></ul></li><li><p>此时，对 fact 的 encode，可以令 <code>F = λf. λn. if (n == 0) then 1 else n * f(n-1)</code>，则 <code>fact = Θ F</code></p></li></ul><h2 id="Simply-Typed-Lambda-Calculus-STLC"><a href="#Simply-Typed-Lambda-Calculus-STLC" class="headerlink" title="Simply-Typed Lambda Calculus (STLC)"></a>Simply-Typed Lambda Calculus (STLC)</h2><p>review of untyped λ-calculus：</p><ul><li><code>(λx. x x) (λx. x x) → ...</code></li><li>所以这部分内容是给 λ-calculus 加类型系统</li></ul><p>为什么要类型：</p><ul><li>Type checking catched “simple” mistakes early</li><li>(Type safety) Well-typed programs will not go wrong</li><li>Typed programs are easier to analyze and optimize</li></ul><p>Outline：</p><ul><li>Typing rules 定型规则：assign types to terms</li><li>Type safety</li></ul><p>Judgment：</p><ul><li>statement：<code>J</code> 是关于某些形式化的性质</li><li>derivation（比如 a proof）：<code>⊢ J</code> 推导，比如 <code>⊢ M : τ</code> 是 informal 地表示 M 有类型 τ</li><li>meaning（”judgment semantics”）：<code>⊨ J</code> 定义 J 的含义</li></ul><p>为 λ-calculus 加类型：</p><ul><li><code>(Types) τ,σ ::= T | σ -&gt; τ</code></li><li><code>(Terms) M, N ::= x | λx : τ. M | M N</code></li></ul><p>Typin judgment：</p><ul><li><p><code>Γ ⊢ M : τ</code>，M 在上下文 Γ 中是类型 τ</p><ul><li>$\Gamma \in \mathcal{P}(Var \times Type)$，是一个集合</li></ul></li><li><p>Typring context (a set of typing assumptions)：<br><code>Γ ::= · | Γ, x:τ</code></p><ul><li><code>·</code>：Empty context，说明 M 是 closed terms（即没有自由变量）</li><li><code>Γ, x:τ</code> 是一个集合，表示 <code>Γ</code> 再加上所有 M 中自由变量的类型</li></ul></li></ul><p>Typing rules（a.k.a. Static Semantics）：<br>$$<br>\frac{}{\Gamma, x: \tau \vdash x: \tau} \quad(var)<br>\\quad\<br>\frac{\Gamma \vdash M: \sigma \rightarrow \tau \quad\quad\quad \Gamma \vdash N: \sigma}{\Gamma \vdash M N: \tau}\quad (app)<br>\\quad\<br>\frac{\Gamma, x: \sigma \vdash M: \tau}{\Gamma \vdash(\lambda x: \sigma . M): \sigma \rightarrow \tau}\quad (abs)<br>$$</p><ul><li>typing derivation 例子：<br><img src="image-20211002200239220.png" alt="image-20211002200239220"></li></ul><p>Soundness and completeness 可靠性和完备性：</p><ul><li><p>Soundness：A sound type system never accepts a program that can go wrong</p><ul><li><p>No false negatives 没有假阴性</p></li><li><p>well-type terms in STLC never go wrong</p><ul><li><p><font color="red">type safety theorem</font>：<br>If $\cdot \vdash M: \tau$ and $M \rightarrow^{*} M^{\prime}$<br>then $\cdot \vdash M^{\prime}: \tau$ and ($M^{\prime} \in \text{Values}$ or $\exists M^{\prime \prime} . M^{\prime} \rightarrow M^{\prime \prime}$)</p><ul><li><code>Values</code>：定义在语言语义中的，比如 λ-abstraction (<code>λx. M</code>)、constants (<code>c</code>)，即表示规约到一个具体的值了</li><li>即是说，well-typed term 要么不会终止规约，要么规约到一个期望类型的值</li></ul></li><li><p>type safety 的两个 key lemmas</p><ul><li><font color="red">preservation (subject reduction)</font>：<br>If $\cdot \vdash M: \tau$​ and $M \rightarrow M^{\prime}$​，<br>then $\cdot \vdash M^{\prime}: \tau$​</li><li><font color="red">progress</font>：<br>If $\cdot \vdash M: \tau$​​​，<br>then ($M \in \text{Values}$​​​ or $\exists M^{\prime} . M \rightarrow M^{\prime}$​​​​)</li><li>一个问题：当修改 type system 或 reduction rule 时，preservation 和 progress 是否还能成立</li></ul></li></ul></li></ul></li></ul><p>对 type safety 的<font color="blue">证明</font>（From Lecture Notes）</p><ul><li>证之前先重设一下现在的 Syntax 和 Semantics：<br>$$<br>Syntax:\quad\quad<br>\begin{aligned}<br>e &amp;::=c\ |\ \lambda x \cdot e \ |\ x \mid e\ e \<br>v &amp;::=c \mid \lambda x \cdot e \<br>\tau &amp;::=\text { int } \mid \tau \rightarrow \tau \<br>\Gamma &amp;::=\cdot \mid \Gamma, x: \tau<br>\end{aligned}<br>\\quad\ Evaluation\ Rules:\quad\quad</li></ul><pre><code>\begin{aligned}
&amp;\frac{}{(\lambda x . e) v \rightarrow e[v / x]} &amp;  \text{(E-APPLY)}
\\\\ &amp;
\frac{e_{1} \rightarrow e_{1}^{\prime}}{e_{1} e_{2} \rightarrow e_{1}^{\prime} e_{2}} &amp;  \text{(E-APP1)}
\\\\ &amp;
\frac{e_{2} \rightarrow e_{2}^{\prime}}{v e_{2} \rightarrow v e_{2}^{\prime}} &amp;  \text{(E-APP2)}
\end{aligned}

\\\quad\\ Typing\ Rules:\quad\quad

\begin{aligned}
&amp;\frac{}{\Gamma \vdash c: \text { int }} &amp; \text{(T-CONST)}
\\\\ &amp;
\frac{}{\Gamma \vdash x: \Gamma(x)} &amp; \text{(T-VAR)}
\\\\ &amp;
\frac{\Gamma, x: \tau_{1} \vdash e: \tau_{2} \quad x \notin \operatorname{Dom}(\Gamma)}{\Gamma \vdash \lambda x . e: \tau_{1} \rightarrow \tau_{2}} &amp; \text{(T-FUN)}
\\\\ &amp;
\frac{\Gamma \vdash e_{1}: \tau_{2} \rightarrow \tau_{1} \quad \Gamma \vdash e_{2}: \tau_{2}}{\Gamma \vdash e_{1} e_{2}: \tau_{1}} &amp; \text{(T-APP)}
\end{aligned}
$$</code></pre><ul><li>首先证 <font color="red">progress</font>（If $\cdot \vdash e: \tau$​​​，then ($e \in \text{Values}$​​​ or $\exists e^{\prime} . e \rightarrow e^{\prime}$​​​)），可以看到 progress 的前提是 $\cdot \vdash e: \tau$​​​​​​，那如何可以得到 $\cdot \vdash e: \tau$​​​​​​​（使其满足的前提是什么）？答案是 typing rules 的里的 “分子” 即 condition。所以要对每个 typing rule，利用得到的 condition 单独讨论。<ul><li>一些前置 Lemma<ul><li>Canonical Forms：<pre><code>If $\cdot \vdash v: \tau$, then
    i. If $\tau$ is int, then $v$ is a constant, i.e., some $c$.
    ii. If $\tau$ is $\tau_{1} \rightarrow \tau_{2}$, then $v$ is a lambda, i.e., $\lambda x . e$ for some $x$ and e.</code></pre></li></ul></li><li>对 T-CONST，此时 e 是 c，一个常量，<font color="blue">属于 Values</font>，满足 progress。不用多说。</li><li>对 T-VAR，想要 $\cdot \vdash e: \tau$ 匹配 $\Gamma \vdash x: \Gamma(x)$，不可能，即 $\cdot \vdash e: \tau$ 不可能从 T-VAR 得到（因为 Γ 是 ·，所以不可能存在 Γ(x)），此时 progress 的 if 是 false 的，那么 progress 自然满足。T-VAR 改为 $\frac{}{\Gamma, x: \tau\ \vdash\ x: \tau}$​ 也是可行的。</li><li>对 T-FUN，此时 e 是 $\lambda x. e’ $（出现了两个 e，所以后面一个加个撇），是一个 λ-abstraction，<font color="blue">属于 Values</font>，满足 progress。</li><li>对 T-APP，此时 e 是 $e_1 e_2$​​，通过 T-APP 由果得因得到 condition 是 $· \vdash e_{1}: \tau_{2} \rightarrow \tau_{1}$​​ 且 $·\vdash e_2 : \tau_2 $​​。<br>如果 e1 不属于 Values，那么 e1 可以继续规约（在这里就用了 progress），即有 e1 → e1’，运用一下 E-APP1，此时 $e_1 e_2 \rightarrow e_1’ e_2$​​，即<font color="blue">能向前规约一步</font>；<br>如果 e1 属于 Values，<pre><code>若 e2 不属于 Values，同理用 E-APP2，有 $e_1 e_2 \rightarrow e_1e_2&apos;$​​，即&lt;font color=blue&gt;能向前规约一步&lt;/font&gt;。
若 e2 属于 Values，由于 $· \vdash e_{1}: \tau_{2} \rightarrow \tau_{1}$​​，此时 e1 一定是个 λ-abstraction（PDF 里先证 Canonical Forms 这个 Lemma 后得到），运用 E-APPLY，`e1 e2` 是&lt;font color=blue&gt;能向前规约一步&lt;/font&gt;的。</code></pre></li></ul></li><li>然后证 <font color="red">preservation</font>（If $\cdot \vdash e: \tau$​​​​​ and $e \rightarrow e^{\prime} $​​​​​，then $\cdot \vdash e^{\prime}: \tau$​​​​​），和证 progress 一样的方式。<ul><li>一些前置 Lemma<ul><li>Substitution：$\text { If } \Gamma, x: \tau^{\prime} \vdash e: \tau \text { and } \Gamma \vdash e^{\prime}: \tau^{\prime}, \text { then } \Gamma \vdash e\left[e^{\prime} / x\right]: \tau $</li><li>Weakening：$\text { If } \Gamma \vdash e: \tau \text { and } x \notin \operatorname{Dom}(\Gamma), \text { then } \Gamma, x: \tau^{\prime} \vdash e: \tau $</li><li>Exchange：$\text { If } \Gamma, x: \tau_{1}, y: \tau_{2} \vdash e: \tau \text { and } y \neq x, \text { then } \Gamma, y: \tau_{2}, x: \tau_{1} \vdash e: \tau $</li></ul></li><li>对 T-CONST，e 是 c，一个常量，这是不满足 $e\rightarrow e’$ 的，所以不可能。满足 preservation（if 是 false 的，那 if-then 就是 true 的）</li><li>对 T-VAR，和证 progress 时的 T-VAR 类似，在空上下文中无法做 typecheck，所以这个 if 也是 false，即 if 的条件不可能是从 T-VAR 导出的。</li><li>对 T-FUN，e 是 $\lambda x. e_b$，一个 λ-abstraction，属于 Values，其不满足 $e\rightarrow e’$​ 的，所以不可能。</li><li>对 T-APP，此时 e 是 $e_1 e_2$​，通过 T-APP 由果得因得到 condition 是 $· \vdash e_{1}: \tau_{2} \rightarrow \tau$​ 且 $·\vdash e_2 : \tau_2 $​。<br>然后对于条件 $e\rightarrow e’$​（也是 $e_1e_2 \rightarrow e’$​），有三种可能导出 $\cdot \vdash e^{\prime}: \tau$​ 如下<ul><li>对 E-APP1，由 $e=e_1e_2$​​​ 且 $e’=e_1’e_2$​​​​​，得 $e_1 \rightarrow e_1’ $​​​​​。<br>又 $·\ \vdash e_1 : \tau_2 \rightarrow \tau$​​​​​，得 $·\ \vdash e_1’ : \tau_2 \rightarrow \tau$​​​​​。（在这里就用了 preservation）<br>又 $·\vdash e_2 : \tau_2 $​​​​​，用 T-APP 得 $\cdot \vdash e_1’e_2: \tau$​​​​​。故 $\cdot \vdash e^{\prime}: \tau$​​​​​。</li><li>对 E-APP2，由 $e=ve_2$ 且 $e’=ve_2’$，得 $v=e_1$ 且 $e_2 \rightarrow e_2’$。<br>又 $·\vdash e_2 : \tau_2 $，得 $·\vdash e_2’ : \tau_2 $。<br>又 $· \vdash e_{1}: \tau_{2} \rightarrow \tau $，用 T-APP 得 $\cdot \vdash e_1e_2’: \tau$。故 $\cdot \vdash e^{\prime}: \tau $.</li><li>对 E-APPLY，由 $e=(\lambda x. e_b)v$ 且 $e’ = e_b[v/x] $，得 $e_1$ 是 $\lambda x. e_b$ 且 $e_2$ 是 $v$。<br>又 $· \vdash e_{1}: \tau_{2} \rightarrow \tau $，得 $·,x:\tau_2 \vdash e_b :\tau$。<br>又 $·\vdash e_2 : \tau_2 $ 再用上 Substitution Lemma（PDF里有证明）得 $· \vdash e_b[e_2/x] : \tau$。故 $\cdot \vdash e^{\prime}: \tau $。</li></ul></li></ul></li><li>Completeness：A complete type system never rejects a program that can’t go wrong<ul><li>No false positives 没有假阳性</li><li>not complete example<ul><li>对于 <code>(λx. (x (λy. y)) (x 3)) (λz. z)</code> 无法找到 σ, τ 使 <code>x:σ ⊢ (x (λy. y)) (x 3):τ</code>，因为对于 x 我们无法 pick 到一个类型</li><li>但实际上 <code>(λx. (x (λy. y)) (x 3)) (λz. z)</code> 能规约到 <code>3</code></li><li>strong normalization theorem：well-typed terms in STLC always terminate<br>但 <code>(λx. x x) (λx. x x)</code> 无法终止，故不能被 assigned 一个类型</li></ul></li></ul></li><li>然而对于图灵完备的程序设计语言，程序是否会出错是不能确定的<ul><li>类型系统不能又 sound 又 complete</li><li>在保证 sound 的前提下，尽可能 complete</li></ul></li></ul><h3 id="Adding-stuff-扩展"><a href="#Adding-stuff-扩展" class="headerlink" title="Adding stuff 扩展"></a>Adding stuff 扩展</h3><p>可以扩展的：</p><ul><li>Extend the syntax (types &amp; terms)</li><li>Extend the operational semantics (reduction rules)</li><li>Extend the type system (typing rules)</li><li>Extend the soundness proof (new proof cases)</li></ul><p>adding product type：</p><ul><li><p><code>(Types) τ,σ ::= ...(之前的) | σ x τ</code></p></li><li><p><code>(Terms) M,N ::= ...(之前的) | &lt;M,N&gt; | proj1 M | proj2 M</code></p></li><li><p>Reduction rules（下面式子中把 proj1 改成 proj2 或者把 M 改成 N，可以有另外 3 个 rules）<br>$$<br>\frac{}{\text {proj1}&lt;\mathrm{M}, \mathrm{N}&gt;\rightarrow \mathrm{M} }<br>\\quad\<br>\frac{\mathrm{M} \rightarrow \mathrm{M}^{\prime} }{&lt;\mathrm{M}, \mathrm{N}&gt;\rightarrow&lt;\mathrm{M}^{\prime}, \mathrm{N}&gt;}<br>\\quad\</p><p>\frac{\mathrm{M} \rightarrow \mathrm{M}^{\prime}}{\operatorname{proj1} \mathrm{M} \rightarrow \operatorname{proj1} \mathrm{M}^{\prime}}<br>\<br>$$</p></li><li><p>Typing rules<br>$$<br>\begin{aligned}<br>&amp;\frac{\Gamma \vdash \mathrm{M}: \sigma \quad \Gamma \vdash \mathrm{N}: \tau}{\Gamma \vdash&lt;\mathrm{M}, \mathrm{N}&gt;: \sigma \times \tau} \text { (pair) } \\quad\<br>&amp;\frac{\Gamma \vdash \mathrm{M}: \sigma \times \tau}{\Gamma \vdash \operatorname{proj1} \mathrm{M}: \sigma}(\text {proj1) } \\quad\<br>&amp;\frac{\Gamma \vdash \mathrm{M}: \sigma \times \tau}{\Gamma \vdash \operatorname{proj2} \mathrm{M}: \tau}(\operatorname{proj2})<br>\end{aligned}<br>$$</p></li><li><p>typing derivation example</p><img src="image-20211009121031157.png" style="zoom:25%"></li><li><p>加类型后要证 soundness theorem (证 type safety)</p><ul><li>Preservation</li><li>Progress 里的 Values 要包括新加的 <code>&lt;v1,v2&gt;</code></li></ul></li></ul><p>Adding sum stype：</p><ul><li><p><code>(Types) τ,σ ::= ... | σ + τ</code></p></li><li><p><code>(Terms) M,N ::= ... | left M | right M | case M do M1 M2</code></p><ul><li>类比 Java 中两个子类实现接口方法，具体一个 instance 执行的时候还是要看是哪个子类的方法。<br>如果 instance 是 left 类（型）构造出来的，则执行 M1 方法，如果是 right 类（型）</li></ul></li><li><p>reduction rules:<br>$$<br>\frac{}{\text{case (left M) do M1 M2 } \rightarrow \text{M1 M}}<br>\\quad\<br>\frac{}{\text{case (right M) do M1 M2 } \rightarrow \text{M2 M}}<br>\\quad\<br>\frac{M \rightarrow M’}{ \text{case (M) do M1 M2 } \rightarrow \text{case (M’) do M1 M2 } }<br>\\quad\<br>\frac{M1 \rightarrow M1’}{ \text{case (M) do M1 M2 } \rightarrow \text{case (M) do M1’ M2 } }<br>\\quad\<br>\frac{M2 \rightarrow M2’}{ \text{case (M) do M1 M2 } \rightarrow \text{case (M) do M1 M2’ } }<br>\\quad\<br>\frac{M \rightarrow M’}{ \text{left M} \rightarrow \text{left} M’ }<br>\\quad\<br>\frac{M \rightarrow M’}{ \text{right M} \rightarrow \text{right} M’ }<br>$$</p></li><li><p>typing rules:<br>$$<br>\frac{\Gamma \vdash \mathrm{M}: \sigma}{\Gamma \vdash \text { left } \mathrm{M}: \sigma+\tau} \text { (left) } \quad \frac{\Gamma \vdash \mathrm{M}: \tau}{\Gamma \vdash \text { right } \mathrm{M}: \sigma+\tau} \text { (right) }<br>\\quad\<br>\frac{\Gamma \vdash \mathrm{M}: \sigma+\tau \quad\quad \Gamma \vdash \mathrm{M} 1: \sigma \rightarrow \rho \quad\quad \Gamma \vdash \mathrm{M} 2: \tau \rightarrow \rho}{\Gamma \vdash \text { case M do M1 M2: } \rho} \text{(case)}<br>$$</p></li><li><p>typing derivation examples</p><img src="image-20211009214647898.png" style="zoom:50%"></li><li><p>加类型后要证 soundness theorem (证 type safety)</p><ul><li>Preservation</li><li>Progress 里的 Values 要包括新加的 <code>left v</code> 和 <code>right v</code></li></ul></li></ul><p>Products vs. sums：</p><ul><li>“logical duals” (more on this later)<ul><li>To make a <code>σ x τ</code>, we need a <code>σ</code> <strong>and</strong> a <code>τ</code></li><li>To make a <code>σ + τ</code>, we need a <code>σ</code> <strong>or</strong> a <code>τ</code></li><li>Given a <code>σ x τ</code>, we can get a <code>σ</code> or a <code>τ</code> or both (our “choice”)</li><li>Given a <code>σ + τ</code>, we must be prepared for either a <code>σ</code> or a <code>τ</code> (the value’s “choice”)</li></ul></li></ul><p>Add recursion：</p><ul><li><p>由于 “strong normalization theorem”，即每个 well-typed terms 在 STLC 中要能终止。而有的递归是不会终止的，所以递归不被定型规则接纳（不可能找到 fixed-point combinators 的类型）</p></li><li><p>现在，添加一个递归的显式构造器：<br><code>(Types) τ,σ ::= ...</code> （如上所说，不加新的类型）<br><code>(Terms) M,N ::= ... | fix M</code></p></li><li><p>对于 <code>fix</code> 的 reduction rules：<br>$$<br>\frac{}{\mathbf{fix}\ \lambda x.M \rightarrow M[\mathbf{fix}\ \lambda x.M/x]}<br>\\quad\<br>\frac{M\rightarrow M’}{\mathbf{fix}\ M \rightarrow \mathbf{fix}\ M’}<br>$$</p><img src="image-20211011171431262.png" style="zoom:50%"></li><li><p>对 fix 定型（typing fix）<br>$$<br>\frac{\Gamma \vdash M: \tau \rightarrow \tau}{\Gamma \vdash \text { fix } M: \tau} \text { (fix) }<br>$$</p><ul><li>Math explanation:<br>If M is a function from τ to τ,<br>then <code>fix M</code>, the fixed-point of M, is some τ with the fixed-point property</li><li>Operational explanation:<br><code>fix λx.M’</code> reduces to <code>M’[fix λx.M’/x]</code><ul><li>The substitution <code>[fix λx.M’/x]</code> 意味着 <code>x</code> 和 <code>fix λx.M’</code> 同类型</li><li>The result <code>M&#39;</code> 由 <code>fix λx.M’</code> 规约而来，意味着二者同类型</li></ul></li></ul></li><li><p>而 strong normalization 则被消除了</p></li></ul><h3 id="Curry-Howard-isomorphism-同构"><a href="#Curry-Howard-isomorphism-同构" class="headerlink" title="Curry-Howard isomorphism 同构"></a>Curry-Howard isomorphism 同构</h3><p>我们用这玩意干啥：</p><ul><li>定义 PL</li><li>定义类型系统来找出 bad 程序</li></ul><p>逻辑学家用着玩意干啥：</p><ul><li>定义逻辑命题，比如 <code>p, q ::= B | p∧q | p∨q | p=&gt;q</code></li><li>定义一个证明系统，去证明一些 “good” propositions</li></ul><p>Slogens 口号：</p><ul><li>Propositions are Types 命题就是类型</li><li>Proofs are Programs 证明就是程序</li></ul><p>Empty and nonempty types：</p><ul><li><p>“nonempty” types：存在这样类型的 closed terms</p><ul><li><code>λx: τ. x</code>: τ → τ</li><li><code>λx: τ. λf: τ → σ. f x</code>: τ → (τ → σ) → σ</li><li><code>λf: τ → σ → ρ. λx: σ. λy: τ. f y x</code>: (τ → σ → ρ) → σ → τ → ρ</li><li><code>λx: τ. &lt;left x, left x&gt;</code>: τ → ((τ + σ) × (τ + ρ))</li><li><code>λf: τ → ρ. λg: σ → ρ. λx: τ + σ. (case x do f g)</code>: (τ → ρ) → (σ → ρ) → (τ + σ) → ρ</li><li><code>λx: τ × σ. λy: ρ. &lt; &lt;y, proj1 x&gt;, proj2 x &gt;</code>: (τ × σ) → ρ → ((ρ × τ) × σ)</li></ul></li><li><p>“empty” types：没有这样类型的 closed terms，也构造不出来</p><ul><li>τ</li><li>τ → σ</li><li>τ + (τ → σ)</li><li>τ → (σ → τ) → σ</li></ul></li><li><p>那如何得知一个 type 是否是 nonempty</p><ul><li><p><font color="red">eliminate：将 <code>→</code> 换为 <code>=&gt;</code>，将 <code>×</code> 换为 <code>∧</code>，将 <code>+</code> 换为 <code>∨</code></font></p></li><li><p>nonempty（即以下可以在命题逻辑中被证明）</p><ul><li><p>τ =&gt; τ</p><p>τ =&gt; (τ =&gt; σ) =&gt; σ</p><p>(τ =&gt; σ =&gt; ρ) =&gt; σ =&gt; τ =&gt; ρ</p><p>τ =&gt; ((τ ∨ σ) ∧ (τ ∨ ρ))</p><p>(τ =&gt; ρ) =&gt; (σ =&gt; ρ) =&gt; (τ ∨ σ) =&gt; ρ</p><p>(τ ∧ σ) =&gt; ρ =&gt; ((ρ ∧ τ) ∧ σ)</p></li></ul></li><li><p>empty（以下无法在命题逻辑中被证明）</p><ul><li>τ<br>τ =&gt; σ<br>τ ∨ (τ =&gt; σ)<br>τ =&gt; (σ =&gt; τ) =&gt; σ</li></ul></li><li><p>例子：propositional-logic proof 命题逻辑证明</p><img src="image-20211011205113020.png" style="zoom:33%"></li><li><p>propositional logic（natural deduction 自然推导）</p><img src="image-20211011205239844.png" style="zoom:50%"></li></ul></li></ul><p>总结：</p><ul><li><p>给定一个 well-typed closed terms，在 typing derivation 上 erase 这些 terms，最终得到一个 propositional-logic proof</p></li><li><p>给定一个 propositional-logic proof 存在一个 closed term 为该类型</p></li><li><p>一个可以经过 type-checks 的 term 即是一个证明，它表明了 logic formula 如何 derive 到它的类型</p><ul><li><code>λx: τ. x</code> is a proof that <code>τ =&gt; τ</code></li><li><code>λx: τ. λf: τ → σ. f x</code> is a proof that <code>τ =&gt; (τ =&gt; σ) =&gt; σ</code></li><li><code>λf: τ → σ → ρ. λx: σ. λy: τ. f y x</code> is a proof that <code>(τ =&gt; σ =&gt; ρ) =&gt; σ =&gt; τ =&gt; ρ</code></li><li><code>λx: τ. &lt;left x, left x&gt;</code> is a proof that <code>τ =&gt; ((τ ∨ σ) ∧ (τ ∨ ρ))</code></li><li><code>λf: τ → ρ. λg: σ → ρ. λx: τ + σ. (case x do f g)</code> is a proof that <code>(τ =&gt; ρ) =&gt; (σ =&gt; ρ) =&gt; (τ ∨ σ) =&gt; ρ</code></li><li><code>λx: τ × σ. λy: ρ. &lt; &lt;y, proj1 x&gt;, proj2 x &gt;</code> is a proof that <code>(τ ∧ σ) =&gt; ρ =&gt; ((ρ ∧ τ) ∧ σ)</code></li></ul></li><li><p><font color="red">Constructive</font> <em>(hold that thought)</em> propositional logic（构造主义的命题逻辑） 与<br>simply-typed lambda-calculus with pairs and sums 是同样的东西（同构）</p><ul><li>Computation and logic（logic 为了做证明） are deeply connected</li><li>λ is no more or less made up than implication 蕴含</li></ul></li><li><p>“一个逻辑无论如何会对应到类型系统上面”</p></li><li><p>why care，为什么关心 curry-howard 同构</p><ul><li>fascinating</li><li>不需要将 logic 和 computing 看作不一样的东西</li><li>Thinking “the other way” can help you know what’s possible/impossible 思考另一种方式给你带来新的可能与不可能</li><li>Can form the basis for automated theorem provers</li><li>Type systems should not be <em>ad hoc</em> piles of rules! 类型系统不应该是<em>临时性的</em>规则堆积!</li></ul></li></ul><p>Classical vs. Constructive 经典命题逻辑与构造主义的命题逻辑之间对比：</p><ul><li><p>classical propositional logic 多了 “law of the excluded middle 排中律”<br>$$<br>\frac{}{\Gamma \vdash p \or(p \Rightarrow q)}<br>\quad\quad<br>\text{Think}\quad p \or \neg p<br>$$</p></li><li><p>STLC does not support it: e.g. no closed term has type <code>ρ+(ρ→σ)</code></p></li><li><p>Logics without this rule are called “constructive构造主义的” or “intuitionistic直觉主义的”</p><ul><li>Formulae are <em>only</em> considered “true” when we have direct evidence (“proofs produce examples”)</li></ul></li><li><p>例子：</p><ul><li>定义：存在两个 irrational number 无理数 a 和 b 使得 $a^b$ 是有理数</li><li>经典证明：使用排中律。对于 $\sqrt2^\sqrt2$<ul><li>如果它是有理数，诶，那 $a=b=\sqrt2$，得证</li><li>如果它是无理数，令 $a = \sqrt2^\sqrt2, b=\sqrt2$，此时 $a^b = (\sqrt2^\sqrt2)^\sqrt2 = \sqrt2^{\sqrt2\times \sqrt2} = (\sqrt2)^2 = 2$，得证</li></ul></li><li><strong>Constructive logics would not accept this argument</strong></li></ul></li><li><p>In constructive logics, “branch on possibilities” by making “excluded middle” an explicit assumption 在构造主义逻辑里，硬是要引入排中律，只能显式引入：<br><font color="blue">(p∨(p⇒q))</font>∧(p⇒r)∧((p⇒q)⇒r)⇒r</p></li></ul><p>对 “fix” 补充：</p><ul><li>A “non-terminating proof” is no proof at all</li><li>回想一下其定型规则是 $\frac{\Gamma \vdash M: \tau \rightarrow \tau}{\Gamma \vdash \text { fix } M: \tau} \text { (fix) }$，其中相当引入了 $\tau \rightarrow \tau$ 可以得到 $\tau$ ，如果有了这条规则那相当于能证 everything</li><li>So the “logic” is inconsistent</li></ul><p>Last word on Curry-Howard：</p><ul><li><p>Not just constructive propositional logic &amp; STLC</p></li><li><p><strong>Every</strong> logic has a corresponding typed system</p><ul><li>Classical logics</li><li>Inconsistent logics</li></ul></li><li><p>If you remember one thing:<br>$$<br>\frac{\Gamma \vdash M: \sigma \rightarrow \tau \quad\quad \Gamma \vdash N: \sigma}{\Gamma \vdash M N: \tau}(\mathrm{app}) \quad\Leftrightarrow\quad \frac{\Gamma \vdash p \Rightarrow q \quad\quad \Gamma \vdash p}{\Gamma \vdash q} (\Rightarrow -elim)<br>$$</p></li></ul><h2 id="Operational-Semantics"><a href="#Operational-Semantics" class="headerlink" title="Operational Semantics"></a>Operational Semantics</h2><blockquote><p>现在让我们从 functional language 回到 Imperative languages</p></blockquote><p>Why formal semantics（Formal semantics gives an unambiguous不含糊的 definition of what a program written in the language should do）：</p><ul><li>Understand the subtleties细微之处 of the language</li><li>Offer a formal reference and a correctness definition for implementors of tools (parsers, compilers, interpreters, debuggers, etc)</li><li>Prove global properties of any program written in the language</li><li>Verify programs against formal specifications</li><li>Prove two different programs are equivalent/non-equivalent</li><li>From a computer readable version of the semantics, an interpreter can be automatically generated (full compiler generation is not yet feasible可行的)</li></ul><p>semantics 分类：</p><ul><li>Operational semantics 操作语义：程序如何一步步执行（比如 λ-calculus 里的 reduction rules）</li><li>Denotational semantics 指称语义：将程序指称到某种数学对象上（比如 tree、linklist）</li><li>Axiomatic semantics 公理语义：推导程序性质的证明系统</li></ul><h3 id="Operational-semantics"><a href="#Operational-semantics" class="headerlink" title="Operational semantics"></a>Operational semantics</h3><p>学习目标：</p><ul><li>write down the evaluation/execution steps, if given the operational semantics rules</li><li>formulate the operational semantics rule, if given the informal meaning of an expression/statement</li></ul><p>概念：</p><ul><li><p>操作语义定义了程序的执行</p></li><li><p>Sequence of steps, formulated as transitions of <em>an abstract machine</em><br>操作语义是步骤的序列，可形式化为一个抽象状态机的转移过程</p></li><li><p>Configurations of <em>the abstract machine</em> include：</p><ul><li><font color="blue">Expression/statement</font> being evaluated/executed</li><li><font color="blue">States</font>: abstract description of registers, memory and other data structures involved in computation <img src="image-20211019163112392.png" style="zoom:25%"></li></ul></li><li><p>Different approaches of operational semantics：</p><ul><li>Small-step semantics：描述了每一步执行</li><li>Big-step semantics：描述了执行的总体结果 overall result</li></ul></li></ul><blockquote><p>接下来到具体的 small-step 和 big-step 之前，先描述一下待会要作为例子的命令式语言的语法</p></blockquote><p>Syntax of a Simple Imperative Language：</p><img src="image-20211019164434523.png" style="zoom:25%"><ul><li>注意这里加粗的 $\mathbf{n}$，表示的是数字 numerals $\mathbf{0,1,2,\cdots}$，本身没有意义，只是用来描述这些数的语法 syntax。<br>需要区分其和自然数 natural numbers $0, 1,2,\cdots $ 之间的区别。</li><li>我们用 $\lfloor\mathbf{n}\rfloor $ 来表示 the meaning of $\mathbf{n}$，现在假设 $\lfloor\mathbf{n}\rfloor=n,\lfloor\mathbf{1}\rfloor=1,\cdots $</li><li>The distinction is subtle 不易察觉的; 狡猾的; 巧妙的, but important, because it is one manifestation表示 of the difference between syntax and semantics. <img src="image-20211019165118282.png" style="zoom:25%"></li></ul><p>States：</p><ul><li><code>(State) σ ∈ Var → Values</code></li><li>Values 是什么？$\mathbf{n} \ or \ n\ ? $，答案是都可以，反正我们认为 Values 是 natural number, boolean values 等</li><li>对于 <code>σ1 = {(x, 2), (y, 3), (a, 10)}</code> 我们写作 $ { x\rightsquigarrow2, y\rightsquigarrow3,a\rightsquigarrow10 } $，简约起见，都假设是 total function</li><li>单点修改：$\sigma_1 { y\rightsquigarrow7 } { x\rightsquigarrow2, y\rightsquigarrow7,a\rightsquigarrow10 } $</li><li>后面的操作语义会使用这样的 configurations 形式 $(e,\sigma), (b,\sigma) $</li></ul><h4 id="Small-step"><a href="#Small-step" class="headerlink" title="Small-step"></a>Small-step</h4><h5 id="base"><a href="#base" class="headerlink" title="base"></a>base</h5><p>Small-step structural operational semantics (SOS)：</p><ul><li>Systematic definition of operational semantics<ul><li>The program syntax is inductively-defined</li><li>So we can also define the semantics of a program in terms of the semantics of its parts</li><li>“Structural”: syntax oriented and inductive</li></ul></li><li>例子<ul><li>The state transition for <code>e1 + e2</code> is described using the transition for <code>e1</code> and the transition for <code>e2</code></li><li>The state transition for <code>c1;c2</code> is described using the transitionfor <code>c1</code> and the transition for <code>c2</code>.</li></ul></li></ul><p>Small-step SOS for expression evaluation：</p><ul><li><p>addition：<br>$$<br>\frac{\left(e_{1}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}, \sigma\right)}{\left(e_{1}+e_{2}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}+e_{2}, \sigma\right)}<br>\\quad\<br>\frac{\left(e_{2}, \sigma\right) \longrightarrow\left(e_{2}^{\prime}, \sigma\right)}{\left(\mathbf{n}+e_{2}, \sigma\right) \longrightarrow\left(\mathbf{n}+e_{2}^{\prime}, \sigma\right)}</p><p>\\quad\</p><p>\frac{\left\lfloor\mathbf{n}<em>{1}\right\rfloor\lfloor+\rfloor\left\lfloor\mathbf{n}</em>{2}\right\rfloor=\lfloor\mathbf{n}\rfloor}{\left(\mathbf{n}<em>{1}+\mathbf{n}</em>{2}, \sigma\right) \longrightarrow(\mathbf{n}, \sigma)}<br>$$<br>（需要注意上式和 $\begin{aligned}\frac{\left(e_{2}, \sigma\right) \longrightarrow\left(e_{2}^{\prime}, \sigma\right)}{\left(e_{1}+e_{2}, \sigma\right) \longrightarrow\left(e_{1}+e_{2}^{\prime}, \sigma\right)}<br>\\quad\<br>\frac{\left(e_{1}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}, \sigma\right)}{\left(e_{1}+\mathbf{n}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}+\mathbf{n}, \sigma\right)} \end{aligned} $ 不一样，左优先和右优先）</p></li><li><p>Subtraction，结构和 addition 类似，把 <code>+</code> 换成 <code>-</code> 即可</p></li><li><p>Variables：<br>$$<br>\frac{\sigma(x)=\lfloor\mathbf{n}\rfloor}{(x, \sigma) \longrightarrow(\mathbf{n}, \sigma)}<br>$$</p></li><li><p>总结<br>$$<br>\frac{\left(e_{1}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}, \sigma\right)}{\left(e_{1}+e_{2}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}+e_{2}, \sigma\right)}<br>\quad<br>\frac{\left(e_{2}, \sigma\right) \longrightarrow\left(e_{2}^{\prime}, \sigma\right)}{\left(\mathbf{n}+e_{2}, \sigma\right) \longrightarrow\left(\mathbf{n}+e_{2}^{\prime}, \sigma\right)}<br>\<br>\frac{\left(e_{1}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}, \sigma\right)}{\left(e_{1}-e_{2}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}-e_{2}, \sigma\right)}<br>\quad<br>\frac{\left(e_{2}, \sigma\right) \longrightarrow\left(e_{2}^{\prime}, \sigma\right)}{\left(\mathbf{n}-e_{2}, \sigma\right) \longrightarrow\left(\mathbf{n}-e_{2}^{\prime}, \sigma\right)}<br>\<br>\frac{\left\lfloor\mathbf{n}<em>{1}\right\rfloor\left\lfloor+\left\rfloor\left\lfloor\mathbf{n}</em>{2}\right\rfloor=\lfloor\mathbf{n}\rfloor\right.\right.}{\left(\mathbf{n}<em>{1}+\mathbf{n}</em>{2}, \sigma\right) \longrightarrow(\mathbf{n}, \sigma)}<br>\quad \frac{\left\lfloor\mathbf{n}<em>{1}\right\rfloor\lfloor-\rfloor\left\lfloor\mathbf{n}</em>{2}\right\rfloor=\lfloor\mathbf{n}\rfloor}{\left(\mathbf{n}<em>{1}-\mathbf{n}</em>{2}, \sigma\right) \longrightarrow(\mathbf{n}, \sigma)}<br>\quad<br>\frac{\sigma(x)=\lfloor\mathbf{n}\rfloor}{(x, \sigma) \longrightarrow(\mathbf{n}, \sigma)}<br>$$</p></li><li><p>例子：假设 σ(x) =10, σ(y)=42</p><p>$(x+y, \sigma) \longrightarrow(10+y, \sigma) \longrightarrow(10+42, \sigma) \longrightarrow(52, \sigma) $</p></li></ul><p>Small-step SOS for boolean expressions：</p><ul><li><p>Comparisions：<br>$$<br>\frac{\left(e_{1}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}, \sigma\right)}{\left(e_{1}=e_{2}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}=e_{2}, \sigma\right)} \quad \frac{\left(e_{2}, \sigma\right) \longrightarrow\left(e_{2}^{\prime}, \sigma\right)}{\left(\mathbf{n}=e_{2}, \sigma\right) \longrightarrow\left(\mathbf{n}=e_{2}^{\prime}, \sigma\right)}<br>\\quad\<br>\frac{\left.\left\lfloor\mathbf{n}<em>{1}\right\rfloor \lfloor=\right\rfloor\left\lfloor\mathbf{n}</em>{2}\right\rfloor}{\left(\mathbf{n}<em>{1}=\mathbf{n}</em>{2}, \sigma\right) \longrightarrow(\mathbf{true }, \sigma)} \quad \frac{\left.\neg\left(\left\lfloor\mathbf{n}<em>{1}\right\rfloor \lfloor=\right\rfloor\left\lfloor\mathbf{n}</em>{2}\right\rfloor\right)}{\left(\mathbf{n}<em>{1}=\mathbf{n}</em>{2}, \sigma\right) \longrightarrow(\mathbf{false }, \sigma)}<br>$$</p></li><li><p>Negation：<br>$$<br>\frac{(b, \sigma) \longrightarrow\left(b^{\prime}, \sigma\right)}{(\neg b, \sigma) \longrightarrow\left(\neg b^{\prime}, \sigma\right)}<br>\\quad\<br>\overline{(\neg \mathbf {true}, \sigma) \longrightarrow(\mathbf {false}, \sigma)} \quad \overline{( \neg \mathbf{false }, \sigma) \longrightarrow(\mathbf {true }, \sigma)}<br>$$</p></li><li><p>Conjunction 合取：<br>$$<br>\frac{\left(b_{1}, \sigma\right) \longrightarrow\left(b_{1}^{\prime}, \sigma\right)}{\left(b_{1} \wedge b_{2}, \sigma\right) \longrightarrow\left(b_{1}^{\prime} \wedge b_{2}, \sigma\right)}</p><p>\\quad\</p><p>\frac{\left(b_{2}, \sigma\right) \longrightarrow\left(b_{2}^{\prime}, \sigma\right)}{\left(\mathbf{true} \wedge b_{2}, \sigma\right) \longrightarrow\left(\mathbf{true} \wedge b_{2}^{\prime}, \sigma\right)}<br>\quad<br>\frac{\left(b_{2}, \sigma\right) \longrightarrow\left(b_{2}^{\prime}, \sigma\right)}{\left(\mathbf {false} \wedge b_{2}, \sigma\right) \longrightarrow\left(\mathbf { false } \wedge b_{2}^{\prime}, \sigma\right)}<br>\\quad\<br>\frac{}{(\mathbf { true } \wedge \mathbf { true, } \sigma) \longrightarrow(\mathbf { true, } \sigma)} \quad \frac{}{(\mathbf { true } \wedge \mathbf { false }, \sigma) \longrightarrow(\mathbf { false }, \sigma)}<br>\\quad\<br>\frac{}{(\mathbf { false } \wedge \mathbf { true, } \sigma) \longrightarrow(\mathbf { false }, \sigma)} \quad \frac{}{(\mathbf { false } \wedge \mathbf { false, } \sigma) \longrightarrow(\mathbf { false }, \sigma)}<br>$$</p><ul><li>short-circuit calculation 版<br>$$<br>\frac{\left(b_{1}, \sigma\right) \longrightarrow\left(b_{1}^{\prime}, \sigma\right)}{\left(b_{1} \wedge b_{2}, \sigma\right) \longrightarrow\left(b_{1}^{\prime} \wedge b_{2}, \sigma\right)} \</li></ul></li></ul><pre><code>\frac{}{\left(\mathbf { true } \wedge b_{2}, \sigma\right) \longrightarrow\left(b_{2}, \sigma\right)} \\

\frac{}{\left(\mathbf { false } \wedge b_{2}, \sigma\right) \longrightarrow(\mathbf { false }, \sigma)}
$$</code></pre><p>Small-step SOS for statements（statement 执行关系一般是这种形式 $(c,\sigma)\longrightarrow(c’,\sigma’)\ or\ (c,\sigma)\longrightarrow \sigma’$）：</p><ul><li><p>skip<br>$$<br>\frac{}{(\mathbf{skip}, \sigma) \longrightarrow \sigma}<br>$$</p></li><li><p>assignment<br>$$<br>\frac{(e, \sigma) \longrightarrow\left(e^{\prime}, \sigma\right)}{(x:=e, \sigma) \longrightarrow\left(x:=e^{\prime}, \sigma\right)}<br>\quad<br>\frac{}{(x:=\mathbf{n}, \sigma) \longrightarrow \sigma { x \rightsquigarrow\lfloor\mathbf{n}\rfloor } }<br>$$</p><ul><li>例子<br>$$<br>(x:=10+12, \sigma) \longrightarrow(x:=22, \sigma) \longrightarrow \sigma { x \rightsquigarrow 22 }<br>\<br>\left(x:=x+1, \sigma^{\prime}\right) \longrightarrow\left(x:=22+1, \sigma^{\prime}\right) \longrightarrow\left(x:=23, \sigma^{\prime}\right) \longrightarrow \sigma^{\prime} { x \rightsquigarrow 23 }<br>$$</li></ul></li><li><p>sequential composition<br>$$<br>\frac{\left(c_{0}, \sigma\right) \longrightarrow\left(c_{0}^{\prime}, \sigma^{\prime}\right)}{\left(c_{0} ; c_{1}, \sigma\right) \longrightarrow\left(c_{0}^{\prime} ; c_{1}, \sigma^{\prime}\right)} \quad \frac{\left(c_{0}, \sigma\right) \longrightarrow \sigma^{\prime}}{\left(c_{0} ; c_{1}, \sigma\right) \longrightarrow\left(c_{1}, \sigma^{\prime}\right)}<br>$$</p><ul><li>例子<br>$$<br>\begin{aligned}<br>&amp;(x:=10+12 ; x:=x+1, \sigma) \<br>&amp;\longrightarrow(x:=22 ; x:=x+1, \sigma) \<br>&amp;\longrightarrow(x:=x+1, \sigma { x \rightsquigarrow 22 } ) \<br>&amp;\longrightarrow(x:=22+1, \sigma { x \rightsquigarrow 22 } ) \<br>&amp;\longrightarrow(x:=23, \sigma { x \rightsquigarrow 22 } ) \<br>&amp;\longrightarrow \sigma { x \rightsquigarrow 23 }<br>\end{aligned}<br>$$</li></ul></li><li><p>if<br>$$<br>\frac{(b, \sigma) \longrightarrow\left(b^{\prime}, \sigma\right)}{(\mathbf{if}\ b\ \mathbf{then}\ c_{0}\ \mathbf{else}\ \left.c_{1}, \sigma\right) \longrightarrow\left(\right. \mathbf{if}\ b^{\prime}\ \mathbf{then}\ c_{0}\ \mathbf{else}\ \left.c_{1}, \sigma\right)}<br>\\quad\<br>\frac{}{\text { (if true then } \left.c_{0} \text { else } c_{1}, \sigma\right) \longrightarrow\left(c_{0}, \sigma\right)}<br>\\quad\<br>\frac{}{\text { (if false then } \left.c_{0} \text { else } c_{1}, \sigma\right) \longrightarrow\left(c_{1}, \sigma\right)}<br>$$</p></li><li><p>while<br>$$<br>\frac{}{\text { (while } b \text { do } c, \sigma) \longrightarrow \text { (if } b \text { then }(c ; \text { while } b \text { do } c) \text { else skip, } \sigma \text { ) }}<br>$$</p></li></ul><p>Zero-or-multiple steps：</p><ul><li><p>我们定义 $\longrightarrow^<em>$ 为 the reflexive transitive colsure of $\longrightarrow $​：<br>$$<br>\frac{}{(c, \sigma) \longrightarrow^{</em>}(c, \sigma)}<br>\quad<br>\frac{(c, \sigma) \longrightarrow\left(c^{\prime}, \sigma^{\prime}\right) \quad\quad \left(c^{\prime}, \sigma^{\prime}\right) \longrightarrow^{<em>}\left(c^{\prime \prime}, \sigma^{\prime \prime}\right)}{(c, \sigma) \longrightarrow^{</em>}\left(c^{\prime \prime}, \sigma^{\prime \prime}\right)}<br>$$</p></li><li><p>N-step transitions:<br>$$<br>\frac{}{(c, \sigma) \longrightarrow^{0}(c, \sigma)}<br>\quad<br>\frac{(c, \sigma) \longrightarrow\left(c^{\prime}, \sigma^{\prime}\right) \quad\left(c^{\prime}, \sigma^{\prime}\right) \longrightarrow^{n}\left(c^{\prime \prime}, \sigma^{\prime \prime}\right)}{(c, \sigma) \longrightarrow^{n+1}\left(c^{\prime \prime}, \sigma^{\prime \prime}\right)}<br>$$</p><ul><li><p>于是我们有 $(c, \sigma) \longrightarrow^{*}\left(c^{\prime}, \sigma^{\prime}\right) \text { iff } \exists n \cdot(c, \sigma) \longrightarrow^{n}\left(c^{\prime}, \sigma^{\prime}\right) $</p></li><li><p>$(c, \sigma) \longrightarrow^{*} \sigma^{\prime} $</p><ul><li>例子<br>$$<br>\begin{aligned}<br>c \stackrel{\text { def }}{=}\ &amp; y:=x ; a:=1 ;\<br>&amp;\text {while }(y&gt;0) \text { do }\<br>&amp;(a:=a \times y;y:=y-1)<br>\end{aligned}<br>$$<br>假设 $\sigma= { x \rightsquigarrow 3, y \rightsquigarrow 2, a \rightsquigarrow 9 } $，有 $\sigma^{\prime}= { x \rightsquigarrow 3, y \rightsquigarrow 0, a \leadsto 6 } $</li></ul></li></ul></li></ul><p>Some fact about $\longrightarrow$，一些性质：</p><ul><li><p>Theorem (Determinism）：<br>For all $c, \sigma, c^{\prime}, \sigma^{\prime}, c^{\prime \prime}, \sigma^{\prime \prime}$,<br>if $(c, \sigma) \longrightarrow\left(c^{\prime}, \sigma^{\prime}\right)$ and $(c, \sigma) \longrightarrow\left(c^{\prime \prime}, \sigma^{\prime \prime}\right)$,<br>then $\left(c^{\prime}, \sigma^{\prime}\right)=\left(c^{\prime \prime}, \sigma^{\prime \prime}\right)$​</p></li><li><p>Corollary推论 (Confluence合流性)<br>For all $c, \sigma, c^{\prime}, \sigma^{\prime}, c^{\prime \prime}, \sigma^{\prime \prime}$,<br>if $(c, \sigma) \longrightarrow^{<em>}\left(c^{\prime}, \sigma^{\prime}\right)$ and $(c, \sigma) \longrightarrow^{</em>}\left(c^{\prime \prime}, \sigma^{\prime \prime}\right)$,<br>then there exist $c^{\prime \prime \prime}$ and $\sigma^{\prime \prime \prime}$ such that $\left(c^{\prime}, \sigma^{\prime}\right) \longrightarrow^{<em>}\left(c^{\prime \prime \prime}, \sigma^{\prime \prime \prime}\right)$ and $\left(c^{\prime \prime}, \sigma^{\prime \prime}\right) \longrightarrow^{</em>}\left(c^{\prime \prime \prime}, \sigma^{\prime \prime \prime}\right)$​</p></li><li><p>Normalization：<br>There are no infinite sequences of configurations $\left(e_{1}, \sigma_{1}\right),\left(e_{2}, \sigma_{2}\right) , \cdots $ such that, for all $i,\left(e_{i}, \sigma_{i}\right) \longrightarrow\left(e_{i+1}, \sigma_{i+1}\right) $<br>That is, every evaluation path eventually reaches a normal form.</p><ul><li>Normal forms:<br>For expressions, the normal forms are <code>(n, σ)</code> for numeral <strong>n</strong><br>For booleans, the normal forms are <code>(true, σ)</code> and <code>(false, σ)</code></li><li>需要注意 <code>(e, σ)</code> 和 <code>(b, σ)</code> 是 normalizing 的，但 <code>(c, σ)</code> 不是。<br>如下：<br>For any state <code>σ</code> , there is no <code>σ&#39;</code> such that $\text {(while true do skip, } \sigma) \longrightarrow^{*} \sigma^{\prime} $​</li></ul></li></ul><blockquote><p>Next: we will see some variations of the current small-step semantics</p><p>Note when we modify the semantics, we define a different language.</p></blockquote><h5 id="Variation-I"><a href="#Variation-I" class="headerlink" title="Variation I"></a>Variation I</h5><ul><li>思想：直接定义一个求表达式值的符号，如 $[[e]]_{i n t e x p} \sigma=n $​</li></ul><p>$$<br>\frac{[[ e ]]<em>{\operatorname{intexp}} \sigma=n}{(x:=e, \sigma) \longrightarrow \sigma { x \rightsquigarrow n } }<br>\\quad\<br>[[e]] _{\text {intexp }} \sigma=n \text { iff }(e, \sigma) \longrightarrow^{*}(\mathbf{n}, \sigma) \text { and } n=\lfloor\mathbf{n}\rfloor<br>\\quad\<br>\frac{[[b]]</em>{\text {boolexp }} \sigma=\text {true}}{\text { (if } \left.b \text { then } c_{0} \text { else } c_{1}, \sigma\right) \longrightarrow\left(c_{0}, \sigma\right)}<br>\\quad\<br>\frac{[[b]]<em>{\text {boolexp }} \sigma=\text {false}}{\left(\text { if } b \text { then } c</em>{0} \text { else } c_{1}, \sigma\right) \longrightarrow\left(c_{1}, \sigma\right)}<br>\\quad\<br>\frac{[[b]] _{\text {boolexp }} \sigma=\text {true}}{\text { (while } b \text { do } c, \sigma) \longrightarrow(c ; \text { while } b \text { do } c, \sigma)} \\quad\<br>\frac{[[b]] _{\text {boolexp }} \sigma=\text {false}}{(\text {while } b \text { do } c, \sigma) \longrightarrow \sigma}<br>$$</p><ul><li>例子 $(x:=10+12, \sigma) \longrightarrow \left(x:=22, \sigma\right) \longrightarrow \sigma { x \rightsquigarrow 22 } $​​​​</li></ul><h5 id="Variation-II"><a href="#Variation-II" class="headerlink" title="Variation II"></a>Variation II</h5><ul><li>思想：<ul><li>需要注意一下，之前的版本里同时存在 two forms of transitions for statements：$(c, \sigma)\rightarrow(c’,\sigma’) \quad (c,\sigma)\rightarrow\sigma’ $​，这会导致我们需要对两种形式都要定义和证明 → 的性质（though this isn’t a big deal）</li><li>所以将 <strong>skip</strong> 重载作为 a flag for termination</li></ul></li></ul><p>$$<br>\frac{\left(c_{0}, \sigma\right) \longrightarrow\left(c_{0}^{\prime}, \sigma^{\prime}\right)}{\left(c_{0} ; c_{1}, \sigma\right) \longrightarrow\left(c_{0}^{\prime} ; c_{1}, \sigma^{\prime}\right)}<br>\quad<br>\frac{}{\left(\mathbf{s k i p} ; c_{1}, \sigma\right) \longrightarrow\left(c_{1}, \sigma\right)}<br>\\quad\<br>\frac{[[ e ]]<em>{\operatorname{intexp}} \sigma=n}{(x:=e, \sigma) \longrightarrow (\mathbf{skip},\sigma { x \rightsquigarrow n } )}<br>\\quad\<br>\frac{[[b]]</em>{\text {boolexp }} \sigma=\text {true}}{\text { (if } \left.b \text { then } c_{0} \text { else } c_{1}, \sigma\right) \longrightarrow\left(c_{0}, \sigma\right)}<br>\\quad\<br>\frac{[[b]]<em>{\text {boolexp }} \sigma=\text {false}}{\left(\text { if } b \text { then } c</em>{0} \text { else } c_{1}, \sigma\right) \longrightarrow\left(c_{1}, \sigma\right)}<br>\\quad\<br>\frac{[[b]] _{\text {boolexp }} \sigma=\text {true}}{\text { (while } b \text { do } c, \sigma) \longrightarrow(c; \text{while } b \text { do } c, \sigma)} \\quad\<br>\frac{[[b]] _{\text {boolexp}} \sigma=\text {false}}{(\text {while } b \text { do } c, \sigma) \longrightarrow (\mathbf{skip},\sigma)}<br>$$</p><blockquote><p>接下来我们针对 Variation II 来扩展以下特性：</p><ul><li>Going wrong</li><li>Local variable declaration</li><li>Dynamically-allocated data</li></ul></blockquote><h5 id="Going-wrong"><a href="#Going-wrong" class="headerlink" title="Going wrong"></a>Going wrong</h5><p>出错分类：</p><ul><li><p>Divided by zero</p><p>先补一下除法语义</p></li><li><p>Access. Non-existing data</p></li><li><p>…</p></li></ul><p>补充：<br>$$<br>\text{Expressions: }\quad<br>\frac{\mathbf{n_{2}} \neq 0 \quad\left\lfloor\mathbf{n_{1}}\right\rfloor \left\lfloor/\right\rfloor \left\lfloor\mathbf{n_{2}}\right\rfloor=\lfloor \mathbf{n}\rfloor}{\left(\mathbf{n_1/n_2}, \sigma\right) \longrightarrow(\mathbf{n}, \sigma)} \quad \frac{}{\left(\mathbf{n_1/0}, \sigma\right) \longrightarrow \mathbf{abort}}<br>\\quad\<br>\text{Assigment:}\quad\frac{[[ e ]]<em>{\operatorname{intexp}} \sigma=n}{(x:=e, \sigma) \longrightarrow (\mathbf{skip},\sigma { x \rightsquigarrow n } )}<br>\quad<br>\frac{[[ e ]]</em>{\operatorname{intexp}}\sigma = \bot}{(x:=e, \sigma) \longrightarrow \mathbf{abort}}<br>\\quad\<br>\begin{aligned}<br>&amp;[[e]] _{\operatorname{intexp}} \sigma=n &amp;\text { iff }&amp; \quad(e, \sigma) \longrightarrow^{<em>}(\mathbf{n}, \sigma) \text { and } n=\lfloor\mathbf{n}\rfloor \<br>&amp;[[e]] _{\text {intexp }} \sigma =\perp &amp;\text { iff }&amp; \quad(e, \sigma) \longrightarrow^{</em>} \mathbf { abort }<br>\end{aligned}</p><p>\\quad\<br>\text{Add new rules:}\quad<br>\frac{\left(c_{0}, \sigma\right) \longrightarrow \text { abort }}{\left(c_{0} ; c_{1}, \sigma\right) \longrightarrow \text { abort }}<br>\quad<br>\frac{[[b]]<em>{\text {boolexp }} \sigma=\bot}{\left(\text { if } b \text { then } c</em>{0} \text { else } c_{1}, \sigma\right) \longrightarrow \text{abort}}<br>\quad<br>\frac{[[b]] _{\text {boolexp}} \sigma=\bot}{(\text {while } b \text { do } c, \sigma) \longrightarrow\text{abort}}<br>$$</p><p>区分 “going wrong” 和 “getting stuck”：</p><ul><li>gets stuck 指的是在 state <code>σ</code>，不存在 <code>c&#39;, σ&#39;</code> 使 <code>(c, σ) → (c&#39;, σ&#39;)</code></li><li>在 Variation II 中，skip 在任何时候都会 gets stuck，因为 <code>(skip, σ)</code> 无法向前</li><li>共同点：language-dependent 二者都和具体的语言相关</li></ul><h5 id="Local-variable-declaration"><a href="#Local-variable-declaration" class="headerlink" title="Local variable declaration"></a>Local variable declaration</h5><p>Statements: <code>c ::= ... | newvar x := e in c</code></p><p>Semantics：</p><ul><li><p>一个有并发问题的语义是：$\large\frac{\sigma\ x=\lfloor\mathbf{n}\rfloor}{(\mathbf{newvar}\ x:=e\ \mathbf{in}\ c, \sigma) \longrightarrow(x:=e\ ;\ c\ ;\ x:=\mathbf{n},\ \sigma)}$</p></li><li><p>正确的语义是 (due to Eugene Fink)：</p></li></ul><p>$$<br>\frac{n=[[e]]<em>{\text {intexp }} \sigma \quad (c, \sigma { x \rightsquigarrow n } ) \longrightarrow\left(c^{\prime}, \sigma^{\prime}\right) \quad \sigma^{\prime} x=\left\lfloor\mathbf{n}^{\prime}\right\rfloor}{(\mathbf {newvar}\ x:=e \text { in } c, \sigma) \longrightarrow\left(\mathbf{newvar}\ x:=\mathbf{n}^{\prime} \text { in } c^{\prime}, \sigma^{\prime} { x \rightsquigarrow \sigma x } \right)}<br>\<br>\frac{}{(\mathbf{newvar}\ x:=e \text { in skip, } \sigma) \longrightarrow(\text{skip}, \sigma)}<br>\\quad\<br>\frac{[[e]] _{\operatorname{intexp}} \sigma=\perp}{(\mathbf { newvar }\ x:=e \text { in } c, \sigma) \longrightarrow \mathbf{abort}}<br>\<br>\frac{n=[[e]]</em>{\text {intexp }} \sigma \quad (c, \sigma { x \rightsquigarrow n } ) \longrightarrow \mathbf{abort}}{(\mathbf { newvar }\ x:=e \text { in } c, \sigma) \longrightarrow \mathbf{abort}}<br>$$</p><p>Heap for dynamically-allocated data：</p><ul><li><p>Notations：<br>$$<br>\begin{array}{ll}<br>\text { (States) } &amp; \sigma::=(s, h) \<br>\text { (Stores) } &amp; s \in \text{Var}\rightarrow \text {Values} \<br>\text { (Heaps) } &amp; h \in \text{Loc}\rightharpoonup_{\text{fin}} \text {Values } \<br>\text { (Values) } &amp; v \in \operatorname{lnt} \cup \text { Bool } \cup \text { Loc }<br>\end{array}<br>$$</p></li><li></li><li><p>注意 $\rightharpoonup_{\text{fin}} $ 表示 Partial Mapping。<br>Loc 里有 “没有 allocation” 和 “已经 allocation” 的引用，所以是 partial mapping</p></li></ul><p>A simple language with heap manipulation：</p><ul><li><p>Statements：<br>$$<br>\begin{aligned}<br>x &amp; ::= \quad … &amp;<br>\<br>&amp;\quad \mid x := \operatorname{alloc}(e) &amp; \text { allocation }<br>\<br>&amp;\quad \mid y:=[x] &amp; \text { lookup } \<br>&amp;\quad \mid {[x]:=e} &amp; \text { mutation } \<br>&amp;\quad \mid \text {free}(x) &amp; \text { deallocation }<br>\end{aligned}<br>$$</p></li><li><p>Configurations: <code>(c, (s, h))</code></p></li><li><p>Semantics：<br>$$<br>\text{alloc:}\quad<br>\frac{l \notin \operatorname{dom}(h)\quad [[e]]<em>{intexp} s=n}{(x:=\operatorname{alloc}(e),(s, h)) \longrightarrow(\operatorname{skip},(s { x \rightsquigarrow l } , h \uplus { I \rightsquigarrow n } ))}<br>\\quad\\text{free:}\quad<br>\frac{s\ x=l \quad l \in \operatorname{dom}(h)}{(\operatorname{free}(x),(s, h)) \longrightarrow(\operatorname{skip},(s, h \backslash { l } ))}<br>\quad or\quad \frac{s\ x=l\quad h(l)=n }{(\operatorname{free}(x),(s, h)) \longrightarrow(\operatorname{skip},(s, h- { (l,n) } )) }<br>\<br>\frac{s(x)\notin dom(h)}{(free(x),\ (s,h))\longrightarrow \mathbf{abort}}<br>\\quad\\text{lookup:}\quad<br>\frac{s\ x=l \quad h\ l=n}{(y:=[x],(s, h)) \longrightarrow(\mathbf{skip},\ (s { y \rightsquigarrow n } , h))}<br>\\quad\\text{mutation:}\quad<br>\frac{s\ x=l \quad l \in \operatorname{dom}(h) \quad [[e]]</em>{i n t e x p} s=n}{([x]:=e,(s, h)) \longrightarrow(\mathbf{s k i p},(s, h { l \rightsquigarrow n } ))}<br>$$</p></li></ul><blockquote><p>Summary of small-step structural operational semantics (SOS)：</p><p>对于 transition rules 的规则：$\large \frac{P_1 \quad \cdots\quad P_n }{(c,\ \sigma)\longrightarrow (c’,\ \sigma’)} $​，其中 $P_i$​ 是 Condition（或叫 Premise），它们可能是：</p><ul><li>Other transitions corresponding to the sub-terms</li><li>Side conditions: predicates that must be true</li></ul></blockquote><h5 id="small-step-contextual-semantics"><a href="#small-step-contextual-semantics" class="headerlink" title="small-step contextual semantics"></a>small-step contextual semantics</h5><blockquote><ul><li><p>small-step contextual semantics, a.k.a. reduction semantics</p></li><li><p>An alternative presentation of small-step operational semantics using redex and evaluation contexts.</p></li></ul></blockquote><p>引入：</p><ul><li><p>对于之前的 small-step SOS:<br>$$<br>\frac{\left(e_{1}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}, \sigma\right)}{\left(e_{1}+e_{2}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}+e_{2}, \sigma\right)}<br>\quad<br>\frac{\left(e_{2}, \sigma\right) \longrightarrow\left(e_{2}^{\prime}, \sigma\right)}{\left(\mathbf{n}+e_{2}, \sigma\right) \longrightarrow\left(\mathbf{n}+e_{2}^{\prime}, \sigma\right)}<br>\<br>\frac{\left(e_{1}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}, \sigma\right)}{\left(e_{1}-e_{2}, \sigma\right) \longrightarrow\left(e_{1}^{\prime}-e_{2}, \sigma\right)}<br>\quad<br>\frac{\left(e_{2}, \sigma\right) \longrightarrow\left(e_{2}^{\prime}, \sigma\right)}{\left(\mathbf{n}-e_{2}, \sigma\right) \longrightarrow\left(\mathbf{n}-e_{2}^{\prime}, \sigma\right)}<br>\<br>\frac{\left\lfloor\mathbf{n}<em>{1}\right\rfloor\left\lfloor+\left\rfloor\left\lfloor\mathbf{n}</em>{2}\right\rfloor=\lfloor\mathbf{n}\rfloor\right.\right.}{\left(\mathbf{n}<em>{1}+\mathbf{n}</em>{2}, \sigma\right) \longrightarrow(\mathbf{n}, \sigma)}<br>\quad \frac{\left\lfloor\mathbf{n}<em>{1}\right\rfloor\lfloor-\rfloor\left\lfloor\mathbf{n}</em>{2}\right\rfloor=\lfloor\mathbf{n}\rfloor}{\left(\mathbf{n}<em>{1}-\mathbf{n}</em>{2}, \sigma\right) \longrightarrow(\mathbf{n}, \sigma)}<br>\quad<br>\frac{\sigma(x)=\lfloor\mathbf{n}\rfloor}{(x, \sigma) \longrightarrow(\mathbf{n}, \sigma)}<br>$$</p></li><li><p>我们观察顶部的 4 条规则，发现能结合成一条：<br>$$<br>\frac{(r, \sigma) \longrightarrow\left(e^{\prime}, \sigma\right)}{(\mathcal{E}[r], \sigma) \longrightarrow\left(\mathcal{E}\left[e^{\prime}\right], \sigma\right)}<br>\\quad\<br>\begin{aligned}<br>\text{Redex: }&amp; \quad r ::= x \ \mid\ \mathbf{n+n} \ \mid\ \mathbf{n-n}<br>\<br>\text{Evaluation Context (reduction context): }&amp; \quad \mathcal{E}\ ::=\ [\ ] + e \mid [\ ]-e \mid \mathbf{n}+[\ ] \mid \mathbf{n}-[\ ]<br>\end{aligned}<br>$$</p></li></ul><p>Redex：</p><ul><li><p>redex: a syntactic expression or command that can be reduced (transformed) in one atomic step<br>$$<br>\begin{aligned}<br>r &amp; ::=\ x &amp;<br>\<br>&amp;\quad \mid n + n<br>\<br>&amp;\quad \mid x := n<br>\<br>&amp;\quad \mid skip\ ;\ c<br>\<br>&amp;\quad \mid if\ true\ then\ c\ else\ c<br>\<br>&amp;\quad \mid if\ false\ then\ c\ else\ c<br>\<br>&amp;\quad \mid while\ b\ do\ c<br>\<br>&amp;\quad \mid\ …<br>\end{aligned}<br>$$</p><ul><li>(1+3)+2 不是 redex，1+3 是 redex</li></ul></li><li><p>Local reduction rules: one rule for each redex $(r, \sigma)\longrightarrow (t, \sigma’) $</p></li><li><p>对于 local reduction rules 这里缺个例子</p></li></ul><p>Evaluation contexts：</p><ul><li><p>a term with a “hole” in the place of a sub-term</p><ul><li>Location of the hole indicates the next place for evaluation</li><li>If ℰ is a context, then ℰ[r] is the expression obtained by replacing redex r for the hole in context ℰ</li><li>Now, if (r, σ) → (t, σ’), then (ℰ[r], σ) → (ℰ[t], σ‘)</li></ul><p>$$<br>\begin{aligned}<br>&amp; \mathcal{E} ::=\ [\ ] &amp;<br>\<br>&amp;\quad \mid \mathcal{E} + e<br>\<br>&amp;\quad \mid \mathbf{n} + \mathcal{E}<br>\<br>&amp;\quad \mid x := \mathcal{E}<br>\<br>&amp;\quad \mid \mathcal{E}\ ;\ c<br>\<br>&amp;\quad \mid if\ \mathcal{E}\ then\ c\ else\ c<br>\<br>&amp;\quad \mid\ …<br>\end{aligned}<br>$$</p><ul><li>例子：<br><code>x := 1+ []</code><br><del><code>while false do x:= 1+[ ]</code></del><br><del><code>if b then c else [ ]</code></del></li></ul></li></ul><p>Global reduction rule：</p><ul><li><p>General idea of the contextual semantics</p><ul><li><p>Decompose the current term into<br>1、the next redex r<br>2、and an evaluation context ℰ (the remaining program).</p></li><li><p>Reduce the redex r to some other term t</p></li><li><p>Put t back into the original context, yielding ℰ[t].<br>$$<br>\text{Formalized as a small-step rule: } \frac{(r, \sigma)\longrightarrow (t,\sigma’)}{(\mathcal{E}[r], \sigma) \longrightarrow (\mathcal{E}[t], \sigma’) }<br>$$</p></li></ul></li><li><p><code>Contextual semantics rules = Global reduction rule + Local reduction rules for individual r</code></p></li><li><p>例子：</p><img src="image-20211029151450969.png" style="zoom:25%"></li><li><p>例子：</p><img src="image-20211029151518915.png" style="zoom:25%"></li></ul><p>Contextual semantics for boolean expressions：</p><ul><li><p>Normal evaluation of ∧：define the following contexts, redexes, and local rules<br>$$<br>\begin{aligned}<br>\mathcal{E} &amp;::= \cdots\ |\ \mathcal{E} \and b\ |\ \mathbf{true} \and \mathcal{E}\ |\ \mathbf{false}\ \and\ \mathcal{E}<br>\<br>r &amp; ::=\ldots \mid \text { true } \wedge \text { true } \mid \text { true } \wedge \text { false } \mid \text { false } \wedge \text { true } \mid \text { false } \wedge \text { false } \<br>&amp;(\text { true } \wedge \text { true, } \sigma) \longrightarrow(\text { true }, \sigma) \quad \ldots<br>\end{aligned}<br>$$</p></li><li><p>Short-circuit evaluation of ∧：<br>$$<br>\begin{aligned}<br>&amp;\mathcal{E}::=\ldots \mid \mathcal{E} \wedge b \<br>&amp;r::=\ldots \mid \text { true } \wedge b \mid \text { false } \wedge b \<br>&amp;(\text { true } \wedge b, \sigma) \longrightarrow(b, \sigma) \quad(\text { false } \wedge b, \sigma) \longrightarrow(\text { false }, \sigma)<br>\end{aligned}<br>$$</p></li></ul><blockquote><p>Summary of contextual semantics：</p><ul><li>Think of a hole as representing a program counter (PC, it means the local command will be executed)</li><li>The rules for advancing holes are non-trivial<ul><li>Must decompose entire command at every step</li><li>So, inefficient to implement contextual semantics directly</li></ul></li><li>Major advantage of contextual semantics is that it allows a mix of global and local reduction rules<ul><li>Global rules indicate next redex to be evaluated (defined by the grammar of the context)</li><li>Local rules indicate how to perform the reduction one for each redex</li></ul></li><li>We have discussed small-step semantics, which describes each single step of the execution<ul><li>Structural operational semantics</li><li>Contextual semantics</li></ul></li></ul></blockquote><h4 id="Big-step"><a href="#Big-step" class="headerlink" title="Big-step"></a>Big-step</h4><p>Big-step semantics (a.k.a. natural semantics)：</p><ul><li>which describes the overall result of the execution</li></ul><p>$$<br>\overline{(n, \sigma) \Downarrow\lfloor\mathbf{n}\rfloor}<br>\quad<br>\frac{\sigma x=n}{(x, \sigma) \Downarrow n}<br>\\quad\<br>\frac{\left(e_{1}, \sigma\right) \Downarrow n_{1} \quad\left(e_{2}, \sigma\right) \Downarrow n_{2}}{\left(e_{1}+e_{2}, \sigma\right) \Downarrow n_{1}\lfloor+\rfloor n_{2}} \quad\quad \frac{\left(e_{1}, \sigma\right) \Downarrow n_{1} \quad\left(e_{2}, \sigma\right) \Downarrow n_{2}}{\left(e_{1} \ \mathbf{op}\ e_{2}, \sigma\right) \Downarrow n_{1}\lfloor \mathbf{op}\rfloor n_{2}}<br>$$</p><ul><li><p>例子</p><ul><li>big-step：</li></ul><img src="image-20211029160718989.png" style="zoom:25%"> * small-step：$(3+(2+1), \sigma) \longrightarrow(3+3, \sigma) \longrightarrow(6, \sigma) $ * 结论：Big-step semantics more closely models a recursive interpreter.</li><li><p>for boolean expression：<br>$$<br>\overline{(\text{true, } \sigma) \Downarrow \text { true }} \quad \overline{(\text{false, } \sigma) \Downarrow \text { false }}<br>\<br>\text{Normal evaluation of }\and : \frac{\left(b_{1}, \sigma\right) \Downarrow \text { false } \quad\left(b_{2}, \sigma\right) \Downarrow \text { true }}{\left(b_{1} \wedge b_{2}, \sigma\right) \Downarrow \text { false }}<br>\<br>\text{Short-circuit evaluation of }\and : \frac{\left(b_{1}, \sigma\right) \Downarrow \text { false }}{\left(b_{1} \wedge b_{2}, \sigma\right) \Downarrow \text { false }}<br>$$</p></li><li><p>for statements：<br>$$<br>\frac{(e, \sigma) \Downarrow n}{(x:=e, \sigma) \Downarrow \sigma { x \rightsquigarrow n } }<br>\<br>\frac{}{(\text {skip, } \sigma) \Downarrow \sigma}<br>\<br>\frac{\left(c_{0}, \sigma\right) \Downarrow \sigma^{\prime} \quad\left(c_{1}, \sigma^{\prime}\right) \Downarrow \sigma^{\prime \prime}}{\left(c_{0} ; c_{1}, \sigma\right) \Downarrow \sigma^{\prime \prime}} \quad \frac{(b, \sigma) \Downarrow \text { true }\left(c_{0}, \sigma\right) \Downarrow \sigma^{\prime}}{\left(\text{if } b \text { then } c_{0} \text { else } c_{1}, \sigma\right) \Downarrow \sigma^{\prime}}<br>\<br>\frac{(b, \sigma) \Downarrow \text {false} \quad\left(c_{1}, \sigma\right) \Downarrow \sigma^{\prime}}{\left(\text {if } b \text { then } c_{0} \text { else } c_{1}, \sigma\right) \Downarrow \sigma^{\prime}} \quad \frac{(b, \sigma) \Downarrow \text { false}}{\text {(while } b \text { do } c, \sigma) \Downarrow \sigma}<br>\<br>\frac{(b, \sigma) \Downarrow \text{true}\quad (c, \sigma) \Downarrow \sigma^{\prime} \quad (\text {while } b \text { do } c, \sigma) \Downarrow \sigma^{\prime \prime}} {\left(\text {while } b \text { do } c, \sigma^{\prime}\right) \Downarrow \sigma^{\prime \prime}}<br>$$</p></li><li><p>for variable declaration：<br>$$<br>\frac{(e, \sigma) \Downarrow n \quad\quad (c, \sigma { x \rightsquigarrow n } ) \Downarrow \sigma^{\prime}}{(\text{newvar } x:=e \text { in } c, \sigma) \Downarrow \sigma^{\prime} { x \rightsquigarrow \sigma x } }<br>$$</p></li><li><p>for abort：<br>$$<br>\frac{(e, \sigma) \Downarrow \mathbf{abort}}{(x:=e, \sigma) \Downarrow \mathbf { abort }} \quad \frac{\left(c_{0}, \sigma\right) \Downarrow \mathbf { abort }}{\left(c_{0} ; c_{1}, \sigma\right) \Downarrow \mathbf{abort}}<br>$$</p><ul><li>和 small-step 等价：<br>$(c, \sigma)\Downarrow \mathbf{abort}\quad \text{iff}\quad (c,\sigma)\longrightarrow^* \mathbf{abort} \ (c,\sigma)\Downarrow\sigma’\quad\text{iff}\quad (c,\sigma)\longrightarrow^*(\mathbf{skip}, \sigma’)$</li></ul></li></ul><p>Some facts about $\Downarrow $：</p><ul><li>Theorem (Determinism)：<br>$\large \forall e, \sigma, n, n’.\quad (e, \sigma)\Downarrow n \and (e, \sigma)\Downarrow n’ \quad \Longrightarrow\quad n = n’ $​​</li><li>Theorem (Totality)：<br>$\large \forall e,\sigma.\ \exists n.(e,\sigma)\Downarrow n$​​</li><li>Theorem (Equivalence to small-step semantics)：<br>$\large (e,\sigma) \Downarrow \lfloor \mathbf{n} \rfloor \quad \text{iff} \quad(e,\sigma)\Longrightarrow^* (\mathbf{n}, \sigma) $​</li></ul><blockquote><p>Small-step vs. Big-step：</p><ul><li>Small-step can clearly model more complex features, like concurrency, divergence, and runtime errors.</li><li>Although one-step-at-a-time evaluation is useful for proving certain properties, in some cases it is unnecessary work to talk about each small step.</li><li>Big-step semantics more closely models a recursive interpreter.</li><li>Big-steps may make it quicker to prove things, because there are fewer rules. The “boring” rules of the small-step semantics that specify order of evaluation are folded in big-step rules.</li><li>Big-step: all programs without final configurations (infinite loops, getting stuck) look the same. So you sometimes can’t prove things related to these kinds of configurations.</li></ul></blockquote><blockquote><p>Summary of operational semantics：</p><ul><li>Precise specification of dynamic semantics</li><li>Simple and abstract (compared to implementations)<ul><li>No low-level details such as memory management, data layout, etc</li></ul></li><li>Often not compositional (e.g. while)</li><li>Basis for some proofs about languages</li><li>Basis for some reasoning about particular programs</li><li>Point of reference for other semantics</li></ul></blockquote><h2 id="Hoare-Logic"><a href="#Hoare-Logic" class="headerlink" title="Hoare Logic"></a>Hoare Logic</h2><blockquote><p>Floyd-Hoare Logic is a method of reasoning mathematically about imperative programs. Hoare Logic 是一种对命令式程序进行性质证明的方法。</p><p>这节课讲的是命令式程序的公理语义 axiomatic semantics。</p><p>hoare logic 的研究至今都很活跃，比如：</p><ul><li>separation logic (reasoning about pointers)</li><li>concurrent program logics</li></ul></blockquote><p>以下的命令式语言还是以这个为例：</p><img src="image-20211115193440105.png" style="zoom:50%"><h3 id="Program-Specifications"><a href="#Program-Specifications" class="headerlink" title="Program Specifications"></a>Program Specifications</h3><blockquote><p>如何刻画程序性质？一个简单的想法 —— 描述程序执行前和执行后的两个状态：<br><img src="image-20211115193801591.png" style="zoom:67%"></p></blockquote><p>Hoare’s notation (Hoare triples)：</p><ul><li><p>假设有一个程序 c，开始状态 p，结束状态 q</p><ul><li>partial correctness specification：<code>{p}c{q}</code>，partial 的意思是，有一些状态 p 在程序 c 下不会映射到终止状态，但是一旦可以终止，那么终止状态满足 q</li><li>total correctness specification: <code>[p]c[q]</code>，total 的意思是状态 p 执行程序 c，一定会终止，并且终止状态满足 q，比起 partial correctness 多了 “终止” 的信息<ul><li>Informally: Total correctness = Termination + Partial correctness</li><li>如果要证明 total correctness，就可以分开证 partial 和 termination</li></ul></li><li>其他：<ul><li>p 和 q 是 assertions 断言，p 叫 precondition 先验条件，q 叫 postcondition 后验条件</li><li>历史上用 <code>p{c}q</code> 作 notation 也可，只不过现在用得少了。</li></ul></li></ul></li><li><p>Logical variables：</p><ul><li>先看看这个 $\left { x=x_{0} \wedge y=y_{0}\right } r:=x ; x:=y ; y:=r\left { x=y_{0} \wedge y=x_{0}\right } $</li><li>其中 $x_0$ 和 $y_0$ 就叫做 logical variables，也叫 ghost variables<ul><li>他们只用在 assertion，不会出现在程序 c</li><li>可能是常量值</li></ul></li></ul></li><li><p>一些例子 program specs（注意下面由花括号有中括号），partial correctness 要求程序若能终止则它最终状态满足 q，但是如果程序不终止的话，那自然满足了：</p><img src="image-20211115195320616.png" style="zoom:67%"> <img src="image-20211115200613483.png" style="zoom:67%"></li><li><p>Specification 可能会很 tricky：</p><ul><li><p>一个例子：将 y 设置为 x 和 y 的最大值<br>回答是<code>[true]c[y = max(x, y)]</code> 吗？当然不是，有几种程序都满足这个：</p><ul><li><code>if x&gt;= y then y:=x else skip</code></li><li><code>if x&gt;=y then x:=y esle skip</code></li><li><code>y := x</code></li></ul><p>正确的答案是 <code>[x = x0 ∧ y = y0] c [y = max(x0,y0)]</code></p></li><li><p>总结</p><ul><li>specification 很容易写错</li><li>证明系统对写错的 specification 计算证明出来了也没有什么用，因为 p, q 就写错了</li><li>此时 testing 反而是有用的</li></ul></li></ul></li></ul><p>Assertions：</p><ul><li><p>predicate logic (a.k.a. first-order logic) forms the basis for program specification</p><img src="image-20211115221917199.png" style="zoom:50%"></li><li><p>derivation of assertions：</p><ul><li><code>⊢ p</code>: there exists a proof or derivation of p following the inference rules.</li></ul></li><li><p>semantics of assertions</p><ul><li><code>σ ⊨ p</code>: p holds in σ<img src="image-20211115223031200.png" style="zoom:50%"></li></ul></li><li><p>补充：<code>⊢ J</code> 是证明（意味着 J 可被证明），<code>⊨</code> 是关心它的性质</p></li><li><p>Validity of assertions</p><ul><li>p holds in σ (i.e. σ ⊨ p)</li><li>p is valid: <code>for all σ, p holds in σ</code></li><li>p is unsatisfiable: <code>┌p is valid</code></li></ul></li></ul><h3 id="Inference-Rules-of-Hoare-Logic"><a href="#Inference-Rules-of-Hoare-Logic" class="headerlink" title="Inference Rules of Hoare Logic"></a>Inference Rules of Hoare Logic</h3><blockquote><p>构造 partial correctness specifications 的形式化，需要有公理 axioms 和推导规则。这就是 Floyd-hoare logic 所提供的：</p><ul><li>Hoare 的演绎系统形式化</li><li>Floyd 的一些基本思想</li></ul></blockquote><p>Judgments 有三种：</p><ul><li>predicate logic formulas</li><li>partial correctness specification</li><li>total correctness specification</li></ul><h4 id="Rules-for-Hoare-Logic"><a href="#Rules-for-Hoare-Logic" class="headerlink" title="Rules for Hoare Logic"></a>Rules for Hoare Logic</h4><p>The assignment rule of Hoare logic：<br>$$<br>\frac{}{ { p [ e/x ] } x:=e { p } } \text{(AS)}<br>$$</p><ul><li><p>通过上面这个 rule，你会发现，The most central aspect of imperative languages is reduced to simple syntactic formula substitution<br>例子：</p><img src="image-20211115231017375.png" style="zoom:67%"></li><li><p>可能有人觉得上面这个赋值语句规则是 “backwards” 的，那 forward 版的应该是怎样呢：<br>$$<br>\frac{}{ { p } \ x:=e\ { \exists v.x = e [ v/x ] \wedge p [ v/x ] } } \text{(AS-FW)}<br>$$</p><ul><li><p>这里的 v 是一个 fresh variable，用于指代 x 的旧值，但 v 不等价于 x，也不出现在 p 或 e 中</p><p>例子：</p><img src="image-20211116110713393.png" style="zoom:50%"></li><li><p>虽然感觉 forward 很符合直觉，但是实际上比 backwards 更难用（因为引入了 exists，若不能很快消除，则会一路带着）</p></li></ul></li></ul><p>引入 SP 和 WC：</p><ul><li><p>Strengthening precedent (SP) 增强前条件：<br>$$<br>\frac{ p \Rightarrow q \quad { q } c { r } }{ { p } c { r } } \text{(SP)}<br>$$</p></li><li><p>Weakening consequent (WC) 减弱后条件：<br>$$<br>\frac{ { p } c { q } \quad q \Rightarrow r}{ { p } c { r } } \text{(WC)}<br>$$</p></li><li><p>The consequence rules（用上面两条规则可 derive 出这条规则，用这条规则也可以导出上面两个）：<br>$$<br>\frac{p\Rightarrow p’\quad { p’ } c { q’ } \quad q’\Rightarrow q}{ { p } c { q } }<br>$$</p><ul><li>这条规则不是语法制导的，没法通过 c 来确定什么时候用这条规则，需要根据使用者判断</li></ul></li><li><p>例子：</p><img src="image-20211116171842999.png" style="zoom:50%"> <img src="image-20211116171900449.png" style="zoom:50%"></li></ul><p>其他语句的 rules：</p><ul><li><p>The sequential composition rule<br>$$<br>\frac{ { p } c_{1} { r } \quad { r } c_{2} { q } }{ { p } c_{1} ; c_{2} { q } }\text{(sc)}<br>$$</p><ul><li>例子：<img src="image-20211116215741384.png" style="zoom:67%"></li><li>例子：<img src="image-20211116215759316.png" style="zoom:67%"></li></ul></li><li><p>The skip rule：<br>$$<br>\frac{}{ { p } \mathbf{s k i p} { p } } \text { (SK) }<br>$$</p></li><li><p>The conditional rule:<br>$$<br>{ { p \wedge b } \ c_1\ { q } \ \ \ \ \ \ { p \wedge \neg b } \ c_2\ { q } \over { p } \ \textbf{if } b \textbf{ then } c_1 \textbf{ else } c_2\ { q } }\ (\texttt{CD})<br>$$</p><ul><li>例子：<img src="image-20211116220412391.png" style="zoom:67%"></li></ul></li><li><p>conjunction/disjunction rules:<br>$$<br>{ { p } \ c\ { q } \ \ \ \ \ \ { p’ } \ c\ { q’ } \over { p \wedge p’ } \ c\ { q \wedge q’ } }\ (\texttt{CA})<br>\\<br>{ { p } \ c\ { q } \ \ \ \ \ \ { p’ } \ c\ { q’ } \over { p \vee p’ } \ c\ { q \vee q’ } }\ (\texttt{DA})<br>$$</p><ul><li>这两条规则可以没有，但有的话会更方便，比如证明 <code>{p}c{q1∧q2}</code> 可以拆成 <code>{p}c{q1}</code> 和 <code>{p}c{q2}</code> 利用上面来证</li><li>到目前未知给出的 rules 都会满足 total correctness（因为还没引入循环，程序还是能终止的）</li></ul></li></ul><p>引入循环：</p><ul><li><p>partial correctness of while:<br>$$<br>{ { i \wedge b } \ c\ { i } \over { i } \ \textbf{while } b \textbf{ do } c\ { i \wedge \neg b } }\ (\texttt{WHP})<br>$$</p><ul><li><p><code>i</code> 是 loop invariant 循环不变式，如果执行一次 c 能保持 i 前后成立，那执行任意次也可以，最终在 while 结束时，一定是循环条件不成立了</p></li><li><p>例子：</p><img src="image-20211116224431663.png" style="zoom:43%"><ul><li><p>例子（计算 x/y）：</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;true&#125;  r:=x; z:=0; while y&lt;=r do r:=r-y;z:=z+1; &#123;y&lt;y∧x=r+y*z&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><pre><code>证明：有空再证</code></pre><ul><li><p>如何找 loop invariant</p><ul><li>观察性质<ul><li>初始化时 invariant i 是满足的</li><li><code>i ∧ ┌b</code> 在结果一定成立</li><li>b 满足时，方法 c 会 preserve 这个 i</li></ul></li><li>思考循环中的 loop invariant<ul><li>what <font color="blue">has been done</font> so far together with what <font color="blue">remains to bedone</font></li><li>holds <font color="blue">at each iteration</font> of the loop</li><li>and gives <font color="blue">the desired result</font> when the loop terminates</li></ul></li><li>例子：<img src="image-20211121104243940.png" style="zoom:50%"><ul><li>这个例子在求 factorial，对于它，一个顺其自然的 invariant 是 $f= x!$</li><li>但需要注意，结尾我们需要 $f=n!$，而循环规则只会给我们 $\neg(x&lt;n)$</li><li>所以有时候需要对 invariant 进行 strengthen 一下，使得他们能 work</li><li>所以最终的 invariant 应该是 $f=x ! \wedge x \leq n $，后面部分的 $x\le n$ 和 $\neg(x\lt n)$ 结合后能导出 $x=n$</li></ul></li><li>例子：<img src="image-20211121105003704.png" style="zoom:50%"><ul><li>这个例子和上面的类似，我们思考一下循环做的事情：<ul><li>过程中 f 保存着结果</li><li>剩下的 x! 是仍需要被计算的</li><li>n! 是我们期待的结果</li></ul></li><li>所以一个循环不变式是 <code>f * x! = n!</code>，x 变小，f 变大，好像很合理</li><li>注意一下结尾我们还需要 x=0，而 (WHP) 只会给 $\neg (x&gt;0)$</li><li>所以加强一下不变式，得到 $(f * x !=n !) \wedge x \geq 0 $</li></ul></li></ul></li><li><p>证明 partial correctness</p><ul><li>例子：<img src="image-20211121112311941.png" style="zoom:50%"></li></ul></li><li><p>total correctness of while:<br>$$<br>{[i \wedge b \wedge (e = x_0)]\ c\ [i \wedge (e &lt; x_0)] \ \ \ \ \ \ i \wedge b \Rightarrow e \geqslant 0 \over [i]\ \textbf{while } b \textbf{ do } c\ [i \wedge \neg b]}\ (\texttt{WHT})<br>\\<br>\text{Here,}\quad x_0 \notin \text{fv}( c ) \cup \text{fv}(e) \cup \text{fv}(i) \cup \text{fv}(b)<br>$$</p><ul><li><p>$x_0 $​​ 是 logical variable，e 是 variant</p></li><li><p>在我们设定的 language 里，while 是唯一可以导致 non-termination 的语句，所以证明 total correctness 就要证明 while 语句的终止</p></li><li><p>此外，我们要找到 some non-negative metric (e.g. a loop counter) decreases on each iteration of c</p></li><li><p>variant: this decreasing metric</p><ul><li><p>例子：<img src="image-20211121105003704.png" style="zoom:50%"></p><p>找到 invariant：$i \stackrel{\text { def }}{=}(f=x ! \wedge x \leq n) $，找到 variant：$e \stackrel{\text { def }}{=}(n-x) $​</p></li></ul></li><li><p>basic idea:</p><ul><li>the first premise: the metric is decreased by execution of c</li><li>the second premise: when the metric becomes negative, b is false, and the loop terminates (invariant i is always satisfied)</li></ul></li><li><p>补充 Termination specifications<br>$$<br>\frac{ { p } c { q } \quad[p] c[\text{true}]}{[p]c[q]}<br>\<br>\frac{[p] c[q]}{ { p } c { q } } \quad \frac{[p] c[q]}{[p] c[\text{true}]}<br>\<br>\frac{ { p } c { q } \quad \text{no while in c}}{[p]c[q]}<br>$$</p></li><li><p>例子：</p><img src="image-20211122154215600.png" style="zoom:45%"><p>Loop invariant 是 $i \overset{def}{=} x\le 10$<br>Loop variant 是 $e\overset{def}{=} 10-x=x_0$<br>b 是 $x\not= 10 $<br>$$<br>\Large<br>\frac{<br>\frac{<br>\frac{</p><pre><code>x\le10 \and x\not=10 \and 10-x=x_0 \Rightarrow x+1\le10\and 10-(x+1)\lt x_0
\quad\quad
 \{ x+1\le10\and 10-(x+1)\lt x_0]\ x:=x+1\ [x\le10\and 10-x\lt x_0 \} </code></pre><p>}{[x\le10 \and x\not=10 \and 10-x=x_0]\ x:=x+1\ [x\le10\and 10-x\lt x_0]}<br>\quad\quad<br>x\le10 \and x\not=10 \Rightarrow 10-x \ge 0<br>}{[x \leq 10] \text { while } x \neq 10 \text{ do}\ x:=x+1\ [x\le10\and \neg(x\not=10)] \quad\quad x\le10\and \neg (x\not=10)\Rightarrow x=10}<br>}{[x \leq 10] \text { while } x \neq 10 \text { do } x:=x+1[x=10]}<br>$$</p></li><li><p>例子：<br>$$<br>c \stackrel{\text { def }}{=} f:=1 ; \text { while } x&gt;0 \text { do }(f:=f * x ; x:=x-1)<br>\<br>[x=n]\ c\ [x&lt;0 \vee f=n !]<br>$$<br>证明两个 goal：$(G 1)[x&lt;0] c[x&lt;0] \(G 2)[x=n \wedge x \geq 0] c[f=n !] $</p><img src="image-20211122164752901.png" style="zoom:25%"></li></ul></li></ul><h4 id="make-it-easier-to-apply"><a href="#make-it-easier-to-apply" class="headerlink" title="make it easier to apply"></a>make it easier to apply</h4><p>Derived rules（导出一些简化证明的 rules）：</p><ul><li><p>Assignment:<br>$$<br>{p \Rightarrow q[e/x] \over { p } \ x:=e\ { q } }<br>$$</p></li><li><p>Sequenced assignment:<br>$$<br>{ { p } \ c\ { q[e/x] } \over { p } \ c;x:=e\ { q } }<br>$$</p></li><li><p>while rule for partial correctness:<br>$$<br>{p \Rightarrow i \ \ \ \ \ \ { i \wedge b } \ c\ { i } \ \ \ \ \ \ i \wedge \neg b \Rightarrow q \over { p } \ \textbf{while } b \textbf{ do } c\ { q } }<br>$$</p></li><li><p>while rule for total correctness:<br>$$<br>\begin{aligned}<br>&amp; p \Rightarrow i \<br>&amp; i \wedge b \Rightarrow e \geqslant 0 \<br>&amp; i \wedge \neg b \Rightarrow q \<br>&amp;[i \wedge b \wedge (e=x_0)]\ c\ [i \wedge (e &lt; x_0)]\end{aligned}<br>\over [p]\ \textbf{while } b \textbf{ do } c\ [q]<br>$$</p></li><li><p>multiple sequential composition:<br>$$<br>\frac{\begin{aligned} &amp; p_0 \Rightarrow q_0 \<br>&amp; { q_0 } \ c_0 { p_1 } &amp; p_1 \Rightarrow q_1 \<br>&amp; \dots &amp; \dots \<br>&amp; { q_{n-1} } \ c_{n-1} { p_n } &amp; p_n \Rightarrow q_n \end{aligned}}{ { p_0 } \ c_0;\dots;c_{n-1}\ { q_n } } \quad\quad (\texttt{MSQ}_n)<br>$$</p></li></ul><p>Annotating programs:</p><ul><li>还记得吗 sequential composition rule：$\frac{ { p } c_{1} { r } \quad { r } c_{2} { q } }{ { p } c_{1} ; c_{2} { q } }\text{(sc)} $​ 里引入了一个新的 assertion r</li><li>所以为了用这条 rule，就必须要找到一个合适的 assertion（类似要用 WHP 就要找 invariant），比如，若 $c_2$ 是 $x:=e$，那么 r 就是 $q[e/x] $</li><li>在开始证明之前，在程序中找出 assertion 并标记上是对证明有帮助的，比如 <img src="image-20211122234139802.png" style="zoom:50%"></li></ul><blockquote><p>上面两种 —— derived rules 和 annotating programs 可以简化手工证明，但其实都是为了下面的 mechanize</p><p>program verification 服务</p></blockquote><h3 id="Automated-program-verification"><a href="#Automated-program-verification" class="headerlink" title="Automated program verification"></a>Automated program verification</h3><blockquote><p>这一节会介绍一下 the architecture of a simple program verifier，当然这也是 with respect to the rules of Hoare Logic 的</p><p>需要清楚：</p><ul><li>证明是冗长又无聊的（即使程序可能很简单）</li><li>有很多琐碎的小细节需处理，其中很多是微不足道的 lots of fiddly little details to get right, many of which are trivial，比如 <code>(r = x ^ z = 0) =&gt; (x = r + y   z)</code></li></ul></blockquote><p>Architecture of a verifier:</p><img src="image-20211123150225384.png" style="zoom:50%"><ul><li><p>输入：hoare tuple 或者 annotated specification，用户可以再插入一些中间 assertions</p></li><li><p>用 verifier 证明 <code>{p}c{q}</code> 有 3 步：</p><ul><li><p>在程序 c 中 annotate 一些 assertion</p><p>（这很 tricky，需要智慧和对程序的理解，也许以后可以用 AI 解决）</p></li><li><p>从 annotated specification 生成一些 logic formulas (a.k.a. verification conditions, VCs)<br>（这是可以纯机械化完成的）</p></li><li><p>VCs 进而被传到 theorem prover，进行证明，证不了会报给程序员</p></li></ul></li></ul><p>这部分（Automated program varification）没学完</p><p>TODO: PPT 109页~145页。。。。</p><h3 id="Soundness-and-Completeness"><a href="#Soundness-and-Completeness" class="headerlink" title="Soundness and Completeness"></a>Soundness and Completeness</h3><blockquote><p>The set of inference rules gives us a logic system. This kind of logic is called program logic, which is designed specifically for program verification.</p><p>We use <code>⊢{p}c{q}</code> to represent that there is a derivation of <code>{p}c{q}</code> following the rules. 称 <code>⊢{p}c{q}</code> 为 judgement，它是由 Hoare Logic 定义和推导出来的，此时这里不涉及这个式子的含义，是纯 syntactic 的东西。</p><p>We use <code>⊨ {p}c{q}</code> to represent the meaning of <code>{p}c{q}</code>. 用语义来定义这个式子的含义，比如 Hoare logic 里就是 “程序开始满足p执行c能终止则满足q” 这个含义，这是现实生活中的含义，需要用语义来定义。</p><p>程序逻辑的 Soundness、Completeness 就是建立 <code>⊢{p}c{q}</code> 和 <code>⊨ {p}c{q}</code> 之间的关系。</p><p>简单来说，若 <code>⊢</code> 能推出 <code>⊨</code>，即是 soundness 有保证，那么凡是逻辑上能推导的东西，那它语义上一定对；若 <code>⊨</code> 能推出 <code>⊢</code>，即是说 completeness 有保证，那么凡是含义上是对的东西，那 syntax 上都能被 Hoare logic 推导。</p></blockquote><p>Soundness of the program logic:</p><ul><li>If <code>⊢{p}c{q}</code>, we have <code>⊨ {p}c{q}</code></li><li>If <code>⊢[p]c[q]</code>, we have <code>⊨ [p]c[q]</code></li></ul><p>Completeness of the program logic:</p><ul><li>If <code>⊨ {p}c{q}</code>, we have <code>⊢ {p}c{q}</code></li><li>If <code>⊨ [p]c[q]</code>, we have <code>⊢ [p]c[q]</code></li></ul><blockquote><p>如果底层逻辑 underlying logic 是可靠和完备的，那么 Hoare logic 也是。（比如，若要证 <code>{p}c{q}</code>，而恰好底层逻辑能给 <code>{p&#39;}c&#39;{q&#39;}</code> 和 <code>p=&gt;p&#39;</code> 和 <code>q&#39;=&gt;q</code>）但底层逻辑，即 predicate logic 是 sound 但 incomplete 的。</p><p>下面来证。</p></blockquote><h4 id="证明-Hoare-logic-的可靠性和完备性"><a href="#证明-Hoare-logic-的可靠性和完备性" class="headerlink" title="证明 Hoare logic 的可靠性和完备性"></a>证明 Hoare logic 的可靠性和完备性</h4><p>Roadmap:</p><ul><li><p>Review of predicate logic:</p><ul><li>syntax<img src="image-20211219100126369.png" style="zoom:50%"></li><li>semantics<img src="image-20211219100503216.png" style="zoom:50%"> <img src="image-20211219100756759.png" style="zoom:50%"></li><li>soundness and completeness<ul><li>Soundness: if <code>⊢p</code> then <code>⊨p</code>。这个可以顺着 <code>⊢p</code> 的推导，用离散数学学过的逻辑来推 <code>⊨p</code></li><li>Completeness: if <code>⊨p</code> then <code>⊢p</code>。不可证。<ul><li>Godel’s incompleteness theorem: there exists no proof system for arithmetic in which all valid assertions are systematically derivable.</li></ul></li></ul></li></ul></li><li><p>Formal semantics of Hoare triples:</p><ul><li><p>Preconditions and postconditions</p></li><li><p>Semantics of commands</p></li><li><p>Soundness of Hoare axioms and rules</p></li><li><p>Completeness and relative completeness</p></li></ul></li></ul><p>Semantics of Hoare triples:</p><ul><li><p><code>{p}c{q}</code> is is valid, iff</p><ul><li>if <code>c</code> is executed in a state <code>σ</code> such that <code>σ ⊨ p</code></li><li>and if the execution of <code>c</code> starting in <code>σ</code>  terminates in a state <code>σ&#39;</code></li><li>then <code>σ&#39; ⊨ q</code></li></ul></li><li><p>下面来形式化它<br>$$<br>\models { p } c { q } \text { iff } \forall \sigma, \sigma^{\prime} .(\sigma \models p) \wedge\left((c, \sigma) \longrightarrow^{*}\left(\text {skip, } \sigma^{\prime}\right)\right) \Rightarrow\left(\sigma^{\prime} \models q\right)</p><p>\\<br>\models[p] c[q] \text { iff } \forall \sigma \cdot(\sigma \models p) \Rightarrow \exists \sigma^{\prime} .\left((c, \sigma) \longrightarrow^{*}\left(\text {skip, } \sigma^{\prime}\right)\right) \wedge\left(\sigma^{\prime} \models q\right)<br>$$</p></li><li><p>上式在这个语言是 deterministic 时是可以的，但是倘若 c 是一些带有不确定性的语句，比如 C 中的 alloc 或涉及随机数的语句，即 c 所在的语言不是 <strong>deterministic</strong> 的，那就不对了，此时无法表达 “执行c能终止” 这个事情。</p></li></ul><p>Soundness proof (for partial correctness)</p><ul><li><p>Soundness: If <code>⊢{p}c{q}</code>, we have <code>⊨ {p}c{q}</code></p></li><li><p>Definition $\text{Safe}^n(c,\sigma,q) $</p><ul><li>$\text{Safe}^0(c,\sigma,q) $ always holds</li><li>$\text{Safe}^{n+1}(c,\sigma,q) $ Holds iff one of the following is true<ul><li><code>c=skip</code> and <code>σ ⊨ q</code>; or</li><li>There exist c’ and σ’ such that $(c,σ)\longrightarrow (c’,σ’)$ and $\text{Safe}^n(c’,\sigma’,q) $</li></ul></li><li>We say $\text{Safe}(c,\sigma,q) $ iff $\text{Safe}^n(c,\sigma,q) $ holads for all n.</li></ul></li><li><p>Lemma 1</p><ul><li>For all σ, if <code>σ ⊨ p</code> implies $\text{Safe}(c,\sigma,q) $, then <code>⊨{p}c{q}</code></li></ul></li><li><p>Lemma 2</p><ul><li>If <code>⊢{p}c{q}</code>, then for all σ such that <code>σ⊨p</code>, we have $\text{Safe}(c,\sigma,q) $</li></ul></li></ul><p>TODO: PPT 159页~171页，被略过了。。。。</p><p>Semantics and soundness based-on big-step semantics:</p><ul><li>证明会更简单</li><li>证明略。。。</li></ul><p>Incompleteness of Hoare logic:</p><ul><li><p>证法1: observe that for any p<br>$$<br>\begin{aligned}<br>\models { \text {true} } \mathbf{s k i p} { p } &amp;\Leftrightarrow&amp; \models p \<br>\vdash { \text {true} } \mathbf{s k i p} { p } &amp;\Leftrightarrow&amp; \vdash p<br>\end{aligned}<br>$$<br>如果 completeness（If <code>⊨ {p}c{q}</code>, we have <code>⊢ {p}c{q}</code>） 能被证的话，就违背了歌德定理。</p></li><li><p>证法2 (从计算理论的角度证): <code>⊨ {true}c{false}</code> iff c does not halt. 但 halting problem 是 undecidable 的</p></li></ul><p>Relative completeness:</p><ul><li><p>实际上，incompleteness 是因为 rules(SP) 和 rules(WC) 他们都涉及谓词逻辑的蕴含 the validity of implications within predicate logic。而谓词逻辑是不 decidable 的，所以没有证明系统可以将这些 implication 都证出来。</p></li><li><p>Therefore: separation of proof system (Hoare logic) and assertion language (predicate logic)</p><p>我们将和 the validity of implications within predicate logic 相关的 Hoare logic 里的 rule 分开来。</p></li><li><p>if an “oracle” is available which decides whether a given assertion is valid, then all valid partial correctness properties can be systematically derived<br>==&gt; Relative completeness</p></li><li><p>Theorem [Cook 1978]: Hoare Logic is relatively complete（在下面式子中的上下文中证 completeness），一个例子是：$\text { if } \vDash { p } c { q } \text { then } \Gamma \vdash { p } c { q } \text { where } \Gamma= { p \mid(\models p) } $</p><ul><li>证明的思想是：if we know that a partial correctness property is valid, then we know that there is a corresponding derivation<br>一个简单的例子是：assume that, e.g., <code>{p}c1;c2{q}</code> has to be derived. This requires an intermediate assertion r such that <code>{p}c1{r}</code> and <code>{r}c2{q}</code>。具体的则是如何找到这些中间断言。</li><li></li></ul></li></ul><p>TODO: PPT 176页~193页，暂时略过了。。。。</p><h2 id="Separation-Logic"><a href="#Separation-Logic" class="headerlink" title="Separation Logic"></a>Separation Logic</h2><blockquote><ul><li><p>Separation Logic: Extension of Hoare logic for reasoning about pointers</p></li><li><p>Details took 30 years to evolve</p></li></ul><p>Overview:</p><ul><li>Low-level programming language<ul><li>Extension of simple imperative language</li><li>Commands for allocating, accessing, mutating, and deallocating data structures</li><li>Dangling pointer faults (if pointer is dereferenced)</li></ul></li><li>Program specification and proof<ul><li>Extension of Hoare logic</li><li>Separating (independent, spatial) conjunction(<em>) and implication(-\</em>)</li></ul></li><li>Inductive definitions over abstract structures</li></ul></blockquote><h3 id="The-programming-language"><a href="#The-programming-language" class="headerlink" title="The programming language"></a>The programming language</h3><img src="image-20211220100107869.png" style="zoom:67%"> <img src="image-20211220100135188.png" style="zoom:67%"> <img src="image-20211220100154261.png" style="zoom:67%"> <img src="image-20211220100346621.png" style="zoom:67%"><ul><li>Note that:<ul><li>Expressions depend only upon the store<ul><li>no side effects or nontermination</li><li>cons and [-] are parts of commands</li></ul></li><li>Allocation is nondeterminate</li></ul></li></ul><h4 id="Operational-Semantics-1"><a href="#Operational-Semantics-1" class="headerlink" title="Operational Semantics"></a>Operational Semantics</h4><ul><li>s: store (variable -&gt; value)</li><li>h: heap (address -&gt; value)</li></ul><p>$$<br>{[[ e ]]<em>{intexp} s \notin \text{dom}(h) \over (x:=[e], (s,h)) \longrightarrow \textbf{abort}}<br>\<br>{[[ e ]]</em>{intexp} s \notin \text{dom}(h) \over (x:=[e], (s,h)) \longrightarrow \textbf{abort}}<br>\<br>{[[ e ]]<em>{intexp} s = l \ \ \ \ l \in \text{dom}(h) \over ([e] := e^\prime, (s,h)) \longrightarrow (\textbf{skip}, (s, h\lbrace l \leadsto [[ e^\prime ]]</em>{intexp} s \rbrace))}<br>\<br>{[[ e ]]<em>{intexp} s \notin \text{dom}(h) \over ([e]:=[e^\prime], (s,h)) \longrightarrow \textbf{abort}}<br>\<br>{[[ e_1 ]]</em>{intexp} s = n_1 \ \ \ \ [[ e_2 ]]_{intexp} s = n_2 \ \ \ \ \lbrace l, l+1 \rbrace \cap \text{dom}(h) = \emptyset \over (x := \textbf{cons}(e_1,e_2), (s,h)) \longrightarrow (\textbf{skip}, (s\lbrace x \leadsto l \rbrace, h\lbrace l \leadsto n_1, l+1 \leadsto n_2 \rbrace))}<br>$$</p><h3 id="Assertions"><a href="#Assertions" class="headerlink" title="Assertions"></a>Assertions</h3><p>Standard predicate calculus: $\wedge \ \ \ \ \vee \ \ \ \ \neg \ \ \ \ \Rightarrow \ \ \ \ \forall \ \ \ \ \exists $</p><p>plus:</p><ul><li><code>emp</code>: empty heap</li><li><code>e↦e′</code>: singleton heap (contains one cell)</li><li><code>p1∗p2</code>: separating conjunction (heap can be split into two disjoint parts)</li><li><code>p1−∗p2</code>: separating implication (if the heap is extended with a disjoint part in which p1 holds, then p2 holds for the extended heap)</li></ul><p>Abbreviations:</p><ul><li>$e \mapsto - \overset{def}{=} \exists x^\prime.\ e \mapsto x^\prime$ where x′x′ not free in e</li><li>$e \hookrightarrow e’ \overset{\Delta}{=} e \mapsto e^\prime * \textbf{true} $</li><li>$e \mapsto e_1, \dots, e_n \overset{def}{=} e \mapsto e_1 * \cdots * (e+n-1) \mapsto e_n $</li><li>$e \hookrightarrow e_1, \dots, e_n \overset{def}{=} e \hookrightarrow e_1 * \cdots * (e+n-1) \hookrightarrow e_n $</li></ul><p>Examples of Separating Conjunction:</p><ol><li><code>x↦3,y</code> asserts that <code>[x]=3, [x+1]=y</code></li><li><code>y↦3,x</code> asserts that <code>[y]=3, [y+1]=x</code></li><li><code>(x↦3,y)∗(y↦3,x)</code> asserts that (1) and (2) hold for <strong>separate parts</strong> of the heap</li><li><code>(x↦3,y)∧(y↦3,y)</code> asserts that (1) and (2) hold for <strong>the same heap</strong>, happens only if x=y<img src="image-20211221103117187.png"></li><li><code>(x↪3,y)∧(y↪3,x)</code> asserts that either (3) or (4) may hold and that the heap may contain additional cells</li></ol><p>Example of Separating Implication:</p><ul><li>Suppose <code>p</code> holds for<ul><li>Store: <code>x:α,…</code></li><li>Heap: <code>[α]=3,[α+1]=4,…</code></li></ul></li><li>Then <code>(x↦3,4) −∗ p</code> holds for<ul><li>Store: <code>x:α,…</code></li><li>Heap: <strong>no requirements</strong></li></ul></li><li>and <code>(x↦1,2)∗((x↦3,4)−∗p)</code> holds for<ul><li>Store: <code>x:α,…</code></li><li>Heap: <code>[α]=1,[α+1]=2,…</code><img src="image-20211221103358202.png" style="zoom:50%"></li></ul></li></ul><h4 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h4><ul><li><code>[x1:y1|…|xn:yn]</code>: function with domain <code>{x1,…,xn}</code> that maps each <code>xi</code> to <code>yi</code>.</li><li><code>[f|x1:y1|…|xn:yn]</code>: function whose domain is the union of the domain of <code>f</code> and <code>{x1,…,xn}</code> that maps <code>xi</code> to <code>yi</code> and others to <code>f x</code>.</li></ul><p>For heaps:</p><ul><li><code>h0⊥h1</code>: <code>h0</code> and <code>h1</code> have disjoint domains</li><li><code>h0⋅h1</code>: the union of heaps with disjoint domains</li></ul><h4 id="The-Meaning-of-Assertions"><a href="#The-Meaning-of-Assertions" class="headerlink" title="The Meaning of Assertions"></a>The Meaning of Assertions</h4><ul><li><code>s</code>: store</li><li><code>h</code>: heap</li><li><code>p</code>: assertions whose free variables belong to the domain of <code>s</code></li></ul><p><code>s,h ⊨ p</code> indicates that the state <code>s,h</code> satisfies <code>p</code>, or <code>p</code> is true in <code>s,h</code>, or <code>p</code> holds in <code>s,h</code>.</p><ul><li>$s, h \vDash b$ iff $[[ b ]]_{boolexp} s = \textbf{true} $</li><li>$s, h \vDash p $ iff $s, h \vDash p $ is false</li><li>$s, h \vDash p_0 \wedge p_1 $ iff $s, h \vDash p_0$ and $s, h \vDash p_1 $ (similarly for $\vee, \Rightarrow, \dots $)</li><li>$s, h \vDash \forall v.\ p$ iff $\forall x \in \mathbb{Z}.\ [s | v:x], h \vDash p $</li><li>$s, h \vDash \exists v.\ p$ iff $\exists x \in \mathbb{Z}.\ [s | v:x], h \vDash p $</li><li>$s, h \vDash \textbf{emp}$ iff $\text{dom }h = \lbrace \rbrace $</li><li>$s, h \vDash e \mapsto e^\prime$ Iff $\text{dom }h = \lbrace [[ e ]]<em>{exp} s \rbrace $ and $h([[ e ]]</em>{exp} s) = [[ e^\prime ]]_{exp} s$</li><li>$s, h \vDash p_0 * p_1 $ iff $\exists h_0, h_1.\ h_0 \perp h_1$ and $h_0 \cdot h_1 = h$ and $s, h_0 \vDash p_0 $ and $s, h_1 \vDash p_1 $</li><li>$s, h \vDash p_0\ {-*}\ p_1 $ iff $\forall h^\prime.\ (h^\prime \perp h \text{ and } s, h^\prime \vDash p_0) $ implies $s, h \cdot h^\prime \vDash p_1 $</li></ul><p>Valid: When <code>s,h ⊨ p</code> holds for all states <code>s,h</code>, we say that <code>p</code> is valid.</p><p>Satisfiable: When <code>s,h ⊨ p</code> holds for some state <code>s,h</code>, we say that <code>p</code> is satisfiable.</p><p>Examples:</p><ul><li>$s, h \vDash x \mapsto y $ iff <code>dom h={s x}</code> and <code>h(s x)=s y</code></li><li>$s, h \vDash x \mapsto - $ iff <code>dom h={s x}</code></li><li>$s, h \vDash x \hookrightarrow y $ iff <code>s x∈dom h</code> and <code>h(s x)=s y</code></li><li>$s, h \vDash x \hookrightarrow - $ iff <code>s x∈dom h</code></li><li>$s, h \vDash x \mapsto y, z $ iff <code>h=[s x:s y | s x+1:s z]</code></li><li>$s, h \vDash x \mapsto -, - $ iff <code>dom h={s x,s x+1}</code></li><li>$s, h \vDash x \hookrightarrow y, z $ iff <code>h ⊇ [s x:s y | s x+1:s z]</code></li><li>$s, h \vDash x \hookrightarrow -, - $ iff <code>dom h⊇{s x, s x+1}</code></li></ul><h3 id="Inference-Rules-for-Assertions"><a href="#Inference-Rules-for-Assertions" class="headerlink" title="Inference Rules for Assertions"></a>Inference Rules for Assertions</h3><p>Inference Rules ($\mathcal{P} $ stands for premise):</p><p>$$<br>{\mathcal{P}_1 \ \ \ \ \dots \ \ \ \ \mathcal{P}_n \over \mathcal{C}}<br>$$</p><blockquote><p>Note on soundness:</p><ul><li>$\frac{p}{q} $ is sound iff for all instances, if p is valid, then q is valid.</li><li>$\dfrac{}{p \Rightarrow q} $ is sound iff for all instances, p⇒q is valid.</li></ul></blockquote><p>Inference rules for <code>∗</code> and <code>−∗</code>:</p><ul><li>$p_0 * p_1 \Leftrightarrow p_1 * p_0 $</li><li>$(p_0 * p_1) * p_2 \Leftrightarrow p_0 * (p_1 * p_2) $</li><li>$p * \textbf{emp} \Leftrightarrow p $</li><li>$(p_0 \vee p_1) * q \Leftrightarrow (p_0 * q) \vee (p_1 * q) $</li><li>$(p_0 \wedge p_1) * q {\ \Rightarrow\ } (p_0 * q) \wedge (p_1 * q) $</li><li>$(\exists x.\ p_0) * p_1 \Leftrightarrow \exists x.\ (p_0 * p_1) $ where x not free in p1</li><li>$(\forall x.\ p_0) * p_1 {\ \Rightarrow\ } \forall x.\ (p_0 * p_1) $ where x not free in p1</li><li>Monotonicity: $\Large {p_0 \Rightarrow p_1 \ \ \ \ q_0 \Rightarrow q_1 \over p_0 * q_0 \Rightarrow p_1 * q_1} $</li><li>Currying: $\Large {p_0 * p_1 \Rightarrow p_2 \over p_0 \Rightarrow (p_1 {-*} p_2)} $</li><li>Decurrying: $\Large {p_0 \Rightarrow (p_1 {-*} p_2) \over p_0 * p_1 \Rightarrow p_2} $</li></ul><p>Two <strong>Unsound</strong> Axiom Schemata:</p><ul><li>Contraction: <code>p⇒p∗p</code> (e.g. <code>p:x↦1</code>)</li><li>Weakening: <code>p∗q⇒p</code> (e.g. <code>p:x↦1</code> and <code>q:y↦2</code>)</li></ul><p>Some Axiom Schemata for <code>↦</code>:</p><ul><li>$(e_1 \mapsto e_1^\prime) \wedge (e_2 \mapsto e_2^\prime) \Leftrightarrow (e_1 \mapsto e_1^\prime) \wedge (e_1 = e_2) \wedge (e_1^\prime = e_2^\prime) $</li><li>$(e_1 \hookrightarrow e_1^\prime) * (e_2 \hookrightarrow e_2^\prime) {\ \Rightarrow\ } e_1 \neq e_2 $</li><li>$\textbf{emp} \Leftrightarrow \forall x.\ \neg(x \hookrightarrow -) $</li><li>$(e \hookrightarrow e^\prime) \wedge p {\ \Rightarrow\ } (e \mapsto e^\prime) * ((e \mapsto e^\prime) \ {-*}\ p) $</li></ul><h3 id="Classes-of-Assertions"><a href="#Classes-of-Assertions" class="headerlink" title="Classes of Assertions"></a>Classes of Assertions</h3><h4 id="Pure-Assertions"><a href="#Pure-Assertions" class="headerlink" title="Pure Assertions"></a>Pure Assertions</h4><p>An assertion p is <em>pure</em> iff, for all stores s and all heaps <code>h</code> and <code>h′</code>:<br>$$<br>s, h \vDash p \text{ iff } s, h^\prime \vDash p.<br>$$<br>A sufficient syntactic criterion is that an assertion is pure if it does not contain <strong>emp</strong>, ↦ or ↪.</p><p>Axiom Schemata for Purity:</p><ul><li><code>p0∧p1⇒p0∗p1</code> when <code>p0</code> or <code>p1</code> is pure</li><li><code>p0∗p1⇒p0∧p1</code> when <code>p0</code> and <code>p1</code> are pure</li><li><code>(p∧q)∗r⇔(p∗r)∧q</code> when <code>q</code> is pure</li><li><code>(p0−∗p1)⇒(p0⇒p1)</code> when <code>p0</code> is pure</li><li><code>(p0⇒p1)⇒(p0−∗p1)</code> when <code>p0</code> and <code>p1</code> are pure</li></ul><h4 id="Strictly-Exact-Assertions-Yang"><a href="#Strictly-Exact-Assertions-Yang" class="headerlink" title="Strictly Exact Assertions (Yang)"></a>Strictly Exact Assertions (Yang)</h4><p>An assertion is <em>strictly exact</em> iff, for all stores ss and all heaps <code>h</code> and <code>h′</code>:<br>$$<br>s, h \vDash p \text{ and } s, h^\prime \vDash p \text{ implies } h = h^\prime.<br>$$<br>Examples of Strictly Exact Assertions:</p><ul><li><code>emp</code></li><li><code>e↦e′</code></li><li><code>p∗q</code> where p and q are strictly exact</li><li><code>p∧q</code> where p or q is strictly exact</li><li><code>p where p⇒q</code> is valid and q is strictly exact</li></ul><p><strong>Proposition:</strong> When q is strictly exact, $((q * \textbf{true}) \wedge p) \Rightarrow (q * (q\ {-<em>}\ p)) $ is valid. (This leads to the final axiom schema for ↦, i.e. $(e \hookrightarrow e^\prime) \wedge p \Rightarrow (e \mapsto e^\prime) * ((e \mapsto e^\prime)\ {-</em>}\ p) $</p><h4 id="Precise-Assertions"><a href="#Precise-Assertions" class="headerlink" title="Precise Assertions"></a>Precise Assertions</h4><p>An assertion <code>q</code> is <em>precise</em> iff for all <code>s</code> and <code>h</code>, there is at most one <code>h′⊆h</code> such that<br>$$<br>s, h’ \vDash q.<br>$$<br>Examples of Precise Assertions:</p><ul><li>all strictly exact assertions</li><li><code>e ↦ −</code></li><li><code>p∗q</code> where p and q are precise</li><li><code>p∧q</code> where p or q is precise</li><li><code>p</code> where <code>p⇒q</code> is valid and <code>q</code> is precise</li></ul><p><strong>Proposition:</strong> When <code>q</code> is precise, $(p_0 * q) \wedge (p_1 * q) \Rightarrow (p_0 \wedge p_1) * q $ is valid. When $q$ is precise and $x$ is not free in $q$. $\forall x.\ (p * q) \Rightarrow (\forall x.\ p) * q $ is valid.</p><h4 id="Intuitionistic-Assertions"><a href="#Intuitionistic-Assertions" class="headerlink" title="Intuitionistic Assertions"></a>Intuitionistic Assertions</h4><p>An assertion <code>i</code> is <em>Intuitionistic</em> iff, for all stores <code>s</code> and heaps <code>h</code> and <code>h′</code>:<br>$$<br>(h \subseteq h^\prime \text{ and } s, h \vDash i) \text{ implies } s, h^\prime \vDash i<br>$$<br>Assume <code>i</code> and <code>i′</code> are intuitionistic assertions, and <code>p</code> is any assertion, then:</p><p>The following assertions are intuitionistic:</p><ul><li><p>any pure assertion</p></li><li><p><code>p∗i</code></p></li><li><p><code>p−∗i</code></p></li><li><p><code>i−∗p</code></p></li><li><p><code>i∧i′</code></p></li><li><p><code>i∨i′</code></p></li><li><p><code>∀v. i</code></p></li><li><p><code>∃v. i</code></p></li></ul><p>Special cases:</p><ul><li><code>p∗true</code></li><li><code>true −∗ p</code></li><li><code>e↪e′</code></li></ul><p>The following inference rules are sound:</p><ul><li><code>(i∗i′)⇒(i∧i′)</code></li><li><code>(i∗p)⇒i</code></li><li><code>i⇒(p−∗i)</code></li><li>$\dfrac{p \Rightarrow i}{(p * \textbf{true} \Rightarrow i)} $</li><li>$\dfrac{i \Rightarrow p}{i \Rightarrow (\textbf{true}\ {-*}\ p)} $</li></ul><h3 id="Specifications-and-Inference-Rules"><a href="#Specifications-and-Inference-Rules" class="headerlink" title="Specifications and Inference Rules"></a>Specifications and Inference Rules</h3><h4 id="Specifications"><a href="#Specifications" class="headerlink" title="Specifications"></a>Specifications</h4><ul><li>Partial correctness: {p} c {q}</li><li>Total correctness: [p] c [q]</li></ul><p>Differences with Hoare Logic:</p><ul><li>Specifications are universally quantified implicitly over both stores and heaps,</li><li>Specifications are universally quantified implicitly over all possible executions,</li><li>Any execution (from a state satisfying p) that gives a memory fault falsifies both partial and total specifications.</li></ul><h4 id="Rule-of-Constancy-unsound"><a href="#Rule-of-Constancy-unsound" class="headerlink" title="Rule of Constancy (unsound)"></a>Rule of Constancy (unsound)</h4><p>${\lbrace p \rbrace \ c \ \lbrace q \rbrace \over \lbrace p \wedge r \rbrace \ c \ \lbrace q \wedge r \rbrace} $ is unsound, e.g. ${\lbrace x \mapsto - \rbrace \ [x]:=4 \ \lbrace x \mapsto 4 \rbrace \over \lbrace x \mapsto - \wedge y \mapsto 3 \rbrace \ [x]:=4 \ \lbrace x \mapsto 4 \wedge y \mapsto 3 \rbrace}$ does not hold when x=y.</p><h4 id="★-The-Frame-Rule（Separation-logic-里最重要的-rule）"><a href="#★-The-Frame-Rule（Separation-logic-里最重要的-rule）" class="headerlink" title="★ The Frame Rule（Separation logic 里最重要的 rule）"></a>★ The Frame Rule（Separation logic 里最重要的 rule）</h4><p>$$<br>{\lbrace p \rbrace \ c \ \lbrace q \rbrace \over \lbrace p * r \rbrace \ c \ \lbrace q * r \rbrace}<br>$$</p><p>where no variable occurring free in r is modified by c.</p><p>Reasoning and specification are confined to the cells that the program actually accesses. The value of any other cell automatically remains unchanged.</p><p>Local reasoning:</p><ul><li>The set of variables and heap cells that may actually be used by a command is called its <em>footprint</em></li><li>if <code>{p} c {q}</code> is valid, then <code>p</code> will assert that the heap contains all the cells in the footprint of <code>c</code></li><li>if <code>p</code> asserts that the heap contains <em>only</em> cells in the footprint of <code>c</code>, then <code>{p} c {q}</code> is a <em>local specification</em></li><li>if <code>c′</code> contains <code>c</code>, it may have a larger footprint described by <code>p∗r</code></li></ul><h4 id="Soundness-of-the-Frame-Rule"><a href="#Soundness-of-the-Frame-Rule" class="headerlink" title="Soundness of the Frame Rule"></a>Soundness of the Frame Rule</h4><p>Consider <strong>dispose</strong> x:<br>$$<br>\lbrace \textbf{emp} \rbrace \ \textbf{dispose }x \ \lbrace \textbf{emp} \rbrace<br>$$<br>the frame rule would give:<br>$$<br>\lbrace \textbf{emp} * x \mapsto 10 \rbrace \ \textbf{dispose }x \ \lbrace \textbf{emp} * x \mapsto 10 \rbrace<br>$$<br>and thus $\lbrace x \mapsto 10 \rbrace \ \textbf{dispose }x \ \lbrace x \mapsto 10 \rbrace $ which is patently false.</p><p>We define:</p><ul><li><p>If, starting in the state <code>s,h</code>, no execution of a command <code>c</code> aborts, then <code>c</code> is safe at <code>s,h</code></p></li><li><p>If, starting in the state <code>s,h</code>, every execution of <code>c</code> terminates without aborting, then <code>c</code> must terminate normally at <code>s,h</code></p><p>Then the programming language satisfies <font color="blue">safety monotonicity</font>:</p></li><li><p>If $\hat h \subseteq h $ and c is safe at $s, h - \hat h $, then c is safe at $s, h $</p><img src="image-20211221163944917.png" style="zoom:67%"></li><li><p>If $\hat h \subseteq h $ and c must terminate normally at $s, h - \hat h $ , then c must terminate normally at $s, h $</p></li><li><p>一些理解：safety monotonicity 可以说小的状态下能执行终止，那大的状态也行</p></li></ul><p>The programming language also satisfies <font color="blue">the frame property</font>:</p><ul><li>If $\hat h \subseteq h $ and c is safe at $s, h - \hat h $ and some execution of c starting at $s,h $ terminates normally in the state $s’,h’$</li><li>then $\hat h \subseteq h’ $ and some execution of c starting at $s, h - \hat h $ terminates normally in the state $s^\prime, h^\prime - \hat h $<img src="image-20211221163959271.png" style="zoom:67%"></li><li>一些理解：frame property 可以说，从大的状态执行得到一个 heap，那么可以从小的状态执行得到一个 sub heap</li></ul><p><strong>Proposition:</strong> If the programming language satisfies <font color="blue">safety monotonicity</font> and <font color="blue">the frame property</font>, then the frame rule is sound for both partial and total correctness.</p><p><font color="red">Locality = Safety Monotonicity + the Frame Property</font></p><p>Locality 是必考内容。卷子上会给 Locality 的定义，如何理解这个定义，是必考内容。</p><h2 id="Review"><a href="#Review" class="headerlink" title="Review"></a>Review</h2><p>这门课：Formal Language，考察：读+写，</p><p>Lambda Calculus:</p><ul><li>Untyped<ul><li>Reduction</li></ul></li><li>Simply typed<ul><li>Reduction vs typing : progress &amp; preservation</li></ul></li></ul><p>Imperative languages:</p><ul><li>Operational semantics<ul><li>Small-step &amp; big-step</li></ul></li><li>Hoare logic<ul><li>Reasoning using Hoare logic</li></ul></li><li>Separation logic<ul><li>Assertion semantics &amp; locality</li></ul></li></ul></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://zhangt.top/CS/FSPL-Study-Notes/">程序设计语言的形式语义-学习笔记</a></li><li><strong>本文作者：</strong><a href="https://zhangt.top">ZhangT</a></li><li><strong>本文链接：</strong><a href="https://zhangt.top/CS/FSPL-Study-Notes/">https://zhangt.top/CS/FSPL-Study-Notes/</a></li><li><strong>发布时间：</strong>2021-10-01</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><hr style="height:1px;margin:1rem 0"><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><i class="fas fa-tags has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/tags/PL/">PL</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？投喂一下吧！ヾ(●´∀｀●)</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i> </span><span>支付宝</span><div class="qrcode"><img src="/images/alipay.jpg" alt="支付宝"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/CS/Static-Analysis-Study-Notes/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">静态分析-学习笔记</span></a></div><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/LIFE/The-Willpower-Instinct/"><span class="level-item">《自控力》阅读笔记</span> <i class="level-item fas fa-chevron-right"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"91f36240e98756fc091e",clientSecret:"20de2f4dadd54bc04ad8db6c1090fb00a9477ac4",id:"358e4507b5e13c28a63d4dd74c6f9ab9",repo:"zhangt2333.github.io",owner:"zhangt2333",admin:"zhangt2333",createIssueManually:!1,distractionFreeMode:!1});gitalk.render("comment-container")</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered"><div><img class="image is-96x96 has-mb-6" src="/images/avatar.png" alt="Zhang T"><p class="is-size-4 is-block">Zhang T</p><p class="is-size-6 is-block">感受我的感受</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Nanjing &lt;- Qingdao, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><div class="level-item has-text-centered is-marginless"><a href="/archives/"><p class="heading">文章</p><p class="title has-text-weight-normal">23</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/categories/"><p class="heading">分类</p><p class="title has-text-weight-normal">5</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/tags/"><p class="heading">标签</p><p class="title has-text-weight-normal">24</p></a></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/zhangt2333" target="_blank"><i class="fab fa-github"></i>&nbsp;&nbsp;关注我</a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu" style="max-height:750px;overflow:auto"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#程序设计语言的形式语义"><span class="has-mr-6">1</span> <span>程序设计语言的形式语义</span></a><ul class="menu-list"><li><a class="is-flex" href="#Introdution"><span class="has-mr-6">1.1</span> <span>Introdution</span></a></li><li><a class="is-flex" href="#Mathematical-backgroud"><span class="has-mr-6">1.2</span> <span>Mathematical backgroud</span></a><ul class="menu-list"><li><a class="is-flex" href="#Sets-★"><span class="has-mr-6">1.2.1</span> <span>Sets ★</span></a></li><li><a class="is-flex" href="#Relations"><span class="has-mr-6">1.2.2</span> <span>Relations</span></a></li><li><a class="is-flex" href="#Functions-★"><span class="has-mr-6">1.2.3</span> <span>Functions ★</span></a></li><li><a class="is-flex" href="#Products"><span class="has-mr-6">1.2.4</span> <span>Products</span></a></li><li><a class="is-flex" href="#Sums-or-Disjoint-Unions"><span class="has-mr-6">1.2.5</span> <span>Sums (or Disjoint Unions)</span></a></li></ul></li><li><a class="is-flex" href="#Coq-相关"><span class="has-mr-6">1.3</span> <span>Coq 相关</span></a></li><li><a class="is-flex" href="#Lambda-Calculus-λ-calculus"><span class="has-mr-6">1.4</span> <span>Lambda Calculus (λ-calculus)</span></a><ul class="menu-list"><li><a class="is-flex" href="#Syntax"><span class="has-mr-6">1.4.1</span> <span>Syntax</span></a></li><li><a class="is-flex" href="#Semantics"><span class="has-mr-6">1.4.2</span> <span>Semantics</span></a></li><li><a class="is-flex" href="#Programming-in-λ-calculus"><span class="has-mr-6">1.4.3</span> <span>Programming in λ-calculus</span></a></li></ul></li><li><a class="is-flex" href="#Simply-Typed-Lambda-Calculus-STLC"><span class="has-mr-6">1.5</span> <span>Simply-Typed Lambda Calculus (STLC)</span></a><ul class="menu-list"><li><a class="is-flex" href="#Adding-stuff-扩展"><span class="has-mr-6">1.5.1</span> <span>Adding stuff 扩展</span></a></li><li><a class="is-flex" href="#Curry-Howard-isomorphism-同构"><span class="has-mr-6">1.5.2</span> <span>Curry-Howard isomorphism 同构</span></a></li></ul></li><li><a class="is-flex" href="#Operational-Semantics"><span class="has-mr-6">1.6</span> <span>Operational Semantics</span></a><ul class="menu-list"><li><a class="is-flex" href="#Operational-semantics"><span class="has-mr-6">1.6.1</span> <span>Operational semantics</span></a></li></ul></li><li><a class="is-flex" href="#Hoare-Logic"><span class="has-mr-6">1.7</span> <span>Hoare Logic</span></a><ul class="menu-list"><li><a class="is-flex" href="#Program-Specifications"><span class="has-mr-6">1.7.1</span> <span>Program Specifications</span></a></li><li><a class="is-flex" href="#Inference-Rules-of-Hoare-Logic"><span class="has-mr-6">1.7.2</span> <span>Inference Rules of Hoare Logic</span></a></li><li><a class="is-flex" href="#Automated-program-verification"><span class="has-mr-6">1.7.3</span> <span>Automated program verification</span></a></li><li><a class="is-flex" href="#Soundness-and-Completeness"><span class="has-mr-6">1.7.4</span> <span>Soundness and Completeness</span></a></li></ul></li><li><a class="is-flex" href="#Separation-Logic"><span class="has-mr-6">1.8</span> <span>Separation Logic</span></a><ul class="menu-list"><li><a class="is-flex" href="#The-programming-language"><span class="has-mr-6">1.8.1</span> <span>The programming language</span></a></li><li><a class="is-flex" href="#Assertions"><span class="has-mr-6">1.8.2</span> <span>Assertions</span></a></li><li><a class="is-flex" href="#Inference-Rules-for-Assertions"><span class="has-mr-6">1.8.3</span> <span>Inference Rules for Assertions</span></a></li><li><a class="is-flex" href="#Classes-of-Assertions"><span class="has-mr-6">1.8.4</span> <span>Classes of Assertions</span></a></li><li><a class="is-flex" href="#Specifications-and-Inference-Rules"><span class="has-mr-6">1.8.5</span> <span>Specifications and Inference Rules</span></a></li></ul></li><li><a class="is-flex" href="#Review"><span class="has-mr-6">1.9</span> <span>Review</span></a></li></ul></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/">TTTT&#39;s Blog</a><p class="is-size-7">&copy; 2022 ZhangT&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},skipTags:["script","noscript","style","textarea","pre","code"],processEscapes:!0,tex2jax:{inlineMath:[["$","$"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>