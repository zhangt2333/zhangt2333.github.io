{"pages":[{"title":"My Resume","text":"个人简历A Programmer, A ACMer, A Text Lovers","link":"/about/index.html"}],"posts":[{"title":"ACMLife-0_0-领航帖","text":"序言不知努力打ACM的时间还有多少，想将语言、知识点、题库都重新整理、总结。大概分为三个部分：语言，包括Cpp、Java、Python在ACM方面的入门及奇技淫巧。知识点，仅代表我的学习顺序。题解，可能混在知识点章节中。目录0_0-领航帖0_1-cpp总结0_2-java总结0_3-python总结0_4-做题总结1-贪心、思维、暴力2-二分3-尺取4-三分5-开关模型、折半枚举6-搜索7-图论入门、并查集8-最小生成树9-最短路、差分约束系统、DAG10-网络流11-二分图匹配12-动态规划入门13-区间dp、状压dp14-树形dp、dp优化 (斜率优化等)15-快速幂、矩阵快速幂16-素筛、gcd、拓展gcd17-组合计数、容斥原理、lucas定理18-剩余系、费马小定理、积性函数、数学反演 （缺）19-计算几何（缺）20-RMQ范围最小值查询、BIT树状数组21-线段树、扫描线22-LCA、dfs序23-KMP、Manacher、trie树24-后缀数组25-莫队26-数位dp27-re初步","link":"/ACM/ACMLife-0_0-First/"},{"title":"ACMLife-0_1-cpp总结","text":"[TOC]序言因为入了ACM的原因初识cpp，而从来都很少地熟悉她，只是拿着通用的编程语言技巧去使用她，这未免过于肤浅。想要总结出cpp一些头文件在算法竞赛上的好用以及一些被忽略的用法，故对于一些在算法竞赛不常用且不算奇技淫巧的东西会选择性忽略。stdio.h (cstdio)在ACM比赛中，一般使用标准输入输出，读入题目输入，将程序输出与答案进行对比，来判定程序的正确性。cstdio(C Standard Input and Output Library)是C语言的原生库，比起C++新定义的流对象操作库iostream在效率方面自然更优，故建议是只用cstdio，不用iostream，因为前者熟练使用起来几乎可以替代后者，且在时间效率上无懈可击。cstdio这个库较为重要的知识在于五个方面：格式化输入输出到标准IO流格式化输入输出到字符串单字符输入输出输入输出重定向快速读入、缓冲区冲刷格式化输入输出到标准IO流主要关注两个函数scanf、printf。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/* 变量定义 */int i; double d; char c; int is[15]; unsigned int ui; long long ll;/* 读入 */scanf(\"%d %lf %c %d %u %lld\", &amp;i, &amp;d, &amp;c, &amp;is[1], &amp;ui ,&amp;ll); // 其中&amp;aa[1]可换为`aa + 1`scanf(\"%1d\", &amp;i); // 只读1位到a/* 输出 */printf(\"%d %.2f %c %s %d %u %lld\", i, d, c, s+1, is[1], ui, ll); // 注意duoble输出是%f,%.2f表示四舍五入到百分位/* 有关进制的输入输出 */int a, b; scanf(\"%o %x\", &amp;a, &amp;b); // 表示将输入看作8进制、16进制读入，比如输入\"0777 0x3FFFFFF\"(可以没有前导0、0x)。输出同理。/* 有关占位输出和标准形式输出 */printf(\"%*d\", 5, 10); // 5位长度输出整数10printf(\"%x %#x %#X\", 15, 15, 15); // 输出f 0xf 0XFprintf (\"%4.2f %+.0e %E \\n\", 3.1416, 3.1416, 3.1416); // 输出3.14 +3e+000 3.141600E+000/* 变量地址的输出 */int a; printf(\"%p %#p\", a); // 输出类似00000053 0x53/* 关于char[]的输入输出 */char s[105];scanf(\"%s\", s); // 读入一个字符串，且首指针放到s+0scanf(\"%s%s%s\", s+1, s+21, s+41); // 读入三个字符串，且首指针分贝放到s+1、s+21、s+41，注意本样例若前两个字符串长度超过19，就会在内存有重叠而造成使用出错/* 读入一行的处理 */scanf(\"%[^\\n]%*c\\n\", s); // 读入一行(第一种形式)，首指针为s+0。%*c表示忽略后一个字符scanf(\"%[^\\n]\", s);getchar(); // 读入一行(第二种形式)，首指针为s+0。getchar()表示把\\n取掉printf(\"%s %s\", s+0, s+1); // 分别表示从第0、1位开始输出，直到遇到'\\0'，所以想截断输出一个字符串还可以将字符串的某个位置置为'\\0'即可输出前半部分/* 相关于string的输入输出 */string s;s.resize(100); // 想用scanf读string必须预先设置大小scanf(\"%s\", &amp;s[0]); // 读入到stringscanf(\"%[^\\n]%*c\", &amp;s[0]); // 读入1行到string/* 对于string的用scanf读入一行 直接读入由于resize，有时会出现奇怪的问题（后面会填充为空格） 比如读入下面的格式：1this is a bug problem.*/// 建议下面这样做：char tmp[100];scanf(\"%s\", tmp+1); s=tmp+1; // 先读入到char[]再令string=char[]printf(\"%s\", s.c_str()); // 输出string/* 多组输入的实现-T组数组 */int T;scanf(\"%d\", &amp;T);while(T--) { /* 代码 */ }/* 多组输入的实现-读入到文件末尾EOF */while(~scanf(\"%d%d\",&amp;n,&amp;m)) { /* 代码 */ }/* 在stdin中输入结束符 */Unix terminal \"End of File\" (same as \"exit\" on many shells) —— ctrl+dDOS \"End of File\" —— ctrl+z格式化输入输出到字符串主要关注sscanf、sprintf。和scanf、printf的使用一致，只是输入、输出的对象从标准输入输出变成了char[]。12345char s[] = \"123 52.2 adas\";int a; double b; char ss[105];sscanf(s, \"%d%lf%s\", &amp;a, &amp;b, ss); // a=123, b=52.2, ss=\"adas\"a++; ss[0]='b';sprintf(s, \"%d%lf%s\", a, b, ss); // s=\"12452.2bdas\" 后面还追有 '\\0' 's' '\\0'单字符输入输出大多数情况下scanf、printf配合%c可以适应单字符输入输出的要求。但是对于优化效率，getchar()、putchar()十分有用。12char c = getchar(); // 从标准输入读入一个字符putchar(c); // 输出一个字符到标准输出输入输出重定向freopen可以将标准输入输出导向文件，在一些规定了文件输入输出的ACM题目，或者本地调试时极为有用。12freopen(\"in.txt\", \"r\", stdin); // 重定向输入流freopen(\"out.txt\", \"w\", stdout);// 重定向输出流快速读入、缓冲区冲刷对于一些大量数据读入的ACM题目，格式化的输入，在底层对于识别格式串时已浪费不少时间。快速读入是一种声明了众多针对不同数据类型的读入函数，且预先将所有bytes当作char类型读到数组作为缓冲区，随后再从缓冲区中模拟读入的一种优化读入效率操作。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768char s[]=\"-123456\"; // 模拟的缓冲区void read(int &amp;x){ x=0; bool sign=0; int i=0; if(s[i] == '-') sign=1, i++; for(; s[i]!='\\0'; i++) x = x*10 + (s[i]-'0'); if(sign) x=-x;}namespace fastIO { #define BUF_SIZE 100000 // 预定义缓冲区大小 #define LL long long //fread-&gt;read bool IOerror=0; inline char nc(){ static char buf[BUF_SIZE],*p1=buf+BUF_SIZE,*pend=buf+BUF_SIZE; if (p1==pend){ p1=buf; pend=buf+fread(buf,1,BUF_SIZE,stdin); if (pend==p1){IOerror=1;return -1;} } return *p1++; } inline bool blank(char ch){return ch==' '||ch=='\\n'||ch=='\\r'||ch=='\\t';} inline void read(int &amp;x){ bool sign=0; char ch=nc(); x=0; for (;blank(ch);ch=nc()); if (IOerror)return; if (ch=='-')sign=1,ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())x=x*10+ch-'0'; if (sign)x=-x; } inline void read(LL &amp;x){ bool sign=0; char ch=nc(); x=0; for (;blank(ch);ch=nc()); if (IOerror)return; if (ch=='-')sign=1,ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())x=x*10+ch-'0'; if (sign)x=-x; } inline void read(double &amp;x){ bool sign=0; char ch=nc(); x=0; for (;blank(ch);ch=nc()); if (IOerror)return; if (ch=='-')sign=1,ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())x=x*10+ch-'0'; if (ch=='.'){ double tmp=1; ch=nc(); for (;ch&gt;='0'&amp;&amp;ch&lt;='9';ch=nc())tmp/=10.0,x+=tmp*(ch-'0'); } if (sign)x=-x; } inline void read(char *s){ char ch=nc(); for (;blank(ch);ch=nc()); if (IOerror)return; for (;!blank(ch)&amp;&amp;!IOerror;ch=nc())*s++=ch; *s=0; } inline void read(char &amp;c){ for (c=nc();blank(c);c=nc()); if (IOerror){c=-1;return;} } #undef LL #undef BUF_SIZE}using namespace fastIO;// 本地测试时，只能用freopen才可进行测试，读入改为read(n)，n为变量缓冲区冲刷，fflush(stdout);，可以将输出缓冲区中的内容当即输出，在一些交互题上是必须要使用的。ctype.h (cctype)ctpye.h是对一些常用字符的判断、转换做了封装的一个C语言原生库。尽管大多可以用一行加减操作替代，但利用好，可以缩减代码长度，减少出错率，优化可读性，有学习的必要性。例如，判断一个char字符我们可以这样写：if(c &gt;= 'a' &amp;&amp; c &lt;= 'z')，但在ctpye.h封装的函数中，一句if(islower(c)更为简洁。更为深刻的例子当然有，比如判断一个字母或数字可以用if(isalnum(c))。主要的函数有：islower(c)，判小写字母。等效c&gt;=’a’ &amp;&amp; c&lt;=’z’isupper(c)，判大写字母。等效c&gt;=’A’ &amp;&amp; c&lt;=’Z’isalpha(c)，判字母。等效(c&gt;=’a’ &amp;&amp; c&lt;=’z’ || c&gt;=’A’ &amp;&amp; c&lt;=’Z’)isdigit(c)，判数字isblank(c)，判空白符isspace(c)，判空格tolower(c)，转为小写。等效c&gt;=’A’&amp;&amp;c&lt;=’Z’ ? c+’a’-‘A’ : c;toupper(c)，转为大写math.h (cmath)数学库。常用的函数都有，比如cos、sin、tan、acos、asin、atan、exp、log、pow、sqrt。pi的定义const double pi = acos(-1.0);比较好用的向上取整ceil(1.2)，向下取整floor(1.2)，整数取绝对值abs(-232)，浮点数取绝对值fabs(-232.2323)。fabs还可用于浮点数判等：123456printf(0.1+0.1+0.1==0.3?\"yes\":\"no\"); // 输出no// 判等 —— 允许误差内const double eps = 1e-8;double a, b;if(fabs(a-b) &lt; eps) printf(\"equals\");stdlib.h (cstdlib)这个库定义了一些通用函数。而我们主要用到的是字符串转变量、转换进制输出到字符串、随机数生成。字符串转变量1234int i = atoi(\"12123\");long long l = atoll(\"321321321321321323\");double d = atof(\"-21.2323\"); char s[] = \"12 2.33\"; double d = atof(s+2); // s+2或s+3都行转换进制输出到字符串1234char s[100];itoa(23, s, 2); // 23转换为2进制输出到字符串sitoa(23, s, 3); // 23转换为3进制输出到字符串sitoa(23, s, 8); // 23转换为8进制输出到字符串s随机数生成1234567891011121314151617/* C语言的伪随机数 */srand (time(NULL)); // 初始化随机数种子(生成器)，time函数在time.h库int i = rand() % 10 + 1; // 随机生成一个位于[1, 10]的数#define randInt(x,y) rand()%y+x // 定义一个随机数宏/* mt19937随机数 */mt19937 rnd(time(0));printf(\"%lld\\n\", rnd());// mt19937随机数-随机分布生成auto dice_rand = bind(uniform_int_distribution&lt;int&gt;(1, 6), mt19937(time(0)));auto real_rand = bind(uniform_real_distribution&lt;double&gt;(0,1),mt19937(time(0))); // [0,1)auto real_rand1 = bind(uniform_real_distribution&lt;double&gt;(0,nextafter(1,DBL_MAX)),mt19937(time(0))); // [0,1]cout &lt;&lt; dice_rand() &lt;&lt; endl;cout &lt;&lt; real_rand() &lt;&lt; endl;// 利用mt19937打乱序列mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());shuffle(s+1, s+1+n, rng);string.h (cstring)string.h定义了一些对于字符串、数组的常用操作。比较常用的有：获取字符串长度、字符串拷贝、字符串比较、字符串追加、字符串分割、内存拷贝、内存比较等。字符串操作12345678910111213141516171819202122char s[] = \" 12354aaasd\"/* 获取字符串长度 */int len = strlen(s+1);/* 获取字符串中第一个'a'的下标 */int stIndx = strchr(s+1, 'a')-s;/* 字符串比较 */int cmp = strcmp(s, \"123\"); // 相等返回0，&lt;0则表示串1字典序小于串2/* 字符串追加 */strcat(s, \"233333\"); // 往字符串末'\\0'位置追加内容，注意不能超长度/* 字符串split，将一个字符串按某字符分割放入vector(regex有更简洁强大的写法) */vector&lt;string&gt; v;char str[] = \"sda/das//d/sad/sa/d/dsad/\";char *p=strtok(str,\"/\");while(p){ v.push_back(p); p=strtok(null,\"/\");}内存操作1234567891011121314151617181920/* 内存拷贝 */char a[20], b[20];memcpy(a+2, b+1, sizeof(char)*10); // 将b+1后10个内存拷贝到a+2后struct p {int a;double b;char c;} p1, p2;memcpy(p1, p2, sizeof(p)); // 拷贝结构体/* 数组初始化 */int a[10];memset(a, -1, sizeof(a)); // 初始化数组为-1memset(a, 0, sizeof(a)); // 初始化数组为0memset(a, 0x3fffffff, sizeof(int)*10); // 初始化数组为极大值// 注意，除了-1、0、极大值外，不要穿其他值，因为传入int，填充内存时当作unsigned char进行填充/* 内存比较 */int a[3]={1,2,3}, b[3]={1,2,4};memcmp(a, b, sizeof(int)*3); // 比较，会返回-1、0、1的一个/* 获取素组中第一个1的下标 */int a[10]={6,3,2,6,8,1,1,3,7,5};int stIndx = (int*)memchr(a, 1, sizeof(int)*10) - a; // 其中数组长度10可用或者sizeof(a)/sizeof(a[0])替代time.h (ctime)time.h定义了获取、操作日期和时间的函数。常用用途有：获取当前cpu时间测评程序的运行时间、获取系统时间、巧妙利用库中函数处理时间戳。测评程序运行时间1234// 在算法末尾加上#ifdef LOCAL printf(\"Time Cost: %.4f\\n\", clock()*1.0/CLOCKS_PER_SEC);#endif获得系统时间12time_t t; time(&amp;t); // 或 time_t = time(NULL)printf(\"%d %s\", t, ctime(&amp;t)); // 输出自1970年1月1日以来经过的秒数和“d m y h:m:s Y”格式的字符串时间戳转格式化时间串12345time_t t = time(0);struct tm *p = gmtime(&amp;t);char s[100];strftime(s, sizeof(s), \"%Y-%m-%d %H:%M:%S\", p); // string format timeprintf(\"%d: %s\\n\", t, s); // 1498124250: 2017-06-22 09:37:30格式化时间串转时间戳123456789char s[] = \"2019-04-01 12:32:11\";struct tm t = {0};t.tm_year = atoi(s) - 1900; // 注意1900t.tm_mon = atoi(s+5) - 1; // 注意1t.tm_mday = atoi(s+8);t.tm_hour = atoi(s+11);t.tm_min = atoi(s+14);t.tm_sec = atoi(s+17);printf(\"%d\", mktime(&amp;t));获得某年某月是星期几1234567891011121314151617/* C++库 */int year=2019, month=4, day=1;time_t t = time(0);struct tm *p;p = gmtime(&amp;t);p-&gt;tm_year = year - 1900;p-&gt;tm_mon = month - 1;p-&gt;tm_mday = day;mktime(p); // 规整tm结构体的变量，更新p-&gt;tm_wdayprintf(\"That day is a %d\\n\", p-&gt;tm_wday); // 0是星期天1是星期一/* 蔡勒公式 */int Day(int y, int m, int d) { // 1~7分别表示星期一到星期日 if (m == 1 || m == 2) {m += 12;--y;} return (d + 2 * m + 3 * (m + 1) / 5 + y + y / 4 - y / 100 + y / 400) % 7 + 1;}arrayarray是c++11中定义的容器类。用法大多与原生数组所重，更方便的用法在不定长数组vector中也得以体现，所以array相对有用的东西较少，学习必要性较小。123/* 获得数组长度 */int a[] = {1,2,3,4,4};int len = sizeof(a) / sizeof(a[0]) = end(a) - begin(a);vectorvector是不定长数组容器。其数组长度的扩增策略是每次乘2，所以倘若数组长度下界较为确定的话，声明vector时传入初始大小是比较明智的。对于容器类，较为关注的是它的声明、赋值、遍历、清空操作及相应复杂度了。1234567891011121314151617181920/* 声明 */vector&lt;int&gt; v(10); // 初始大小为10vector&lt;int&gt; v(10, 0); // 初始大小为10，每个值都是0vector&lt;vector&lt;int&gt; &gt; G(n+1,vector&lt;int&gt;(m+1)); // 二维动态数组声明/* 赋值 */v.push_back(20); // 末尾放入一个元素20v[0] = 12; // 首元素改为12v.insert(v.begin()+1, 1); // 第2个位置插入1v.emplace(v.begin()+1, 1); // 第2个位置插入1，不复制构造而直接插入，优化/* 遍历 */for(int i=0, n=v.size();i&lt;n;i++) printf(\"%d\\n\", v[i]); // 原生for(vector&lt;int&gt;::iterator it=v.begin();it!=v.end();++it) printf(\"%d\\n\", *it); // 迭代器for(int i : v) printf(\"%d\", i); // for rangefor(auto i : v) printf(\"%d\", i); // for rangefor(auto &amp;i : v) i++; // 每个数自增1/* 清空 */v.clear(); // 整个清空v.pop_back(); // 删除最后元素 v.erase(v.begin()); // 删除首个元素v.erase(v.begin(), v.begin()+3); // 删除前3个元素listlist是链表容器。将数组换作链表使用，更在意的是其增删操作的时间复杂度和存储的空间复杂度。在链表容器中，除了对基本函数了解外，理应对迭代器有较好的理解和应用。若对时空复杂度有更高要求，单向链表forward_list也许更适合，但由于操作的相似性，就不提及了。1234567891011121314151617181920212223242526272829303132333435363738394041424344/* 声明 */list&lt;int&gt; l1;list&lt;int&gt; l2(l1.begin(), l1.end()-1); // 拷贝其他链表的一部分，复杂度是O(n)/* 赋值 */l1.push_back(1); // 在链表尾加一个元素l1.push_front(1); // 在链表头加一个元素/* 遍历 */l1.front(); // 首元素l1.back(); // 尾元素for(list&lt;int&gt;::iterator it = l1.begin(); it != l1.end(); it++) printf(\"%d\\n\", *it);for(list&lt;int&gt;::reverse_iterator it = l1.rbegin(); it != l1.rend(); it++) printf(\"%d\\n\", *it);for(auto &amp;i : l) printf(\"%d \", i);/* 迭代器删减 */list&lt;int&gt;::iterator it = l1.begin();it++; // 迭代器移动l1.insert(it, 1); // 在迭代器后加一个元素it = l1.erase(it); // 删除迭代器当前元素，必须重新赋值迭代器否则失效，赋值后迭代器等于被删元素下一个/* 清空 */l1.pop_front(); // 删除首元素l1.pop_back(); // 删除尾元素l1.clear(); // 清空链表/* 排序，复杂度nlogn */bool cmp(const int &amp;o1, const int &amp;o2) {return o1 &gt; o2;}l1.sort(cmp); // 空参数为递减/* 链表反向 */l1.reverse();/* 链表拼接 */l1.splice(l1.end(), l2); // 之后l2被清空 l1.splice(l1.end(), l2, l2.begin(), l2.end());l1.merge(l2)； // 有序链表的归并/* 删除链表中全部某值元素 */l1.remove(89); // 第一种bool cmp(const int &amp;o) {return o==89;} l1.remove_if(cmp); // 第二种/* 去重 */l1.sort(); l1.unique();mapmap是关联容器，提供键-值对的映射方法，底层是红黑树。在map头文件中提供了map和multimap两种，其中multimap提供了单键多值映射。一般使用map，主要使用在离散化数据、判重。unordered_map是无序map，无法简单获得升序键-值，但在时间复杂度上有些许优化，用法类似，不提及了。单键单值映射1234567891011121314151617181920212223242526272829/* 声明 */map&lt;int, bool&gt; mp;/* 赋值 */mp[13] = true;/* 查key是否有对应value */if(mp[13]) printf(\"visited\"); // 这里可以直接如此，而如果 value 类型非 bool 时需换成以下这种if(mp.find(13) != mp.end()) printf(\"visited\");/* 遍历 */for(map&lt;int,int&gt;::iterator it=mp.begin();it!=mp.end();it++) printf(\"%d %d\\n\", it-&gt;first, it-&gt;second); // 输出是升序的for(map&lt;int,int&gt;::reverse_iterator it=mp.rbegin();it!=mp.rend();it++) printf(\"%d %d\\n\", it-&gt;first, it-&gt;second); // 输出是降序的/* 遍历 c++11 特性 */for(auto &amp;entry : mp) printf(\"%d %d\\n\", entry.first, entry.second); // for range/* 清空 */mp.erase(13); // 以键为关键字删除某该键-值对，复杂度是 logmp.clear();/* 常量map声明，而不是声明一个空的map随后在main中赋值 */const map&lt;char, char&gt; mp({ {'R', 'P'}, {'P', 'S'}, {'S', 'R'}});单键多值映射1234567891011121314151617/* 声明 */multimap&lt;int, int&gt; mp;/* 赋值 */mp.insert({1, 3});mp.insert(make_pair(1, 3));/* 遍历，全部遍历和map一样，主要关注单值遍历 */for(multimap&lt;int,int&gt;::iterator it=mp.find(1); it-&gt;first==1; it++) printf(\"%d %d\\n\", it-&gt;first, it-&gt;second); // 所有键为1的键-值对auto it = mp.lower_bound(1); // 遍历所有键为1的键-值对for(int i=0;i&lt;mp.count(1);i++,it++) printf(\"%d %d\\n\", it-&gt;first, it-&gt;second);/* 清空 */mp.erase(1); // 删除所有键为1的键值对mp.clear();离散化数据12345678910111213141516/* 利用map离散化 */map&lt;int,int&gt; mp; int indx=0;// 输入数组asort(a,a+n);for(int i=0;i&lt;n;i++){ if(mp.find(a[i]==mp.end())) mp[a[i]] = ++indx; a[i] = mp[a[i]];}/* 利用unique、upper_bound离散化 */vector&lt;int&gt; V;// 输入V;sort(V.begin(). V.end());V.erase(unique(V.begin(), V.end()), V.end());int getid(int x) {return upper_bound(V.begin().V.end(),x)-V.begin()+1;}unordered_map底层是基于开链法的哈希表主要关注一下结构体的 hash 重写和 equals 重写123456789101112131415161718struct Node { Node() {} Node(int _x, int _y):x(_x), y(_y) {} int x, y; bool operator == (const Node &amp;t) const { return x==t.x &amp;&amp; y==t.y; }};struct NodeHash { std::size_t operator () (const Node &amp;t) const { return t.x * 100 + t.y; }};unordered_set &lt;Node, NodeHash&gt; h_set;unordered_map &lt;Node, string, NodeHash&gt; h_map;/* 结合 Lambda 的写法 */unordered_set &lt;Node, NodeHash&gt; h_set;setset集合。底层是红黑树。在set头文件中提供了set和multiset两种，其中multiset允许元素重复。在ACM中用到set，主要用来维护不重复数组。对于集合本身的性质应用——求交并差集，在algorithm库里，是利用vector实现的。当然，如果是在线维护不重复数组，并且要求交并差的话，set是不错的选择。注意一下，set删除数值是log级别的时间复杂度，删除指针所指的节点则是摊销常数。非重复集合可重复集合用法大都与非重复集合相同，且使用频率不大，可以忽略。故只涉及非重复集123456789101112131415161718192021/* 声明 */set&lt;int&gt; s;/* 赋值 */s.insert(1);s.insert(2);/* 遍历 */if(s.find(1) != s.end()) printf(\"The element is in set\");for(set&lt;int&gt;::iterator it=s.begin();it!=s.end();it++) printf(\"%d\", *it); // 全部遍历for(auto &amp;x : s) printf(\"%d\\n\", x); int sz = s.size(); // 大小/* 清空 */s.erase(val); // 删除复杂度是logns.clear();/* 二分 */set&lt;int&gt;::iterator it = s.lower_bound(val); // 查找第一个大于等于 val 的元素，返回指针if (it != set.end()) // 存在该元素 printf(\"%d\\n\", *it);集合交并差123456#include &lt;algorithm&gt;set&lt;int&gt; A, B, ans;set_intersection(A.begin(), A.end(), B.begin(), B.end(), inserter(ans, ans.begin())) // 交set_union(A.begin(), A.end(), B.begin(), B.end(), inserter(ans, ans.begin())) // 并set_difference(A.begin(), A.end(), B.begin(), B.end(), inserter(ans, ans.begin())) // A-Bset_difference(B.begin(), B.end(), A.begin(), A.end(), inserter(ans, ans.begin())) // B-Astackstack，栈，先进后出的数据结构。123456789101112131415/* 声明 */stack&lt;int&gt; s;stack&lt;int, vector&lt;int&gt; &gt; s; // 指定底层容器的栈stack&lt;int, list&lt;int&gt; &gt; s; // 指定底层容器的栈/* 赋值 */s.push(1); // 将1压栈/* 访问 */s.top(); // 访问栈顶/* 清空 */s.pop(); // 弹出栈顶while(!s.empty()) s.pop(); // 清空栈for(int i=s.size(); i; i--) s.pop(); // 清空栈queuequeue，队列，先进先出的数据结构。queue中提供了队列queue、优先队列priority_queue，还有一种双端队列在另外一个头文件deque。123456789101112131415161718192021222324252627/* 声明 */queue&lt;int&gt; q;priority_queue&lt;int&gt; pq; // 优先队列，大根堆priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; pq; // 大根堆, 结构体重载&lt;方法priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq; // 小根堆, 结构体重载&gt;方法// 大根堆 O(n) 线性构造int a[] = {1,3,4,6,78,9}priority_queue&lt;int&gt; pq(a, a+6); /* 赋值 */q.push(1); // 将1入队pq.push(1);/* 队列访问 */q.front(); // 访问队首q.back(); // 访问队尾/* 优先队列访问 */pq.top(); // 访问堆顶/* 清空，二者是相同的 */q.pop(); // 队首出队pq.pop(); // 弹出堆顶while(!q.empty()) q.pop(); // 清空队列for(int i=q.size();i;i--) q.pop(); // 清空队列deque双端队列。用法大多与list类似，不赘述。algorithm算法库，主要关注：二分、排序、去重、全排列等。二分12345vector v = {10,10,10,20,20,20,30,30};int indx = lower_bound (v.begin(), v.end(), 20)-v.begin(); // 返回第一个大于等于20的数的下标 即3int indx = upper_bound (v.begin(), v.end(), 20)-v.begin(); // 返回第一个大于20的数的下标 即6if(binary_search(v.begin(), v.end, 20)) printf(\"existed\"); // 在有序序列中找某个数，第4个参数可传cmp函数。排序12345678910111213141516171819202122232425262728int a[] = {5,3,1,4};vector&lt;int&gt; b = {5,3,1,4};sort(a, a+4); // 左闭右开区间 升序排序sort(b.begin()+1, b.end()); // 只排序第2个元素及其后面的元素，升序排序sort(a, a+4, greater&lt;int&gt;()); // 降序排序struct P { int a,b,c; }Ps[10];bool cmp(const P &amp;p1, const P &amp;p2) { return a!=p.a ? a&lt;p.a : (b!=p.b ? b&lt;p.b : c&lt;p.c); }sort(Ps, Ps+10, cmp); // 传参比较方法，三关键字升序排序struct P { int a,b,c; bool operator&lt;(const P &amp;p) const {// 第1关键字升序，第2关键字降序，第3关键字升序的多关键字排序 if(a != p.a) return a &lt; p.a; if(b != p.b) return b &gt; p.b; return c &lt; p.c; }}Ps[10];sort(Ps, Ps+10); // 重载比较方法，第1关键字升序，第2关键字降序，第3关键字升序的多关键字排序// Lambda 支持的结构体多关键字排序struct P { int a,b,c; }Ps[10];sort(Ps, Ps+10, [](P &amp;p1, P &amp;p2)-&gt;bool{ if(p1.a != p2.a) return p1.a &lt; p2.a; if(p1.b != p2.b) return p1.b &gt; p2.b; return p1.c &lt; p2.c;});去重12345678vector&lt;int&gt; a = {5,3,54,2,1,34,1,1,1,4};sort(a.begin(), a.end()); // 去重前先排序a.resize(unique(a.begin(),a.end()) - a.begin());// 去重，本质是将重复元素移到末尾，返回尾指针int a[] = {1,2,3,1};int n = sizeof(a)/sizeof(a[0]);n = unique(a, a+n) - a; // 如果下标从1开始则还要改成unique(a+1, a+n+1)-a-1，同时注意a[0]对a[1]的影响// unqiue 第3个参数可以传入自定义cmp函数来判断\"重复\"全排列1234567int a[] = {3,2,1};sort(a, a+3); // 全排列的输出顺序是字典序的，若不先排序，则只会输出该状态以及之后的排列do{ for(auto x:a) printf(\"%d \", x); printf(\"\\n\");}while(next_permutation(a, a+3)); // 输出123全排列prev_permutation(a, a+3); // 向前一个排列旋转12vector&lt;int&gt; a = {1,2,3,4,5,6,7};rotate(a.begin(), a.begin()+4, a.end()); // 将a.begin()到a.end()之间，以a.begin()+4为界的左右部分调换，得到{4,5,6,7,1,2,3}，复杂度是线性的，不如了解一下更玄的memcpy?打乱123vector&lt;int&gt; a = {5,3,54,2,1,34,1,1,1,4};random_shuffle(a.begin(), a.end()); // 听说在排序前打乱一下会有玄学效用！sort(a.begin(), a.end());数组判断123456bool IsOdd(int i) {return i%2;}vector&lt;int&gt; a = {1,3,5,7};if(all_of(a.begin(), a.end(), IsOdd)) printf(\"All odd!\"); // 全是奇数if(any_of(a.begin(), a.end(), IsOdd)) printf(\"odd existes!\"); // 存在奇数if(none_of(a.begin(), a.end(), IsOdd)) printf(\"no odd\"); // 不存在奇数int odd = count_if(a.begin(), a.end()); // 奇数数目数组取最值12345// max_element、min_element 返回的是地址int a[10]; for(int i=0;i&lt;10;i++) a[i] = i;cout &lt;&lt; \"minElementIndex: \" &lt;&lt; min_element(a, a+10)-a &lt;&lt; endl; // vector的话 min_element(a.begin(), a.end())-a.begin();cout &lt;&lt; *min_element(a, a+10) &lt;&lt; endl;cout &lt;&lt; *max_element(a, a+10) &lt;&lt; endl;functionalfunctional库，主要关注几个普适的比较函数，在需要传入普通数据类型的比较函数时就不要自己重写cmp了。1234int a[5] = {5,2,1,4,3};sort(a, a+5, greater&lt;int&gt;()); // 降序sort(a, a+5, less&lt;int&gt;()); // 升序priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; Q; // 大根堆LambdaLambda不是cpp中某个库，而是C++11新支持的一个特性，Lambda是基于数学中的λ演算得名的，在C++11里表现为匿名函数的支持，可以替代掉一些一次性的谓词函数，起到简化逻辑、增加可读性的作用。1234567891011121314151617/* 传统的排序 */bool cmp(int a, int b) {return a&lt;b;}int a[] = {1,5,3,2};sort(a, a+4, cmp);/* 引入Lambda，写匿名函数 */sort(a, a+4, [](int a,int b)-&gt;bool{return a&lt;b;} );/* 匿名函数 */auto func = [](int x){ printf(\"%d\\n\", x); }; // 这甚至是一个void函数func(123); // 输出 123/* 带返回值的匿名函数 */auto IsOdd = [](int x)-&gt;bool{return x%2;};printf(IsOdd(1) ? \"YES\" : \"NO\");// 多的不深入探究了string字符串，主要关注各种操作函数：读入、转换、取长度、取下标字符、截取字符串、查找串、拼接。123456789101112131415161718192021/* 读入 */getline(I流， string对象, 分割char); // 这个一个结合cpp流特性的方法，即从Input流中读入一个string，以分割字符为界。/* 数字转字符串 */strings s = to_string(2323.232);/* 取长度 */int sz = s.size();/* 取下标字符 */char c = s[2];/* 截取字符串 */string ss = s.substr(2, 3); // 从第2个字符开始截取长度为3的串/* 查找串 */size_t found = s.find(\"23\", 0); // 从位置0开始找到第1个串\"23\"，找到返回下标，否则found=string::npossize_t found = s.rfind(\"23\", s.size()-1); // 从右侧开始找到第1个串\"23\"，至多找到至pos/* 拼接 */s += \"aaaa\";sstreamsstream是cpp中流的一种，在输入输出章节中，我们大多用scanf、printf替代了cin、cout的作用。但是将流用好，可以起到巧妙处理字符串的功效。其中有学习必要性的是stringstream、istringstream。主要关注：类型转换、分割处理类型转换1234567stringstream ss;ss &lt;&lt; \"1234\"; // 将字符串\"1234\"插入流中int a;ss &gt;&gt; a; // 从流中导出数据到intss.clear(); // 重复使用是有必要的，因为stringstream声明很慢。重复使用要注意清空流ss &lt;&lt; true;ss &gt;&gt; a;分割处理12345678// 和java的Scanner一样好用istringstream iss(\"I want to do what I want\");string s;while(getline(iss, s, ' ')) printf(\"%s\\n\", s.c_str()); // 忽略空格得到单词istringstream iss(\"I want to do\\nwhat I want\");string s;while(getline(iss, s, '\\n')) printf(\"%s\\n\", s.c_str()); // 忽略换行得到断句regex正则表达式，C++11支持。有关正则语法单独讲，这里只讲cpp的正则用法。正则表达式主要关注：匹配、替换、提取、切割。匹配123regex re(\"^abcd(.*)dddd\", regex::icase); // 第二个参数是忽略大小写printf(regex_match(\"abcdasdjufhuiadddd\", re) ? \"yes\": \"no\"); // yesprintf(regex_match(\"233abcdasdjufhuiadddd\", re) ? \"yes\": \"no\"); // no替换123string s = \"&lt;div class=233&gt; &lt;div class=2333&gt;\"; // 现在需要将&lt;&gt;里的div换成htmls = regex_replace(s, regex(\"&lt;div (.*?)&gt;\"), \"&lt;html $1&gt;\");printf(\"%s\\n\", s.c_str()); // 输出&lt;html class=233&gt; &lt;html class=2333&gt;提取1234string s = \"&lt;html&gt; &lt;divdaf ssd&gt; &lt;asdsad&gt;\";regex re(\"&lt;(.*?)&gt;\");for(sregex_iterator p(s.cbegin(), s.cend(), re), q; p != q; ++p) printf(\"匹配串:%s 匹配部分:%s\\n\", p-&gt;str().c_str(), p-&gt;format(\"$1\").c_str());切割12345678/* 切割单词后放入一个vector */string s = \"who lives in a pineapple under the sea?\";regex re(\" \");vector&lt;string&gt; ans{ sregex_token_iterator(s.begin(), s.end(), re, -1), sregex_token_iterator()};for(auto &amp;x : ans) printf(\"%s\\n\", x.c_str());bitsetbitset，仿真的bool数组、01序列，但bool变量是1byte长度，而bitset每个0、1是1bit，具有极优的空间复杂度。除此之外，还有位设置、位翻转等遍历操作。需要注意，bitset是cpp特有的库，对printf的输出以及直接判某位为1不太友好，对cout情有独钟，调试输出的时候需稍加码量，或换用cout。123456789101112131415161718192021222324252627282930313233/* 声明 */bitset&lt;16&gt; a; // 空，全零 0000000000000000bitset&lt;16&gt; b(0x3fff); // 整数参数 0011111111111111bitset&lt;16&gt; c(\"00101\"); // 字符串 0000000000000101/* 赋值 */a[0] = 1; // 低位第0位设为1a.set(0, 1); // 低位第0位设为1a.set(0); // 低位第0位设为1a.set(0, 0); // 低位第0位设为0a.set(); // 设为全1a.reset(); // 设为全0，该函数同样有两个参数，参数1为pos，参数2位value(为空时是0)a.flip(1); // 翻转第1位a.flip(); // 翻转整个01串a&lt;&lt;=1; // a左移1位/* 遍历 */cout &lt;&lt; a &lt;&lt; endl; // cout输出整个01串printf(\"%s\\n\", a.to_string().c_str()); // printf输出整个01串，较为麻烦一些cout &lt;&lt; a[0] &lt;&lt; endl; // cout输出低位第0位printf(\"%d\\n\", a[0]==1); // printf输出低位第0位/* 判位、换型 */a.test(0); // 判断第0位是否为1a.any(); // 判断是否至少1位为1s.none(); // 判断是否全0int one = a.count; // 获得1的个数string s = a.to_string(); // 转换为字符串unsigned long = a.to_ulong(); // 转换为无符号整形unsigned long long = a.to_ullong(); // 转换为无符号整形/* 枚举子集技巧 */for(int s = (1&lt;&lt;n)-1; s; s = (s-1)&amp;((1&lt;&lt;n)-1))tupletuple元组，是多个可异类型数据组成的数据组。utility中的pair是二元组，是tuple的特例。tuple在数组类型较为单一时，比起单独设置struct有更棒的可读性和简洁性。12345678910111213/* 声明 */tuple&lt;int, double, long long&gt; t;tuple&lt;int, int, int, int&gt; t(1, 2, 3, 4);tuple&lt;string, int&gt; t = make_tuple(\"haha\", 2333);/* 赋值 */get&lt;2&gt;(t) = 2333333333333; // 对第2个（也就是第3）元素赋值/* 访问 */int a = get&lt;0&gt;(t); // 取第0部分到aint a;double b;long long c; tie(a, b, c) = t; // 分别取0、1、2部分到a、b、cint sz = tuple_size&lt;decltype(t)&gt;; // 获得元组长度gcc的__builtin_函数GCC提供了一系列的builtin函数，可以实现一些简单快捷的功能来方便程序编写，另外，很多builtin函数可用来优化编译结果。这些函数以“__builtin_”作为函数名前缀，大都与位有关。__builtin_popcount(x)：x中1的个数。__builtin_popcountll(x)：x中1的个数，x是long long。__builtin_ctz(x)：x末尾0的个数 。x=0时结果未定义。__builtin_clz(x)：x前导0的个数。x=0时结果未定义。__builtin_parity(x)：x中1的奇偶性。奇1偶0。__builtin_ffs(x)：返回x右起第一个’1’的位置__gcd(a, b)：返回a和b的最大公约数调用 Linux 分解质数1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;string exec(const char *cmd) { array&lt;char, 128&gt; buffer; string result; unique_ptr&lt;FILE, decltype(&amp;pclose)&gt; pipe(popen(cmd, \"r\"), pclose); if (!pipe)throw std::runtime_error(\"popen() failed!\"); while (fgets(buffer.data(), buffer.size(), pipe.get()) != nullptr) result += buffer.data(); return result;}ll T, n;string s, t;int32_t main() { ios::sync_with_stdio(0), cin.tie(0); cin &gt;&gt; T; while (T—) { cin &gt;&gt; n; t = exec((\"factor \" + to_string(n)).c_str()); istringstream sin(t); while (sin &gt;&gt; s); if (stoll(s) == n)s = \"Prime\"; cout &lt;&lt; s &lt;&lt; endl; }}define、typedefdefine、typedef，宏定义，是C++两种适合用于简化代码重复的手段。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/* 定义max */#define max(a,b) ((a&gt;b)?a:b)/* 定义PI */#define PI acos(-1.0) /* 重定义，便于pair使用 */#define PT pair&lt;int, int&gt;#define x first#define y second /* 重定义long long */typedef long long LL;/* 文件输入输出 */#define FILE(x) freopen(x\".in\",\"r+\",stdin);freopen(x\".out\",\"w+\",stdout) // 重定义输入输出/* 调试神器(通用,不带颜色) */#ifdef LOCAL void dbg() { cout &lt;&lt; \"\\n\"; } template&lt;typename T, typename... A&gt; void dbg(T a, A... x) { cout &lt;&lt; a &lt;&lt; ' '; dbg(x...); } #define logs(x...) cout &lt;&lt; #x &lt;&lt; \" -&gt; \"; dbg(x);#else #define logs(...)#endif/* 调试神器(linux,带颜色) */#ifdef LOCAL void dbg() { cout &lt;&lt; \"\\033[39;0m\\n\"; } template&lt;typename T, typename... A&gt; void dbg(T a, A... x) { cout &lt;&lt; a &lt;&lt; ' '; dbg(x...); } #define logs(x...) cout &lt;&lt; \"---------------- \\033[32;1m\" &lt;&lt; #x &lt;&lt; \" -&gt; \"; dbg(x);#else #define logs(...)#endif/* 调试神器(Windows,带颜色) */namespace tttt { #define rep(i,s,t) for(int i=s;i&lt;=t;i++) #define rrep(i,s,t) for(int i=s;i&gt;=t;i--) #ifdef LOCAL #include &lt;windows.h&gt; #include &lt;iostream&gt; class WinCMD {public:static HANDLE WinCMDHandle;static HANDLE WinCMDInit(){WinCMDHandle=GetStdHandle(STD_OUTPUT_HANDLE);setColor(0x02);std::cout&lt;&lt;\"\\t\\t\\t\\t\\tWelcome to TTTT\\'s WinCMD v0.3\\n\\n\\n\\n\\n\\n\";setColor(0x07);return WinCMDHandle;}static void setColor(int x){SetConsoleTextAttribute(WinCMDHandle,x);}static void setGrey(){setColor(0x08);}static void setGreen(){setColor(0x0A);}static void setWhite(){setColor(0x07);}};HANDLE WinCMD::WinCMDHandle=WinCMD::WinCMDInit(); #define o(x) std::cout&lt;&lt;x; #define O(x) WinCMD::setGrey();o(\"\"#x);WinCMD::setWhite();o(\"[\");WinCMD::setGreen();o(x);WinCMD::setWhite();o(\"] \"); #define arg_cnt_1(...) arg_cnt_2(__VA_ARGS__) #define arg_cnt_2(_1,_2,_3,_4,_5,_6,N,...) N #define arg_cnt(...) arg_cnt_1(__VA_ARGS__,6,5,4,3,2,1,0) #define log1(a,...) o(\"log1: \");O(a);o(\"\\n\"); #define log2(a,b,...) o(\"log2: \");;O(a);O(b);o(\"\\n\"); #define log3(a,b,c,...) o(\"log3: \");O(a);O(b);O(c);o(\"\\n\"); #define log4(a,b,c,d,...) o(\"log4: \");O(a);O(b);O(c);O(d);o(\"\\n\"); #define log5(a,b,c,d,e,...) o(\"log5: \");O(a);O(b);O(c);O(d);O(e);o(\"\\n\"); #define log6(a,b,c,d,e,f,...) o(\"log6: \");O(a);O(b);O(c);O(d);O(e);O(f);o(\"\\n\"); #define loga(a,s,t) {o(\"\\t\\t\\t\\t\"#a\": \");for(int i=s;i&lt;=t;i++){WinCMD::setGrey();o(i);WinCMD::setWhite();o(\"[\");WinCMD::setGreen();o(a[i]);WinCMD::setWhite();o(\"] \");}o(\"\\n\");} #define logs(...) {o(\"\\t\\t\\t\\t\");switch(arg_cnt(__VA_ARGS__)){case 1:log1(__VA_ARGS__);break;case 2:log2(__VA_ARGS__,2);break;case 3:log3(__VA_ARGS__,2,3);break;case 4:log4(__VA_ARGS__,2,3,3);break;case 5:log5(__VA_ARGS__,2,3,3,3);break;case 6:log6(__VA_ARGS__,2,3,3,3,3);break;};} #else #define logs(...) #define loga(a,s,t) #endif}using namespace tttt;#define arg_cnt(...) std::tuple_size&lt;decltype(std::make_tuple(__VA_ARGS__))&gt;::value; // 计算不定参数宏的参数数目#define arg_cnt(...) (sizeof((int[]){0, ##__VA_ARGS__})/sizeof(int)-1); // 另一种解决但只能在参数为int情况Code::Blocks使用ACM竞赛中，一般使用CB作为IDE，调配CB变得好用首当其冲。123456789101112131415161718192021222324251.【控制台界面更改】： Settings-&gt;Environments-&gt; 把&quot;xterm -T $TITLE -e&quot;改成“gnome-terminal -t $TITLE -x“ 然后就可以欢快地&quot;Shift+Ctrl+C/V&quot;复制粘贴了！2.【代码提示功能优化】：Setings-&gt;Editor-&gt;Code pompletion-&gt;(1).Delay for auto-kick-in when typing [.::-&gt;] 改为200ms(2).将Keyword sets to additionally include中1到9都勾上(3).将Automatically launch when typed # letter中的4改成2，这样打两个字母就会有提示了。3.【增加#define LOCAL】Setings-&gt;Compiler-&gt;Global compiler settings-&gt;第二个内窗口有一个选项卡#defines-&gt;新起一行加上LOCAL这5个字母4.【快捷键更改】Settings-&gt;editor-&gt;Keyboard shortcuts(1).变量重命名：Edit-&gt;Rename symbols Ctrl+R(2).运行键：Build-&gt;run F10(3).另存为：File-&gt;Save file as... Ctrl+Shift+S5.【模板文件】Settings-&gt;editor-&gt;Abbreviations(1).在keywords栏点击&quot;add&quot;，起一个名字，然后把代码放到黑区(2).在代码中加一个|表示光标起始(3).回到编辑器，输入刚才模板命名，再按Ctrl+J。OJ手动加栈第一行加上#pragma comment(linker, &quot;/STACK:1024000000,1024000000&quot;)，提交选c++编译器可以加栈内存。","link":"/ACM/ACMLife-0_1-Cpp-Summarize/"},{"title":"ACMLife-0_2-Java总结","text":"[toc]序言java作为一门为面向对象而生的语言，与cpp有着巨大的不同（比如万物皆“引用”）。利用java解决算法竞赛题目，在高精度、字符串处理、封装增强复用性等方面较cpp有优势。在ACM中若想用java替代cpp解决题目，理应对继承、多态、垃圾回收、自动打包解包机制，以及面对对象思想有基本的理解。首先希望你对 java 基础有一定了解（比如对象判等要用.equals），本章更多的是深究 jdk API 中哪些对于 ACM 有优势。IOjava中的输入输出流多带有一种”管道”的概念。标准输入输出标准输入输出的最简洁写法主要依靠两个类：Scanner、System。Scanner在java.util包，需要手动导入，System在java.lang包，会自动导入。12345678910111213141516171819202122232425262728293031323334353637383940414243/* 输入 */Scanner sc = new Scanner(System.in);int a = sc.nextInt();int a = sc.nextInt(2); // 将下一个整数二进制读入long b = sc.nextLong(); long b = sc.nextLong(2); // 将下一个整数二进制读入double d = sc.nextDouble();String s = sc.next(); // 读入下一个字符串(自动跳过空白符)String ss = sc.nextLine(); // 读入一行字符串BigInteger = sc.nextBigInteger(); // 读入高精度整数BigInteger = sc.nextBigInteger(2);// 读入二进制高精度整数BigDecimal = sc.nextBigDecimal(); // 读入高精度小数/* 多组读入 */while(sc.hasNext()) { int a = sc.nextInt();}/* 需要注意，倘若输入如下，两个整数+一行：1 3asdfggh dasd sd*/int a = sc.nextInt(), b = sc.nextInt();String s = sc.nextLine(); // 上面的读法出错，此时读到的s是第一行末尾的换行符，故正确的用法如下：int a = sc.nextInt(), b = sc.nextInt(); sc.nextLine(); // 应先消除第一行末的换行符String s = sc.nextLine(); /* 输出 */System.out.println(\"121212\"); // 输出末带换行System.out.print(\"213213\"); // 输出末不带换行System.out.printf(\"%d\", 123); // 格式化输出/* Scanner 本质上是一个 Iterartor，文档中的解释是\"一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器\" */String input = \"1 fish 2 fish red fish blue fish\";Scanner sc = new Scanner(input).useDelimiter(\"\\\\s*fish\\\\s*\");System.out.println(sc.nextInt()); // 输出1System.out.println(sc.nextInt()); // 输出2System.out.println(sc.next()); // 输出redSystem.out.println(sc.next()); // 输出blue/* 跳过下一个匹配某re模式的信息 */sc.skip(StringOfRegex);格式化输出格式化输出，大多针对小数的保留几位小数的输出。利用printf像cpp一样格式化输出，二是利用DecimalFormat对象。12345/* printf 格式化输出 */System.out.printf(\"%d %10.5f\\n\", 1, 3.4);/* 借由DecimalFormat */DecimalFormat df = new DecimalFormat(\"0.000\");System.out.println(\"x = \" + df.format(1.2345));快速IO快速IO，如同cpp一样，是预先将输入读到缓冲区，模拟读入。第一版快速IO12345678910111213141516171819202122232425/* 代码易懂易记，适合正式比赛 */public class Main{ static BufferedReader in=new BufferedReader(new InputStreamReader(System.in)); static StringTokenizer tok; static String next() {hasNext();return tok.nextToken(); } static String nextLine() {try{return in.readLine();}catch (Exception e) {return null;}} static long nextLong() {return Long.parseLong(next());} static int nextInt() {return Integer.parseInt(next());} static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out)); static boolean hasNext() { while(tok==null||!tok.hasMoreTokens()) try{tok=new StringTokenizer(in.readLine());}catch(Exception e){return false;} return true; } public static void main(String[] args) { int a = nextInt(); String s = nextLine(); out.println(s); out.flush(); // 末要加上 }}第二版快速IO1234567891011121314151617181920212223242526272829/* 代码经过压行，略微暴恐，适合平时做题用，效率略高于第一版 */public class Main{ public static void main(String[] args) throws IOException { /* 写代码 */ out.flush(); out.close(); } static FastReader in = new FastReader(); static PrintWriter out = new PrintWriter(System.out); static class FastReader { private InputStream mIs;private byte[] buf = new byte[1024];private int curChar,numChars;public FastReader() { this(System.in); }public FastReader(InputStream is) { mIs = is;} public int read() {if (numChars == -1) throw new InputMismatchException();if (curChar &gt;= numChars) {curChar = 0;try { numChars = mIs.read(buf);} catch (IOException e) { throw new InputMismatchException();}if (numChars &lt;= 0) return -1; }return buf[curChar++];} public String nextLine(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isEndOfLine(c));return res.toString() ;} public String next(){int c = read();while (isSpaceChar(c)) c = read();StringBuilder res = new StringBuilder();do {res.appendCodePoint(c);c = read();}while (!isSpaceChar(c));return res.toString();} public long l(){int c = read();while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }long res = 0; do{ if (c &lt; '0' || c &gt; '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read();}while(!isSpaceChar(c));return res * sgn;} public int i(){int c = read() ;while (isSpaceChar(c)) c = read();int sgn = 1;if (c == '-') { sgn = -1 ; c = read() ; }int res = 0;do{if (c &lt; '0' || c &gt; '9') throw new InputMismatchException();res *= 10 ; res += c - '0' ; c = read() ;}while(!isSpaceChar(c));return res * sgn;} public double d() throws IOException {return Double.parseDouble(next()) ;} public boolean isSpaceChar(int c) { return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1; } public boolean isEndOfLine(int c) { return c == '\\n' || c == '\\r' || c == -1; } public void scanIntArr(int [] arr){ for(int li=0;li&lt;arr.length;++li){ arr[li]=i();}} public void scanLongArr(long [] arr){for (int i=0;i&lt;arr.length;++i){arr[i]=l();}} public void shuffle(int [] arr){ for(int i=arr.length;i&gt;0;--i) { int r=(int)(Math.random()*i); int temp=arr[i-1]; arr[i-1]=arr[r]; arr[r]=temp; } } }}重定向IO12345678910111213141516171819202122/* 标准输入输出 */static Scanner sc;static { sc = new Scanner(\"in.txt\"); try { System.setOut(new PrintStream(\"out.txt\")); } catch (FileNotFoundException e) { System.exit(0); }}/* 第一版快速IO+重定向 */static BufferedReader in;static PrintWriter out;static { try { in = new BufferedReader(new InputStreamReader(new FileInputStream(\"in.txt\"))); out = new PrintWriter(new OutputStreamWriter(new FileOutputStream(\"out.txt\"))); } catch (FileNotFoundException e) { System.exit(0); }}Integer基本数据类型的包装类中，包含对进制的处理方法、字符串到整型的转换。这里仅拿Integer作范例，Long、Short、Boolean、Double理应有相应的用法。进制相关对于进制转换通过10进制为中介，理应可以处理任意进制间的转换。12345678910111213141516171819/* 进制转换 */Integer.toString(111, 16); // 111是十进制数，16是目标base进制，最大可支持的radix是\"0123456789abcdefghijklmnopqrstuvwxyz\"Integer.valueOf(\"FFFF\", 16) // 16-&gt;10Integer.valueOf(\"776\", 8) // 8-&gt;10Integer.valueOf(\"010101\", 2) // 2-&gt;10Integer.toBinaryString(12); // 将12转成忽略前导零的二进制String，得到1100Integer.toOctalString(12); // 将12转成忽略前导零的八进制String，得到14Integer.toHexString(12); // 将12转成忽略前导零的十六进制String，得到c /* 二进制位处理 */Integer.bitCount(7); // 7的二进制补码中多少个\"1\"Integer.highestOneBit(11); // 11的二进制最左位的幂次 如11=8+2+1, 则返回8Integer.lowestOneBit(11); // 11的二进制最右位的幂次 如11=8+2+1, 则返回1Integer.numberOfLeadingZeros(12); // 返回二进制补码中前导零的个数，如12=1100(2),返回32-4=28Integer.numberOfTrailingZeros(12); // 返回二进制补码中末导零的个数，如12=1100(2),返回2Integer.reverse(12); // 以bit为单位反转12的二进制得到805306368Integer.reverseByte(12); // 以Byte为单位反转12的二进制得到201326592Integer.rotateLeft(12, 2) // 将12的二进制循环左移2位，得到110000，注意是循环左移Integer.rotateRight(12, 2) // 将12的二进制循环右移2位类型转换12int a = Integer.parseInt(\"12345\"); // 经常用来将读入String转intlong b = Long.parseLong(\"233333333333333\");Character基本数据类型 char 的包装类，主要使用其对字符的判断方法、以及case转换。12345678Character.isDigit('1');Character.isLetter('a');Character.isLetterOrDigit('1');Character.isLowerCase('a');Character.isUpperCase('A');Character.isWhitespace(' ');Character.toUpperCase('a');Character.toLowerCase('A');Math数学库123456789101112131415161718192021222324252627282930313233343536Math.abs(double a) Math.max(a, b) // 返回两个值中较大的一个Math.min(a, b) // 返回两个值中较小的一个Math.sin(double a) Math.tan(double a) Math.sqrt(double a) // 返回正确舍入的 double 值的正平方根Math.sinh(double x) // 返回 double 值的双曲线正弦Math.tanh(double x) // 返回 double 值的双曲线余弦 Math.toDegrees(double angrad) // 将用弧度表示的角转换为近似相等的用角度表示的角 Math.toRadians(double angdeg) // 将用角度表示的角转换为近似相等的用弧度表示的角 Math.acos(double a) // 返回一个值的反余弦；返回的角度范围在 0.0 到 pi 之间Math.asin(double a) // 返回一个值的反正弦；返回的角度范围在 -pi/2 到 pi/2 之间Math.atan(double a) // 返回一个值的反正切；返回的角度范围在 -pi/2 到 pi/2 之间Math.atan2(double y, double x) // 将矩形坐标 (x, y) 转换成极坐标 (r, theta)，返回所得角 theta Math.cbrt(double a) // 返回 double 值的立方根 Math.ceil(double a) // 返回最小的（最接近负无穷大）double 值，该值大于等于参数，并等于某个整数 Math.copySign(double magnitude, double sign) // 返回带有第二个浮点参数符号的第一个浮点参数 Math.copySign(float magnitude, float sign) // 返回带有第二个浮点参数符号的第一个浮点参数 Math.cos(double a) // 返回角的三角余弦 Math.cosh(double x) // 返回 double 值的双曲线余弦 Math.exp(double a) // 返回欧拉数 e 的 double 次幂的值。 Math.expm1(double x) // 返回 ex -1 Math.floor(double a) // 返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。Math.getExponent(double d) // 返回 double 表示形式中使用的无偏指数。 Math.getExponent(float f) // 返回 float 表示形式中使用的无偏指数。 Math.hypot(double x, double y) // 返回 sqrt(x2 +y2)，没有中间溢出或下溢 Math.log(double a) // 返回 double 值的自然对数（底数是 e）Math.log10(double a) // 返回 double 值的底数为 10 的对数。 Math.log1p(double x) // 返回参数与 1 之和的自然对数。 Math.nextAfter(double start, double direction) // 返回第一个参数和第二个参数之间与第一个参数相邻的浮点数Math.nextUp(double d) // 返回 d 和正无穷大之间与 d 相邻的浮点值Math.pow(double a, double b) // 返回第一个参数的第二个参数次幂的值Math.rint(double a) // 返回最接近参数并等于某一整数的 double 值Math.round(double a) // 返回最接近参数的 long, 四舍五入Math.scalb(double d, int scaleFactor) // 返回 d × 2scaleFactor，其舍入方式如同将一个正确舍入的浮点值乘以 double 值集合中的一个值Math.signum(double d) // 返回参数的符号函数；如果参数为 0，则返回 0；如果参数大于 0，则返回 1.0；如果参数小于 0，则返回 -1.0Random伪随机数123456789101112131415161718192021222324/* Math库中的简易版 */Math.random() // 返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。 /* 新建随机生成器48位 */Random rand = new Random(); // 随机种子Random rand = new Random(aValueOfLong); // 填入Long作为种子, 不要填入常数/* 生成随机数 */rand.nextInt(); // 在2^32个数中随机生成一个rand.nextInt(3); // 在[0,3)中生成一个随机数rand.nextInt(18)-3;// [-3,15)rand.nextLong(); // 随机生成一个Long, 由于Random是48位故不会生成所有的Longrand.nextBoolean();rand.nextDouble(); // [0.0,1.0)rand.nextDouble()*1.5+1; // [1,2.5)/* 实现：随机抽出数组中的k个数 */int[] result = new int[k];for(int i = 0; i &lt; result.length; i++) { int idx = (int) (Math.random() * n); result[i] = numbers[idx]; numbers[idx] = numbers[n-1]; n--;}BigInteger高精度整数1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/* 声明 */BigInteger bigI1 = new BigInteger(\"123124\");BigInteger bigI2 = BigInteger.valueOf(1234L);long i1 = bigI1.longValue(); // 转long/* 常量 */BigInteger.ONE、BigInteger.ZERO、BigInteger.TEN/* 加add、减substart、乘multiply、除divide、取模mod、取余rem */bigI1 = bigI1.multiply(bigI2); // 时间复杂度有优化 n^1.585 n^1.465System.out.println(bigI1);bigI1.divide(bigI2);bigI1.remainder(bigI2);bigI1.divideAndRemainder(bigI2); // 返回包含(bigI1 / bigI2)、(bigI1 % bigI2)的两个BigInteger的数组, 效率bigI1.pow(bigI2); // bigI1^bigI2/* 比较 compareTo、equals、max、min */System.out.println(bigI1.equals(bigI2)); // 返回 falseSystem.out.println(bigI1.compareTo(bigI2)); // 返回 1、0、-1 分别表示 &gt; = &lt;/* 位操作相关 */BigInteger.valueOf(1+2+4).bitCount(); // 返回3,二进制补码中与符号不同的位的数量BigInteger.valueOf(-1-2-4).bitCount();// 返回2BigInteger.valueOf(1+2+4).bitLength();// 返回3,最小二进制补码表示形式的位数，不包括符号位。BigInteger.valueOf(1+2+4).clearBit(3);// 指定位二进制置零, 右数第3位(下标从0开始算)BigInteger.valueOf(1+2+4).flipBit(3); // 指定位二进制翻转, 右数第3位(下标从0开始算)BigInteger.valueOf(1+2+4).getLowestSetBit(); // 得到右数首个1的位置(下标从0开始算), 若返回-1则数=0// 还有 setBig(n)指定位置1、shiftLeft(n)左移、shiftRight(n)右移、testBit(n)第n位是不是1/* 位运算相关and、or、xor */bigI1 = bigI1.and(bigI2); // 位与bigI1 = bigI1.andNot(bigI2); // 位与 bigI1&amp;~bigI2bigI1 = bigI1.or(bigI2); // 位或bigI1 = bigI1.xor(bigI2); // 位异或bigI1 = bigI1.not(); // 返回取非, 当且仅当此 BigInteger 为非负时，此方法返回一个负值/* 数学 */bigI1.abs();bigI1.negate(); // 返回负的bigI1bigI1.gcd(bigI2);bigI1.isProbablePrime(); // 返回bigT1是否可能为素数, 底层是Miller-Rabin判素bigI1.isProbablePrime(certainty);// 出错率为(1-(1/2)^certainty), certainty越大时间复杂度越高bigI1.modInverse(m); // 返回m的逆元，可能会抛出异常ArithmeticException，当m&lt;=0或者无逆元（即不是m的相对素数）bigI1.modPow(n,mod); // bigI1^n%MOD, bigI1.nextProbablePrime(); // 返回这个数的可能的下一个素数, 出错率小于2^-100BigInteger.probablePrime(int bitLength, Random rnd) // 返回有可能是素数的、具有指定长度的正 BigInteger/* 进制转换 */new BigInteger(\"4123\", 5).toString(30); // 5进制转为30进制输出, 进制不超过可用字符26+数位10=36, 超过就变回十进制/* 拓展：多乘优化 */private static final class MultiplyTask extends RecursiveTask&lt;BigInteger&gt; { private final BigInteger b1, b2; public MultiplyTask(BigInteger b1, BigInteger b2) { this.b1 = b1; this.b2 = b2; } protected BigInteger compute() { return b1.multiply(b2); }}MultiplyTask mt1 = new MultiplyTask(xh, yh);mt1.fork();BigInteger p2 = xl.multiply(yl); // p2 = xl*ylBigInteger p1 = mt1.join();//xh.multiply(yh); // p1 = xh*yhBigDecimal高精度浮点数没写完，留坑！1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* 声明 */BigDecimal a = new BigDecimal(\"12.2121\");BigDecimal b = new BigDecimal(12121);BigDecimal c = BigDecimal.valueOf(121.12);/* 常量 */BigDecimal.ONE、BigDecimal.ZERO、BigDecimal.TEN/* 舍入模式常量 */BigDecimal.ROUND_CEILING // 接近正无穷大的舍入模式BigDecimal.ROUND_FLOOR // 接近负无穷大的舍入模式BigDecimal.ROUND_UP // 舍入远离零的舍入模式BigDecimal.ROUND_DOWN // 接近零的舍入模式BigDecimal.ROUND_HALF_DOWN // 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则上舍入BigDecimal.ROUND_HALF_UP // 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则下舍入BigDecimal.ROUND_HALF_EVEN // 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向偶数舍入BigDecimal.ROUND_UNNECESSARY // 断言请求的操作具有精确的结果，因此不需要舍入/* 加减乘除模余add、subtact、multiply、divide remainder*/BigDecimal addResult = a.add(b);BigDecimal subResult = b.subtract(c);BigDecimal mulResult = a.multiply(c);BigDecimal divResult = b.divide(a, 20, BigDecimal.ROUND_DOWN); // 规定精度和舍入规则BigDecimal remResult = a.remainder(c); // a%c/* 比较 compareTo、equals、max、min*/System.out.println(a.compareTo(b));// 1 0 -1 -&gt; &gt; = &lt;System.out.println(a.equals(b)); /* 小数点操作 */movePointLeft(int n) movePointRight(int n)stripTrailingZeros() // 末导零去除 /* 数学 */abs()negate()// 转负数plus() // 转正数pow(n) // 幂次/* 输出 */System.out.println(a.toString()); // 科学计数法表示System.out.println(a.toEngineeringString()); // 工程计数法表示System.out.println(a.toPlainString()); // 10进制小数表示/* 精度处理 */MathContext mc = new MathContext(精度位数n, 舍入模式);BigDecimal a = new BigDecimal(\"12.2121\", mc);setScale(n)precision() scale() // 如果 BigDecimal 对象用作 SortedMap 中的键或 SortedSet 中的元素，则应特别小心，因为 BigDecimal 的自然排序与 equals 方法不一致。 /* 牛顿法开方 */public static BigDecimal sqrt(BigDecimal value, int scale) { BigDecimal num2 = BigDecimal.valueOf(2); int precision = 120; MathContext mc = new MathContext(precision, RoundingMode.HALF_UP); BigDecimal deviation = value; int cnt = 0; while (cnt &lt; precision) { deviation = (deviation.add(value.divide(deviation, mc))).divide(num2, mc); cnt++; } deviation = deviation.setScale(scale, BigDecimal.ROUND_HALF_UP); return deviation;}// 牛顿迭代法介绍设$f(x)$，求当$f(x)=0$时x的值，则设初始值为$x_0（其值随意）$，则根据牛顿迭代法可得$x_{k+1}=x_k-f(x_k)/f`(x_k)$，若$x_0$在解的邻域内，则牛顿迭代法就可以找到解。BitsetArrays此类包含用来操作数组（比如排序和搜索）的各种静态方法。12345678910111213141516171819202122232425262728293031323334353637383940/* 【数组填充】 * fill源码是for循环 */int a[] = new int[15];Arrays.fill(a, 1);Arrays.fill(a, 0, 8, 2); // 左闭右开/* 【转Collection】 * Arrays.asList() */int a[] = new int[15];Arrays.asList(a);/* 【数组输出】 * Arrays.toString(数组) */System.out.println(Arrays.toString(a));for(int i : a) System.out.print(i + \" \"); // for-each循环/* 【数组拷贝】 * Arrays.copyOf(数组, len); // 从0开始复制返回数组对象 * Arrays.copyOfRange(数组, from, to); */int a[] = {1,2,3,4};int b[] = Arrays.copyOf(a, 3);int c[] = Arrays.copyOfRange(a, 1, 3); // 左闭右开拷贝/* 【数组判等】 * Arrays.equals(a, b); */int a[] = {1,2,3}, b[] = {1,2,3};Arrays.equals(a, b);/* 【二分搜索】 * 需要先排序，可以为对象数组，要实现比较接口 * 返回值&gt;=0时，为搜索值下标 * 返回值 &lt;0时，如-3，则表明该数应该为数组第3个数 */int a[] = {1,3,6,7,98,1090,12332,32431231};System.out.println(Arrays.binarySearch(a, 111));Collections此类包含用来容器类对象（比如排序和搜索）的各种静态方法。1234567891011121314151617/* 【反转】 */Collections.reverse(容器类对象);/* 【取大取小】*/Collections.max(容器类对象); // 还有min/* 【无交集判断】*/Collections.disjoint(a, b); // 返回boolean/* 【打乱】 */Collections.shuffle(容器类对象); /* 【二分】 */int i1 = Collections.binarySearch(buy, m);// ...等Java 容器架构Java 容器主要可划分为 4 个部分：List 列表、Map 映射、Set 集合、工具类 (Iterator迭代器、Enumeration枚举类、Arrays和Collections)上图为 Java 容器的框架图，主干部分有两个：Collection，高度抽象的接口，定义了一个集合的基本操作和属性，分为 List 和 Set 两大分支List，有序列表，每个元素都有其索引。有具体的实现类如 ArrayList、LinkedList、Vector、StackSet，不重复集，每个元素是特殊唯一的。有具体的实现类如 HastSet、TreeSetMap，抽象的映射容器接口，即 &lt;key, value&gt; 键值对的集合。有具体的实现类如 HashMap，TreeMap，WeakHashMap有了 Java 中的多态特性，在具体使用中都建议不直接声明接口的具体实现类，而是用接口接收声明的具体的实现类（形如 List list=new ArrayList()），面向接口编程思想，规范使用，易于扩展。Collection 容器主要先介绍两个 List 的实现类：ArrayList 和 LinkedList。ArrayList 是可随机访问的变长数组，对应 C++ 中的 Vector。LinkedList 是众多接口例如 List、Queue、Deque 等的实现类。IteratorIterator 是一个接口，它是集合的迭代器。集合可以通过 Iterator 去遍历集合中的元素。Iterator 提供的 API 接口，包括：是否存在下一个元素、获取下一个元素、删除当前元素。注意：Iterator 遍历 Collection 时，是 fail-fast 机制的。但是由于 ACM 的单线程，故不介绍。迭代器不是根据索引定义的，而是根据调用next()或previous()所返回的最后一个元素操作定义的。它的位置可以这样理解 ^ element(0) ^ element(1) ^ element(2) ^ element(3) ^ element(4) ^，”^”号表示迭代器当前位置。1234567891011121314151617/* Iterator */Iterator&lt;E&gt; it = ...; // 声明好的迭代器while(it.hasNext()) { System.out.println(it.next()); // 输出当前元素}it.remove(); // 移除当前元素, 比起循环过程中间remove掉某个元素造成整个集合变化，使用迭代器进行遍历过程中的remove是可行的/* ListIterator */ListIterator&lt;E&gt; it = ...; // 声明好的队列迭代器hasNext(); // 迭代器是否处于末尾hasPrevious(); // 迭代器是否处于首部nextIndex(); // 后个元素下标previousIndex(); // 前个元素下标previous(); // 返回前个元素并移动迭代器next(); // 返回后个元素并移动迭代器remove(); // 删除上一次next()或previous()操作返回的元素, 没有则异常set(E); // 设置上一次next()或previous()操作返回的元素为E, 没有则异常ArrayListArrayList，实现了有序序列接口 List，用户可对列表中每个元素的插入位置进行精确地控制，可根据元素的整数索引访问元素。尽管支持使用迭代器 Iterator 进行顺序访问。但由于又实现了 RandomAccess 接口，比起 Iterator，直接使用索引访问会更快。ArrayList 与 Vector 一样是可变数组，与 Vector 不同的有：ArrayList 是不同步的，在多线程模式下有安全问题，而 Vector 是同步的，同一时刻只有一个线程能访问 Vector，故带来了时耗，ACM 中选择 ArrayList，本文不介绍 VectorArrayList 的内存拓展策略是 50% + 1，Vector 是直接加倍，故提前指定数组大小是较明智的12345678910111213141516171819202122232425262728293031323334353637383940414243/* ArrayList声明 */ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(); // 新建初始容量为10的空列表ArrayList&lt;Integer&gt; a = new ArrayList&lt;&gt;(100);// 新建初始容量为100的空列表/* 调整容量 (ArrayList实现类特有方法) */a.ensureCapacity(2000); // 调整容量为2000a.trimToSize(); // 调整容量至当前数组大小，释放内存// ------------------------------------------------------------------------/* 接口接收实现类声明 */List&lt;Integer&gt; a = new ArrayList&lt;&gt;(); // 新建初始容量为10的空列表List&lt;Integer&gt; a = new ArrayList&lt;&gt;(100);// 新建初始容量为100的空列表/* 添加 */a.add(10); // 末尾加10a.add(0,19); // 在第0位置放上元素19, 注意下标不要超过数组范围！a.set(0,22); // 当第0位置的元素更改为22, 注意要当前元素存在/* 访问 */a.get(0); // 获得索引为0的元素a.indexOf(10); // 获得元素10首次出现的位置a.lastIndexOf(10); // 获得元素10最后一次出现的位置a.contains(10); // 返回a是否包含元素10for(Integer x : a) System.out.print(x);// 遍历ArrayListSystem.out.print(a); // 直接输出ArrayList，形如[1,3,45]/* lambda 与 foreach*/a.forEach((x) -&gt; System.out.print(x+\" \")); // 遍历输出每个元素/* 删除 */a.clear(); // 清空a.remove(2); // 删除第2个元素, 参数是基本数据类型inta.remove((Integer)2); // 删除元素2首次出现的位置, 注意泛型Integer(int的包装类)/* 其他 */a.size();a.isEmpty();Object[] objects = a.toArray(); // 转成Object数组// 以下为转成数组的demo，注意 Integer[] as = (Integer[]) a.toArray(); 的用法是错误的Integer list[] = a.toArray(new Integer[a.size()]); List&lt;Integer&gt; sub = a.subList(1, 2); // 截取下标1~2的视图，注意不是拷贝，在sub上操作会反馈回aLinkedListLinkedList，List 接口的链表实现。除此之外，此类实现 Deque 接口，add、poll 提供先进先出队列操作，可作为堆栈、队列、双端队列使用。注意，LinkedList 是不同步的。其接口方法单独作为用法讲。12/* 声明 */LinkedList&lt;Integer&gt; list = new LinkedList&lt;&gt;(); // 声明空列表ListList，可译为 “列表”或”链表”。其在 Java 中是 “列表” 的抽象接口。在此节中将其用作为 “链表”。12345678910111213141516171819202122232425262728293031323334353637/* 接口接收实现类声明 */List&lt;Integer&gt; a = new LinkedList&lt;&gt;(); // 新建空链表/* 添加 */a.add(10); // 末尾加10a.add(0,19); // 在第0位置放上元素19, 注意下标不要超过数组范围！复杂度是O(n/2)a.set(0,22); // 当第0位置的元素更改为22, 注意要当前元素存在。 复杂度是O(n/2)/* 访问 */a.get(0); // 获得索引为0的元素a.indexOf(10); // 获得元素10首次出现的位置a.lastIndexOf(10); // 获得元素10最后一次出现的位置a.contains(10); // 返回a是否包含元素10for(Integer x : a) System.out.print(x);// 遍历LinkedListSystem.out.print(a); // 直接输出LinkedList，形如[1,3,45]/* lambda 与 forEach */a.forEach((x) -&gt; System.out.print(x+\" \")); // 遍历输出每个元素/* 删除 */a.clear(); // 清空a.remove(2); // 删除第2个元素, 参数是基本数据类型inta.remove((Integer)2); // 删除元素2首次出现的位置, 注意泛型Integer(int的包装类)/* 迭代器 */Iterator&lt;Integer&gt; it = a.iterator(); // 迭代器Iterator&lt;Integer&gt; it = list.listIterator(); // 链表(双向)迭代器Iterator&lt;Integer&gt; it = list.listIterator(3); // 从下标3开始的链表得带器/* 其他 */a.size();a.isEmpty();Object[] objects = a.toArray(); // 转成Object数组// 以下为转成数组的demo，注意 Integer[] as = (Integer[]) a.toArray(); 的用法是错误的Integer list[] = a.toArray(new Integer[a.size()]); List&lt;Integer&gt; sub = a.subList(1, 2); // 截取下标1~2的视图，注意不是拷贝，在sub上操作会反馈回aQueue (带 PriorityQueue)主要介绍 Queue 的方法，还有特殊的 Queue 实现类 PriorityQueue 的使用。1234567891011121314151617/* 声明 */Queue&lt;Integer&gt; q = new LinkedList&lt;&gt;(); // 声明空队列/* 赋值 */q.offer(123); // 将元素123入队/* 访问 */int x = q.peek(); // 获取队列头，队列空返回nullint x = q.poll(); // 获取并移除队列头，队列空返回null/* 带抛出异常的操作方法 */q.add(123); // 将元素123入队，超出容量则异常q.remove(); // 获取并移除队列首，队列为空则异常q.element(); // 获取但不移除队列首，队列为空则异常/* 输出 */System.out.println(q);优先队列 PriorityQueue 的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。优先级队列不允许使用 null 元素。注意其类是不同步的。123456789101112/* 声明 */Queue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(); // 声明小根堆Queue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;((o1, o2) -&gt; { return o2 - o1;}); // 声明大根堆/* 线性构造 */Integer[] Is = new Integer[10];for (int i = 0; i &lt; 10; i++) Is[i] = (int) (Math.random()*10+1); // 赋值Queue&lt;Integer&gt; q = new PriorityQueue&lt;&gt;(Arrays.asList(Is));// 操作方法的与Queue一致Deque (作 Stack 用)double ended queue，提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（null 或 false，具体取决于操作）第一个元素（头部）最后一个元素（尾部）抛出异常特殊值抛出异常特殊值插入addFirst(e)offerFirst(e)addLast(e)offerLast(e)移除removeFirst()pollFirst()removeLast()pollLast()检查getFirst()peekFirst()getLast()peekLast()123456789101112131415161718192021222324252627/* 声明 */Deque&lt;Integer&gt; q = new LinkedList&lt;&gt;(); // 声明空队列/* 赋值 */q.offerLast(123); // 将元素123入队尾q.offerFirst(123); // 将元素123入队首/* 访问 */int x = q.peekFirst(); // 获取队列头，队列空返回nullint x = q.peekLast(); // 获取队列尾，队列空返回nullint x = q.pollFirst(); // 获取并移除队列头，队列空返回nullint x = q.pollLast(); // 获取并移除队列头，队列空返回nullint sz = q.size(); // 获得双端队列大小/* 迭代器 */Iterator&lt;Integer&gt; it = q.descendingIterator(); // 逆向迭代器Iterator&lt;Integer&gt; it = q.iterator();/* 带抛出异常的操作方法 */// 略/* 特殊方法 */q.removeFirstOccurrence((Integer)123); // 从此双端队列移除第一次出现的指定元素q.removeLastOccurrence((Integer)123); // 从此双端队列移除第一次出现的指定元素/* 输出 */System.out.println(q);作 Stack 使用12345678910/* 声明 */Deque&lt;Integer&gt; s = new LinkedList&lt;&gt;(); // 声明空栈/* 赋值 */s.push(123); // 将元素123压入栈/* 访问 */int x = s.pop(); // 获取并弹栈int x = s.peek(); // 获取但不弹栈int sz = q.size(); // 获得栈大小Map 容器架构接口：Map 是映射接口，Map中存储的内容是键值对(key-value)。AbstractMap，继承于Map的抽象类，实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。SortedMap 是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。实现类：TreeMap，基于红黑树的 Map、SortedMap、NavigableMap 等接口的实现类，与 C++ 中的 map 对应。适合对节点大小顺序有要求的需求场景HashMap，基于 Hash 的 Map 接口实现类。理想情形下能 O(1) 查找键值对。适合数据熵较高且不关心节点顺序的需求场景。WeakHashMap，其键是弱引用，WeakHashMap会在系统内存范围内，保存所有表项目，一旦内存不够，在GC时，没有被引用的表项很快会被清除掉，从而避免系统内存溢出。可以类比 LRU 策略，WeakHashMap 适用于小场景的缓存以提高内存命中提高查找效率。本文不做介绍。Hashtable，线程安全的 HashMap，但其继承的接口与 HashMap 有所不同。ACM 中选择 HashMap 即可。本文不做介绍。注意 Java 自带容器并没有像 c++ 那样的 multimap。Map.EntryMap.Entry是Map中内部的一个接口，Map.Entry是键值对，Map 可通过 entrySet() 获取Map.Entry的键值对集合，从而通过该集合实现对键值对的操作。123getKey()getValue()setValue(V object)Map1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* 声明 */Map&lt;String, Integer&gt; map = new TreeMap&lt;&gt;(); // 底层是红黑树的mapMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); // 底层是哈希表的map/* 赋值 */map.put(\"tt\", 123);/* 访问 */map.containsKey(\"tt\"); // 是否包含此键map.containsValue(123); // 是否包含此值 O(n)int v = map.get(\"tt\"); // 获取值int v = map.remove(\"tt\"); // 移除并返回键所对应的值, 不存在则返回null，将null自动解包到int会异常/* java中的map计数 使用必须先删再回加 */map.put(\"tt\", map.remove(\"tt\")+1); // 注意可能异常map.put(\"tt\", (map.containsKey(\"tt\")?map.remove(\"tt\"):0) + 1);/* 更高效的map计数 -&gt; 自己写一个类MutableInteger，写自增 */Map&lt;String, MutableInteger&gt; map = new HashMap&lt;&gt;();MutableInteger initValue = new MutableInteger(1);MutableInteger oldValue = efficientCounter.put(a, initValue);if(oldValue != null) initValue.set(oldValue.get() + 1);/* 其他 */map.size(); // map的大小map.isEmpty();/* 遍历所有entry */Collection&lt;Entry&lt;String, Integer&gt;&gt; values = map.entrySet();// foreach遍历for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue());}// Iterator遍历Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();while (entries.hasNext()) { Map.Entry&lt;Integer, Integer&gt; entry = entries.next(); System.out.println(\"Key = \" + entry.getKey() + \", Value = \" + entry.getValue());}/* 遍历所有keys、values */Collection&lt;Integer&gt; keys = map.keys();Collection&lt;Integer&gt; values = map.values();/* 输出 */System.out.println(map);/* 按value排序 */Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();List&lt;Entry&lt;Integer, Integer&gt;&gt; list = new ArrayList&lt;&gt;();list.addAll(map.entrySet());Collections.sort(list, (o1, o2) -&gt; { return o1.getValue() == o2.getValue() ? o1.getKey() - o2.getKey() : o2.getValue() - o1.getValue();});hashMap 重写 hashCode() 和 equals()12345678910111213141516171819202122232425262728293031/* 【HashMap key类 重写hashCode()和equals()】 *//* hashCode()用来定位要存放的位置，equal()用来判断是否相等（有时候我们要的是逻辑上的相等）。原则: 1.同一个对象（没有发生过修改）无论何时调用hashCode()得到的返回值必须一样。 如果一个key对象在put的时候调用hashCode()决定了存放的位置，而在get的时候调用hashCode()得到了不一样的返回值，这个值映射到了一个和原来不一样的地方，那么肯定就找不到原来那个键值对了。2.hashCode()的返回值相等的对象不一定相等，通过hashCode()和equals()必能唯一确定一个对象 不相等的对象的hashCode()的结果可以相等。hashCode()在注意关注碰撞问题的时候，也要关注生成速度问题，完美hash不现实3.一旦重写了equals()（重写equals的时候还要注意要满足自反性、对称性、传递性、一致性），就必须重写hashCode()。而且hashCode()的生成哈希值的依据应该是equals()中用来比较是否相等的字段。 如果两个由equals()规定相等的对象生成的hashCode不等，对于hashMap来说，他们很可能分别映射到不同位置，没有调用equals()比较是否相等的机会，两个实际上相等的对象可能被插入不同位置，出现错误。其他一些基于哈希方法的集合类可能也会有这个问题方法：hashCode() 对所有对象的属性，都得到一个int散列值c，然后将变量的散列值依次 hash = hash*37 + c 合并。 float c = Float.floatToIntBits(f); double long l = Double.doubleToLongBits(f); c = (int(l^(l&gt;&gt;&gt;32))) Object c = object.hashCode();*/@Overridepublic int hashCode() { int result = 17; result = 37*result+name.hashCode(); result = 37*result+age; result = 37*result+(sex ? 0 : 1); return result;}@Overridepublic boolean equals(Object obj) { return obj instanceof Student &amp;&amp; this.name.equals(((Student)obj).name) &amp;&amp; this.age == ((Student)obj).age &amp;&amp; this.sex == ((Student)obj).sex;}// 当前，java的IDE一般都可以直接 Source-&gt;Generate hashCode and equals() 不用手写SortedMap123456789101112/* 声明 */SortedMap&lt;String, Integer&gt; map = new TreeMap(); SortedMap&lt;Integer, Integer&gt; map = new TreeMap&lt;&gt;((o1, o2) -&gt; { return o1.compareTo(o2);}); /* 较Map新增API */K firstKey()SortedMap&lt;K, V&gt; headMap(K endKey)K lastKey()SortedMap&lt;K, V&gt; subMap(K startKey, K endKey)SortedMap&lt;K, V&gt; tailMap(K startKey)NavigableMap继承于SortedMap的接口。一个可导航的键-值对集合，具有了为给定搜索目标报告最接近匹配项的导航方法。1234567891011121314151617181920212223242526/* 声明 */NavigableMap&lt;String, Integer&gt; map = new TreeMap(); /* 提供操作&lt;键,值&gt;对的方法, 不存在则返回null */Entry&lt;K, V&gt; lowerEntry(key) // 返回小于key所对应的键值对的第一个键值对Entry&lt;K, V&gt; floorEntry(key) // 返回小于等于key所对应的键值对的第一个键值对Entry&lt;K, V&gt; ceilingEntry(key) // 返回大于等于key所对应的键值对的第一个键值对Entry&lt;K, V&gt; higherEntry(key) // 返回大于key所对应的键值对的第一个键值对firstEntry(); // 返回首个键值对 pollFirstEntry(); // 弹出首个键值对 lastEntry(); // 返回末个键值对 pollLastEntry(); // 弹出末个键值对 /* 提供操作键的方法 */K lowerKey(key) // 返回小于key的第一个键K floorKey(key) // 返回小于等于key的第一个键K ceilingKey(key) // 返回大于等于key的第一个键K higherKey(key) // 返回大于key的第一个键/* 获取键集 */NavigableSet&lt;String&gt; subset = map.navigableKeySet(); // 获取正序的键集NavigableSet&lt;String&gt; subset = map.descendingKeySet();// 获取反序的键集/* 获取当前map的逆序视图 */NavigableMap&lt;String, Integer&gt; subset = map.descendingMap();Set 容器架构Map 同样继承于 Collection 接口，但在本文将其单独拿出来讲述。Set的实现类都是基于Map来实现接口：Set 是继承于Collection的接口。它是一个不允许有重复元素的集合。AbstractSet 是一个抽象类，它继承于AbstractCollection，AbstractCollection实现了 Set中的绝大部分函数，其它Set的实现类可以通过继承AbstractSet 来减少重复编码。SortedSet、NavigableSet 可以类比 Map实现类：TreeSet，依赖于 TreeMap，底层同样是红黑树。元素有序。HashSet，依赖于 HashMap，底层是拉链法的哈希。元素无序。Set123456789101112131415161718192021222324252627/* 声明 */Set&lt;Integer&gt; set = new TreeSet&lt;&gt;(); // 底层是红黑树Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); // 底层是哈希/* 赋值 */set.add(123);/* 删除 */set.remove(123);set.clear();/* 访问 */set.contains(123);for(Integer x : set) { System.out.println(x);}set.forEach(x -&gt; System.out.println(x));/* 其他 */set.size();set.isEmpty();Object[] objects = set.toArray(); // 转成Object数组// 以下为转成数组的demo，注意 Integer[] as = (Integer[]) a.toArray(); 的用法是错误的Integer list[] = set.toArray(new Integer[set.size()]); /* 输出 */System.out.println(set);SortedSet1234567891011121314/* 声明 */SortedSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); // 从小到大排序SortedSet&lt;Integer&gt; set = new TreeSet&lt;&gt;((o1, o2) -&gt; { return o2 - o1;}); // 从大到小排序SortedSet&lt;String&gt; set2 = new TreeSet&lt;&gt;(); // 从小到大排序/* 较Set新增API */set.first(); // 最低元素set.last(); // 最高元素set.tailSet(123); // 返回set的部分视图，其元素大于等于123set.subSet(123, 126); // 返回set的部分视图，其元素[123,126)间set2.subSet(low, high+\"\\0\");// 返回set2的部分视图，其元素[low,high]间set2.subSet(low+\"\\0\", high);// 返回set2的部分视图，其元素(low,high)间NavigableSet1234567891011121314151617181920/* 声明 */NavigableSet&lt;Integer&gt; set = new TreeSet&lt;&gt;(); // 从小到大排序NavigableSet&lt;Integer&gt; set = new TreeSet&lt;&gt;((o1, o2) -&gt; { return o2 - o1;}); // 从大到小排序NavigableSet&lt;String&gt; set2 = new TreeSet&lt;&gt;(); // 从小到大排序/* 较NavigableSet新增API */set.ceiling(123); // 返回大于等于123的第一个元素，不存在返回nullset.floor(123); // 返回小于等于123的第一个元素，不存在返回nullset.lower(123); // 返回小于123的第一个元素，不存在返回nullset.higher(123); // 返回小于123的第一个元素，不存在返回nullset.headSet(123); // 返回set的部分视图，其元素小于123set.headSet(123, true); // 返回set的部分视图，其元素小于等于123set.pollFirst(); // 获取并移除最低元素，set为空返回nullset.pollLast(); // 获取并移除最高元素，set为空返回null/* 其他 */descendingIterator(); // 逆序迭代器descendingSet(); // 逆序视图排序排序大多是针对数组、容器类对象施展的，同样依靠Arrays、Collections，单独提取出来总结。Arrays.sort() 对[原生数组]操作Collections.sort() 对[容器类对象]操作实现Comparable接口类的排序可比较接口，实现后类的实例可以直接用compareTo比较。1234567891011121314151617/* 原生数组 */Student[] ss = new Student[10];for(int i=0;i&lt;10;i++) ss[i] = new Student(i);Arrays.sort(ss); /* 容器类对象 */List&lt;Student&gt; ss = new LinkedList&lt;&gt;();for(int i=0;i&lt;10;i++) ss.add(new Student(i));Collections.sort(ss);/* student类的定义 */class Student implements Comparable&lt;Student&gt; // 要求实现Comparable{ int age = 0; public int compareTo(Student o) { return age-o.age; } // 年龄升序 public Student(int age) { this.age = age; }}借由Comparator接口类的排序比较器类，帮助对象进行比较，作排序传参。1234567891011121314151617181920212223/* 原生数组 */Student[] ss = new Student[10];for(int i=0;i&lt;10;i++) ss[i] = new Student(i);Arrays.sort(ss, new StudentCompartor()); /* 容器类对象 */List&lt;Student&gt; ss = new LinkedList&lt;&gt;();for(int i=0;i&lt;10;i++) ss.add(new Student(i));Collections.sort(ss, new StudentCompartor());/* student类的定义 */class Student{ int age = 0; public Student(int age) { this.age = age; }}/* studentCompartor类的定义 */class StudentCompartor implements Comparator&lt;Student&gt;{ @Override public int compare(Student o1, Student o2) { return o1.age-o2.age; } // 年龄升序}匿名内部类实现的排序123456789101112131415161718192021222324252627/* 原生数组 */P[] ps = new P[10];for(int i=0;i&lt;10;i++) ps[i] = new P(i);Arrays.sort(ps, new Comparator&lt;P&gt;() { // 第1关键字升序第2关键字降序 public int compare(P o1, P o2) { if(o1.a != o2.a) return o1.a-o2.a; return o2.b-o1.b; }});/* 容器类对象 */List&lt;P&gt; ps = new LinkedList&lt;&gt;();for(int i=0;i&lt;10;i++) ps.add(new P(i,10-i));Collections.sort(ps, new Comparator&lt;P&gt;() { // 第1关键字升序第2关键字降序 public int compare(P o1, P o2) { if(o1.a != o2.a) return o1.a-o2.a; return o2.b-o1.b; }});/* P类的定义 */class P{ int a, b; public P(int a, int b) { this.a = a;this.b = b; }}Lambdajava8 新增了对Lambda表达式的支持。简化多关键字排序123456789101112/* 原生数组 */Arrays.sort(ps, (o1, o2)-&gt;(o1.a!=o2.a ? o1.a-o2.a : o2.b-o2.a));/* 容器类对象 */Collections.sort(ps, (o1, o2)-&gt;(o1.a!=o2.a ? o1.a-o2.a : o2.b-o2.a));/* P类的定义 */class P{ int a, b; public P(int a, int b) { this.a = a;this.b = b; }}String12replace(oldS, newS); // 非正则表达式的全部替换特别字符说明$匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或‘\\r’。要匹配 $ 字符本身，请使用 $。( )标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。*匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。+匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。.匹配除换行符 \\n之外的任何单字符。要匹配 .，请使用 \\。[ ]标记一个中括号表达式的开始。要匹配 [，请使用 [。?匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。\\将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\\”，而 ‘(‘ 则匹配 “(”。^匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。{ }标记限定符表达式的开始。要匹配 {，请使用 {。|指明两项之间的一个选择。要匹配 |，请使用 |。1&apos;单引号。要匹配’，请使用\\&apos;。 &quot;双引号。要匹配“，请使用\\&quot;。StringBuilderRegexjava.util.regex.*中有正则表达式的方法，除此之外String自带方法也支持正则表达式。正则表达式主要关注：匹配、替换、提取、切割。转义12345678910111213// 注意在java里匹配\\需要输入\\\\\\\\，因为\\\\是java语言本身对\\的转义，而到了正则引擎还会经过一层转义。 也可直接使用下面转义Matcher.quoteReplacement(\"\\\\\");static String escapeExprSpecialWord(String keyword) { final String[] fbsArr = { \"\\\\\", \"$\", \"(\", \")\", \"*\", \"+\", \".\", \"[\", \"]\", \"?\", \"^\", \"{\", \"}\", \"|\" }; for (String key : fbsArr) { if (keyword.contains(key)) { keyword = keyword.replace(key, \"\\\\\" + key); } } return keyword;}匹配12String s = \"189893\";if(s.matches(\"1.*?3\")) System.out.println(\"yes\");切割12String s = \"ads1dasd2dasd3dasd4as\";String[] ss = s.split(\"[0-9]\");替换12String s = \"&lt;html class=123&gt; &lt;a href=2333&gt;\";String ss = s.replaceAll(\"&lt;.*? ([^&gt;]*)&gt;\", \"&lt;div $1&gt;\"); // 将标签都换为div提取1234567891011121314151617181920212223242526String testStr = \"Java is one of my favorite programming language!\";Pattern re = Pattern.compile(\"[a-zA-Z]+\");Matcher m = re.matcher(testStr);while(m.find()) System.out.println(\"testStr[\"+m.start()+\", \"+m.end()+\"]: \"+m.group());// 输出各个单词String s = \"&lt;html class=123&gt; &lt;a href=2333&gt; &lt;div sss=asd&gt;\";Pattern re = Pattern.compile(\"&lt;.*? [^&gt;]*=([^&gt;]*)&gt;\");Matcher m = re.matcher(s);while(m.find()){ System.out.println(\"匹配串：\" + m.group(0)); System.out.print(\"匹配部分：\"); for(int i=1;i&lt;=m.groupCount();i++) System.out.print(m.group(i) + \" \"); System.out.println(\"\");}/* 输出标签参数内容：匹配串：&lt;html class=123&gt;匹配部分：123匹配串：&lt;a href=2333&gt;匹配部分：2333匹配串：&lt;div sss=asd&gt;匹配部分：asd*/Eclipse使用123456780.【主题更改】： Window-&gt;Preferences-&gt;General-&gt;Appearance1.【代码提示功能强化】： Window-&gt;Preferences-&gt;Java-&gt;Editor-&gt;Content Assist-&gt;[Auto Activation].[Auto activation triggers for Java]，把&quot;.abcd...xyz&quot;全按上，意思是是按哪些键自动触发代码提示功能。2.【代码提示功能之防空格防等号补全】： Window-&gt;Preferences-&gt;Java-&gt;Editor-&gt;Content Assist-&gt;[Disable insertion triggers except&apos;Enter&apos;]√3.【字体大小】 Ctrl+加号/减号","link":"/ACM/ACMLife-0_2-Java-Summarize/"},{"title":"关于工作、读研、人生","text":"凌晨，研招系统填完志愿，下一段人生，是去南京直博。 其实在过去三年里面，无数次地想过、认为，自己就是本科毕业后出去工作，赚钱，经济独立，家庭，传承，结束一生。要工作，就要打怪升级要积累点缀要丰富简历，为此，在打 ACM 到一定时候，乐趣感就下降到了一定程度，充斥功利和焦虑，几乎要抹杀了我大学为数不多的爱好。好在，我确实是热爱她的。（关于这段经历，我想在毕业前总结到另一篇小作文里）2020 年的春招金三银四，定向投了阿里、腾讯和字节，拼命复习，总结面试技巧，”过五关斩六将”，拿了阿里新零售、微信、字节财经业务的实习 offer，最终暑假选择了小钱钱最少的阿里，理由是 朝圣，看看中国写 Java 最牛逼的地方是怎样的。实习是 10-9-5 工作制，不过经常看到主管比我更晚走。业务开发，实习期支持了两个域，一个是 “区域零售”（线上下单门店发货，比如在淘宝下单优衣库或桶装水可以小时达/半日达，体量被猫超和美团压的很小），一个是 “玲珑家装营销” （家装是强到店业务，营销比如线上流量通过有价礼包优惠券形式引导到店交易，交易上翻，对成交单收佣，这个体量很大上百亿，所以生怕代码中有 bug 造成资损，谨小慎微）。实习最大的要点在于沟通，如何整合阿里的人力资源做生产，产出商业价值，和产品沟通，得让他们知会技术上能支持什么能力，理解他们哪些特性需要快速迭代和试错，和测试沟通，得让他们知道提测的重点和覆盖范围，和老板沟通，得让他们知道你所做事情的意义和产出。关于技术，阿里是真的强，基建上的框架和中间件，产品上的一些文档沉淀，见识和领会了好多，也偷学了不少。还有很多很多，不过这都是他话。（关于如何找实习，找时间另外总结一篇博客吧）…每当上班，走过聚橙路的十字路口，车辆穿行、人头涌动，就会有一种自己真的好渺小的感觉，是这大千世界上的一只小蚂蚁。我知道按照这条路走下去，以我，没有意外的话，一定会物质充裕，生活充实。所以，人活这一生到底为了什么，我高中时候以为我想明白了，赚钱、养家、吃喝玩乐。高考后父亲和我说，如今这个世代，饿不到你，不期望你大富大贵，一生只为赚钱而赚钱，希望做点自己喜欢的事情，最后最好对社会有用。我那时以为我想明白了，赚钱、养家、吃喝玩乐。大学了，发现大学和我想的不一样啊，感觉自己被世界欺骗了。那时我以为我想明白了，写代码、赚钱、养家、吃喝玩乐。“我想让我的代码在我死后继续运行！”，我心里如是想到。但是还是要赚钱、赚钱、赚钱。…人是会分心的，实习期下班路上我会想一下，我如果走了另一条人生道路，如果我不放弃保研了，会怎样。带着一点神奇的缘分，我在刷知乎时看到了关于我导 LY/TT 的信息。首先是 你在南京大学上过最牛的课是什么？，随后是 南京大学「程序设计语言与静态分析」研究组。听了课，心中有股 exciting，感觉有点后悔和愤怒自己为什么之前没有了解过这样的方向。“实话说，我不知道自己适不适合做科研，但我带着很纯粹的目的想跟您读研”，我在义无反顾发邮件给老师后第二天的视频沟通上如是说道。之前几乎没有做过科研。但我想到的是，我在大学做的最多的事情，是打代码。我喜欢创造，喜欢敲下一个个字符，组成一行行代码，运行起来的效果让我着迷。因此，我也对 Programming Language 很感兴趣，她的特点、特性、设计、语法等等，我想知道是哪些天才的想法创造现代编程语言的特性，如函数式编程、反射、多态等等，对于静态分析的方法和应用也有无数的好奇。我想研究 PL，想研究 SA，想为计算机科学做贡献。不是为了 title，不是为了高薪，就是带着这点纯粹的目的，想要跟导师读研。如果我不适合科研，或者我对 PL 变心了，我也有我的退路我的报应，前面说的，饿不死。如果我不适合科研，但是我对 PL 真的无比热爱，我会用心教研与导师一起在国内开枝散叶，让更多的人了解她，加入她（因为在国内，研究 PL 的人真的不多，如果我做不到，就努力让我的学生做到吧）。“这些对兴趣的专注和纯粹本应该是大学生在自己专业上该有的年轻的、百舸争流的样貌，如今却被年薪、房价和社会的物化价值观所左右。如果连我们国家顶尖大学的教育都摆脱不了物欲横流的浮躁，又如何完成国家民族集体人格的进一步塑造？”，我在知乎上看到我导写了这样一句话。…我要报南大，跟我导读研去啦，我心里很确定。所以我来啦，尽管一路波折~…“ZT，经过我们的沟通，我决定了，我愿意收你作我的学生。”…","link":"/CS/About-Work-Study-And-Life/"},{"title":"ACMLife之宁夏丝绸之路赛","text":"前言之前为了省赛名额，学校大概20+支ACM队伍，打了一个多月的积分赛。依据这次积分赛的排名，以及自费参赛的志愿，来平分4月份实验室打的网络邀请赛获得的三个名额。很幸运，我们队伍能够苟到一个名额。去获得一次类似区域赛规模的体验。这是我第一次出去比赛，也是我们队。虽然不知道暑期集训后队伍何去何从，但我们依旧开心。历程睡了一次上铺*15h，到达清爽但是十分晒的宁夏，还有清一色的古铜色皮肤。说实话是真的晒，某hmc学长觉得自己的脖子快被晒得变为进撃の巨人酒店——星海湖宾馆，听说贵宾楼被星海湖环绕，但是我们入住较久的一号楼（喵喵喵？没感觉呀。。。星海湖的一瞥宁夏理工的一瞥宁夏理工学院的体育馆，真气派！（别人的学校：(比赛环境（电脑配置）：I7-6700K、8G、256gSSD但是配了一把全程我不顺手的键盘，呵呵我们的队牌和气球和奖牌，嘿嘿嘿看我在机场发现了什么？一个计时休息服务，感觉很赞呀（孤陋寡闻的我比赛我们总共AC了5道题（C、B、D、H、A），总的来说罚时挺惨的。C题是一道签到题，有关字母表的加密。但我一上来很没感觉，WA了3发，还zz不会写%26了，第4发才AC，感觉队友要砍人？B题是法爷做的计算几何此时刚做完C题的我有点智障，表示法爷能干自己上键盘然后让出键盘，苟蒻的代码手D题展dalao推的概率题他说我们不帮他看题搞得他题意极迷主要是搞题意特别久，然后他上键盘，WA两发后AC。H题，主要关于全序关系和贪心排序吧就是说有n个怪兽，怪兽有hp和攻击力，每局开头hero先被仅存的怪兽围殴一轮减血，然后英雄可以选择攻击一个怪兽，对于某个怪兽的第i次攻击让它掉i滴血。Hero血无限厚，求打完所有怪兽英雄的最低耗血。嘛，最小化问题，应该是贪心了，然后想到对第一关键字攻击力降序、第二关键字hp升序进行双关键字排序，然后就是选择攻击一个怪兽必然打到它over。但是，错啦。于是甩锅，我开始翻A题。队友成功推出是对权值（击打次数/攻击力）进行一个排序，AC。A题是一道有关于栈的先进后出的题，要求我们在实现栈的功能和维护一个栈内最大值。这道题我怨气特别大，我当初第一眼想到维护一个最大值用的应该是优先队列，但是TLE了。紧接着队友了解题意后很顺口地说，用”堆”维护啊！然后，然后你们知道吗？一道维护前缀最大的水题，硬生生地，我被队友怂恿在赛场上现学”二叉堆”！最后，WA了第12发后，队友开始放弃，我始终觉得pop的功能没实现好，加了栈优化，心灰意冷地交了一发，然后突然2s给我返回一个绿色的”Yes”，我(艹皿艹 )？突然大叫一声，整个体育馆看了过来，志愿者过来问我：“请问有什么问题吗？”，我说：“没…没事，我A了道题”。整个人都热血沸腾了，打ACM最激情的时刻，就是万念俱灰，你又不舍得放弃，不断优化、排错，最后返回Accepted的那一刻。你又有了开新题的冲动。总结没有总结，就是开心，诶，嘿嘿A题在两位队友准备放弃的时候我开始狂交题，所以罚时早已料得但是，原以为是铜牌区的顶端，变成了银牌区尾部，你说开不开心？人人拿牌系列还有，志愿者小姐姐真漂亮。","link":"/ACM/An-ACM-Contest-Of-NingXia-Silk-Road/"},{"title":"计算机视觉-学习笔记","text":"自学笔记，单词翻译可能出错第 1 章 绪论概述图像：对客观世界视觉属性的描述视觉：图像获取、基于图像的感知计算机视觉的目标：让机器“理解”图像和视频计算机视觉的应用智能监控无人车医学影像分析机器人（定位、导航）增强/混合现实图像检索智能图像管理/编辑刷脸面孔和数码相机，笑容检测图像拼接体感游戏视觉特效计算机视觉的难点/挑战光照 Illumination物体姿势 Object pose噪声 Clutter遮蔽 Occlusions外观识别 Intra-class appearance视点 Viewpoint类内差异 Intra-Category Variation，比如沙发有很多种复杂度 Complexity成像人眼的成像：物体在视网膜上的成像为倒影、视网膜位于球面上人眼对光线有很强的环境适应能力人眼对亮度的感受与光线强度成对数关系马赫带人对亮度的感觉：亮度的相对性对比引起的相对性前景与背景的相对性整体性：主观轮廓图像获取方式的变化 Camera Obscura：暗箱，点投影绘画针孔相机 Pinhole Camera相机：光圈 Aperture，或者说孔径 Pinhole Size：进光量镜头作用：保持图像清晰对焦，同时收集大面积的光线薄透镜：景深：可以容忍模糊的图像平面之间的距离视野：取决于焦距数字相片：底片被传感器阵列替代电荷耦合器件阵列 (Charge-Coupled device，CCD)图片离散成像素光强量化为像素值颜色传感器：将进光用不同的过滤层转换为传感阵列，ceil 的颜色缺失可从相邻 ceil 中获取处理图像 -&gt; 采样 -&gt; 量化：采样分辨率，采样间隔粗采样 Coarse Sampling细采样 Finer Sampling量化信号量化 $K=2^n $影响图像灰度结构文件格式：矢量图 vector images，.ai .eps .ps ...优点：缩放无混叠 aliasing 和 模糊 blur缺点：难以获取，应用有限位图 bitmap .bmp .jpg .pmg .gif存储像素色彩。优缺点与矢量图相反。将矢量图进行光栅化 rasterize 可得到位图GIF —— Graphics Interchange Format8 位真彩可进行融色 dither优点：生动 animated、易懂 transparentJPEG —— Joint Photographic Experts Group16 bit，一次性不融色 dither 地展示上百万像素约 60% 的压缩比是质量与文件大小的合适比例PNG —— Portable Network Graphics基于 ZIP 的无损压缩4-channel image，4通道图，第4个参数控制透明BMP —— Windows Bitmap简单、未压缩 uncompressed设备独立位图 Device Independent Bitmap, DIB，设备依赖位图 Device Dependent Bitmap, DDB位图的存储结构：size (resolution, dpi, width*height, numOfPixels)Color Space (RGB, CMYK, YUV, Lab, …)Channels (1,2,3,4, gray&amp;color)，通道Depth (8bits, 12bits, …, LDR&amp;HDR)Coordinate system12345678910111213141516171819202122232425262728293031struct MyImage{ int width, height; int type; // 类型(通道数、位深度) /* CV_8UC3: unsigned char[3] CV_32SC1: int[1] CV_32UC1: uint[1] CV_32FC4: float[4] */ void* data; // 图像数据 int step; // 步长 }int* getPixel(const MyImage &amp;img, int x, int y){ // img.type=CV_32SC3: 32位带符号，3通道数据 return (int*)((char*)img.data+y*img.step+x*3*4);}void scanPixels(uchar *data, int width, int height, int step, int nc){ // step步长 nc通道数numOfChannel uchar *row=data; for(int yi=0; yi&lt;height; yi++, row+=step) { uchar *px=row; for(int xi=0; xi&lt;width; xi++, px+=nc) // px now address the pixel (xi,yi) }}void scan_roi_pixels(MyImage &amp;img, int x, int y, int roi_width, int roi_height){ // 通道数nc=img.nc(); scan_pixels( get_pixel(img, x, y), roi_width, roi_height, img.step, img.nc());}第 2 章 图像处理概述像素描述 (x, y, R, G, B)：空间坐标 Spatial coordinate —— x, y像素颜色 —— RGB, YUV, …基本图像处理：基于空间坐标 —— 几何变换（CG 课程中有所关注）基于像素颜色 —— 代数运算（CV 中着重）代数运算像素灰度变换灰度变换 Gray Level Transformation，通过代数运算最简单的图像处理任务逐个像素转换：亮度 Intensity、对比度 Contrast12345678910111213141516171819202122/* 逐个像素扫描处理的通用过程 */void scanPixels(uchar *data, int width, int height, int step, int nc){ // step步长 nc通道数numOfChannel uchar *row=data; for(int yi=0; yi&lt;height; yi++, row+=step) { uchar *px=row; for(int xi=0; xi&lt;width; xi++, px+=nc) // px now address the pixel (xi,yi) }}/* 灰度处理 */void grayTransform(uchar *data, int width, int height, int step, const uchar T[256]){ uchar *row=data; for(int yi=0; yi&lt;height; ++yi, row+=step) { uchar *px=row; for(int xi=0; xi&lt;width; ++xi, px++) *px = Transform(*px); }}亮度调整函数亮度调整：整体变亮或变暗线性函数非线性函数log 函数 $s = c·log(1+r)$幂次函数 $s = c·r^\\gamma $伽马矫正对图像的伽马曲线进行编辑，图像进行非线性色调编辑的方法,检出图像信号中的深色部分和浅色部分，并使两者比例增大，从而提高图像对比度效果对比度调整函数对比度调整：亮的更亮，暗的更暗增加图像处理中被处理的灰度等级范围分层量化 Quantize、固定阈值二值化 Threshold分段线性 PiecewiseSigmoid 函数优美 S 形曲线的数学函数，连续，光滑，严格单调，以(0,0.5)中心对称，是一个非常良好的阈值函数多图像处理输入多幅大小相同的图像，基于对应像素进行计算，输出图像。$O(x, y) = f[I^1(x,y), I^2(x,y), \\cdots , I^N(x,y)] $MultiplyXORORAlpha Blending，阿尔法混合$C = \\alpha F + (1-\\alpha) B$给定 C，如何分离 $\\alpha、F、B $ 。C 去掉 B 的纯色得到 $\\alpha$Image Matting (masking, 抠图)从图像中提取特殊的物体或区域，得到 alpha map对于细微区域或头发等物体的抠图需要解决前景恢复 foreground restoration背景相减当前帧 $I(x, y)=(r,g,b)$，背景 $B(x,y) = (r,g,b) $，阈值 $T $$Diff(x, y) = ||I(x,y)-B(x,y)||^2 ，当 Diff(x,y)&gt;T 则认为是前景$几何处理翻转 flip缩放 resize / zoom in / zoom out / scale旋转 rotation仿射变换 Affine Transform透视变换 Perspective Transform图形变形 Image Warping翻转123456789101112131415161718void vflip(const void *in, int width, int height, int istep, int pix_size, void *out, int ostep){ // 竖直翻转 out = (char*)out+(height-1)*ostep; for(int yi=0; yi&lt;height; ++yi, in=(char*)in+istep, out=(char*)out-ostep){ memcpy(out, in, width*pix_size);}void hflip(const void *in, int width, int height, int istep, int pix_size, void *out, int ostep){ // 水平翻转 / 镜像翻转 char * _in=(char*)in; char *_out=(char*)out+(width-1)*pix_size; for(int yi=0; yi&lt;height; ++yi, _in+=istep, _out+=ostep) { char *in_x=_in, char *out_x=_out; for(int xi=0; xi&lt;width; ++xi, in_x+=px_size, out_x-=px_size) memcpy(out_x, in_x, pix_size) ; }}放大 Zoom in如何填充新增的像素点：方案 1，投影 projection，对小图中的每个像素，计算其在大图中对应的像素。会遗漏像素方案 2，查找 Lookup，对大图中的每个像素，计算其在小图中对应的像素方案 3，重采样 Resampling基于邻近像素的值，计算非整数位置上的颜色值。有三种策略最近邻 （Nearest Neighbor)线性插值 (Bilinear Interpolation)123456float bilinear(float a, float b, float c, float d, float dx, float dy){ float h1=a+dx*(b-a); // =(1-dx)*a+dx*b float h2=c+dx*(d-c); return h1+dy*(h2-h1);}双三次插值 (Bicubic Interpolation)怎么解是 $\\begin{cases} f(0) = d \\ f(1)=a+b+c+d \\ f(2) =8a+4b+2c+d \\ f(3)=27a+9b+3c+d \\end{cases} \\Rightarrow [a,b,c,d] $ 吗？ 不是正确解法，等式过多。正确解法 $\\begin{cases}f(0) = d \\ f(1) = a+b+c+d \\ y’ = 3ax^2 +2bx + c \\ f’(0)=c \\ f’(1)=3a+2b+c \\end{cases} \\Rightarrow [a,b,c,d]$补充：离散函数的导数 $f’(x) = \\frac{[f(x+1)-f(x)]+[f(x)-f(x-1)]}{2}=\\frac{f(x+1)-f(x-1)}{2} $Super-Resolution (超分辨率)以下引入 CG 的笔记，有所更改二维变换原理变换：比例、旋转、镜像、错切、平移对于一个图形，可用顶点表描述图形的几何关系，用连边表来描述图形的拓扑关系。故对图形的变换，只变换图形的顶点表仿射变换Affine Transformation平直性：直线变换后仍是直线平行性：平行线变换后仍平行二维仿射变换： $\\begin{cases} x’ = a_1x+b_1y+c_1 \\ y’=a_2x+b_2y+c_2 \\end{cases}$二维仿射变换，矩阵形式：$\\left[ \\begin{matrix} x^* &amp; y^* \\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} a_1 &amp; a_2\\ b_1 &amp; b_2 \\ c_1 &amp; c_2 \\end{matrix} \\right] $特殊的仿射变换：刚性变换 Rigid Transformation只包含平移和旋转保持物体的形状、尺寸相当于正交变换相似变换 Similar Transformation只包含平移、旋转和等比缩放保持物体的形状仿射变换 Affine Transformation： 在同一平面内部的变换视角变换 Perspective Transform： 可表示不同视角观察到的同一平面，或同一视角观察到的不同平面之间的变换齐次坐标二维平面中用(x, y)表示一个点，不妨说是一个向量(x, y)表示一个点。所以可以用第3维为常数的(x, y, 1)表示二维平面上的向量这种n+1维表示n维的方法称为——齐次坐标表示法，n维向量 $(p_1,p_2,\\cdots,p_n)$ 表示为 $(hp_1,hp_2,\\cdots,hp_n, h)$，其中 $h $ 称为哑坐标，特别的 h=1 时称齐次坐标为规格化坐标。二维仿射变换，齐次坐标表示：$\\left[ \\begin{matrix} x^* &amp; y^*&amp;1 \\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} a_1 &amp; a_2 &amp;0\\ b_1 &amp; b_2&amp;0 \\ c_1 &amp; c_2 &amp;1\\end{matrix} \\right] $不使用齐次坐标可以做比例、对称、旋转变换，但做不到平移变化，无法增加常数项。平移变换不产生变形而移动物体的刚体变换，即物体上的每个点移动相同数量的坐标坐标形式：$\\begin{cases} x^* = x+T_x \\ y^*=y + T_y \\end{cases} $齐次坐标形式：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\0&amp;1&amp;0\\T_x&amp;T_y&amp;1 \\end{matrix} \\right] $比例变换相对于坐标原点沿x方向放缩$S_x$倍，沿y方向放缩$S_y$倍。S &gt; 1放大，S &lt; 1 缩小。坐标形式：$\\begin{cases} x^* = x·S_x \\ y^*=y·S_y \\end{cases} $齐次坐标形式：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} S_x &amp; 0 &amp;0 \\0&amp;S_y&amp;0\\0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x·S_x &amp; y·S_y &amp;1\\end{matrix}\\right] $当 $S_x =S_y $ 时，为整体比例变换，$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\0&amp;1&amp;0\\0&amp;0&amp;S \\end{matrix} \\right] =\\left[ \\begin{matrix} \\frac{x}{S} &amp; \\frac{y}{S} &amp;1\\end{matrix}\\right] $，S&gt;1缩小，0&lt;S&lt;1缩小，S&lt;0发生关于原点的对称等比变换对称变换也称镜像变换。有关于x轴、y轴、原点、某条直线的对称变换关于 x 轴对称：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\0&amp;-1&amp;0\\0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x&amp;-y&amp;1\\end{matrix}\\right] $关于 y 轴对称：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} -1 &amp; 0 &amp;0 \\0&amp;1&amp;0\\0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} -x&amp;y&amp;1\\end{matrix}\\right] $关于原点对称：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} -1 &amp; 0 &amp;0 \\0&amp;-1&amp;0\\0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} -x&amp;-y&amp;1\\end{matrix}\\right] $旋转变换将点绕原点旋转角度 $\\theta$ ，逆时针为正，顺时针为负坐标形式（逆时针）：$\\begin{cases} x^* =r·cos(\\alpha+\\theta)=r·cos\\alpha ·cos\\theta-r·sin\\alpha ·sin\\theta \\ y^* =r·sin(\\alpha+\\theta)=r·cos\\alpha ·sin\\theta + r·sin\\alpha ·cos\\theta\\end{cases} \\Rightarrow \\begin{cases} x^* =x ·cos\\theta-y ·sin\\theta \\ y^* =x ·sin\\theta + y ·cos\\theta\\end{cases} $齐次坐标形式（逆时针）：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} cos\\theta &amp; sin\\theta &amp;0\\-sin\\theta&amp;cos\\theta &amp; 0\\0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x ·cos\\theta-y ·sin\\theta &amp; x ·sin\\theta + y ·cos &amp;1\\end{matrix}\\right] $顺时针只要将 $\\theta = -\\theta $ 即可。基于中心点的旋转先把坐标系以到中心点 $(c_x,c_y)$ ，再以进行旋转错切变换弹性物体的变形处理变换矩阵中的非对角元素起着把图形沿x或y方向错切的作用齐次坐标形式：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} 1 &amp; b &amp; 0\\ c &amp;1 &amp;0\\0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix}c+cy&amp;bx+y &amp;1\\end{matrix}\\right] $沿 x 方向错切，即 b=0 ：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} 1 &amp; 0 &amp; 0\\ c &amp;1 &amp;0\\0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix}c+cy&amp;y &amp;1\\end{matrix}\\right] $复合变换图形作大于一次的变换，$P^* = P · T = P·(T_1·T_2·\\cdots ·T_n) ，n\\gt 1$，矩阵相乘不可交换！二维复合平移：$T = T_{t1}·T_{t2} = \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\0&amp;1&amp;0\\T_{x1}&amp;T_{y1}&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\0&amp;1&amp;0\\T_{x1}&amp;T_{y1}&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\0&amp;1&amp;0\\T_{x1}+T_{x2}&amp;T_{y1}+T_{y2}&amp;1 \\end{matrix} \\right] $二维复合比例：$T = T_{s1}·T_{s2} = \\left[ \\begin{matrix} S_{x1} &amp; 0 &amp;0 \\0&amp;S_{y1}&amp;0\\0&amp;0&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} S_{x2} &amp; 0 &amp;0 \\0&amp;S_{y2}&amp;0\\0&amp;0&amp;1 \\end{matrix} \\right]= \\left[ \\begin{matrix} S_{x1}·S_{x2} &amp; 0 &amp;0 \\0&amp;S_{y1}·S_{y2}&amp;0\\0&amp;0&amp;1 \\end{matrix} \\right]$二维复合旋转：$T = T_{r1}·T_{r2} = \\left[ \\begin{matrix} cos\\theta_1 &amp; sin\\theta_1 &amp;0\\-sin\\theta_1&amp;cos\\theta_1 &amp; 0\\0&amp;0&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} cos\\theta_2 &amp; sin\\theta_2 &amp;0\\-sin\\theta_2&amp;cos\\theta_2 &amp; 0\\0&amp;0&amp;1 \\end{matrix} \\right]=\\left[ \\begin{matrix} cos(\\theta_1+\\theta_2) &amp; sin(\\theta_1+\\theta_2) &amp;0\\-sin(\\theta_1+\\theta_2)&amp;cos(\\theta_1+\\theta_2) &amp; 0\\0&amp;0&amp;1 \\end{matrix} \\right] $坐标系变换图形变换经常需要从一个坐标系变换到另一个坐标系，如下图从x0y变换到x’0’y’上图可以拆分成，$x’0’y’ \\xrightarrow{平移} x’0y’ \\xrightarrow{旋转} x0y $，注意是从目标到源$T = T_{t}·T_{r} = \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\0&amp;1&amp;0\\-x_0&amp;-y_0&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} cos(-\\theta) &amp; sin(-\\theta) &amp;0\\-sin(-\\theta)&amp;cos(-\\theta) &amp; 0\\0&amp;0&amp;1 \\end{matrix} \\right] $任意参考点的几何变换在以往的变换中，以 (0, 0) 为参考点，倘若以任意点为参考点，则：将参考点移到原点（平移）针对原点进行二维几何变换（变换）将原点移到参考点（反平移）二维变换矩阵二维空间中某点的变化可以表示成点的齐次坐标与 3 阶的二维变换矩阵 $T_{2d} $ 相乘$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} a&amp;b&amp;p\\c&amp;d&amp;q\\l&amp;m&amp;s \\end{matrix} \\right] $二维图形几何变换的计算点的变换：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· T $直线的变换（两端点的变换）：$\\left[ \\begin{matrix} x_1^* &amp; y_1^* &amp;1\\ x_2^* &amp; y_2^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x_1 &amp; y_1 &amp;1\\ x_2 &amp; y_2 &amp;1\\end{matrix}\\right] ·T $多边形的变换（每个顶点的变换）：$p =\\left[ \\begin{matrix} x_1^* &amp; y_1^* &amp;1\\ x_2^* &amp; y_2^* &amp;1 \\ \\cdots&amp;\\cdots&amp;\\cdots\\x_n^* &amp;y_n^*&amp;1\\end{matrix}\\right] $代码接口设计由于都是经过仿射矩阵进行变换，更好的形式是输入算好的矩阵，进行仿射变换。1234void rotate(const MyImage &amp;input, MyImage &amp;output, float angle);// ↓ 更好的设计void warpAffine(const MyImage&amp; input, MyImage &amp;output, const Matrix23 &amp;mat);void calcRotationMatrix(Matrix23 &amp;matrix, float angle);应用：图像匹配基于仿射变换的图像匹配在第 t 帧检测特征点 (特征检测)计算特征点在第 t+1 帧的对应 (特征跟踪)。”t, t+1” 两个特征点记位特征点对根据特征点对，估计第 t 帧到第 t+1 帧的仿射变换 A利用 A 对第 t 帧的图像进行变换，将变换的结果作为与第 t+1 帧配准的图像： $Ap_t\\leftrightarrow p_{t+1} $如何估计两个图像之间的仿射变换 $A$？不共线的 3 个平面点对决定一个二维仿射变换$\\left[ \\begin{matrix} x^* &amp; y^* \\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} a_1 &amp; a_2\\ b_1 &amp; b_2 \\ c_1 &amp; c_2 \\end{matrix} \\right] = [a_1 x +b_1 y + c_1, a_2 x + b_2 y + c_2] $不共线的多于 3 个平面点对决定一个二维仿射变换$ A = arg_Amin \\sum\\limits_i ||Ap_i - p_i’||^2 $应用：图像变形 Image Warping记 $[x’ , y’] = f([x, y])$ 为像素坐标的一个映射，实现 $f$ 所表示的图像形变。$f$ 的逆映射为： $[x, y] = f^{-1}([x’, y’]) = \\begin{cases} [x’,y’] , &amp; r&gt;1 \\ [cos\\theta·x’-sin\\theta ·y’ , sin\\theta ·x’+ cos\\theta ·y’ ], &amp; otherwise \\end{cases}$$r = \\sqrt{x’^2+y’^2} ,\\theta = (1-r)^2 $$[x, y], [x’, y’]$ 都是中心归一化坐标正向查找、逆向查找的优缺点 / 局限性第 3 章 空间过滤 Spatial Filtering第 4 章 统计特征 Statistics直方图 Histogram描述一个像素的信息：空间坐标 (x, y)颜色值 (RGB, YUV, ...)(x, y, R, G, B)描述多个像素的信息：空间坐标 -&gt; 图像的结果颜色值 -&gt; 像素颜色的分布直方图：$h(r_k) = n_k $，其中 $r_k$ 是第 $k^{th} $ 灰度级，$n_k $ 是图像中对应灰度级的像素数点数目。令 $n$ 为图像中像素总数，归一化直方图 $p(r_k) = \\frac{n_k}{n}$图像的直方图提供了关于对比度增强的可能性的信息12345678void calc_hist(uchar *data, int width, int height, int step, int H[256]) { memset(H, 0, sizeof(H[0])*256); uchar *row = data; for(int yi=0; yi&lt;height; ++yi, row+=step) for(int xi=0; xi&lt;width; ++xi) H[row[xi]]++;}直方图均衡化 Equalization更”好看”的图像，其像素的灰度级可能有哪些特征：覆盖了所有可能的灰度级均匀分布直方图均等化的工作：设计一个转换函数使其转换为满足”好看”的图像的灰度级要求HK 转换函数：归一化 $r \\rightarrow [0, 1]$用于直方图均等化的灰度级转换函数（可以类比前缀和）：$\\large s_k = T(r_k) = \\sum\\limits_{j=0}^{k} \\frac{n_j}{n}= \\sum\\limits_{j=0}^{k} p_r (r_j)$，其中 $p_r(r)$ 为原始图像灰度分布的概率密度函数例子：下图中灰度级 0、64、255 的像素分别转为了 85、170、255，使得对比度增强证明不是均匀分布：令 $s = T(r) $，其中 $r$ 是原灰度值， $T ()$ 是转换函数，$s=T(r)$ 是转换后的灰度值。该函数是连续的。在 $r\\in [0,1]$ 是单调递增的。$s$ 的概率密度函数：$\\large p_s(s) = p_r(r)|\\frac{dr}{ds}|$$\\large s = T(r) = \\int_0^r p_r(w)dw$其满足 $\\large \\frac{ds}{dr}=\\frac{dT(r)}{dr} = \\frac{d}{dr}[\\int_0^rp_r(w)dw] = p_r(r)$所以 $\\large p_s(s) =p_r(r)|\\frac{dr}{ds}| = p_r(r)\\frac{1}{p_r(r)}=1$总结：转换 $\\large s_k = T(r_k) = \\sum\\limits_{j=0}^{k} \\frac{n_j}{n}= \\sum\\limits_{j=0}^{k} p_r (r_j)$ 不能产生均匀的直方图，其趋向于去扩散输入图像的直方图，使得图像的灰度值覆盖整个区间（对比度增强）。该转换有固定的公式、算法，可以实现完全的自动化，故也利于硬件实现。直方图匹配 Matching直方图匹配的产生缘由：直方图均衡化并不能交互式地图像增强，而是只能产生唯一一种结果 —— 一个近似均匀的直方图。对于增强图像的直方图，有时会有特殊要求，即对其灰度值范围有定制的要求。指定所需密度函数，可以得到如下转换函数 $G(z)$：$\\large v = G(z) = \\sum\\limits_0^z p_z(w)\\approx \\sum\\limits_{i=0}^z\\frac{n_i}{n} $将转换函数的输入设为直方图均等化后的灰度值$\\Rightarrow z=G^{-1}(s) \\Rightarrow z=G^{-1}[T(r)] $应用特殊的方法去做图像增强能构造出有特殊意义的直方图：生成符合指定概率密度函数的直方图（比如高斯函数密度）或在图形设备上指定直方图形状（交互式），然后将其馈入处理器去执行直方图指定算法局部增强 Local Enhancement先前的方法是全局性的，当需要增强细节的时候，需要使用一些局部增强的方法即根据每个像素附近的灰度分布来设计变换函数在邻域进行像素平移时有两种方案一种是进行逐像素平移，此时邻域中仅一行/列改变，每一步移动中以新数据更新前一个位置得到的直方图。另一种减少计算量的方法是使用非重叠区域。在图像增强中使用直方图第 5 章 结构第 6 章 匹配图像匹配：同一场景点在不同图像间像素的对应关系同一视频中的两帧不同人拍摄的同一场景同一场景的不同角度同一物体，不同场景图像匹配的意义：视频处理与分析的基础视觉三维重建的基础早起物体识别、图像检索技术的基础计算机视觉半壁江山的基础图像匹配关注的重点：局部特征因为全局特征面临难以克服的困难：遮挡、形变、环境变化特征检测特征检测与匹配的挑战：对图像几何变换的稳定性。Robust or covariant to out-of-plane (≈affine) transformations对光照、噪声、模糊、分层变化的稳定性 Robust to lighting variations, noise, blur, quantization特征点的特质：稳定检测、易于匹配局部性 Locality：因此对于阻塞和杂乱是鲁棒的。Features are local, therefore robust to occlusion and clutter.大量的 Quantity：We need a sufficient number of regions to cover the object.独特性 Distinctiveness: The regions should contain “interesting” structure.高效性 Efficiency: Close to real-time performance.现成可行的检测器 / 方法 （已成为 CV 领域中许多最新应用的基本构件）：Hessian &amp; HarrisLaplacian, DoGHarris-/Hessian-LaplaceHarris-/Hessian-AffineEBR and IBRMSERSalient Regions角点检测​ 角点是图像很重要的特征,对图像图形的理解和分析有很重要的作用。角点在保留图像图形重要特征的同时,可以有效地减少信息的数据量,使其信息的含量很高,有效地提高了计算的速度,有利于图像的可靠匹配,使得实时处理成为可能。​ 角点在三维场景重建运动估计，目标跟踪、目标识别、图像配准与匹配等计算机视觉领域起着非常重要的作用。在现实世界中，角点对应于物体的拐角，道路的十字路口、丁字路口等。从图像分析的角度来定义角点可以有以下两种定义：​ a. 角点可以是两个边缘的角点；​ b. 角点是邻域内具有两个主方向的特征点；前者往往需要对图像边缘进行编码，这在很大程度上依赖于图像的分割与边缘提取，具有相当大的难度和计算量，且一旦待检测目标局部发生变化，很可能导致操作的失败。早期主要有Rosenfeld 和 Freeman 等人的方法，后期有 CSS 等方法。​ 基于图像灰度的方法通过计算点的曲率及梯度来检测角点，避免了第一类方法存在的缺陷，此类方法主要有 Moravec 算子、Forstner 算子、Harris 算子、SUSAN 算子等。下图中表明了三种点中哪个是角点：平摊 flat：每个方向都没变化边 edge：边方向没有变化角 corner：角点处沿着任何方向移动都会引起像素颜色的明显变化Harris 角点检测将像素点看作滑动窗口，滑动窗口在角点处沿着任何方向移动都会引起像素颜色的明显变化Moravec 算子Moravec 算子是 Harris 算子的前身。思想（个人理解）：定准一个小窗口，小窗口向各个方向移动（造成竖直/水平方向的偏移），窗口区域内的灰度值的变化程度加权到 $E$ 上，这个值越大，窗口内的点越可能是角点。公式：$\\Large E(u,v) = \\sum\\limits_{x, y}(w(x,y) [I(x+u,y+v) - I(x,y)]^2)$其中 $(u, v)$ 是滑动窗口竖直和水平方向的偏移，$w(x,y)$ 是窗口函数，$(x,y)$ 是窗口中心，$I(x+u,y+v)$ 是移动后的亮度，$I(x,y)$ 是移动前的亮度。$E(u,v)$ 越大越可能是角点。窗口函数 $w(x,y)$ 是一种滤波，高斯滤波或均值滤波均可。Moravec 算子存在的问题：只考虑了 4 个方向，所以不存在图像旋转不变性。理应考虑多个方向，但是这个“多”，并不是数量上的，应该是用全微分，涉及到泰勒展开。Harris 算子就是在 Moravec 算子上优化得到。引入 Sobel 梯度算子图像边缘一般都是通过对图像进行梯度运算来实现的。图像梯度的最重要性质是，梯度的方向在图像灰度最大变化率上，它恰好可以反映出图像边缘上的灰度变化 。Sobel 算子主要用作边缘检测，在技术上，它是一离散性差分算子，用来运算图像亮度函数的灰度之近似值。在图像的任何一点使用此算子，将会产生对应的灰度矢量或是其法矢量。Sobel 卷积因子为：$G_x = \\left[ \\begin{matrix} -1 &amp; 0 &amp;+1 \\-2&amp;0&amp;+2\\-1&amp;0&amp;+1 \\end{matrix} \\right] \\ \\ \\ G_y= \\left[ \\begin{matrix} +1 &amp; +2 &amp;+1 \\0&amp;0&amp;0\\-1&amp;-2&amp;+1 \\end{matrix} \\right] $水平方向梯度幅值计算过程可以简易理解如下：Harris 算子对 Moravec 算子的公式利用泰勒展开（原理是 $f(x+u, y+v)\\approx f(x,y)+uf_x(x,y)+vf_y(x,y) $），到：$\\large E(u,v) = \\sum\\limits_{x, y}(w(x,y) [u^2I_x^2+2uvI_xI_y+v^2I_y^2])$其中，$I_x$ 是图像水平梯度，$I_y$ 是图像竖直梯度上式可以化为 $\\large E(u,v) \\approx [u, v](\\sum w(x,y) \\left[ \\begin{matrix} I_x^2 &amp; I_xI_y \\ I_xI_y &amp; I_y^2 \\end{matrix}\\right] ) \\left[ \\begin{matrix} u \\ v\\end{matrix}\\right]$$\\Rightarrow \\large E(u,v) \\approx [u \\ v] · M·\\left[ \\begin{matrix} u \\ v\\end{matrix}\\right]$ ，其中 $\\large M =\\sum\\limits_{x, y} w(x,y) \\left[ \\begin{matrix} I_x^2 &amp; I_xI_y \\ I_xI_y &amp; I_y^2 \\end{matrix}\\right] $这个 $E(u,v) $ 的形式是一个二项式函数，本质上是一个椭圆函数而平坦、边、角点的梯度分布如下，可以看到椭圆长短半径都较大的话可以断定是角点。角点响应 $R= det(M)-k(trace(M))^2 $，其中 $det(M) = I_x^2I_y^2-I_xI_y\\times I_xI_y，trace(M)=I_x^2+I_y^2$$R \\begin{cases}&lt;0 &amp; 边缘点\\ \\approx 0 &amp; 平坦点 \\ &gt; 0 &amp; 角点\\end{cases}$代码 demo 框架总结：Harris 对图像旋转有稳定性，对缩放没有稳定性Harris 对光照变化有稳定性，因为它用的是图像梯度斑点检测 Blob Detection​ 斑点通常是指与周围有着颜色和灰度差别的区域。在实际地图中，往往存在着大量这样的斑点，如一颗树是一个斑点，一块草地是一个斑点，一栋房子也可以是一个斑点。由于斑点代表的是一个区域，”一坨东西”，相比单纯的角点，它的稳定性要好，抗噪声能力要强，所以它在图像配准上扮演了很重要的角色。Hessian 检测器在两个正交方向上搜索强导数。主要响应角点和很强的纹理区域。Hessian 矩阵是一个多元函数的二阶偏导数构成的方阵，描述了函数的局部曲率。对一个图像 f(x,y)，其 Hessian 矩阵如下：$$\\large H(f(x, y))=\\left[\\begin{array}{cc}{\\frac{\\partial^{2} f}{\\partial x^{2}}} &amp; {\\frac{\\partial^{2} f}{\\partial x \\partial y}} \\ {\\frac{\\partial^{2} f}{\\partial x \\partial y}} &amp; {\\frac{\\partial^{2} f}{\\partial y^{2}}}\\end{array}\\right]$$在构造Hessian矩阵前需要对图像进行高斯滤波，去除噪声引起的像素突变，经过滤波后的Hessian矩阵表述为：$$H(\\mathbf{x}, \\sigma)=\\left[\\begin{array}{cc}{I_{x x}(\\mathbf{x}, \\sigma)} &amp; {I_{x y}(\\mathbf{x}, \\sigma)} \\ {I_{x y}(\\mathbf{x}, \\sigma)} &amp; {I_{y y}(\\mathbf{x}, \\sigma)}\\end{array}\\right]$$当Hessian矩阵的判别式取得局部极值（极大值或极小值）时，判定当前点是比周围邻域内其他点更亮或更暗的点，由此来定位关键点的位置。$$\\operatorname{det}(H)=I_{x x} I_{y y}-I_{x y}^{2}=\\lambda_{1} \\lambda_{2}$$对每个像素点计算图像在 X 方向 Y 方向的二阶偏导数，计算图像的 XY 方向的导数代入上式，高斯金字塔SIFT 尺度不变特征转换尺度不变特征转换 (Scale-invariant feature transform 或 SIFT)是一种电脑视觉的算法用来侦测与描述影像中的局部性特征，它在空间尺度中寻找极值点，并提取出其位置、尺度、旋转不变量，此算法由 David Lowe 在 1999 年所发表，2004 年完善总结。数学上，高斯和是唯一一个能模拟近处清晰远处模糊的一个线性和。ORB 特征检测第 7 章 重建","link":"/CS/Computer-Vision-Study-Notes/"},{"title":"汇编语言-学习笔记","text":"第 1 章 预备知识什么是汇编好处：解密程序、逆向工程、病毒木马分析和防止的唯一理解 C 语言程序的最好途径了解操作系统运行细节的最佳方式特定场合下编写程序的必然选择了解计算机工作原理和后继课程学习的基础目标：掌握语法：指令格式 （关键：寻址方式）掌握语义：指令功能 （关键：分类记忆）灵活应用：阅读、编程 （关键：实践）伪指令：由汇编程序在汇编过程中执行的指令指令：告诉 CPU 要执行的操作（一般还要指出操作数地址），在程序运行时执行Intel 80X86 寄存器组8 个 32 位寄存器 （通用寄存器）分为两组：数据寄存器组、指示器变址寄存器组数组寄存器组RegisterEAX累加器AccumulatorEBX基址寄存器BaseECX计数器CountEDX数据寄存器DataEAX 可以看成某个存储单元的地址(EAX) 则表示 EAX 单元中的内容寄存器划分：低 16 位组 —— AX, BX, CX, DX低 8 位组 —— AL, BL, CL, DL高 8 位组 —— AH, BH, CH, DH(AX) = (AH, AL) , …Register31-16位15-8位7-0位EAXAHALEBXBHBLECXCHCLEDXDHDL将 EAX 的低 16 位置 0：MOV AX, 0将 EAX 的低 8~15 位置 1：MOV AH, 0FFH变址寄存器组RegisterESI源变址寄存器Source IndexEDI基址寄寄存器Destination IndexESP堆栈指示器Stack PointerEBP堆栈基址寄存器Base Pointer寄存器划分：ESI、EDI、ESP、EBP 都是 32 位寄存器低 16 位作 16 位寄存器用，SI、DI、SP、BP一般用作指示器或变址寄存器可作为数据寄存器用ESP, SP 一般不作数据寄存器使用Register31-16位15-0位ESISIEDIDIESPBPEBPSP指令预取部件和指令译码部件指令预取部件：将要执行的指令从主存中取出，送入指令排队机构中排队指令译码部件：从指令预取队列中读出指令并译码，再送入译码指令队列排队供执行部件使用指令的提取、译码、执行重叠进行，形成了指令流水线。指令指示器：EIP/IP：保存下一条要被 CPU 执行的指令的偏移地址 EA。由微处理器硬件自动设置EIP/IP 不能由指令直接访问，执行转移指令、子程序调用指令等可使其改变Register31-16位15-0位IPIP分段部件和分页部件$ 虚拟存储空间 \\xrightarrow{分段部件} 一维线性地址 \\xrightarrow{分页部件} 物理存储空间 $虚拟存储地址是一种概念性的逻辑地址，并非实际空间地址程序员编写程序时不用考虑物理存储器大小存储管理单元 MMU 进行虚地址到是地址的自动变换地址变换对应用程序是透明的分段部件中 6 个 16 位的段寄存器：RegisterCS代码段寄存器Code SegmentDS数据段寄存器Data SegmentSS堆栈段寄存器Stack SegmentES附加数据段寄存器FSGS80x86 微处理器结构80x86 的三种工作方式实方式 （实地址方式）相当于 8086CPU 32 位、16 位数据总线、20 位地址总线保护方式 （虚地址）支持多任务环境的工作方式，建立保护机制存储区采用分段、分页的存储管理机制为每个任务提供一台虚拟处理器虚拟 8086 方式保护方式下所提供的同时模拟多个 8086 处理器例如 Windows 的 CMD主存储器内存：用来存放程序和数据的装置字节 Byte：最小的寻址单位字 Word：两个相邻的字节组成一个字低 8 位在低字节（低地址）高 8 位在相邻的高字节上述是小端模式，即低字节在低地址双字 DoubleWord：四个连续的字节，地址是四个字节中最低的地址实验-地址类型转换：“1234567”，在内存中存为 31H、32H、…、37H，从上到下1234567891011int main(){ char s[10]; strcpy(s, \"1234567\"); printf(\"%ld\\n\", *(long *)(s+2)); // 输出 909456435 =(36353433)_16 printf(\"%ld\\n\", *(short *)(s+2));// 输出 13363 = (3433)_16 printf(\"%d\\n\", *(char *)(s+2)); // 输出 51 = (33)_16 *(int *)(s+1)=16706;// 16706=(00004142)_16 printf(\"%s\\n\", s); // 输出 1BA return 0;}堆栈堆栈的建立：1234; 建立一个 16 位段，地址形式是16位段地址, 16位偏移, 使用16位寄存器SP指向栈顶MY_S_NAME SEGMENT USE16 STACK DB 200 DUP(0)MY_S_NAME ENDS进栈指令：PUSH OPS，OP 指操作，S 指源单字进栈： (SP)-2 → SP; 字数据 → [sp];记为 (OPS) → ↓ (sp)双字进栈：(SP)-4 -&gt; SP; …功能：将立即数、寄存器、段寄存器、存储器中的一个字/ 双字数据压入堆栈出栈指令：POP OPD，OP 指操作，D 指目的([SP]) → OPD; (SP+2) → SP记为 ↑ (SP) → OPD功能：将栈顶元素弹出送至某一寄存器、段寄存器 (CS除外)、存储器中8 个 16 位寄存器内容顺序存入指令：PUSHA功能：将 8 个 16 位寄存器按 AX, CX, DX, BX, SP, BP, SI, DI顺序入堆栈说明：入栈的 SP 是执行 PUSHA 之前的 SP 值依次送出 DI, SI, BP, SP, BX, DX, CX, AS 的 POPA 指令8 个 32 位寄存器内容顺序存入指令：PUSHAD功能：将 8 个 32 位寄存器按 EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI顺序入堆栈说明：入栈的 SP 是执行 PUSHAD 之前的 SP 值依次送出 EDI, ESI, EBP, ESP, EBX, EDX, ECX, EAS 的 POPAD 指令物理地址的形成程序中单元 (如变量等) 的相对位置、逻辑地址已定。两段程序的位置如下：确定了白线条的位置，其他线条的位置可它们之间的相对位置关系计算段的开始地址要能被 16 整除，16 = 10H = 10000B段址：段开始单元的物理地址(段首址) / 16偏移地址：距离段首址的距离物理地址 = 段址 * 16 + 偏移地址“段首地址 : 偏移地址”：这样为二维的逻辑地址一个段最大为 64 KB ( $2^{16}$ )1 M 内存至少有 16 个段一个段内可同时访问 4 个段寄存器 CS, DS, ES, SS在代码段中取指令时：指令的物理地址 PA = (CS) 左移4位 + (IP)，注意不是 EIP在数据段中读/写数据时：数据的物理地址 PA = (DS或ES) 左移4位 + 16位偏址 （偏址由寻址方式确定）在堆栈操作时：栈顶的物理地址 PA = (SS) 左移四位 + (SP)8086 CPU 在运行一个程序时，如何确定 CS, DS, ES, SS 中的值呢？在将一个程序装入内存，准备运行时，由操作系统确定程序中定义的各个段在什么位置。对于代码段，系统自动将代码段首址送到 CS 中 ，并设置 IP 为第一条要执行指令的偏移地址（C 语言的 MAIN ）。对于堆栈段，系统将自动把堆栈段首址送到 SS中，并根据定义的堆栈段的大小，设置 SP 的值。实方式物理地址的形成32 位 CPU 与 8086 一样只能寻址 1M 物理存储空间可以访问 6 个段 CS, DS, SS, ES, FS, GS，每个段至多 64K物理地址 = (段寄存器) 左移 4 位 + 偏移地址C 语言变量和指令写在一起，没有分段的概念，而机器语言层次上是要分段的，为什么？变量也需要存储空间存放，而 cpu 执行的执行代码，全部为 01 程序，因此需要堆栈段、数据段、代码段分开，使 cpu 执行代码时可以区分变量和指令。保护方式下物理地址的形成80386 中寄存器 32 位，地址线 32 根。在多任务环境下，系统中有多个程序在运行，程序之间要隔离分段是存储管理的一种方式，为保护提供基础不同程序在不同段中，一个程序可包含多个段段用于封闭具有共同属性的存储区域12345678int main(){ int c[10]; int y = 10; c[-1] = 48; printf(\"%d\\n\", y); // 输出 48 // c[-10000] = 48 会报错，这是分段保护（超出段范围）}描述符，8Byte —— 保护一个段所需的信息及其存放 ：段的起始位置（段基地址）段的大小（段界限）段的特权级段的属性（是代码段，数据段，还是堆栈段？数据段是否可写？代码段是否可读出？）段的位置（在内存还是在磁盘？）段的类型（在系统段还是用户段？）段的使用（段被访问过，还是没有？）分段描述符表 Local Description Table—— 描述符的集合：一个 LDT，是一个系统段，最大可为 64KB，最多可存放 8192 个描述符全局描述符表，只有一个 GDT，最大可为 64KB，存放 8192个描述符。包括：操作系统所使用的段的描述符、各个 LDT 段的描述全局描述符表，在 GDTR 这个 48 位寄存器，存放其地址。还有一个 LDTR，表示全局描述符中 LDT 的偏址“xxxx : yyyyyyyy” 从虚拟地址到线性地址的映射：xxxx 不是段开始的地址，而是指出栈相应段描述符的方式。称之为 段选择符TI = 0从 GDTR 寄存器取 GDT 表的基址在 GDT 表中，以 xxxx 的高 13 位作为偏址，取出描述符 A描述符 A 中的段基址 + yyyyyyyy，即为要访问单元的线性地址TI = 1从 GDTR 寄存器取 GDT 表的基址在 GDT 表中，以 LDTR 寄存器的高 13 位作偏址，取出描述符 A描述符 A 描述的段为一个 LDT 段 (如 LDT_A)用 xxxx 的高 13 位作偏址，在 LDT_A 段中找到描述符 P_AP_A 描述段的基址 + yyyyyyyy 为线性地址从线性地址到物理地址：标识寄存器保存一条指令执行之后，CPU 所处状态的信息及运算结果的特征16 位 CPU 中的标志寄存器是 16 位，称 FLAGS32 位 CPU 中的标志寄存器是 32 位，称 EFLAGS32 位的 EFLAGS 包含了 16 位 FLAGS 的全部标识标志位条件标志位Overflow Flag 溢出Sign Flag 符号Zero Flag 零Carry Flag 进位符号标志 SF，最高位为 1，则 SF=1零标志 ZF，运算结果为 0，则 ZF=1溢出标志 OF，若两个加数最高位相同，且结果最高位相反，则溢出 OF=1进位标志 CF，若运算从最高位向前产生进位 (或借位)，则 CF=1标志寄存器操作指令LAHF (Load AH From Flags)：功能：将标志寄存器的低 8 位送入 AH 中，对标志位无影响。SAHF (Store AH into Flags)：功能：将 AH 中的内容送入标志寄存器的低 8 位中，而高位保持不变。标志寄存器堆栈指令：低 16 位：PUSHF、POPF32 位标志寄存器：PUSHFD、POPFD汇编源程序举例for 语句123456789; AX=0; for(BX=1;BX&lt;100;BX+=2) AX+=BX;MOV AX, 0MOV BX, 1MAINP: CMP BX, 100 JGE EXIT ADD AX, BX ADD BX, 2 JMP MAINPEXIT:dowhile语句12345678; AX=0; BX=1; do{AX+=BX;BX+=2;}while(BX&lt;100);MOV AX, 0MOV BX, 1MAINP: ADD AX, BX ADD BX, 2 CMP BX, 100 JL MAINPEXIT:第 2 章 寻址方式内存中，何处找操作数CPU 如何知道操作数地址C 语言中地址的寻找123456int i, j;int A[10];int *p;int B[20][10];A[i] = 5;B[i][j] = 10;一条指令，关注：操作码 —— 执行什么操作操作数在哪CPU 寄存器主存，操作数在主存时，关注段址/段选择符、段内偏移IO 设备端口操作数类型双操作数的指令格式：操作符 OPD, OPSADD AX, BX，AX 是目的操作数地址，BX 是源操作数地址(OPD) + (OPS) → OPD寄存器寻址格式：R功能：寄存器 R 中的内容即操作数（除个别指令外，R 可为任意寄存器）操作数在寄存器（操作数地址就是符号地址），操作数类型是字节例如：DEC BLADD AX, BXMOV AX, BXADD EAX, EDXMOV AX, BH，注意两个的字节数寄存器间接寻址格式：[R]功能：操作数在内存中，操作数的偏址在寄存器 R 中，即 (R) 为操作数的偏址R 可以是：8 个 32 位通用寄存器中任一：EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP4 个 16 位通用寄存器中任一：BX, SI, DI, BP （向下兼容的遗留问题）操作数所在段是：R 为 BP、EBP、ESP，系统默认操作数在堆栈中，等同于 SS:[R]其他情况，默认操作数在 DS 所指示的段中操作数类型：未知例：MOV AX, [SI]执行前 (AX)=0005H, (SI)=(0020H), DS:(20H)=1234H，执行后 (AX)=1234H, (SI)=0020H。该指令中目的操作数是寄存器寻址，源操作数是寄存器间接寻址若指令是 MOV AL, [SI]，则 (AL)=34H，目的操作数暗示操作数类型MOV EAX, -1 MOV [ESP], EAX POP EBX ，结果 (EBX)=-1MOV AX, [CX]，不能用这个 16 位寄存器MOV AX, BX 和 MOV AX, [BX] 差别很大，前者是值存在 BX 中，后者存的是偏址，还要根据偏址找到值C -&gt; 汇编实例123456789101112; 寄存器间接寻址实现 strcpy(buf2, buf1, ...) MOV SI, OFFSET BUF1 MOV DI, OFFSET BUF2 MOV CX, 5MAINP: MOV AL, [SI] MOV [DI], AL INC SI INC DI DEC CX JNZ MAINPEXIT:变址寻址格式：[R×F + V][R×F] + VV[R×F]功能：操作数在内存。R 中的内容 × F + V 为操作数的偏址R 可以是：8 个 32 位通用寄存器中任一：EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP4 个 16 位通用寄存器中任一：BX, SI, DI, BP （向下兼容的遗留问题）F (比例因子) 可以是：1、2 (字)、4 (双字)、8当 R 为 16 位寄存器时，F = 1V 与操作数所在：当 V 为数值常量，是二进制补码表示的有符号数。若 R 为 BP、EBP、ESP，则系统默认操作数在堆栈中，等同于 SS:[R]；其他情况默认操作数在 DS 所指示的段中当 V 为变量时，取该变量对应单元的有效地址参与运算。即系统默认操作数在该变量或标号所在的段中（除非显式指明形如 CS:[BX]）。例：MOV AL, [EBX*2]+5执行前 (AL)=18H, (EBX)=1100H, DS:(2205H)=55H执行后 (AL)=55H, 其他不变C -&gt; 汇编实例1234567891011121314151617181920212223242526272829; 变址寻址实现 for(i=0;i&lt;5;i++) result+=buf[i];.386STACK SEGMENT USE16 STACK DB 200 DUP(0)STACK ENDSSEG1 SEGMENT USE16BUF DD 10,20,30,40,50RES DD ?SEG1 ENDSCODE SEGMENT USE16 ASSUME CS:CODE, DS:SEG1,SS:STACKSTART: MOV AX, SEG1 MOV DS, AX MOV EBX, 0 MOV EAX, 0LP: CMP EBX, 5 JGE EXIT ADD EAX, BUF[EBX*4] ; DD 定义双字 INC EBX JMP LPEXIT: MOV RES, EAX MOV AX, 4C00H INT 21HCODE ENDS END START12345678910; 变址寻址实现 strcpy(buf2, buf1, ...) MOV EBX, 0MAINP: CMP EBX, 5 JGE EXIT MOV AL, BUF1[EBX*4] MOV BUF2[EBX*4], AL INC EBX JMP MAINPEXIT:基址加变址寻址格式：[BR + IR×F + V]V[BR][IR×F]V[IR×F][BR]V[BR + IR×F]功能：操作数的偏移 = 变址寄存器 IR 中的内容 × 比例因子F + 位移量V + 基址寄存器 BR 的内容EA = (IR)*F + V + (BR)使用 16 位寄存器时：BR ∈ {BX, BP}为 BX 默认操作数在 DS 所指示的段为 BP 默认操作数在 SS 所指示的段IR ∈ {SI, DI}F = 1使用 32 位寄存器时：BR 可是 8 个通用寄存器中任一IR 可是除 ESP 外任一没有比例因子时，写在前面的寄存器是 BR当 BR 为 ESP、EBP，默认段是 SS操作数的类型：当 V 为变量，则操作数类型为变量的类型当 V 为常量，类型位置例：MOV AX, 8[BX][SI]执行前 (AX)=45H, (BX)=30H, (SI)=20H, DS:(0058H)=99H执行后 (AX)=99H，其他不变立即寻址格式：n操作数直接放在指令中，在指令的操作码后操作数是指令的一部分，位于代码段中指令中的操作数是 8 位、 16 位或 32 位二进制数只能作源操作数立即数不能直接送段寄存器直接寻址格式：段寄存器名 : [n]变量变量+常量功能：操作码的下一个字/双字单元的内容为操作数的偏址 EA操作数在内存中。操作数的偏址 EA 紧跟在指令操作码后操作数所在的段：由段寄存器名指示，或是变量所在的段操作数的类型：若有变量，则是定义变量的类型若无，未知例：MOV AX, DS:[2000H]执行前 (AX)=1, DS:(2000H)=976执行后 (AX)=976有关问题寻址方式 6 种，根据操作数的存放位置可归 3 类：寄存器方式立即方式存储器方式寄存器间接寻址变址寻址基址加变址寻址直接寻址双操作数寻址方式的规定：一条指令的源操作数和目的操作数不能同时用存储器方式操作数的类型：寄存器寻址方式中，操作数类型由寄存器定立即数没有类型含变量的寻址方式所表示的操作数类型为变量的类型不含变量的存储器方式所表示的操作数类型未知MOV [BX], 0 两个操作数类型都不明确属性定义算符 PTRMOV BYTE PTR[BX], 0MOV WORD PTR[BX], 0MOV DWORD PTR[BX], 0双操作数的类型规定：双操作数中至少应有一个的类型是明确的若两个操作数的类型都明确，则两个的类型应相同第 3 章 宏汇编语言目标：正确而熟练地使用地址表达式和数值表达式熟悉常用的机器指令的使用格式、功能区别机器指令语句和伪指令语句常用的伪指令功能、使用方法熟练掌握常用的 DOS 系统功能调用 （1, 2, 9, 10 号调用）宏汇编语言表达式常量：便于程序修改、阅读，在MOV CX, 10 中 10 为数值常量MOV CX, AA 中 AA 为符号常量。汇编时编译器会将其换为常量数值表达式：由常量和运算符组成的有意义的式子一个常量是一个数值表达式；由数值表达式通过运算符和括号连接起来是数值表达式算术运算：+、-、&amp;、/、MOD、SHR、SHL关系运算：EQ、NE、LT，GT、LE、GE逻辑运算：AND、OR、XOR、NOT变量：一个数据存储单元的名字存储单元的属性：段属性、偏移地址、单元的类型、单元中的内容变量定义、变量定义伪指令、表达式[, …]DB 字节DW 字DD 双字DF 三字DQ 四字DT 十字表达式有五种数值表达式：X DB 10字符串 （如果串长超过 2 个字符定义伪指令只能用 DB）：Z DW '12'、Y DB '12'、X DB 'abcd'，前两者在内存中情况相反地址表达式（不能出现带寄存器符号，数据定义伪指令只能用 DW、DD，用 DD 的时候包含段首址）。有点像指针，面向对象汇编后的代码中大量使用。? （就是一个问号），表示定义的变量无确定的初值重复字句 n DUP (表达式[,…])X DB 3, DUP(2) 等价于 X DB 2,2,2X DB 3, DUP(1,2) 等价于 X DB 1,2,1,2,1,2标号：机器指令存放地址的符号表示三个属性段属性偏址类型：NEAR, FAR地址表达式：类型运算符 PTRBYTE WORD DWORD FWORD NEAR FARMOV BYTE PTR DS:[2000],2BUF DB 1,2、MOV AX WORD PTR BUF，结果是 0201H。因为 BUF 在内存中从上到下是 01H 02H，取字后就是 0201H跨段前缀段寄存器名：地址表达式段名：地址表达式属性分离算符段属性、偏移地址、类型的分离`SEG 变量或标号，如 MOV AX, SEG BUFOFFSET 变量或标号，如 MOV AX, OFFSET BUFTYPE 变量或标号，如 MOV AX, TYPE BUF常用机器指令语句指令的共同要求：双操作数的操作数类型必须匹配目的操作数一定不能是立即操作数目的操作数和源操作数不能同时为存储器操作数。如果一个操作数在数据存储单元中 ，另一个一定要是立即数或寄存器操作数数据传送指令一般传送指令：MOV 指令MOV OPD, OPS立即数不能送段寄存器；不能用 MOV 指令改变 CS；有符号数传送指令MOVSX OPD, OPS，”S” 指 Signed （386指令）功能：将源操作数的符号向前拓展（符号位是 1 拓展全为 1，符号位是 0 拓展全为 0）成与目的操作数相同的数据类型OPS 不能为立即数OPD 必须为 16/32 位寄存器无符号数传送指令MOVZX OPD, OPS，”Z” 指 Zero （386指令）功能：将源操作数的符号高位补零成与目的操作数相同的数据类型OPS 不能为立即数OPD 必须为 16/32 位寄存器一般数据交换指令：XCHG 指令XCHG OPD, OPS，将源、目的地址指明的单元中内容互换不能使用段寄存器 XCHG DS, AX查表转换指令XLAT。([BX+AL]) → AL，或 ([EBX+AL]) → AL功能：将 (BX) 或 (EBX) 为首址，(AL) 为偏移量的字节存储单元中的数据传送给 ALXLAT 可用来对文本数据进行编码和译码，从而实现简单的加密和解密。用 BX 还是 EBX 取决于 16 位段还是 32 位段12345678; 设有一个 16 进制数码（ 0 ～ 9 ， A~F) 在(AL) 中，现请将该数码转换为对应的 ASCII ; 简单的方法是分类讨论 (AL) 是否小于等于9; 现在用查表实现MYTAB DB &apos;0123456789ABCDEF&apos; MOV BX, OFFSET MYTABXLAT地址传送指令：传送偏移地址指令LEA OPD, OPS，Load effective address功能：计算 OPS 的偏址，并将其送入 OPD 中OPD 一定是一个 16/32 位的通用寄存器；OPS 所提供的一定是一个存储器地址；如果偏址是 32 位，而 OPD 为 16 位，则取低 16 位如果偏址是 16 位，而 OPD 为 32 位，则高 16 位补 0MOV SI, OFFSET NUM 与 LEA SI, NUM 等效没有与 LEA DI, [SI+4] 等效的 MOV 语句没有与 MOV POIN, OFFSET BUF 等效的 LEA 语句传送偏址和数据段首址指令LDS OPD, OPS，Load data segment功能：(OPS) → OPD，(OPS+2或4) → DSOPD 一定是一个 16/32 位的通用寄存器；OPS 所提供的一定是一个存储器地址，类型为 DWORD/FWORD；12345678910111213141516171819202122232425262728293031.386DATA1 SEGMENT USE16 T1 DW -50HT2 DD FT3 DB &apos;1234567&apos;DATA1 ENDSDATA2 SEGMENT USE16BUF DB &apos;ABCDEF&apos;F DW 70HDATA2 ENDSCODE SEGMENT USE16 ASSUME CS:CODE, DS:DATA1START: MOV AX, DATA1 MOV DS, AX MOV SI, 6 MOV AX, [SI] ; (AX)=3231H MOV AX, T1 ; (AX)=0FFB0H LDS SI, T2 MOV AX, [SI] ; (AX)=0070H MOV AX, T1 ; (AX)=4241H, 因为此时段首址变成了DATA2 MOV AH, 4CH INT 21HCODE ENDSEND START算术运算指令一般对标志位都有影响加法指令：加 1 指令INC OPD加指令ADD OPD, OPS带进位加指令ADC OPD, OPS计算 1234 F00FH +1234 80F0H，只允许使用 16 位寄存器12345678910111213141516171819202122data segment use16dn1 dw 0f00fh, 1234hdn2 dw 80f0h, 1234hdsum dw 0, 0data endscode segment assume cs:code, ds:datastart: mov ax, data mov ds, ax mov ax, dn1 add ax, dn2 mov dsum, ax ; 不影响标志位 mov ax, dn1+2 ; 不影响标志位 adc ax, dn2+2 ; 标志位中低位的影响加到当前加法 mov dsum+2, ax mov ah, 4ch int 21hcode endsend start减法指令：DEC 对 OF、SF、ZF、PF、AF 有影响，其他指令对 CF、OF、SF、ZF、PF、AF 有影响减 1 指令DEC OPD求补指令NEG OPD功能：求反加一减指令SUB OPD, OPS带借位减指令SBB OPD, OPS比较指令CMP OPD, OPS(OPD) - (OPS) 的标志位乘法指令：有符号乘法 - 双操作数有符号乘IMUL OPD, OPS功能：(OPD) * (OPS) → OPD，OPD 为 16/32 位寄存器，OPS 为同类型寄存器、存储器操作数或立即数例：IMUL AX, BXIMUL EAX, DWORD PTR[SI]IMUL AX, 3有符号乘法 - 三操作数有符号乘IMUL OPD, OPS, n功能：(OPS) * n → OPD有符号乘法 - 单操作数有符号乘IMUL OPS看 OPS 类型选：字节乘法：(AL) * (OPS) → AX字乘法：(AX) * (OPS) → DX, AX（为什么不是 EAX ？）双字乘法：(EAX) * (OPS) → EDX, EAXOPS 不能是立即数若乘积的高位 不是 低位的符号拓展，而是包含有效位（溢出），则 CF=1, OF=1无符号乘法MUL OPS看 OPS 类型选：字节乘法、字乘法、双字乘法除法指令：有符号除法IDIV OPS看 OPS 类型选：字节除法：(AX) / (OPS) → AH(余), AL(商)字除法：(DX, AX) / (OPS) → DX(余), AX(商)双字除法：(EDX, EAX) / (OPS) → EDX(余), EAX(商)无符号除法DIV OPS同理，看 OPS 类型符号拓展指令：将字节转换成字CBW功能：将 AL 中的符号拓展到 AH 中将字节转换成字CWD功能：将 AX 中的符号拓展到 DX 中将 AX 中的有符号数拓展为 32 位送 EAXCWDE将 EAX 中的有符号数拓展为 64 位送 EDX, EAXCDQ位操作指令逻辑运算指令：NOT OPD：(OPD) 求反 → OPDAND OPD, OPS：(OPD)&amp;(OPS) → OPDOR OPD, OPS：(OPD)|(OPS) → OPDXOR OPD, OPS：(OPD)^(OPS) → OPD测试指令：TEST OPD, OPS功能：依据 (OPD)^(OPS) 设置标志位，(OPD)、(OPS) 不变CF=0, OF=0, ZF、SF、PF 依结果而定。AND、OR、XOR 亦是如此移位指令：算术左移 SAL Shift Arithmetic Left逻辑左移 SHL SHift Logical Left逻辑右移 SHR SHift Logical Right算术右移 SAR Shift Arithmetic Right循环左移 ROL Rotate Left循环右移 ROR Rotate Right带进位的循环左移 RCL Rotate Left through Carry格式：操作符 OPD, n 或 CL功能：将 (OPD) 中的所有位按操作符规定的方式移动，结果存在 OPD 对应的单元中特别说明：OPD 可是寄存器或地址表达式；在 8086 中 n 只能是 1，其他要用 CL串操作指令控制转移指令第4章 分支程序设计中涉及处理机控制指令伪指令语句处理器选择伪指令：告诉汇编程序选择何种 CPU 所支持的指令系统伪指令功能伪指令功能.8086接受8086指令（缺省方式）.586接受 Pentium 指令（除特权指令）.386接受80386指令（除特权指令）.586P接受全部 Pentium 指令.386P接受所有80386指令.686接受 Pentium Pro 指令（除特权指令）.486接受80486指令（除特权指令）.686P接受全部 Pentium Pro 指令.486P接受所有80486指令.MMX接受 MMX 指令.386MASM 不同版本支持的指令系统不同数据定义伪指令：格式：[变量名] 数据定义伪指令 表达式 [, ...]功能：定义一数据存储区，其类型由所使用的数据定位伪指令指定表达式 5 种：数值表达式、字符串、地址表达式、?、重复字句具体查看本章 “宏汇编语言表达式” 部分 -&gt; 变量相关符号定义伪指令：格式： 符号名 EQU 表达式功能：为常量、表达式及其他符号定义一个等价的符号名说明：符号名不可省。数据定义中变量名可省。变量占用存储单元，但符号名不占用存储单元。段定义伪指令：段定义伪指令：格式：段名 SEGMENT [使用类型] [定位方式] [组合方式] ['类别'] ...... 段名 ENDS“使用类型”：USE16，16 位段，段的最大长度为 64KB，地址的形式是 16 位段地址和 16 位偏移地址，寻址方式为 16 位寻址方式；USE32，.386 默认使用 32 位段。使用了伪指令 .386 （或以上），”使用类型” 才起作用假定伪指令：格式：ASSUME 段寄存器名:段名 [, ...]功能：用来设定段寄存器与段之间的对应关系目标程序运行时才能给段寄存器置值CS 和 SS 的内容将由操作系统自动设置DS 和 ES 的内容须由程序指令设置，且一定要做，这才能保证正确地产生数据存储单元的物理地址在程序启动时，DS 中的值是程序段前缀 Program Segment Prefix （PSP）置汇编地址计数器伪指令汇编地址计数器：＄汇编程序在翻译程序时，每遇到一个新段，就将汇编地址计数器置 0 。在分配存储单元后（变量定义、机器指令），汇编地址计数器累加其分配的单元长度。＄用来记录正在被汇编程序翻译的语句的地址。标号和变量的偏移地址就是准备翻译该语句时当前汇编地址计数器＄的值。汇编地址计数器符号＄可出现在表达式中。ORG 数值表达式功能：将 $ 设置成数值表达式的值。数值表达式的值应为非负的整数，其值可在 0 ～ 65535 之间（16 位段）或 0 ～4G 之间（ 32 位段）源程序结束伪指令：END [表达式]功能：遇到该语句是，汇编工作停止如果有表达式，指出第一条被执行指令的地址。如果无表达式，则说明该程序不能单独运行，这时，它作为一个子模块供其他程序调用。不可将 END 语句错误地安排在程序中间。常用 DOS 系统功能调用调用操作系统提供的功能：设备管理、文件管理、目录管理等一般过程：调用号放入 AH 中置好入口参数INT 21H调用结束，分析出口参数键盘输入 1 个字符 —— 1 号：MOV AH, 1INT 21H功能：等待从键盘输入一个字符;将输入字符的ASCII 码 → AL;将该字符送显示器显示。显示输出 1 个字符 —— 2 号：MOV AH, 2MOV DL, 带显示字符的 ASCIIINT 21H功能：将 DL 中的字符送显示器显示显示输出字符串 —— 9 号：LEA DX, 字符串首偏移地址MOV AH, 9INT 21H功能：从 DS：DX 所指向的单元开始，依次显示字符，直到遇到 ‘$‘ 为止。若字符串本身包含 ‘$‘ 就用 2 号调用循环输出吧键盘输入字符串 —— 10 号：LEA DX, 缓冲区首偏移地址MOV AH, 10INT 21H功能：从 DS：DX 所指的输入缓冲区输入字符串并送显示器显示1234567891011121314151617181920212223242526272829STACK SEGMENT STACK DB 200 DUP(0)STACK ENDSDATA SEGMENTBUF DB 11 ; 表示至多 10 个字符 DB ? ; 放实际输入字符个数 DB 11 DUP(0) ; 字符串最后一字符是 0DHDATA ENDSCODE SEGMENT ASSUME CS:CODE, DS:DATA, SS:STACK START: MOV AX, DATA MOV DS, AX LEA DX, BUF MOV AH, 10 INT 21H ; LEA DX, BUF; MOV AH, 9; INT 21H MOV AH, 4CH INT 21HCODE ENDS END START第 4 章 程序设计方法分支程序设计1234567891011;if(x==y) statements1;else statements2 MOV AX, X CMP AX, Y JNE L1 statements1 JMP L2L1: statements2L2: ...转移指令：条件转移简单条件转移 10 条无符号数条件转移 4 条有符号数条件转移 4 条无条件转移 JMP段内直接、段间直接段内间接、段间间接条件转移简单条件转移：指令条件JZ / JEZF=1JNZ / JNEZF=0JSSF=1JNSSF=0JOOF=1JNOOF=0JCCF=1JNCCF=0JP / JPEPF=1JNP / JPOPF=0无符号数条件转移指令：指令条件JA / JNBECF=0 且 ZF=0JAE / JNBCF=0 或 ZF=1JB / JNAECF=1 且 ZF=0JBE / JNACF=1 或 ZF=1123456 CMP AX, BX JA L1 ...L1: ...; 将 (AX), (BX) 当成无符号数，执行(AX)-(BX)，若(AX)&gt;(BX)，则CF一定会为0，ZF=0，转移到L1处有符号数条件转移指令：指令条件JG / JNLESF=OF 且 ZF=0JGE / JNLSF=OF 或 ZF=1JL / JNGESF != OF 且 ZF=0JLE / JNGSF != OF 或 ZF=1例子：根据输入的数字，显示对应的串。如 0 -&gt; ‘zero’, 1 -&gt; ‘first’, …，对于不同的输入，输出的串长度不同。程序的关键：如何根据输入，将对应的待显示的串首址送 DX打表的写法：123456STR0 DB &apos;zero&apos;, &apos;$&apos;STR1 DB &apos;one&apos;, &apos;$&apos;...TAB DW STR0, STR1, STR2, ...; 使用如下MOV DX, TAB[BX]无条件转移格式名称功能JMP 标号段内直接(IP/EIP)+位移量 → IP/EIPJMP OPD段内间接(OPD) → IP/EIPJMP 标号段间直接标号的EA → IP/EIP段首址 → CSJMP OPD段间间接(OPD) → IP/EIP(OPD+2或4) → CS例子：根据不同输入，跳到不同程序段。1-&gt;LP1, 2-&gt;LP2, …朴素的写法：12345... 判1JMP LP1... 判2JMP LP2...打表的写法：把指令地址列表构造好，直接 JMP TAB[BX]。（swtich-case 和 面向对象时大量采用）条件控制流伪指令，知道有就行了，本课不推荐使用。我们深入底层。1234567891011121314151617181920212223.386data segment USE16x db -5bufp db &apos;positive &gt; 0 $&apos;bufn db &apos; &lt; 0 $&apos;zero db &apos;zero $&apos;data endscode segment USE16 ....if x==0 lea dx, zero.elseif x&gt;0 lea dx, bufp.else lea dx, bufn.endif mov ah, 9 int 21h ; 出错，理由如下X DB -5 ; 可能会当成无符号数X SBYTE -5 ; 定义位有符号数; 类似的还有 SWORD SDWORD循环程序设计例：设以 BUF 为首址的一片单元中，存放了 N 个有符号字节数据，找出其中的最大数，存放到 AL中。123BUF DB 1,-10,20,-25, 25,50, …N = $ - BUF ; 如果是DW就再除2 ; ...80x86 提供四种计数控制循环转移指令：LOOP 标号功能：(CX / ECX) - 1 → CX / ECX若 (CX / ECX) 不为 0，则转标号处执行。基本等价于 DEC CX/ECX JNZ 标号，因为 LOOP 指令对标志位无影响LOOPE / LOOPZ 标号功能：(CX / ECX) - 1 → CX / ECX若 (CX / ECX) 不为 0，且 ZF=1，则转标号处执行。等于 0 转移指令，本指令对标志位无影响例子：判断以 BUF 为首址的 10 个字节中是否有非 0 字节。有，则置 ZF 为 0, 否则 ZF 置为 1 。12345 MOV CX, 10 MOV BX, OFFSET BUF -1L3: INC BX CMP BYTE PTR [BX], 0 LOOPE L3LOOPNE / LOOPNZ 标号功能：(CX / ECX) - 1 → CX / ECX若 (CX / ECX) != 0，且 ZF=0，则转标号处执行。例子：判断以 BUF 为首址的 10 个字节中是否有空格字节。JCXZ / JECXZ 标号若 (CX/ECX) 为 0，则转移子程序设计子程序格式：12345子程序名 PROC [类型] 过程体子程序名 ENDP; 类型：FAR 和 NEAR (缺省); NEAR 为段内调用，即主子程序在同一个代码段内。FAR 类型为段间调用，被另外代码段调用的过程可定义为FAR子程序的调用和返回（CALL 和 RET）名称JMP 格式CALL 格式段内直接JMP 标号CALL 标号段间直接JMP 标号 (FAR)CALL 标号 (FAR)直接调用段内直接调用格式：CALL 子程序名功能：(IP/EIP) -&gt; (SP/ESP)目的地址 EA -&gt; IP/EIP段间直接调用格式：CALL FAR PTR 子程序名功能：a.(CS)→↓(SP/ESP)b.(IP/EIP)→↓(SP/ESP)c.目的地址的段首址→ CSd.目的地址的EA→IP/EIP间接调用段内间接调用格式：CALL WORD PTR OPD(16位段)CALL DWORD PTR OPD(32位段)功能：(IP/EIP)→↓(SP/ESP）(OPD)→IP/EIP段间间接调用格式：CALL DWORD PTR OPD(16位段)CALL FWORD PTR OPD(32 位段)功能：a.(CS)→↓(SP/ESP)b.(IP/EIP)→↓(SP/ESP)c.(OPD)→IP/EIPd.(OPD+2/4)→CS注：OPD寻址方式与JMP类似①段内间接调用可用除立即方式以外的其它寻址方式；②段间间接调用可用除立即方式和寄存器寻址方式以外的其它寻址方式；间接调用时，子程序的入口地址可由寻址方式得到。应用：多个子程序入口地址组成地址表时，可用寻址方式确定转入子程序的入口地址。返回指令 RET格式：RET / RET n功能：a. 段内返回: ↑(SP)→IP/EIPb. 段间返回: ↑(SP)→IP/EIP, ↑(SP)→CS子程序调用现场的保护方法调用现场的保护与恢复：保护现场：主要指调用子程序时，主程序中使用的寄存器的值不因子程序的调用而被破坏。可在主程序做，也能在子程序做主程序与子程序的参数传递：参数传递 : 主程序为子程序提供入口参数，子程序返回结果给主程序寄存器法: 将所需参数放在寄存器中带入子程序。适合于参数少的情况。优点：传递信息快，编程简单方便，节省存贮单元，但参数不能太多，要避免出错。注意的问题：出口参数是子程序交给主程序的处理结果，没有必要将其列在需要保护的现场寄存器之中。而入口参数是否要保护，可依实际情况事先约定。堆栈法：堆栈法指将传递的参数放在堆栈中，进入子程序或返回主程序后，再将参数从堆栈中一一取出送入指定的寄存器。当参数个数较多时，一般用堆栈法传递参数，在使用堆栈时要特别注意栈顶的变化，要收回堆栈中传递参数的单元。约定单元法：将数据与运行好的结果放入事先规定好的存贮单元中。例子：子程序RADIX，将EAX中的32位无符号二进制数转换为(EBX)所指定进制的ASCII码送入(SI)所指定的偏移地址为首地址的存储区中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101; 寄存器法.386RADIX PROC PUSH CX PUSH EDX MOV CX, 0LOP1: MOV EDX, 0 DIV EBX PUSH DX INC CX OR EAX, EAX JNE LOP1NEXT: POP AX CMP AX, 10 JB L2 ADD AL, 7L2: ADD AL, 30H ； MOV [SI], AL INC SI LOOP NEXT POP EDX POP CX RETRADIX ENDP; 约定单元法RADIX PROC PUSH CX PUSH EDX PUSH EBX PUSH EAX PUSH SI MOVZX EBX，NUM MOV EAX，NUM1 MOV SI ， NUM+2 MOV CX, 0L1: MOV EDX, 0 DIV EBX PUSH DX INC CX OR AX,AX JNE L1NEXT: POP AX CMP AX, 10 JB L2 ADD AL, 7L2: ADD AL, 30H MOV [SI], AL INC SI LOOP NEXT MOV NUM+4 ， SI POP SI POP EAX POP EBX POP EDX POP CX RETRADIX ENDP; 堆栈法RADIX PROC PUSH CX PUSH EDX PUSH EAX PUSH EBX PUSH BP MOV BP, SP MOV SI, 18[BP] MOV EAX,20[BP] MOV EBX,24[BP] MOV CX,0 ; -----(1)L1: MOV EDX,0 DIV EBX PUSH DX INC CX OR AX, AX JNE L1NEXT: POP AX ; ---(2) CMP AX,10 JB L2 ADD AL,7L2: ADD AL, 30H MOV [SI],AL INC SI LOOP NEXT POP BP POP EBX POP EAX POP EDX POP CX RET 10 ; ----(3) 把栈内10个字节的空间都释放RADIX ENDP第 5 章 程序设计的其他方法和技术宏指令的定义与调用模块化程序设计方法及连接技术","link":"/CS/Assembly-Language-Study-Notes/"},{"title":"一个纯Java纯TCP协议的即时通讯程序HIM","text":"HIM一个纯Java纯TCP协议的即时通讯程序。HIM即Here I am or Here Instant Message，来自于我的【高级程序设计语言课程设计】课程，对服务端和客户端通信部分开源。 目录课设要求服务端架设WindowsLinux项目介绍目录结构服务端原理简单阐述开发历程前言需求分析数据库建模数据访问层设计缓存数据设计通讯协议层设计课设要求题目名称：Mini QQ基本要求：本次设计要求利用Java实现支持2-N人联机的迷你QQ应用程序PC版，支持如下基本需求:仿照腾讯QQ开发系统的应用功能（通过模仿和自己创意）。必备功能：二人即时聊天群聊功能传递文件（在线传、离线传）实时发送表情与图片、视频即时手动画图功能——画者所画，双方实时可见拓展功能： 在现有腾讯QQ已有功能的启发下，创新开发出更多的应用功能服务端架设有没有办法能马上用上这个服务端呢？有，所以我把这章节置前了。Windows安装好Java，并配置好环境变量，我的版本是 “JDK1.8.0_131”(在cmd中输入java -version即可显示版本)。安装好MySQL，由于喜好精简，于是开发环境版本是”v5.0.96”，当然在linux下”v5.7.21”也成功了。进入MySQL，建立一个数据库：(1). 在命令行输入：mysql -u root -p，再输入密码进入数据库(2). 输入 CREATE DATABASE HIM_Db CHARACTER SET UTF8;(3). 关于建表，com.HIM.server.Db_Init是自动建表的类把本仓库源码下载，使用eclipse对目录建立Java Project，在src/com/HIM/server下有Main.java，即main方法所在地。在启动服务端前还有一件事就是配置HIM_server.properties文件，该文件在项目目录下，尤其注意”JDBC基本信息”的配置。先启动服务端，再启动客户端(昂，客户端没开源，不过我会上传打包好的程序到release的)Linux部署完成后用Putty连接服务器，上来先更新：$ sudo apt-get update$ sudo apt-get upgrade然后是安装Mysql:$ sudo apt-get install mysql-server修改它的配置：$ vim /etc/mysql/mysql.conf.d/mysqld.cnf将bind-address = 127.0.0.1这行使用#注释掉，并且在[mysqld]字段后加上 character-set-server=utf8。由此实现开发环境连接生产环境数据库，和解决编码问题。然后是安装JDK:$ sudo apt-get install default-jdk配置好HIM_server.properties文件先，该文件在项目目录下，尤其注意”JDBC基本信息”的配置。创建一个项目目录，用SFTP把项目传上去：123456psftp&gt; open xx.xx.xxx.xx //你的服务器iplogin as: root //输入用户名和密码了root@xx.xx.xxx.xx&apos;s password:Remote working directory is /rootpsftp&gt; sudo mkdir /var/tttt/HIM_server //我创的项目目录psftp&gt; put -r t:/桌面/HIM/ /var/tttt/HIM_server/SSH中后台挂起服务端：$ nohup java -jar /var/tttt/HIM_server/HIM_server.jar &gt;&gt; log/log.txt &amp;若要实时调试则输入：``$ java -jar /var/tttt/HIM_server/HIM_server.jar test `启动客户端项目介绍目录结构1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950HIM├─src│ └─com│ └─HIM│ ├─client│ │ FileTransfer.java //托管文件传输的类│ │ Server_API.java //与服务端通信的api│ │ Thread_receiver.java //纯接收服务端信息的线程│ │ YouDrawMeGuessComm.java //实时画图数据传输者│ │ ...│ ├─common //一些Bean类和工具类│ │ Bean_fileinfo.java│ │ Bean_friendinfo.java│ │ Bean_message.java│ │ Bean_mood.java│ │ Bean_picture.java│ │ Bean_quninfo.java│ │ Bean_subgroup.java│ │ Bean_userinfo.java│ │ Enum_constellation.java│ │ Enum_sex.java│ │ logger.java│ │ SubGroupManager.java│ │ tools.java│ └─server│ config.java │ Db_C3P0_ConnectionPoolUtil.java //数据库连接池 │ Db_Init.java //数据库初始化类│ Db_Operate.java //数据库操作类│ logger.java //日志记录类│ Main.java│ OnlineUserManager.java //在线用户管理类│ QunMessageManager.java //群功能托管类│ ServerThreadsManager.java //连接线程管理类│ Thread_CommandLineControl.java //命令行界面控制类│ Thread_Greeter.java //ServerSocket│ Thread_Server.java //响应客服端请求└─test └─com └─HIM └─test ├─client │ Demo_ChatPanel.java │ Demo_test.java │ FileTransfer_test.java │ Server_API_test.java │ TesterConfig.java │ YouDrawMeGuessComm_test.java └─server Db_Operate_test.java服务端原理简单阐述（接下来要施展口技了）1234567891011121314151617181920212223业务处理的实现：（模型:客户端&lt;-&gt;TCP&lt;-&gt;服务端&lt;-&gt;JDBC&lt;-&gt;Mysql数据库）1.客户端——Socket-&gt;服务端2.服务端——JDBC-&gt;MySQL3.MySQL——处理完-&gt;服务端4.服务端——Socket-&gt;客户端 聊天功能的实现：（由于是纯TCP且客户端之前不连接，故客户端间通讯都是通过服务器中介）1.客户登录后，把其接收者线程&lt;int UserID-&gt;String&quot;IP:Port&quot;&gt;信息put进一个管理OnlineUser的HashMap里面。2.当客户端发送消息Bean_message后，取出其中的接受者ID，拿到OnlineUser的HashMap中映射一下，有则接而将得到的String&quot;IP:Port&quot;在ServerThread的HashMap映射得到线程，将message通过线程中的Object流写出。群聊功能的实现：维护一个&lt;群号-&gt;群成员数组&gt;的Map，里面就是服务器拿到message后判断为群消息类型进而对群中每一个成员按部就班&quot;施展&quot;聊天功能，批量转发message。 | -&gt; 读取配置文件&quot;HIM_server.properties&quot;成常量设在config类 | -&gt; 日志功能初始化 | -&gt; c3p0连接池初始化服务端启动 | | -&gt; 数据库建表，exist则不建 | -&gt; 群功能托管类启动 | -&gt; 主线程while循环中ServerSocket不断接入新的连接，并把它丢入线程池和一个管理ServerThread的&lt;String&quot;IP:Port&quot;-&gt;Thread&gt;的HashMap中 | -&gt; 先用Thread_receiver连接上服务端客户端启动 | -&gt; 再用Server_API连接上服务端 | -&gt; 调用Server_API的功能就行了​ emmmmm，还有什么要说的，想不到了啊，要不上代码吧开发历程前言Thanks for coming here.从Week2到Week11。作为学习JAVA以来的第一个项目，她的意义已经不再局限于一个课设了，就像教育孩子直到成其可用之才。很长一段时间我是在不断学习高级技术和推翻自己先前的想法。对于代码中魔法值肆虐、包结构过于精简、类名过于”神奇”等现象，请给我提Issue。如果能教一下我该怎么修正错误的习惯，感激不尽！这一章虽说是”开发历程”，其实也是摘抄我实验报告的部分罢了，或所尽口舌之快而不得其髓。另外，客户端是我的小伙伴写的，所以我无法开源，但已经将程序Demo上传到release还有，Gayhub作为最大的同性交友平台，欢迎来邮件~需求分析123456789本次课程设计立足于市场上热门的即时通讯软件QQ为原型，要求设计了一套自己的聊天软件模式，实现基本的聊天、数据传输功能，并提供了很大的发散空间，可以让我们添加更多的个性设计。于此，需求分析方面很简单：客户端，用户的使用部分，提供主要的界面和服务请求，如：登录界面、注册界面、信息查看修改界面、主窗体界面、聊天界面等。通过网络发送请求到服务端，并接受服务端反馈，处理、显示结果。服务端，提供服务的开启、关闭功能，负责处理核心的业务逻辑，负责连接数据库，保存和读取数据。通过网络接收客户端发送的请求，间接操作数据库，反馈结果于客户端，并用日志记录客户端请求。业务方面，提供业务有：注册、登录、登出、查询个人信息、查询分组列表、查询好友列表、昵称查询用户、ID查询用户、批量查询用户、更新好友列表、更新个人信息、更新头像、更改密码、上传文件、下载文件、上传头像、下载头像、发送消息（个人消息、群消息、图片、文件、“你画我猜”请求）、查询未读消息、群号查询群、群名查询群、查询用户所属群、查询群成员列表、上传群文件、查询群文件、创建群、加入群、退出群、更新群消息、更新个人的群名片、发表说说、查询好友说说。数据库建模1234567891011121.UserInfo(UserID,Passwd,Sign,PhotoIndex,Nickname,Sex,Birthday,Constellation,ApplyDate)2.ChatRecord(Index,SendTime,Sender,Type,Receiver,QunID,Content,Fonttype,Fontsize,Fontcolor,Readed)3.FileInfo(InfoIndex,Type,Size,MD5,Name,Path)4.LoginInfo(InfoIndex,UserID,IP,Port,LoginTime,Status)5.MoodRecord(Index,Poster,PostTime,Content)6.PhotoInfo(InfoIndex,MD5,Path)7.QunFile(Index,QunID,Uploader,UploadTime,FileIndex)8.QunInfo(QunID,QunName,PhotoIndex,CreateTime)9.SubGroup(GroupIndex,UserID,GroupName)10.UserEmoticon(Index,Fileindex,UserID)11.UserFriend(UserID,FriendID,GroupIndex,Alias)12.UserQun(Relation,UserID,QunID,Alias,JoinTime)数据访问层设计12345数据访问层，即将数据库写出读出的相关及其支持方法归分到相应的数据库操作类，在这里，主要是Db_Operate类和Db_Init类，里面提供了类似于register、login、addFriend等写入数据的静态方法，和queryUser、queryQuninfo等查询数据的静态方法。 此外，数据库连接的池化管理对数据访问的效率和系统的稳定性有些极大的作用。引入连接池，即对于一个服务端，初始化之时创建初始数量的Connection，每次请求时就直接从连接池拿取，用完放回，拿取之前，连接池对拿取前进行Connection可效性检验，失效或当前无可用连接则新建连接后返回。 JDK没有提供连接池。我使用了Java比较主流的四大连接池之一C3P0连接池，一个开源的JDBC连接池。使用起来还是蛮简单的。只要封装一个方法，方法里面对配置好的ComboPooledDataSource使用.getConnectons()方法就行了。缓存数据设计12在客户端与客户端通讯的时候，不同功能传输的数据量及类型不一，考虑到数据的存储和项目的可维护性，设计了一些Bean类，在网络IO的时候就可以直接传输对象。设计的Bean类有如下：Bean_userinfo、Bean_friendinfo、Bean_subgroup、Bean_quninfo、Bean_fileinfo、Bean_message，类之用途如其名。通讯协议层设计12345计算机之间数据传输的常用通讯协议有两种，即TCP和UDP。TCP是可靠的面向连接的通信协议，UDP是不可靠的面向无连接的通信协议。在服务端与客户端通讯中，由于多是处理像登录、加好友、查询群等交互的业务，故采用了TCP协议，长连接维护数据流和对象流，从而实现一次连接，随时业务。 在客户端与客户端的通讯中，起初在实现聊天功能是时候设想采用UDP协议，客户端从服务端拿到好友们IP和UDP端口，服务端起到一个维护在线用户信息的作用，聊天交给客户端们自己实现。但其网络条件较差时常出现掉包现象和无固定外网ip情况下将无法通讯情况，于是退而继续采用TCP协议，利用”转发”，实现客户端与客户端的连接。","link":"/Programing/HIM-An-Instant-Messaging-Software/"},{"title":"春招实习指南","text":"春招实习指南前言本文会以我自身的视角来总结一下如何获得春招实习的机会。 明确内心一个人活着，他可以想着去更为广阔的舞台实现他宏伟的目标，也可以想着去强大自身立足社会守护好自己这一片安详的小天地。而作为在校生的你，自然会根据家庭/经济/感情/兴趣/经历/眼界/现状等因素设计你的下一步着点，工作/读研/保资/选调/考公，你多多少少得明确下一个方向。努力准备机会，确实是留给有准备的人的。以往的资历固然重要，但是从现在开始你的努力才是真正确定结果的关键。胆大心细脸皮要厚，但不意味着不要脸，你是国内一流大学生有着属于自己的傲骨，招聘不是你求他招你，而是展现你自己让他觉得需要你。当然，其实我认为脸皮厚的真正境界是胆大心细敢想敢做，”想” 一定在 “做” 的前面，脸皮厚到像个憨批一样也不好。谨小慎微推动一件事情的完成会分为很多个小节点，只有你步步为营、谨小慎微，确保每一个小节点都完美完成，才能使你的努力和实力能百分百地作用。就拿人与人之间的沟通来说，与用人单位方沟通，必然要有十足的敬畏之心，就这一点来说，并不是所有人都会做得很好，但万一就是因为一个小节点完成得不好，就算其他节点完成得再好，也会留下一定的几率崩盘。沟通能力大企业讲究协同合作，沟通能力会更大程度上在你的面试过程中体现出来，如果沟通能力不佳，还是需要在语气/声调/用词/停顿/语言组织/神情神貌方面多下功夫，一个简单的训练自己的方法是小黄鸭调试法，对着小黄鸭或者空气大声地（会更有效果）临场发挥/深情背诵一些讲话。扯得差不多了，现在进入正题。春招/秋招/校招/社招/三方有很多概念需要知道。春招：金三银四（金三月银四月的意思）。大部分的实习生会在春招招入，因为要进行暑期实习了。春招也是毕业生秋招后补录的一种手段。秋招：金九银十，金八银九。毕业生招聘的高峰，大部分公司/事业群/岗位/小组的 hc (head count) 最多的时候三方：三方协议，指用人单位、应聘者、学校三方之间的协议，用人单位确保 hc 留给应聘者，学校确保应聘者只签署一个三方协议，应聘者确保自己毕业后回去用人单位工作。三方是 offer 的最后一个流程，只能签一家，毁约代价大，但三方之前流程节点的 “录用意向书” 等的毁约代价看公司和 HR。校招：对在校生/毕业生的招聘，正式员工最终要签三方。社招：社会招聘，一般招聘有工作经验的人。这里补一句，尽管程序员跳槽频繁，但是绝不能太频繁，在我实习的公司社招，除非特别优秀（一般这种人都是直接去挖的），5年3跳和3年2跳是简历面都过不了即面试机会都不会给的。信息获取渠道：互联网公司校招，一般多逛牛客网。CSDN，哎，还是有一些文章总结得不错的。微信公众号，各种技术类公众号可以提升眼界。知乎，只要你搜过的东西，它就会给你多推的。一些常见的招聘 APP，BOSS、拉钩等等。我春招没用过。可能社招用得多一点。但是如果没有内推人选的话对初步了解大公司的部门机构也是有帮助的，可以为你定向投 CV(curriculum vitae) 提供一定的信息。关注点：公司、岗位、技术栈、工作内容面经：一般非常有用内推：拿鹅厂举例子，强烈建议定向投鹅厂的不要投简历池，而是找人内推，因为投鹅厂简历池虽然可以选择意向事业群和岗位，但是有概率被截胡（亲身经历，我投 CDG 被 WXG 截胡，我同学投图形算法岗被数据库引擎岗截胡，我看傻了）。拿阿里举例子，阿里内部百多个部门可能上千个小组，投简历池确实很看缘分，但是内推我们又不知道有哪些小组这些小组老板怎么样前景怎么样干的活怎么样，所以找你实习过的学长、朋友帮忙考察十分重要。否者只能多看牛客/知乎的部门招聘广告了备战校招简历 —— 超级简历、STAR 原则笔试 —— 牛客、LeetCode面试 —— 自我介绍、面经、文章总结、自己总结我的面经字节跳动一面：算法题：求根号 N（牛顿法现场推不出来，直接二分，注意 N=0~1 的特殊性）算法题：找出数组中出现次数超过一半的数（抵消）算法题：八皇后Spring AOP 各种问TCP 握手为什么 3 次，挥手为什么 4 次你有什么要问我二面：说一下做的项目。算法题一道 dp给一个一年内出行的日子数组 out_days = [1, 4, 7, 11, 30, 145]假如有日票价格、周票价格、年票价格，问最小花费太紧张(人生第 2 次企业面试) dp 状态设计错了，转移方程写不出，一条路走到黑凉凉，因为没有问我“有什么问题要问我吗”。第二天早上收到短信 “暂时不录取您为’后端研发’岗位.”，下午又接到字节的电话约面试，另一个小组吧。又一面：各种基础，计网/OS/MySQL/数据结构（线性开型散列、哈希冲突、红黑树、B 树和 B+ 树）ConcurrentHashMap 底层实现（讲到分段锁大概就行）一道单向链表交叉题，判断并输出公共节点你有什么要问我又二面：聊各种实现，就是聊，把思考过程说出来一道简单 dp你有什么要问我又三面：一道二叉树转双向链表（要求是中序遍历的序列），在堆空间复杂度 O(1)，栈空间复杂度不限下完成一道股票买入卖出题，dp/贪心你有什么要问我HR 面：现在能入职+远程上班么还投了哪些厂及情况，手上有哪些 offer，想好了微信我字节跳动改名叫字节效率吧！鹅鹅鹅厂一面：进程、线程TCP 保证可靠性多态的实现虚函数底层原理算法题 —— 压缩算法，https://www.nowcoder.com/questionTerminal/c27561e5b7e0441493adb9a54071888d，模拟题算法题 —— LeetCode044 简化版，只有 “*“ 版，动态规划解法你有什么要问我二面：自我介绍近期的项目map 底层了解吗堆内存和栈内存MySQL 引擎有哪些，区别查询比较多用哪个 MySQL 引擎char 数组查找两个相同的字符怎么找Top K 问题协程了解吗Hash 碰撞解决TCP 保证可靠性TCP 为什么四次挥手用过哪些 C++11 特性多态的实现实习时间你有什么要问我三面（那天面试了 5 次，记不大清楚了）：自我介绍问我怎么做到的取得 ACM 的成绩和绩点（简历经历）新冠背景下，怎么实现一个人查询自己有无新冠，节省空间（一直没听懂题意，本质上是 bool 数组用 bitset 优化）现有系统上死锁了，破坏死锁的哪个条件HTTP 连接能否基于同一个 TCP 连接建立多个（HTTP2 下可以）Linux 下编程过么，或者用过的 Linux 指令unique 函数你自己实现（双指针实现）你有什么要问我四面：自我介绍聊项目，问哪些组件深入了解过打代码，一个对抗博弈搜索 —— 100 个苹果，AB两人轮流吃，每人吃 1~5 个，保证 A 能吃到最后一个苹果的方案。用搜索实现，而不是直接套结论（Nim博弈的其中一个模型）微信的附近的人的实现思路…还问了很多工程架构的问题忘了。工程架构问的比较多感觉这个面试官是架构组的（领导）…你有什么要问我阿里里里笔试-第 1 场 https://www.nowcoder.com/discuss/386873：最少次数打牌，暴力一下可过给 n 个不降串，n 个串没有先后顺序之说。从 n 个里面选择一些，拼成最长的不降串。（n&lt;=1e6，所以串的和长度&lt;=1e6）dp[i]['z'-'a'] 用前 i 个串，以某个字母为结尾，拼成的串的最长长度一面 —— 电话面试：自我介绍让拿一个自己的项目自己讲把话题导向了线程池、TCP 阻塞线程池为什么要自己创建，不用 Executors线程池的线程数目怎么设定，多个线程池时线程数目怎么设定TCP 阻塞方法epoll 机制知道吗SpringIoC / AOP 的原理挑一个讲讲了 IoC，问 Bean 是怎么装配的自动注入的原理Spring 启动过程问了是工作还是只是想实习一下你有什么要问我二面 —— 电话面试：自我介绍从项目入手，聊一聊根据人的不同吧。面试官和我主要讨论的是怎么学习，规划（没有聊技术）…你有什么要问我三面 —— 视频面试（又名 “和 P9 大佬聊chui天niu的经历”）：自我介绍围绕菁英班问一下（科研向）问一下做了哪些科研，说了一下上学期的科研实践成果。做过一些计算机视觉，传统算法+启发式优化Java 中哪部分最熟，说一下你的理解问一下 CCSP，主要问第 4 题 CPU 调度的实现和进一步可优化，提了一下时间片轮转和多优先级队列的思考你有什么要问我 —— “您现在做的工作/方向是？”HRG 面：各种问简历上说的程序设计思维与实践讲师是啥科研经历自己觉得自己的优点、缺点（这是情商检测题吗…哎）…你有什么要问我四面 —— 电话技术面：…感觉是压力面，主要就是怼我，然后互怼，后来我也语速加快。交叉面（五面 —— 电话技术面）：忘记了。但是问的问题没有前面的刁钻，并且面试官人很好，会听完你说，停顿一下才会继续说。没有深挖基础（逮住一个点一直问到不会为止），所以也有点害怕 233。阿里效率堪忧，让我一度认为被养鱼面试总结回过头来看，总结一下。有的厂的确并没有对面试官的面试原则进行规范，让面试官随意发挥，随意问。所以面试到底是发现被面试者的优点，还是放大他的缺点？有的有原则，有的没有。如果只是因为一道题不会做就直接切掉的话，那么对其他方面考察是不是基本没有考察（当然，如果被问到的这个问题是被设定为该厂的 “必要条件” 的话，那就没办法。比如字节跳动以面试的算法难度出名，能不能抽到面试者熟悉的算法就决定了结果，当然这也是面试者的短板效应。）一二三面，基本就是换人问同一套，但是问什么肯定因面试官不同而不同，然后一二三面肯定有难度递进，面试官知道你现在是二面，就不会再问你简单的问题。所以要适当的引导，回答的时候带上你的心思和引导，把话题尽可能导向你熟悉的方面。遇到不熟悉的方面也尽可能直接示弱，或者表示你对该问题不熟悉但现场思考后给出类似问题的回答。（非常重要）另外，对于面试官问的问题，不妨一旁同时拿笔记一下，如果他说了一大堆你没记住，很尴尬。非常感谢 qd、hmc 学长的内推了，学长探出来的路，给了我机会认识人非常好的主管、师兄。说在最后互联网公司的技术岗有非常多类别，PC 端、移动端、后端、算法、运维等等等等。朋友，如果说前端是距离用户最近的窗口，那后端就是整个数据的支撑体系，如何将业务数据抽象成 “合适” 的数据结构，设计合适的数据流（接口）去为前端提供服务，撑住并发的流量，这是（还有质量保证和可持续等等）后端的挑战和魅力。后端有做中间件的，也有做业务的。后者 hc 多并且技术难度没那么大。（哦，插一句，实习期不要太过于在乎薪资，如果我为了每天 400 的薪资去字节的话，可能就见识不到阿里的各种技术和沉淀了，也不一定会决定回来保研了。为什么提这一嘴，自然是因为阿里的薪资真的低）我个人非常推荐去做业务开发类的短期实习，成长可以非常快。长达几个月的实习，可以让你体验步入社会的感觉，毕竟，离毕业很近了。而且，这是一个机会，让你对自己的人生规划，更加清晰…最后抄一段手机备忘录的文字上来。人类用文字去承载文明和科技。我想用我的文字，去承载故事以及思考。陷入工作，陷入职场，一方面是循环和单调会磨损好奇心，一方面是渗出了孤独，高强度的工作挤压了生活。于是会有每晚下班后，黑光下辗转不眠的报复性熬夜，会有上班通勤时，面对人头涌动心里突然的悲凉.缺乏思考容易陷入一种自我感动，会觉得自己工作那么辛苦，没有功劳也有苦劳！但其实什么都没有…叔本华说过人要么孤独要么庸俗。而后，热情平滑下降，空窗期，会开始觉得迷茫和无趣。源源不断的工作，加上缺少思考的空洞。很想有一个很集中的时间，情绪忽然低落，让我去好好思考和总结一下，真正落下一些文字，但其实鲜有…离职这天，百丈思绪，却也是提笔而不落，草草了之，成了此文。程序员不仅仅是写代码，而且写 CRUD 也不难，难的是真正思考业务的本质，业务的价值，思考如何去更好地创造商业价值。技术承载业务，业务创造价值。这就是业务线的程序员生活吧。","link":"/LIFE/Internship-Guide-In-The-Spring/"},{"title":"我在 SDU 讲课啦 —— 《程序设计思维与实践》讲师经历与复盘","text":"前言​ 程序设计思维与实践是计算机科学与技术专业的专业必修课，阐述利用程序设计解决具体问题中普遍意义的概念、经验、思维、方法。除了课堂授课外，课程还包括上机实验、模拟测试，与下学期开设的《CSP软件能力认证》课程互为补充，全面培养学生的程序设计思维和编程解决实际问题的实践能力。​ 程序设计思维与实践 (Thinking and Practice in Programming)，是学院创新性课程设置，为提高大家程序设计水平，充分考虑各方面情况，研究决定聘用编程高手引领大家学习。身边的人，熟悉的人，刚刚成长起来的人，与大家更有共同语言，交流更方便快捷。—— 来自指导老师言我的总结与思考&quot;缘起&quot; —— 故事的发生​ 程序设计思维与实践 （下面简称 “程设”），后来我在为之写上的英文名是 Thinking and Practice in Programming（灵感来自 Thinking in Java，我觉得较为贴切）。​ 在学院的支持以及栾老蔡老的争取下，这门课诞生了，开课第一年 2019 年，也就是我的大二，由熟悉的 ACM 实验室的学长给我们上课，世豪/活鱼/玉鑫/双乐，这是第一届的讲师团队，加上宝盒他们也就是第一届的 TA 团队。​ 当时这门课简直就是 ACM 实验室必修课的弱化版，ACM 实验室的小伙伴们听课都十分轻松，看着一些同学从 “抓耳挠腮” 到懵逼，像极了自己大一时刚加入 ACM 时的样子，十分好玩。当时没有意识到，这其实同样也是我们第二年时想要着力改变但却不得不权衡的一点。&quot;流&quot; —— 团队与工作流​ 2020 年初，考试周，教务预选课，我看到 18 级的课表里有 “程设” 这门课，当时试着联系了一下蔡老和栾老，栾老表示今年让我牵头搞一搞这件事，拉上了东东，我们四个人碰了碰面聊了聊。当晚，凑齐了瑞瑞/qq/ZJM/苟狗学长在内的 6 人，组成了第二届的 TA 团队。​ 我们当晚在 N3-237 把 19 年的大纲大改特改，定下了 16 节课的大纲和内容初稿。我拿出 “操作系统教学大纲”，拷贝，重命名为 “程序设计思维与实践教学大纲”，想了想，在英文名那填上了 Thinking and Practice in Programming，填了填其他文字，把 16 节课程设计的表格塞进去。发给了栾老，栾老说好的我和蔡老师审审看。​ 寒假的时候备好了一半的课，疫情原因，开启了直播讲课的生涯（哭笑），每次讲课前都得自己从头到尾预讲一遍，梳理自己的讲课流，所以实际讲课还算发挥正常。每节课就是设计内容框架(详细版) -&gt; 制作 PPT / 出课后题 -&gt; 预讲 -&gt; 讲课 -&gt; 课后题 CodeReview / 验收，这样一个工作流。&quot;所思&quot; —— 复盘与反思​ 相比于去年，今年的课程内容设计上已经跳出了 ACM 那一套，把核心目标定为了 “CSP”，让 “CSP” 作为这门课成效的真正验收方式，面向 “CSP” 设计，此外也夹杂了一些我们 6 人的私货，比如东东对于图论算法的理解、我的 C++ 技巧和模拟题技巧。​ 回过头来看，首先第一点要反思的是，我们没有对 CSP-T1 和 CSP-T2 引起重视，学期中的时候我们才发现 —— 课程难度曲线的起点(x=0) 其实不够低。一部分同学感觉课程难，上课跟进难度大，平时作业题也开始缺少独立完成的元素。​ 表象是实验课上同学们对低端题 1A 过题率不高，哪怕成绩中等偏上的同学，也会栽倒在 CSP-T1/CSP-T2 上，所以学期中我们紧急商量调整了作业题，开始灌水加水题，一方面想要提高同学的自信，毕竟一直刷难题是很打击自信心的，这也是 ACM 实验室中非 OI 选手较少的原因；另一方是重新重视 T1/T2，我们前面一直教 T4/T5 的知识点，练 T3 的大模拟，同时被 18 级 ACM/原 OI 选手插值的榜单让我们放松了警惕轻视了 T1/T2。那，经过改进后训练一段时间 T1/T2 榜单有所回升，虽然我们并不满意。​ 再聊聊我们讲课模式的优缺点吧：讲课模式的亮点其实是 “live coding” + 干货 + 干货 + 学长的精炼。那，这门课不像很多基础学科，拥有宏大的背景，以及所谓的时代呼唤。她就是一门汇集了《计算机导论》+《数据结构》+《离散数学》+《算法设计与分析》等众多知识点于实践性的过渡性课程，用于提升学生的代码能力（或者我觉得更本质的说法是 —— 提升程序性逻辑思维和实践能力）、对经典算法应用的融会贯通。&quot;所得&quot; —— 如何改进​ 所以，如果有的话，对于明年程设团队我的第一类改进建议是：课程难度曲线最好降低，起步缓点；多刷 T1/T2 难度的水题，前期稳步提升（包括自信心和成就感的提升）；重视经典算法；删掉较难算法；给学生减负（今年就预计出错，对学生要求偏高）；最最重要：始终想着是要教会大部分学生。​ 第二类问题，少数的 ACM/OI 选手是变数。可能本门课的大部分知识点他们都会，仅仅起到一个复习的作用（这里提出一个观点 “酷爱算法竞赛的同学自然会加入 ACM 实验室去深入学习高级算法”，可以辨析辨析）。对于他们，我提出两种畅想，一是分级，课程大纲每节课都标注一部分拓展内容，对部分打过算法竞赛的同学提出更深的要求，好处是因材施教，缺点是课程团队成本巨大以及涉及授课内容不一致下的绩点划分，基本不可能实现；二是今年我们的方法 —— 一碗水端平，作业里有中等题和难题，难题权重小，所有同学一起面对，好处是公平（基础不一不能算数，每个人的水平本身就不可能一样）；缺点是中上游同学开始内卷，”选做”=必做，同时劝退中下游同学。​ 第三类问题，关于针对 CSP 的模拟训练，限时+赛后评测模式。由于今年是网络形式，大家无法在实验室同时进行模拟，就很吃亏，很难度量这部分在发挥授课效果中的比重。此外，按照形式来看，两个大班是很难同时调上实验课的，今年在家网课我们艰难尝试，而明年在学校的话估计很难调上，出两套题势在必行。更重要的是，要验证这个 “氛围+限时+赛后评测” 训练想法是否有教学效果，实践是检验真理的唯一标准嘛。​ 第四类问题，资产积累和复用。已经有了两届的资产积累，更别说第二届课程团队如此地用力设计课程，今后的课程团队在课程设计和资源准备上，有了借鉴，有所省力，将更多精力放在题目质量和教学效果上。​ 第五类问题，一定要多多复盘，多多思考，多多总结，缺乏对教学的思考一定会慢慢缺少灵魂、压抑热情。​ 第六类问题，自研 OJ 的迫切性，今年我们使用 VJ 做实验平台。临时自搭 Vijos、QDUOJ 做月测试平台，都在多人比赛时发现了他们的一些 Bug 和产品缺陷 (为此我们还魔改了)，我在 De 它们开源系统的 Bug 时十分痛苦。​ …&quot;SDUOJ&quot; —— 创新机会的未来基建​ 程序设计是计算机学生的必备基础，程序设计能力也在课程实验、研究生复试、工作面试中广泛出现。正因如此，国内计算机顶尖大学 (比如清北浙大) 均有由自己学校开发与维护的，支持学生训练以及课程实验设计使用的在线评测平台。​ (先抛开 SE 专业的 OJ 不说，因为那个 OJ 功能太基本，且当前已没人维护)​ 在这个在线评测系统不可或缺的大背景下，山东大学作为一个 985、双一流高校，迫切需要一个自主研发、稳定可用、需求可控的 OJ，用于收口教学外部依赖、资产沉淀、打造教学闭环。而 SDUOJ 便是我想在离开山大前，给 SDUCS 留的礼物（在 CS，我害怕我毕业后 10 年，SDUCS 依旧没有自研的 OJ。我怕，所以我想到了，这个人非我不可，我会在大四尽力花一年时间去做好这件事，并确保她尽可能传承下去）&quot;做梦&quot; —— 我所想的教学闭环​ 怎样形成教学闭环呢？我想的是：​ 现今，《计算机导论》（也就是 C++ 课），《数据结构》、《数据结构课程谁》、《程序设计思维与实践》、《CSP 软件能力认证》、《算法导论》等课程的实践部分，即实验，都是独立设计 + 人为验收 (费时费力)，或者可能依赖于三方平台，或者实验本身仅是一个实验文档，没有对实验成果进行自动化测试验证，对于课程实践部分也缺少复盘/反思/迭代，也就是资产积累。​ 我所想的是，SDUOJ 接入到 SDUCS 的教学生态后，C++ 课可以基于 SDUOJ 提供的能力设计各种基础的题目，提供自动化测试和反馈，同样地，《数据结构》和《程序设计思维与实践》等课更是如此。通过实验，提高学生的程序设计能力，学生在 CSP 认证中也会更出彩，学生从事科研工作不会被代码能力设瓶颈，学生就业更是有强大助力，结果就是山大学生专业素质提升。而 SDUOJ 则是成为伴随 SDUCS 学子从大一到大四学习生涯必不可少的伙伴。当然，更重要是传承。团队总结​ 作为一个假假的 TM、人形任务分发器 (不是) ，为我们今年的工作做一个团队总结吧。​ 今年是《程序设计思维与实践》开课的第二年，依旧采用这种“反转课堂”的授课方式，”聘用编程高手引领大家学习”。知识硬核，成长飞速，大大提高了 18 级学生的编程能力，这会在他们今后课程的实验编码中或在 CSP 认证中将会得到验证。​ 2020 年的课程团队秉着 “这大概是 18 级同学们最后一门编程课”、”对学生负责对自己负责” 的信念，精心设计课程内容、讲授经验。如今已经圆满完成 2020 年的授课任务，比起 2019 年，有了革新，也带来了效果。​ 由衷地希望这门课会一直延伸、传承下去，作为 SDUCS 的一个特色。这需要同学们的证明 —— 去向学院证明，证明这门课是有意义的。​附录 课程大纲与我の授课周次主题课程内容内容 负责人内容 校验人1算法复杂度、C++与STL（上）1、课程概述/大纲2、程序设计竞赛相关名词，如 VJ、OJ、AC、RE 等，以及评测系统的使用3、按题目分析复杂度：快速幂、快速乘4、数据范围、时限以及复杂度三者关系5、Input / Ouput6、vector / list、algorithm (只讲 sort，结构体 sort，lambda sort)资料：附加文档（常用技巧、IDE、白盒测试总结）实验：IO习题、快速幂习题1道、结构体sort习题1道、暴力专题，共 26 道水题张/杨刘/黄2C++与STL（下）、搜索（上）1、stack2、queue、priority_queue3、红黑树/哈希拉链法实现的 map/unordered_map、set/unordered_set，要求会实现红黑树STL的多关键字排序，拓展重载哈希方法、哈希因子调参4、BFS 解题框架5、CSP中对BFA的考察6、BFS隐式图问题作业：BFS 例题2道实验：小模拟3道张/杨刘/黄3搜索（下）、贪心（上）1、DFS 八皇后、选数问题2、CSP考察：CSP-再卖菜 (70、80、100分做法)3、贪心热身、贪心算法、贪心指标4、区间调度问题、最小延迟调度问题作业：贪心2道张/黄刘/杨4贪心（下）、二分1、区间选点问题证明 +典型例题2、二分算法框架（比较不同写法产生的边界问题）3、浮点数二分4、 二分答案（25min）作业：课上例题刘/ 黄张/杨5线性数据结构的应用1、单调栈，及其例题 （25min） 2、 单调队列，及其例题 （25min） 3、 尺取 例题×2（30min） 4、 一维前缀和、二维前缀和，及其例题 (20min) 作业：滑动窗口 最大立方图 尺取刘/黄张/杨6图和树的性质与应用（上）1、 树的存储（邻接表、前向星）（15min） 2、 树的遍历（DFS、BFS）（35min） 3、 并查集与 Kruskal（prim）（50min） 作业：树的直径题、最小生成树题张/黄刘/杨7图和树的性质与应用（中）1、 多元最短路floyd（20min） 2、 最短路 Dijkstra（20min） 3、 Bellman-ford及队列优化（40min） 作业：最短路练习2题刘/ 黄张/杨8图和树的性质与应用（下）1、 差分约束系统（30min） 2、 图的拓扑排序（20min） 3、 图的强连通分量分解（30min） 作业：差分约束一道，拓扑排序一道刘/ 黄张/杨9复杂模拟题的普适性方法1、题意分析与解题框架设计2、面向对象与模拟题3、例题演示作业：课上模拟题1道张/杨刘/黄10动态规划（一）1、 递推（20min） 2、 数字三角形（10min） 3、 记忆化（30min） 4、 LIS（25min） 5、 LCS（15min） 作业：递推 LIS张/杨刘/黄11动态规划（二）1. 背包 DP 0-1型、滚动数组 （40min） 2. 多重背包及二进制拆分（30min） 3. 完全背包（20min） 4. 输出方案 作业：0-1背包 多重背包张/杨刘/黄12动态规划（三）1、 区间dp（40min） 2、 状压dp（50min） 作业：区间dp例题、状压dp例题刘/杨张/黄13动态规划 （四）1、 树形DP（60min） 2、 单调队列优化DP（45min） 作业：树形dp例题、单调队列优化dp刘/杨张/黄14矩阵的应用1、 矩阵结构体（15min） 2、 矩阵快速幂（40min） 3、 矩阵快速幂优化DP（30min） 作业：矩阵快速幂优化DP刘/黄张/杨15字符串1、 KMP（50min）+ 例题 2、 Trie（50min）+例题 作业：KMP、Trie刘/黄张/杨16总复习预录课张/杨刘/黄17待定增补内容18期末考试因为 2020 年 新冠 原因，全国上网课。我们也不例外，大半部分都是网络直播授课。采用了 高校邦 平台，有回放机制。以下展示我的一些授课回放：负责的 3/4/数据班 的课程首页：https://sddx.gaoxiaobang.com/#/courses/detail/37875Week1.算法复杂度、C++与STL(上)章节页：https://sddx.class.gaoxiaobang.com/class/37875/unit/311455/chapter/2381327直播间回放页：http://view.csslcloud.net/api/view/callback?roomid=BAAB59F97EC821D99C33DC5901307461&amp;userid=DE93C3369EBDD724&amp;liveid=F3A92282D3EEDF78&amp;recordid=BB345AD22A1068ACWeek2.C++与STL(下) 、搜索(上)章节页：https://sddx.class.gaoxiaobang.com/class/37875/unit/311455/chapter/2453482直播间回放页：http://view.csslcloud.net/api/view/callback?roomid=EB1199F458B3D5289C33DC5901307461&amp;userid=DE93C3369EBDD724&amp;liveid=B4C3756AA1942BFE&amp;recordid=4CEF988EB2BF9D42Week3.搜索(下)、贪心(上)章节页：https://sddx.class.gaoxiaobang.com/class/37875/unit/311455/chapter/2496399直播间回放页：http://view.csslcloud.net/api/view/callback?roomid=B47547E3F1132E519C33DC5901307461&amp;userid=DE93C3369EBDD724&amp;liveid=46E054146C78F063&amp;recordid=B74963F59561AEBAWeek6.图和树的性质与应用(上)章节页：https://sddx.class.gaoxiaobang.com/class/37875/unit/311455/chapter/2533205直播间回放页：http://view.csslcloud.net/api/view/callback?roomid=CEBA38EA50665FC69C33DC5901307461&amp;userid=DE93C3369EBDD724&amp;liveid=8E7D16D64D335249&amp;recordid=39513DA3E4339F3EWeek9.复杂模拟题的普适性方法章节页：https://sddx.class.gaoxiaobang.com/class/37875/unit/311455/chapter/2550733直播间回放页：http://view.csslcloud.net/api/view/callback?roomid=31BFC8EC02968A689C33DC5901307461&amp;userid=DE93C3369EBDD724&amp;liveid=4DC28DC90BF16207&amp;recordid=7BB4707E9D2D55BEWeek10.动态规划(一)章节页：https://sddx.class.gaoxiaobang.com/class/37875/unit/311455/chapter/2557326直播间回放页：http://view.csslcloud.net/api/view/callback?roomid=A7FB434941F97F849C33DC5901307461&amp;userid=DE93C3369EBDD724&amp;liveid=5CABB7256769D873&amp;recordid=DC0074349BAEDA21Week11.动态规划(二)章节页：https://sddx.class.gaoxiaobang.com/class/37875/unit/311455/chapter/2558667直播间回放页：http://view.csslcloud.net/api/view/callback?roomid=8B20ECD4B1479FBF9C33DC5901307461&amp;userid=DE93C3369EBDD724&amp;liveid=CD329390099A801A&amp;recordid=C0919F3C23E610D6Week16.期末总复习串讲章节页：https://sddx.class.gaoxiaobang.com/class/37875/unit/311455/chapter/2580181视频m3u8页：https://gxbvideo-gs.gaoxiaobang.com/lcms/video/file/eb4834db1eb949c69903e2a339edad71_trans720p.m3u8","link":"/CS/My-Teaching-On-SDU-Programming/"},{"title":"计算机系统原理-二进制炸弹拆解实验记录","text":"拆弹前置mips学习视频：https://www.bilibili.com/video/av34932484/?p=37https://www.bilibili.com/video/av34932484/?p=38指令现查：https://blog.csdn.net/sdreamq/article/details/50776404https://www.cnblogs.com/blacksunny/p/7192416.html寄存器现查：寄存器名地址编号用途说明$00保存固定的常数0$at1汇编器专用$v0 ~ $v12 ~ 3表达式计算或函数调用的返回结果$a0 ~ $a34 ~ 7函数调用参数1～3$t0 ~ $t78 ~ 15临时变量，函数调用时不需要保存和恢复$s0 ~ $s716 ~ 23函数调用时需要保存和恢复的寄存器变量$t8 ~ $t924 ~ 25临时变量，函数调用时不需要保存和恢复$k0 ~ $k126 ~ 27操作系统专用$gp28全局指针变量(Global Pointer)$sp29堆栈指针变量(Stack Pointer)$fp30帧指针变量(Frame Pointer)$ra31返回地址(Return Address)GDB使用启动gdb：gdb bomb查看反编译dump：disas 函数名查看断点：info breakpoints删除断点：delete id监控变量：display 变量地址，最好用之一，结合*用查看变量：x[/][num][d/c] 地址，最好用之一打印变量值：p 地址查看寄存器：i r 寄存器下一条指令：ni向下执行直到遇到断点：n万能代码：help方法阅读反编译代码、汇编代码反编译代码：顺式结构，但是会往回跳，对于一些对象常量赋值直接上地址而不是标签汇编代码：”跳来跳去”，但是常量一目了然，对于对象常量赋值使用了标签gdb断点调试、变量监控看不懂反编译代码里寄存器附近有什么的时候，多用gdb的x指令display结合ni，监控变量变化写注释以及对代码分段对于循环结构，容易找到循环节愉快拆弹下面涉及到题解，想要7倍的快乐的同学请自己拆弹。注：注释有些许错误。自己拆解可以得到乐趣，领悟真谛！Main首先简单看一下这个Main，基本上是6关相连着：读入、进关、出关。完成一个关卡会执行一次phase_defused这个关卡完成函数，输出祝福语之类的。当然里面有点秘密就是了。12345678910111213141516171819202122232425262728293031323334353637383940Dump of assembler code for function main: 0x00400900 &lt;+0&gt;: addiu sp,sp,-48 # ... 省略 0x00400ba8 &lt;+680&gt;: jal 0x401fec &lt;read_line&gt; # ... 0x00400bbc &lt;+700&gt;: jal 0x400d6c &lt;phase_1&gt; # ... 0x00400bc8 &lt;+712&gt;: jal 0x402264 &lt;phase_defused&gt; # ... 0x00400bf4 &lt;+756&gt;: jal 0x401fec &lt;read_line&gt; # ... 0x00400c08 &lt;+776&gt;: jal 0x400dbc &lt;phase_2&gt; # ... 0x00400c14 &lt;+788&gt;: jal 0x402264 &lt;phase_defused&gt; # ... 0x00400c40 &lt;+832&gt;: jal 0x401fec &lt;read_line&gt; # ... 0x00400c54 &lt;+852&gt;: jal 0x400ed4 &lt;phase_3&gt; # ... 0x00400c60 &lt;+864&gt;: jal 0x402264 &lt;phase_defused&gt; # ... 0x00400c8c &lt;+908&gt;: jal 0x401fec &lt;read_line&gt; # ... 0x00400ca0 &lt;+928&gt;: jal 0x4012bc &lt;phase_4&gt; # ... 0x00400cac &lt;+940&gt;: jal 0x402264 &lt;phase_defused&gt; # ... 0x00400cd8 &lt;+984&gt;: jal 0x401fec &lt;read_line&gt; # ... 0x00400cec &lt;+1004&gt;: jal 0x4013e8 &lt;phase_5&gt; # ... 0x00400cf8 &lt;+1016&gt;: jal 0x402264 &lt;phase_defused&gt; # ... 0x00400d24 &lt;+1060&gt;: jal 0x401fec &lt;read_line&gt; # ... 0x00400d38 &lt;+1080&gt;: jal 0x401500 &lt;phase_6&gt; # ... 0x00400d44 &lt;+1092&gt;: jal 0x402264 &lt;phase_defused&gt; # ... End of assembler dump.下面进入第一关：Phase_112345678910111213141516171819202122232425262728293031323334353637Dump of assembler code for function phase_1: 0x00400d6c &lt;+0&gt;: addiu sp,sp,-32 0x00400d70 &lt;+4&gt;: sw ra,28(sp) 0x00400d74 &lt;+8&gt;: sw s8,24(sp) 0x00400d78 &lt;+12&gt;: move s8,sp # 为函数所需空间压栈 0x00400d7c &lt;+16&gt;: sw a0,32(s8) # 32(s8) = a0 0x00400d80 &lt;+20&gt;: lw a0,32(s8) # a0 = 32(s8) # 设置函数参数a0 0x00400d84 &lt;+24&gt;: lui v0,0x40 0x00400d88 &lt;+28&gt;: addiu a1,v0,10092 # 设置函数参数a1。0x40和10092不是简单的数字常量是地址这里，查汇编代码发现和&quot;$LC12&quot;标签有关，这个标签是常量&apos;.ascii &quot;Let&apos;s begin now!\\000&quot;&apos; 0x00400d8c &lt;+32&gt;: jal 0x401cf8 &lt;strings_not_equal&gt; # 进入函数&lt;strings_not_equal&gt;，出来后函数返回值放在v类寄存器 0x00400d90 &lt;+36&gt;: nop 0x00400d94 &lt;+40&gt;: beqz v0,0x400da4 &lt;phase_1+56&gt; # v0 == 0就跳到+56行，跳过了下面+48行的炸弹，故这里要求&lt;strings_not_equal&gt;返回值为0，即不能&quot;strings_not_equal&quot;， 两个字符串要相等，即输入串和常量串&quot;Let&apos;s begin now!&quot;相等，的解。 0x00400d98 &lt;+44&gt;: nop 0x00400d9c &lt;+48&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00400da0 &lt;+52&gt;: nop # 引爆炸弹 0x00400da4 &lt;+56&gt;: move sp,s8 0x00400da8 &lt;+60&gt;: lw ra,28(sp) 0x00400dac &lt;+64&gt;: lw s8,24(sp) 0x00400db0 &lt;+68&gt;: addiu sp,sp,32 0x00400db4 &lt;+72&gt;: jr ra 0x00400db8 &lt;+76&gt;: nop # 还原栈现场，返回End of assembler dump.输入Let&apos;s begin now!Phase_212345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091Dump of assembler code for function phase_2: 0x00400dbc &lt;+0&gt;: addiu sp,sp,-64 0x00400dc0 &lt;+4&gt;: sw ra,60(sp) 0x00400dc4 &lt;+8&gt;: sw s8,56(sp) 0x00400dc8 &lt;+12&gt;: move s8,sp 0x00400dcc &lt;+16&gt;: lui gp,0x42 0x00400dd0 &lt;+20&gt;: addiu gp,gp,-20080 0x00400dd4 &lt;+24&gt;: sw gp,16(sp) 0x00400dd8 &lt;+28&gt;: sw a0,64(s8) 0x00400ddc &lt;+32&gt;: addiu v0,s8,28 0x00400de0 &lt;+36&gt;: lw a0,64(s8) 0x00400de4 &lt;+40&gt;: move a1,v0 0x00400de8 &lt;+44&gt;: jal 0x401ba8 &lt;read_six_numbers&gt; # 压栈、读入6个数，存到28(s8)、32(s8)、36(s8)、40(s8)、44(s8)、48(s8) 0x00400dec &lt;+48&gt;: nop 0x00400df0 &lt;+52&gt;: lw gp,16(s8) 0x00400df4 &lt;+56&gt;: lw v1,28(s8) # 将v1 = 输入的六个数第1个 0x00400df8 &lt;+60&gt;: li v0,1 # 将v0 = 1 0x00400dfc &lt;+64&gt;: beq v1,v0,0x400e10 &lt;phase_2+84&gt; # 判断v1=v0=1，满足则跳+84行 0x00400e00 &lt;+68&gt;: nop 0x00400e04 &lt;+72&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00400e08 &lt;+76&gt;: nop 0x00400e0c &lt;+80&gt;: lw gp,16(s8) # 要求第一个参数为1 0x00400e10 &lt;+84&gt;: li v0,1 # 将v0 = 1 0x00400e14 &lt;+88&gt;: sw v0,24(s8) # 将24(s8) = v0 = 1 0x00400e18 &lt;+92&gt;: b 0x400ea8 &lt;phase_2+236&gt; # 跳到+236行 0x00400e1c &lt;+96&gt;: nop # 令24(s8) = 1，进入+236行 0x00400e20 &lt;+100&gt;: lw v0,24(s8) # v0 = 24(s8) 0x00400e24 &lt;+104&gt;: nop 0x00400e28 &lt;+108&gt;: addiu v0,v0,-1 # v0 -= 1 0x00400e2c &lt;+112&gt;: sll v0,v0,0x2 # v0 *= 4 0x00400e30 &lt;+116&gt;: addiu v1,s8,24 # v1 = s8+24，是一个地址 0x00400e34 &lt;+120&gt;: addu v0,v1,v0 # v0 += v1，即s8+24的地址向后偏移24(s8)个 0x00400e38 &lt;+124&gt;: lw a0,4(v0) # 参数寄存器，a0 = 4(v0) # 总结上面几句就是从s8+28向后取第24(s8)个变量，即num[i]，num是输入的六个数的数组 0x00400e3c &lt;+128&gt;: li v1,12 # v1 = 12 0x00400e40 &lt;+132&gt;: lw v0,24(s8) # v0 = 24(s8) 0x00400e44 &lt;+136&gt;: nop 0x00400e48 &lt;+140&gt;: subu v0,v1,v0 # v0=v1-v0=12-24(s8) 0x00400e4c &lt;+144&gt;: lw v1,-32660(gp) # 又出现了奇怪的常数，-32660(gp)，还是对全局指针的常数，反编译代码难看出什么，可以gdb一下，发现是现在0($v1) 为学号的第一位， 相应的4($v1)...一直到44($v1)。 # 当然也可以看汇编源码，发现上一行是&quot;lw $3,%got(ID_num)($28)&quot;一目了然了。 0x00400e50 &lt;+148&gt;: sll v0,v0,0x2 # v0 *= 4, 第一次的时候v0 = (12-1)*4，第二次是(12-2)*4=40 0x00400e54 &lt;+152&gt;: addu v0,v1,v0 # v0 = 学号第一位的地址+v0这个偏移量，即学号的从后数的第24(s8)位的地址 0x00400e58 &lt;+156&gt;: lw v0,0(v0) # 将 v0 = 学号的从后数的第24(s8)位的内容 0x00400e5c &lt;+160&gt;: nop 0x00400e60 &lt;+164&gt;: mult a0,v0 # 将lo,hi = a0*v0 = a0*学号的从后数的第24(s8)位，其中a0是 0x00400e64 &lt;+168&gt;: mflo a0 # 将a0 = lo = 乘法结果 0x00400e68 &lt;+172&gt;: lw v0,24(s8) # v0 = 24(s8) 0x00400e6c &lt;+176&gt;: nop 0x00400e70 &lt;+180&gt;: sll v0,v0,0x2 # v0 *= 2 0x00400e74 &lt;+184&gt;: addiu v1,s8,24 # v1 = s8+24，是一个地址 0x00400e78 &lt;+188&gt;: addu v0,v1,v0 # v0 = s8+24 + 24(s8)，还是一个地址 0x00400e7c &lt;+192&gt;: lw v0,4(v0) # 即v0 = 28(s8)后的第24(s8)个变量 0x00400e80 &lt;+196&gt;: nop 0x00400e84 &lt;+200&gt;: beq a0,v0,0x400e98 &lt;phase_2+220&gt; # 若a0=原a0*学号的从后数的第24(s8)位的内容 == v0=输入六个参数的第24(s8)个 则跳转+220行，不会爆炸 # 这里的原a0????????????????????????? 0x00400e88 &lt;+204&gt;: nop 0x00400e8c &lt;+208&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00400e90 &lt;+212&gt;: nop 0x00400e94 &lt;+216&gt;: lw gp,16(s8) 0x00400e98 &lt;+220&gt;: lw v0,24(s8) 0x00400e9c &lt;+224&gt;: nop 0x00400ea0 &lt;+228&gt;: addiu v0,v0,1 0x00400ea4 &lt;+232&gt;: sw v0,24(s8) 0x00400ea8 &lt;+236&gt;: lw v0,24(s8) # v0 = ++ 24(s8)的意思 0x00400eac &lt;+240&gt;: nop 0x00400eb0 &lt;+244&gt;: slti v0,v0,6 # v0=(v0&lt;6) 0x00400eb4 &lt;+248&gt;: bnez v0,0x400e20 &lt;phase_2+100&gt; # v0!=0，即满足上式，进入+100行 # 循环结构, 24(s8) 从0~5，执行6次 0x00400eb8 &lt;+252&gt;: nop 0x00400ebc &lt;+256&gt;: move sp,s8 0x00400ec0 &lt;+260&gt;: lw ra,60(sp) 0x00400ec4 &lt;+264&gt;: lw s8,56(sp) 0x00400ec8 &lt;+268&gt;: addiu sp,sp,64 0x00400ecc &lt;+272&gt;: jr ra 0x00400ed0 &lt;+276&gt;: nop # 收栈，还原现场，返回End of assembler dump.输入：%d %d %d %d %d %d1 学号倒数第1位*输入数字的第1个 学号倒数第2位*输入数字的第2个 学号倒数第3位*输入数字的第3个 学号倒数第4位输入数字的第4个 学号倒数第5位输入数字的第5个我的答案：1 0 0 0 0 0phase_3从phase_3开始就注释就是拆弹现场的迷la乱ji笔记，没有精修了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226Dump of assembler code for function phase_3: 0x00400ed4 &lt;+0&gt;: addiu sp,sp,-56 0x00400ed8 &lt;+4&gt;: sw ra,52(sp) 0x00400edc &lt;+8&gt;: sw s8,48(sp) 0x00400ee0 &lt;+12&gt;: move s8,sp 0x00400ee4 &lt;+16&gt;: lui gp,0x42 0x00400ee8 &lt;+20&gt;: addiu gp,gp,-20080 0x00400eec &lt;+24&gt;: sw gp,24(sp) 0x00400ef0 &lt;+28&gt;: sw a0,56(s8) 0x00400ef4 &lt;+32&gt;: lw a0,56(s8) 0x00400ef8 &lt;+36&gt;: lui v0,0x40 0x00400efc &lt;+40&gt;: addiu a1,v0,10112 0x00400f00 &lt;+44&gt;: addiu v1,s8,44 0x00400f04 &lt;+48&gt;: addiu v0,s8,40 0x00400f08 &lt;+52&gt;: addiu a2,s8,36 0x00400f0c &lt;+56&gt;: sw a2,16(sp) 0x00400f10 &lt;+60&gt;: move a2,v1 0x00400f14 &lt;+64&gt;: move a3,v0 0x00400f18 &lt;+68&gt;: lw v0,-32636(gp) # 看到熟悉的-3xxxx(gp) 0x00400f1c &lt;+72&gt;: nop 0x00400f20 &lt;+76&gt;: move t9,v0 # 把v0放到t9 0x00400f24 &lt;+80&gt;: jalr t9 # 跳转到t9去 0x00400f28 &lt;+84&gt;: nop # 然后从t9回来后，v0=输入参数的个数 0x00400f2c &lt;+88&gt;: lw gp,24(s8) # gdb调试了一下 x /12 $s8 才发现我输入的&quot;555555&quot;，也就说是在44(s8)是我输入的第一个数字 0x00400f30 &lt;+92&gt;: slti v0,v0,3 # v0=(v0&lt;3) 然后就会爆炸，就是输入的数字少于3个会爆炸 0x00400f34 &lt;+96&gt;: beqz v0,0x400f48 &lt;phase_3+116&gt; # v0==0就到+116行 0x00400f38 &lt;+100&gt;: nop 0x00400f3c &lt;+104&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00400f40 &lt;+108&gt;: nop 0x00400f44 &lt;+112&gt;: lw gp,24(s8) 0x00400f48 &lt;+116&gt;: lw v0,44(s8) # 把我输入的第一个数字放到v0 0x00400f4c &lt;+120&gt;: nop 0x00400f50 &lt;+124&gt;: sltiu v1,v0,8 # v1=(输入的第一个数字&lt;8) 0x00400f54 &lt;+128&gt;: beqz v1,0x401190 &lt;phase_3+700&gt; # 输入的第一个数&gt;=8会跳到+700行，不用往下看了，是爆炸，也就是说输入的第一个数字要小于8 0x00400f58 &lt;+132&gt;: nop 0x00400f5c &lt;+136&gt;: sll v1,v0,0x2 # v1 = 输入的第一个数字*4 0x00400f60 &lt;+140&gt;: lui v0,0x40 # v0 = 64的高16位 = 64*65536 = 4194304 0x00400f64 &lt;+144&gt;: addiu v0,v0,10124 # v0 = 4194304+10124 = 4204428 0x00400f68 &lt;+148&gt;: addu v0,v1,v0 # v0 = 输入的第一个数字*4 + 4204428 0x00400f6c &lt;+152&gt;: lw v0,0(v0) # v0 = v0地址上的数字，应该是一个子程序地址，输入的第一个数是1的时候为4198336，是2的手为4198404 0x00400f70 &lt;+156&gt;: nop 0x00400f74 &lt;+160&gt;: jr v0 # 进入v0这个子程序，如果输入的第一个数是1则到+236行，为2到+304行，为3时候到+372行，为4时候到+436行，为5时到+504行，为6时到+572行，为7时到+632行，为0的时候直接顺着下去到+168 0x00400f78 &lt;+164&gt;: nop 0x00400f7c &lt;+168&gt;: li v0,113 0x00400f80 &lt;+172&gt;: sb v0,32(s8) 0x00400f84 &lt;+176&gt;: lw v0,-32660(gp) 0x00400f88 &lt;+180&gt;: nop 0x00400f8c &lt;+184&gt;: lw v1,44(v0) 0x00400f90 &lt;+188&gt;: lw v0,36(s8) 0x00400f94 &lt;+192&gt;: nop 0x00400f98 &lt;+196&gt;: mult v1,v0 0x00400f9c &lt;+200&gt;: mflo v1 0x00400fa0 &lt;+204&gt;: li v0,777 0x00400fa4 &lt;+208&gt;: beq v1,v0,0x4011ac &lt;phase_3+728&gt; # 要学号第12位*输入的第二个数字去掉首位 == 777 0x00400fa8 &lt;+212&gt;: nop 0x00400fac &lt;+216&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00400fb0 &lt;+220&gt;: nop 0x00400fb4 &lt;+224&gt;: lw gp,24(s8) 0x00400fb8 &lt;+228&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x00400fbc &lt;+232&gt;: nop 0x00400fc0 &lt;+236&gt;: li v0,98 # 输入第一个数字为1时候到达的地方 0x00400fc4 &lt;+240&gt;: sb v0,32(s8) 0x00400fc8 &lt;+244&gt;: lw v0,-32660(gp) # -3xxxx(gp)一看到，应该要出现学号了 # 此时0($v0)是学号的第1位 以此类推 4($v0) 0x00400fcc &lt;+248&gt;: nop 0x00400fd0 &lt;+252&gt;: lw v1,44(v0) # v1 = 学号第12位 0x00400fd4 &lt;+256&gt;: lw v0,36(s8) # v0 = 输入的第二个数字去掉首位 0x00400fd8 &lt;+260&gt;: nop 0x00400fdc &lt;+264&gt;: mult v1,v0 0x00400fe0 &lt;+268&gt;: mflo v1 0x00400fe4 &lt;+272&gt;: li v0,214 0x00400fe8 &lt;+276&gt;: beq v1,v0,0x4011b8 &lt;phase_3+740&gt; # 学号第12位*输入的第二个数字去掉首位 == 214 则跳到+720行，好的想都不用想了，我学号第12位是0，第一条路没了。 0x00400fec &lt;+280&gt;: nop 0x00400ff0 &lt;+284&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00400ff4 &lt;+288&gt;: nop 0x00400ff8 &lt;+292&gt;: lw gp,24(s8) 0x00400ffc &lt;+296&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x00401000 &lt;+300&gt;: nop 0x00401004 &lt;+304&gt;: li v0,98 # 第二条路 0x00401008 &lt;+308&gt;: sb v0,32(s8) 0x0040100c &lt;+312&gt;: lw v0,-32660(gp) # 依旧相似的重复 0x00401010 &lt;+316&gt;: nop 0x00401014 &lt;+320&gt;: lw v1,44(v0) 0x00401018 &lt;+324&gt;: lw v0,36(s8) 0x0040101c &lt;+328&gt;: nop 0x00401020 &lt;+332&gt;: mult v1,v0 0x00401024 &lt;+336&gt;: mflo v1 0x00401028 &lt;+340&gt;: li v0,755 0x0040102c &lt;+344&gt;: beq v1,v0,0x4011c4 &lt;phase_3+752&gt; # 学号第12位*输入的第二个数字去掉首位 == 755 则跳到+752行，好的想都不用想了，我学号第12位是0，第二条路没了。 0x00401030 &lt;+348&gt;: nop 0x00401034 &lt;+352&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00401038 &lt;+356&gt;: nop 0x0040103c &lt;+360&gt;: lw gp,24(s8) 0x00401040 &lt;+364&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x00401044 &lt;+368&gt;: nop 0x00401048 &lt;+372&gt;: li v0,107 # 第三条路，熟悉的场tao景lu 0x0040104c &lt;+376&gt;: sb v0,32(s8) 0x00401050 &lt;+380&gt;: lw v0,-32660(gp) 0x00401054 &lt;+384&gt;: nop 0x00401058 &lt;+388&gt;: lw v1,44(v0) 0x0040105c &lt;+392&gt;: lw v0,36(s8) 0x00401060 &lt;+396&gt;: nop 0x00401064 &lt;+400&gt;: mult v1,v0 0x00401068 &lt;+404&gt;: mflo v0 0x0040106c &lt;+408&gt;: beqz v0,0x4011d0 &lt;phase_3+764&gt; # 学号第12位*输入的第二个数字去掉首位 == 0 则跳转到764行，咦我的学号满足啊，但先去看看第四五六七条路 0x00401070 &lt;+412&gt;: nop 0x00401074 &lt;+416&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00401078 &lt;+420&gt;: nop 0x0040107c &lt;+424&gt;: lw gp,24(s8) 0x00401080 &lt;+428&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x00401084 &lt;+432&gt;: nop 0x00401088 &lt;+436&gt;: li v0,111 # 第四条路 0x0040108c &lt;+440&gt;: sb v0,32(s8) 0x00401090 &lt;+444&gt;: lw v0,-32660(gp) 0x00401094 &lt;+448&gt;: nop 0x00401098 &lt;+452&gt;: lw v1,44(v0) 0x0040109c &lt;+456&gt;: lw v0,36(s8) 0x004010a0 &lt;+460&gt;: nop 0x004010a4 &lt;+464&gt;: mult v1,v0 0x004010a8 &lt;+468&gt;: mflo v1 0x004010ac &lt;+472&gt;: li v0,228 0x004010b0 &lt;+476&gt;: beq v1,v0,0x4011dc &lt;phase_3+776&gt; # 要等于228，不行 0x004010b4 &lt;+480&gt;: nop 0x004010b8 &lt;+484&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x004010bc &lt;+488&gt;: nop 0x004010c0 &lt;+492&gt;: lw gp,24(s8) 0x004010c4 &lt;+496&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x004010c8 &lt;+500&gt;: nop 0x004010cc &lt;+504&gt;: li v0,116 # 第5条路 0x004010d0 &lt;+508&gt;: sb v0,32(s8) 0x004010d4 &lt;+512&gt;: lw v0,-32660(gp) 0x004010d8 &lt;+516&gt;: nop 0x004010dc &lt;+520&gt;: lw v1,44(v0) 0x004010e0 &lt;+524&gt;: lw v0,36(s8) 0x004010e4 &lt;+528&gt;: nop 0x004010e8 &lt;+532&gt;: mult v1,v0 0x004010ec &lt;+536&gt;: mflo v1 0x004010f0 &lt;+540&gt;: li v0,513 0x004010f4 &lt;+544&gt;: beq v1,v0,0x4011e8 &lt;phase_3+788&gt; # 要等于513，不行 0x004010f8 &lt;+548&gt;: nop 0x004010fc &lt;+552&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00401100 &lt;+556&gt;: nop 0x00401104 &lt;+560&gt;: lw gp,24(s8) 0x00401108 &lt;+564&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x0040110c &lt;+568&gt;: nop 0x00401110 &lt;+572&gt;: li v0,118 # 第6条路 0x00401114 &lt;+576&gt;: sb v0,32(s8) 0x00401118 &lt;+580&gt;: lw v0,-32660(gp) 0x0040111c &lt;+584&gt;: nop 0x00401120 &lt;+588&gt;: lw v1,44(v0) 0x00401124 &lt;+592&gt;: lw v0,36(s8) 0x00401128 &lt;+596&gt;: nop 0x0040112c &lt;+600&gt;: mult v1,v0 0x00401130 &lt;+604&gt;: mflo v1 0x00401134 &lt;+608&gt;: li v0,780 0x00401138 &lt;+612&gt;: beq v1,v0,0x40114c &lt;phase_3+632&gt; #要等于780，不行 0x0040113c &lt;+616&gt;: nop 0x00401140 &lt;+620&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00401144 &lt;+624&gt;: nop 0x00401148 &lt;+628&gt;: lw gp,24(s8) 0x0040114c &lt;+632&gt;: li v0,98 # 第7条路 0x00401150 &lt;+636&gt;: sb v0,32(s8) 0x00401154 &lt;+640&gt;: lw v0,-32660(gp) 0x00401158 &lt;+644&gt;: nop 0x0040115c &lt;+648&gt;: lw v1,44(v0) 0x00401160 &lt;+652&gt;: lw v0,36(s8) 0x00401164 &lt;+656&gt;: nop 0x00401168 &lt;+660&gt;: mult v1,v0 0x0040116c &lt;+664&gt;: mflo v1 0x00401170 &lt;+668&gt;: li v0,824 0x00401174 &lt;+672&gt;: beq v1,v0,0x4011f4 &lt;phase_3+800&gt; # 要等于824，不行 0x00401178 &lt;+676&gt;: nop 0x0040117c &lt;+680&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00401180 &lt;+684&gt;: nop 0x00401184 &lt;+688&gt;: lw gp,24(s8) 0x00401188 &lt;+692&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x0040118c &lt;+696&gt;: nop 0x00401190 &lt;+700&gt;: li v0,120 0x00401194 &lt;+704&gt;: sb v0,32(s8) 0x00401198 &lt;+708&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x0040119c &lt;+712&gt;: nop 0x004011a0 &lt;+716&gt;: lw gp,24(s8) 0x004011a4 &lt;+720&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x004011a8 &lt;+724&gt;: nop 0x004011ac &lt;+728&gt;: nop 0x004011b0 &lt;+732&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x004011b4 &lt;+736&gt;: nop 0x004011b8 &lt;+740&gt;: nop 0x004011bc &lt;+744&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x004011c0 &lt;+748&gt;: nop 0x004011c4 &lt;+752&gt;: nop 0x004011c8 &lt;+756&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x004011cc &lt;+760&gt;: nop 0x004011d0 &lt;+764&gt;: nop # 第三条路的到点 0x004011d4 &lt;+768&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x004011d8 &lt;+772&gt;: nop 0x004011dc &lt;+776&gt;: nop 0x004011e0 &lt;+780&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x004011e4 &lt;+784&gt;: nop 0x004011e8 &lt;+788&gt;: nop 0x004011ec &lt;+792&gt;: b 0x4011f8 &lt;phase_3+804&gt; 0x004011f0 &lt;+796&gt;: nop 0x004011f4 &lt;+800&gt;: nop # 最终都会汇集到的地方 0x004011f8 &lt;+804&gt;: lb v0,40(s8) # 追踪了一下40($s8)在从t9出来后就没变了 0x004011fc &lt;+808&gt;: lb v1,32(s8) # lb 读末八位进来 0x00401200 &lt;+812&gt;: nop 0x00401204 &lt;+816&gt;: beq v1,v0,0x401218 &lt;phase_3+836&gt; 0x00401208 &lt;+820&gt;: nop 0x0040120c &lt;+824&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00401210 &lt;+828&gt;: nop 0x00401214 &lt;+832&gt;: lw gp,24(s8) 0x00401218 &lt;+836&gt;: move sp,s8 0x0040121c &lt;+840&gt;: lw ra,52(sp) 0x00401220 &lt;+844&gt;: lw s8,48(sp) 0x00401224 &lt;+848&gt;: addiu sp,sp,56 0x00401228 &lt;+852&gt;: jr ra 0x0040122c &lt;+856&gt;: nopEnd of assembler dump.输入%d %c %d第一个数字44($s8)，要小于8,代表了8个条件分支第二个参数40($s8)，是8个条件分支里会设置的最后比对ASCII相等第三个数字乘以学号最后一位乘起来去和8个条件分支的常数判等我的答案：3 k 任意一个数字恭喜完成Phase_3…Phase_41234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Dump of assembler code for function phase_4: 0x004012bc &lt;+0&gt;: addiu sp,sp,-40 0x004012c0 &lt;+4&gt;: sw ra,36(sp) 0x004012c4 &lt;+8&gt;: sw s8,32(sp) 0x004012c8 &lt;+12&gt;: move s8,sp 0x004012cc &lt;+16&gt;: lui gp,0x42 0x004012d0 &lt;+20&gt;: addiu gp,gp,-20080 0x004012d4 &lt;+24&gt;: sw gp,16(sp) 0x004012d8 &lt;+28&gt;: sw a0,40(s8) 0x004012dc &lt;+32&gt;: lw v1,40(s8) 0x004012e0 &lt;+36&gt;: lui v0,0x40 0x004012e4 &lt;+40&gt;: addiu v0,v0,10156 0x004012e8 &lt;+44&gt;: move a0,v1 0x004012ec &lt;+48&gt;: move a1,v0 0x004012f0 &lt;+52&gt;: addiu v0,s8,24 0x004012f4 &lt;+56&gt;: move a2,v0 0x004012f8 &lt;+60&gt;: lw v0,-32636(gp) 0x004012fc &lt;+64&gt;: nop 0x00401300 &lt;+68&gt;: move t9,v0 # 让读入函数的返回值为v0，看下一行就知道了“jalr”，调用了系统的ddl 0x00401304 &lt;+72&gt;: jalr t9 0x00401308 &lt;+76&gt;: nop 0x0040130c &lt;+80&gt;: lw gp,16(s8) # 可以从这里开始，x /7d $s8发现是输入的那一个参数，即24($s8) 0x00401310 &lt;+84&gt;: move v1,v0 # 令v1=v0=实际参数数目 0x00401314 &lt;+88&gt;: li v0,1 # 规定的输入参数数目为v0=1 0x00401318 &lt;+92&gt;: bne v1,v0,0x401330 &lt;phase_4+116&gt; # 判断输入参数为1个，不等的话就去+116行引爆炸弹吧 0x0040131c &lt;+96&gt;: nop 0x00401320 &lt;+100&gt;: lw v0,24(s8) # 把输入的那个参数读入到v0 0x00401324 &lt;+104&gt;: nop 0x00401328 &lt;+108&gt;: bgtz v0,0x401340 &lt;phase_4+132&gt; # 输入的那个参数大于0就跳到+132 0x0040132c &lt;+112&gt;: nop 0x00401330 &lt;+116&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00401334 &lt;+120&gt;: nop 0x00401338 &lt;+124&gt;: lw gp,16(s8) 0x0040133c &lt;+128&gt;: nop 0x00401340 &lt;+132&gt;: lw v0,-32660(gp) # 把学号第一位首&quot;地址&quot;放到v0 0x00401344 &lt;+136&gt;: nop 0x00401348 &lt;+140&gt;: lw v0,44(v0) # 0是第一位首地址，44就是取第十二位学号到v0 0x0040134c &lt;+144&gt;: nop 0x00401350 &lt;+148&gt;: andi v0,v0,0x1 # v0 &amp;= 0x1 0x00401354 &lt;+152&gt;: andi v0,v0,0xff # v0 &amp;= 0xff (是255) 0x00401358 &lt;+156&gt;: beqz v0,0x40139c &lt;phase_4+224&gt; # 两次与运算之后等于0的话就去+224行，否则继续，我的学号最后一位是0，与上什么都是0，那就去+224行 0x0040135c &lt;+160&gt;: nop 0x00401360 &lt;+164&gt;: lw v0,24(s8) 0x00401364 &lt;+168&gt;: nop 0x00401368 &lt;+172&gt;: move a0,v0 0x0040136c &lt;+176&gt;: jal 0x401230 &lt;func4&gt; 0x00401370 &lt;+180&gt;: nop 0x00401374 &lt;+184&gt;: lw gp,16(s8) 0x00401378 &lt;+188&gt;: move v1,v0 0x0040137c &lt;+192&gt;: li v0,8 0x00401380 &lt;+196&gt;: beq v1,v0,0x4013d0 &lt;phase_4+276&gt; 0x00401384 &lt;+200&gt;: nop 0x00401388 &lt;+204&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x0040138c &lt;+208&gt;: nop 0x00401390 &lt;+212&gt;: lw gp,16(s8) 0x00401394 &lt;+216&gt;: b 0x4013d0 &lt;phase_4+276&gt; 0x00401398 &lt;+220&gt;: nop 0x0040139c &lt;+224&gt;: lw v0,24(s8) # 降落完毕，把输入的那个参数放到v0 0x004013a0 &lt;+228&gt;: nop 0x004013a4 &lt;+232&gt;: move a0,v0 # 把v0即输入的那个参数放到a0 0x004013a8 &lt;+236&gt;: jal 0x401230 &lt;func4&gt; # 进入函数func4 0x004013ac &lt;+240&gt;: nop 0x004013b0 &lt;+244&gt;: lw gp,16(s8) # 从func4回来 0x004013b4 &lt;+248&gt;: move v1,v0 # v1 = v0 = func4的返回值 0x004013b8 &lt;+252&gt;: li v0,13 # v0 = 13 0x004013bc &lt;+256&gt;: beq v1,v0,0x4013d0 &lt;phase_4+276&gt; # v1 == v0的话，就去276完成该关卡，蛤？也就是说要func的返回值为13。。。行吧，去看情况② 0x004013c0 &lt;+260&gt;: nop 0x004013c4 &lt;+264&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x004013c8 &lt;+268&gt;: nop 0x004013cc &lt;+272&gt;: lw gp,16(s8) 0x004013d0 &lt;+276&gt;: move sp,s8 0x004013d4 &lt;+280&gt;: lw ra,36(sp) 0x004013d8 &lt;+284&gt;: lw s8,32(sp) 0x004013dc &lt;+288&gt;: addiu sp,sp,40 0x004013e0 &lt;+292&gt;: jr ra 0x004013e4 &lt;+296&gt;: nopEnd of assembler dump.引入func412345678910111213141516171819202122232425262728293031323334353637383940414243444546474849Dump of assembler code for function func4: 0x00401230 &lt;+0&gt;: addiu sp,sp,-40 0x00401234 &lt;+4&gt;: sw ra,36(sp) 0x00401238 &lt;+8&gt;: sw s8,32(sp) 0x0040123c &lt;+12&gt;: sw s0,28(sp) 0x00401240 &lt;+16&gt;: move s8,sp 0x00401244 &lt;+20&gt;: sw a0,40(s8) # 把输入的那个参数存到40(s8) 0x00401248 &lt;+24&gt;: lw v0,40(s8) # v0 = 40(s8) = 输入的那个参数 0x0040124c &lt;+28&gt;: nop 0x00401250 &lt;+32&gt;: slti v0,v0,2 # v0 = (v0&lt;2) 0x00401254 &lt;+36&gt;: bnez v0,0x40129c &lt;func4+108&gt; # 也就是说情况①输入参数小于2的话去+108行 0x00401258 &lt;+40&gt;: nop 0x0040125c &lt;+44&gt;: lw v0,40(s8) # 好的，情况②，我们把v0=输入的参数 0x00401260 &lt;+48&gt;: nop 0x00401264 &lt;+52&gt;: addiu v0,v0,-1 # v0 = 输入的参数-1 0x00401268 &lt;+56&gt;: move a0,v0 # a0 = v0 0x0040126c &lt;+60&gt;: jal 0x401230 &lt;func4&gt; # 再进一次func4，蛤？递归吗？每次的传参都会-1，但相应的应该也会影响返回的值，我们往下看 0x00401270 &lt;+64&gt;: nop 0x00401274 &lt;+68&gt;: move s0,v0 # 假设递归回来后, s0 = v0 = 返回值，想象s0寄存器的作用是啥呀？（我在干嘛？|_・) 0x00401278 &lt;+72&gt;: lw v0,40(s8) # v0 = 40(s8) = 此时应该叫phase_4输入参数已经不合适了，要叫func4输入参数 0x0040127c &lt;+76&gt;: nop 0x00401280 &lt;+80&gt;: addiu v0,v0,-2 # v0 -= 2 0x00401284 &lt;+84&gt;: move a0,v0 # a0 = v0 0x00401288 &lt;+88&gt;: jal 0x401230 &lt;func4&gt; # a0是参数寄存器，也就是说又递归去了。 0x0040128c &lt;+92&gt;: nop 0x00401290 &lt;+96&gt;: addu v0,s0,v0 # 然后把两个返回值加起来，可以得到递归程序了：int func4(int a0){ if(a0&lt;2) return 1; return func4(a0-1) + func4(a0-2);}# 也就是求斐波那契数列的第a0项 0x00401294 &lt;+100&gt;: b 0x4012a0 &lt;func4+112&gt; 0x00401298 &lt;+104&gt;: nop 0x0040129c &lt;+108&gt;: li v0,1 # 情况①：把v0=1，应该是作返回值？ 0x004012a0 &lt;+112&gt;: move sp,s8 # 下面就是收栈返回了，情况①可以返回phase_4，那就先回去看看吧，爆了再回来(#^.^#) 0x004012a4 &lt;+116&gt;: lw ra,36(sp) 0x004012a8 &lt;+120&gt;: lw s8,32(sp) 0x004012ac &lt;+124&gt;: lw s0,28(sp) 0x004012b0 &lt;+128&gt;: addiu sp,sp,40 0x004012b4 &lt;+132&gt;: jr ra 0x004012b8 &lt;+136&gt;: nopEnd of assembler dump.# func4是求斐波那契数列第n项(从0开始)，那么现在第几项=13，答案是固定的6读入 %d第四关答案：一个大于0的参数6Phase_512345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182Dump of assembler code for function phase_5: 0x004013e8 &lt;+0&gt;: addiu sp,sp,-72 0x004013ec &lt;+4&gt;: sw ra,68(sp) 0x004013f0 &lt;+8&gt;: sw s8,64(sp) 0x004013f4 &lt;+12&gt;: move s8,sp 0x004013f8 &lt;+16&gt;: sw a0,72(s8) 0x004013fc &lt;+20&gt;: lw a0,72(s8) 0x00401400 &lt;+24&gt;: jal 0x401c78 &lt;string_length&gt; # 看到这里，似乎要读入一串东西，然后取长度什么的 0x00401404 &lt;+28&gt;: nop 0x00401408 &lt;+32&gt;: move v1,v0 # v1 = v0 = 函数返回值 = 输入字符串的长度 0x0040140c &lt;+36&gt;: li v0,6 # v0 = 6 0x00401410 &lt;+40&gt;: beq v1,v0,0x401420 &lt;phase_5+56&gt; # 输入串长度=6的话就去+56行否则Boom 0x00401414 &lt;+44&gt;: nop 0x00401418 &lt;+48&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x0040141c &lt;+52&gt;: nop 0x00401420 &lt;+56&gt;: sw zero,24(s8) # 24(s8) = 0 0x00401424 &lt;+60&gt;: b 0x4014a8 &lt;phase_5+192&gt; # 跳+192行 0x00401428 &lt;+64&gt;: nop 0x0040142c &lt;+68&gt;: lw v0,24(s8) # 取v0 = 24(s8) = 循环计次量 0x00401430 &lt;+72&gt;: lw v1,24(s8) # 取v1 = 24(s8) = 循环计次量 0x00401434 &lt;+76&gt;: lw a0,72(s8) # 取a0 = 输出字符串的首位char的地址（x *($s8+72)可以看到） 0x00401438 &lt;+80&gt;: nop 0x0040143c &lt;+84&gt;: addu v1,a0,v1 # v1 = str[0]+v1 0x00401440 &lt;+88&gt;: lb v1,0(v1) # 读入v1的值， 此时v1应该是地址，那么a0也是地址，上一步中v1就是下标偏移量，lb是读末八位进来，也就是v1=str[i]的ASCII码 # 上面几句应该就是第几次循环读下标为几的char 0x00401444 &lt;+92&gt;: nop 0x00401448 &lt;+96&gt;: andi v1,v1,0xff # v1 &amp;= 0xff 11111111 0x0040144c &lt;+100&gt;: andi v1,v1,0xf # v1 &amp;= 0xf 00001111 # 上面两步就是消掉这个char前4位 0x00401450 &lt;+104&gt;: sll v0,v0,0x2 # v0 *= 4 0x00401454 &lt;+108&gt;: addiu a0,s8,24 # a0 = s8+24是一个地址 0x00401458 &lt;+112&gt;: addu v0,a0,v0 # v0 = a0+v0循环计次量*4后的东西 0x0040145c &lt;+116&gt;: sw v1,12(v0) # 再令12(v0) = v1 = str[i]消掉前4位 0x00401460 &lt;+120&gt;: lw a0,24(s8) # a0 = 循环计次量 0x00401464 &lt;+124&gt;: lw v0,24(s8) # v0 = 循环计次量 0x00401468 &lt;+128&gt;: nop 0x0040146c &lt;+132&gt;: sll v0,v0,0x2 # a0 *= 4 0x00401470 &lt;+136&gt;: addiu v1,s8,24 0x00401474 &lt;+140&gt;: addu v0,v1,v0 0x00401478 &lt;+144&gt;: lw v1,12(v0) 0x0040147c &lt;+148&gt;: lui v0,0x41 0x00401480 &lt;+152&gt;: addiu v0,v0,12524 0x00401484 &lt;+156&gt;: addu v0,v1,v0 0x00401488 &lt;+160&gt;: lb v1,0(v0) 0x0040148c &lt;+164&gt;: addiu v0,s8,24 0x00401490 &lt;+168&gt;: addu v0,v0,a0 0x00401494 &lt;+172&gt;: sb v1,4(v0) 0x00401498 &lt;+176&gt;: lw v0,24(s8) 0x0040149c &lt;+180&gt;: nop 0x004014a0 &lt;+184&gt;: addiu v0,v0,1 0x004014a4 &lt;+188&gt;: sw v0,24(s8) 0x004014a8 &lt;+192&gt;: lw v0,24(s8) # v0 = 24(s8)，就在这里打断点吧 0x004014ac &lt;+196&gt;: nop 0x004014b0 &lt;+200&gt;: slti v0,v0,6 # v0 = (v0&lt;6) 0x004014b4 &lt;+204&gt;: bnez v0,0x40142c &lt;phase_5+68&gt; # 小于6就去68行，猜测，上面v0&lt;6，所以应该是一个循环结构24(s8)是计次变量，循环6次，然后出来，先进去看循环结构 0x004014b8 &lt;+208&gt;: nop 0x004014bc &lt;+212&gt;: sb zero,34(s8) # 令34(s8)=0 0x004014c0 &lt;+216&gt;: addiu v0,s8,28 # v0 = s8+28 ， 是一个地址 0x004014c4 &lt;+220&gt;: move a0,v0 # a0 0x004014c8 &lt;+224&gt;: lui v0,0x40 0x004014cc &lt;+228&gt;: addiu a1,v0,10160 0x004014d0 &lt;+232&gt;: jal 0x401cf8 &lt;strings_not_equal&gt; # 进入判断生成字符串和常数字符串“giants”相等不，gdb试探， 0x004014d4 &lt;+236&gt;: nop 0x004014d8 &lt;+240&gt;: beqz v0,0x4014e8 &lt;phase_5+256&gt; 0x004014dc &lt;+244&gt;: nop 0x004014e0 &lt;+248&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x004014e4 &lt;+252&gt;: nop 0x004014e8 &lt;+256&gt;: move sp,s8 0x004014ec &lt;+260&gt;: lw ra,68(sp) 0x004014f0 &lt;+264&gt;: lw s8,64(sp) 0x004014f4 &lt;+268&gt;: addiu sp,sp,72 0x004014f8 &lt;+272&gt;: jr ra 0x004014fc &lt;+276&gt;: nopEnd of assembler dump.输入：%s长度为6，是一个密文原文giants，要求现在给出密文，映射表如下（小写应该也可以）A-&gt;s，B-&gt;r,C-&gt;v,D-&gt;e,E-&gt;a,F-&gt;w,G-&gt;h,H-&gt;o,I-&gt;b,J-&gt;p,K-&gt;n,L-&gt;u,M-&gt;t,N-&gt;f,O-&gt;g,P-&gt;iQ-&gt;s,R-&gt;r,S-&gt;v,T-&gt;e,U-&gt;a,V-&gt;w,W-&gt;h,X-&gt;o,Y-&gt;b,Z-&gt;p，循环咯故其中一个答案为：OPUKMQPhase_6123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261Dump of assembler code for function phase_6: 0x00401500 &lt;+0&gt;: addiu sp,sp,-96 0x00401504 &lt;+4&gt;: sw ra,92(sp) 0x00401508 &lt;+8&gt;: sw s8,88(sp) 0x0040150c &lt;+12&gt;: move s8,sp 0x00401510 &lt;+16&gt;: lui gp,0x42 0x00401514 &lt;+20&gt;: addiu gp,gp,-20080 0x00401518 &lt;+24&gt;: sw gp,16(sp) 0x0040151c &lt;+28&gt;: sw a0,96(s8) 0x00401520 &lt;+32&gt;: lui v0,0x41 0x00401524 &lt;+36&gt;: addiu v0,v0,12592 0x00401528 &lt;+40&gt;: sw v0,32(s8) 0x0040152c &lt;+44&gt;: addiu v0,s8,36 0x00401530 &lt;+48&gt;: lw a0,96(s8) 0x00401534 &lt;+52&gt;: move a1,v0 0x00401538 &lt;+56&gt;: jal 0x401ba8 &lt;read_six_numbers&gt; 0x0040153c &lt;+60&gt;: nop 0x00401540 &lt;+64&gt;: lw gp,16(s8) 0x00401544 &lt;+68&gt;: sw zero,28(s8) # 令28(s8) = 0，猜测是循环计次变量 0x00401548 &lt;+72&gt;: b 0x40163c &lt;phase_6+316&gt; # 到+316行 0x0040154c &lt;+76&gt;: nop 0x00401550 &lt;+80&gt;: lw v0,28(s8) # v0 = i 0x00401554 &lt;+84&gt;: nop 0x00401558 &lt;+88&gt;: sll v0,v0,0x2 # v0 *= 4 0x0040155c &lt;+92&gt;: addiu v1,s8,24 # v1 = s8+24 地址 0x00401560 &lt;+96&gt;: addu v0,v1,v0 0x00401564 &lt;+100&gt;: lw v0,12(v0) # 再算上这个12，本质从36开始取，取num[i]到v0 0x00401568 &lt;+104&gt;: nop 0x0040156c &lt;+108&gt;: slti v0,v0,7 # v0=(num[i]&lt;7) 0x00401570 &lt;+112&gt;: beqz v0,0x40159c &lt;phase_6+156&gt; # 当num[i]&gt;=7就跳+156行爆炸，所以六个数都要小于7 0x00401574 &lt;+116&gt;: nop 0x00401578 &lt;+120&gt;: lw v0,28(s8) # v0 = 循环计次量i 0x0040157c &lt;+124&gt;: nop 0x00401580 &lt;+128&gt;: sll v0,v0,0x2 # v0 *= 4 0x00401584 &lt;+132&gt;: addiu v1,s8,24 0x00401588 &lt;+136&gt;: addu v0,v1,v0 0x0040158c &lt;+140&gt;: lw v0,12(v0) # 再算上这个12，本质从36开始取，取num[i]到v0 0x00401590 &lt;+144&gt;: nop 0x00401594 &lt;+148&gt;: bgtz v0,0x4015a8 &lt;phase_6+168&gt; # 判断是否大于0，大于就跳+168或者就下一行爆炸，到这里得到了六个数都是[1,6]间的数 0x00401598 &lt;+152&gt;: nop 0x0040159c &lt;+156&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x004015a0 &lt;+160&gt;: nop 0x004015a4 &lt;+164&gt;: lw gp,16(s8) 0x004015a8 &lt;+168&gt;: lw v0,28(s8) # v0 = 循环计次量i 0x004015ac &lt;+172&gt;: nop 0x004015b0 &lt;+176&gt;: addiu v0,v0,1 # v0++ 0x004015b4 &lt;+180&gt;: sw v0,24(s8) # 令24(s8) = v0,好像也是计次变量，但从1开始 0x004015b8 &lt;+184&gt;: b 0x401618 &lt;phase_6+280&gt; # 跳 0x004015bc &lt;+188&gt;: nop 0x004015c0 &lt;+192&gt;: lw v0,28(s8) # v0 = 循环计次量i 0x004015c4 &lt;+196&gt;: nop 0x004015c8 &lt;+200&gt;: sll v0,v0,0x2 # v0 *= 2 0x004015cc &lt;+204&gt;: addiu v1,s8,24 0x004015d0 &lt;+208&gt;: addu v0,v1,v0 0x004015d4 &lt;+212&gt;: lw v1,12(v0) # 上面几条就是取v1 = num[i] 0x004015d8 &lt;+216&gt;: lw v0,24(s8) # v0 = 24(s8) 这是啥，上次的i，也就是i-1 0x004015dc &lt;+220&gt;: nop 0x004015e0 &lt;+224&gt;: sll v0,v0,0x2 0x004015e4 &lt;+228&gt;: addiu a0,s8,24 0x004015e8 &lt;+232&gt;: addu v0,a0,v0 0x004015ec &lt;+236&gt;: lw v0,12(v0) # 取v0 = num[24(s8)] 0x004015f0 &lt;+240&gt;: nop 0x004015f4 &lt;+244&gt;: bne v1,v0,0x401608 &lt;phase_6+264&gt; # 两个不相等的时候跳过炸弹，现在的意思是相邻两个不相等蛤? 0x004015f8 &lt;+248&gt;: nop 0x004015fc &lt;+252&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00401600 &lt;+256&gt;: nop 0x00401604 &lt;+260&gt;: lw gp,16(s8) 0x00401608 &lt;+264&gt;: lw v0,24(s8) # v0 = 24(s8) 0x0040160c &lt;+268&gt;: nop 0x00401610 &lt;+272&gt;: addiu v0,v0,1 # v0++ 0x00401614 &lt;+276&gt;: sw v0,24(s8) # 24(s8) = v0 0x00401618 &lt;+280&gt;: lw v0,24(s8) # 蛤？好像是双循环，i=0-&gt;5,j=i+1-&gt;5，使得六个数互不相等 0x0040161c &lt;+284&gt;: nop 0x00401620 &lt;+288&gt;: slti v0,v0,6 # v0 = (循环计次量i&lt;6) 0x00401624 &lt;+292&gt;: bnez v0,0x4015c0 &lt;phase_6+192&gt; # 若v0!=0就到+192行 0x00401628 &lt;+296&gt;: nop 0x0040162c &lt;+300&gt;: lw v0,28(s8) 0x00401630 &lt;+304&gt;: nop 0x00401634 &lt;+308&gt;: addiu v0,v0,1 0x00401638 &lt;+312&gt;: sw v0,28(s8) 0x0040163c &lt;+316&gt;: lw v0,28(s8) # v0 = 28(s8) = 循环计次变量 0x00401640 &lt;+320&gt;: nop 0x00401644 &lt;+324&gt;: slti v0,v0,6 # 从0~5，共6次 0x00401648 &lt;+328&gt;: bnez v0,0x401550 &lt;phase_6+80&gt; # 进入循环体 0x0040164c &lt;+332&gt;: nop 0x00401650 &lt;+336&gt;: sw zero,28(s8) # 从上一个双重循环出来，28(s8)=0 0x00401654 &lt;+340&gt;: b 0x4016f8 &lt;phase_6+504&gt; # 跳到+504 0x00401658 &lt;+344&gt;: nop 0x0040165c &lt;+348&gt;: lui v0,0x41 # v0 = 0x41 0x00401660 &lt;+352&gt;: addiu v0,v0,12592 # v0 += 12592 0x00401664 &lt;+356&gt;: sw v0,32(s8) # 32(s8) = v0 此时发现32(s8)是node1的指针 0x00401668 &lt;+360&gt;: li v0,1 # v0 = 1 0x0040166c &lt;+364&gt;: sw v0,24(s8) # 24(s8) = v0 0x00401670 &lt;+368&gt;: b 0x40169c &lt;phase_6+412&gt; # 进入，应该是第二重循环了 0x00401674 &lt;+372&gt;: nop # ------------------------------这一部分是链表指针后移, 32(s8)是current指针 0x00401678 &lt;+376&gt;: lw v0,32(s8) # v0=32(s8) node1的地址(x *(*($s8+32))) 0x0040167c &lt;+380&gt;: nop 0x00401680 &lt;+384&gt;: lw v0,8(v0) # v0=8(v0) node2的地址 0x00401684 &lt;+388&gt;: nop 0x00401688 &lt;+392&gt;: sw v0,32(s8) # node1的地址指向node2 # ------------------------------这一部分是链表指针后移, 32(s8)是current指针 0x0040168c &lt;+396&gt;: lw v0,24(s8) # v0 = 24(s8) 0x00401690 &lt;+400&gt;: nop 0x00401694 &lt;+404&gt;: addiu v0,v0,1 # v0++了 0x00401698 &lt;+408&gt;: sw v0,24(s8) # 24(s8) = v0 0x0040169c &lt;+412&gt;: lw v0,28(s8) # v0 = 28(s8) 外层循环变量 0x004016a0 &lt;+416&gt;: nop 0x004016a4 &lt;+420&gt;: sll v0,v0,0x2 # v0 *= 4 0x004016a8 &lt;+424&gt;: addiu v1,s8,24 0x004016ac &lt;+428&gt;: addu v0,v1,v0 0x004016b0 &lt;+432&gt;: lw v1,12(v0) # 意思是取36(s8)开始的即输入的第24(s8)个参数到v1 0x004016b4 &lt;+436&gt;: lw v0,24(s8) # 取v0 = 24(s8) 0x004016b8 &lt;+440&gt;: nop 0x004016bc &lt;+444&gt;: slt v0,v0,v1 # v0 = (num[j] &lt; num[i]) 0x004016c0 &lt;+448&gt;: bnez v0,0x401678 &lt;phase_6+376&gt; # 上式满足的话进入+376行 0x004016c4 &lt;+452&gt;: nop 0x004016c8 &lt;+456&gt;: lw v0,28(s8) # v0 = 28(s8) , 外层循环 0x004016cc &lt;+460&gt;: nop 0x004016d0 &lt;+464&gt;: sll v0,v0,0x2 # v0 *= 2 0x004016d4 &lt;+468&gt;: addiu v1,s8,24 0x004016d8 &lt;+472&gt;: addu v0,v1,v0 0x004016dc &lt;+476&gt;: lw v1,32(s8) # 取v1 = node的地址 0x004016e0 &lt;+480&gt;: nop 0x004016e4 &lt;+484&gt;: sw v1,36(v0) # 60之后(s8) = node的地址 0x004016e8 &lt;+488&gt;: lw v0,28(s8) # v0 = 28(s8) = i 0x004016ec &lt;+492&gt;: nop 0x004016f0 &lt;+496&gt;: addiu v0,v0,1 # v0++ 0x004016f4 &lt;+500&gt;: sw v0,28(s8) # 保存 0x004016f8 &lt;+504&gt;: lw v0,28(s8) # v0 = 28(s8) 0x004016fc &lt;+508&gt;: nop 0x00401700 &lt;+512&gt;: slti v0,v0,6 # 也是循环6次 0x00401704 &lt;+516&gt;: bnez v0,0x40165c &lt;phase_6+348&gt; # 进入循环体 0x00401708 &lt;+520&gt;: nop 0x0040170c &lt;+524&gt;: lw v0,60(s8) # 拿链表指针数组[0]到v0 0x00401710 &lt;+528&gt;: nop 0x00401714 &lt;+532&gt;: sw v0,32(s8) # 存到32(s8) 0x00401718 &lt;+536&gt;: li v0,1 # v0=1 0x0040171c &lt;+540&gt;: sw v0,28(s8) # 28(s8) = v0 = 1 0x00401720 &lt;+544&gt;: b 0x40177c &lt;phase_6+636&gt; # 又要进循环了 0x00401724 &lt;+548&gt;: nop 0x00401728 &lt;+552&gt;: lw v0,28(s8) # v0=i 0x0040172c &lt;+556&gt;: nop 0x00401730 &lt;+560&gt;: sll v0,v0,0x2 # v0 *= 4 0x00401734 &lt;+564&gt;: addiu v1,s8,24 0x00401738 &lt;+568&gt;: addu v0,v1,v0 0x0040173c &lt;+572&gt;: lw v1,36(v0) # v1 = 链表指针数组[i] 0x00401740 &lt;+576&gt;: lw v0,32(s8) # v0 = current 0x00401744 &lt;+580&gt;: nop 0x00401748 &lt;+584&gt;: sw v1,8(v0) # v0.next = v1 ------重点 0x0040174c &lt;+588&gt;: lw v0,28(s8) # v0 = i 0x00401750 &lt;+592&gt;: nop 0x00401754 &lt;+596&gt;: sll v0,v0,0x2 0x00401758 &lt;+600&gt;: addiu v1,s8,24 0x0040175c &lt;+604&gt;: addu v0,v1,v0 0x00401760 &lt;+608&gt;: lw v0,36(v0) # v0 = 链表指针数组[i] 0x00401764 &lt;+612&gt;: nop 0x00401768 &lt;+616&gt;: sw v0,32(s8) # 32(s8) = 链表指针数组[i] 0x0040176c &lt;+620&gt;: lw v0,28(s8) # v0 = i 0x00401770 &lt;+624&gt;: nop 0x00401774 &lt;+628&gt;: addiu v0,v0,1 0x00401778 &lt;+632&gt;: sw v0,28(s8) # v0++存入 0x0040177c &lt;+636&gt;: lw v0,28(s8) 0x00401780 &lt;+640&gt;: nop 0x00401784 &lt;+644&gt;: slti v0,v0,6 0x00401788 &lt;+648&gt;: bnez v0,0x401728 &lt;phase_6+552&gt; # 正式进循环 # 所以上循环作用就是，链表重排 0x0040178c &lt;+652&gt;: nop 0x00401790 &lt;+656&gt;: lw v0,32(s8) # v0 = 32(s8) = 尾节点(最后留的指针) 0x00401794 &lt;+660&gt;: nop 0x00401798 &lt;+664&gt;: sw zero,8(v0) # 尾节点.next = 0 0x0040179c &lt;+668&gt;: lw v0,60(s8) # v0 = 头节点 0x004017a0 &lt;+672&gt;: nop 0x004017a4 &lt;+676&gt;: sw v0,32(s8) # 32(s8) = 头节点指针 0x004017a8 &lt;+680&gt;: sw zero,28(s8) # i = 0 0x004017ac &lt;+684&gt;: b 0x401878 &lt;phase_6+888&gt; # 进+888行 0x004017b0 &lt;+688&gt;: nop 0x004017b4 &lt;+692&gt;: lw v0,-32660(gp) # v0为学号第一位 0x004017b8 &lt;+696&gt;: nop 0x004017bc &lt;+700&gt;: lw v0,44(v0) # v0=学号第12位 0x004017c0 &lt;+704&gt;: nop 0x004017c4 &lt;+708&gt;: andi v0,v0,0x1 # 学号第十二位&amp;=1 0x004017c8 &lt;+712&gt;: andi v0,v0,0xff # 学号第十二位&amp;=255 0x004017cc &lt;+716&gt;: beqz v0,0x401818 &lt;phase_6+792&gt; # 我学号最后一位为0，然后进去了，应该是分支，不同分支不同要求 0x004017d0 &lt;+720&gt;: nop 0x004017d4 &lt;+724&gt;: lw v0,32(s8) 0x004017d8 &lt;+728&gt;: nop 0x004017dc &lt;+732&gt;: lw v1,0(v0) 0x004017e0 &lt;+736&gt;: lw v0,32(s8) 0x004017e4 &lt;+740&gt;: nop 0x004017e8 &lt;+744&gt;: lw v0,8(v0) 0x004017ec &lt;+748&gt;: nop 0x004017f0 &lt;+752&gt;: lw v0,0(v0) 0x004017f4 &lt;+756&gt;: nop 0x004017f8 &lt;+760&gt;: slt v0,v1,v0 0x004017fc &lt;+764&gt;: beqz v0,0x401854 &lt;phase_6+852&gt; 0x00401800 &lt;+768&gt;: nop 0x00401804 &lt;+772&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00401808 &lt;+776&gt;: nop 0x0040180c &lt;+780&gt;: lw gp,16(s8) 0x00401810 &lt;+784&gt;: b 0x401854 &lt;phase_6+852&gt; 0x00401814 &lt;+788&gt;: nop 0x00401818 &lt;+792&gt;: lw v0,32(s8) # 取链表指针数组头 0x0040181c &lt;+796&gt;: nop 0x00401820 &lt;+800&gt;: lw v1,0(v0) # v1 = 当前节点内容 0x00401824 &lt;+804&gt;: lw v0,32(s8) 0x00401828 &lt;+808&gt;: nop 0x0040182c &lt;+812&gt;: lw v0,8(v0) # v0 = 链表指针数组头.next的地址 0x00401830 &lt;+816&gt;: nop 0x00401834 &lt;+820&gt;: lw v0,0(v0) # v0 = 链表指针数组头.next的内容了 0x00401838 &lt;+824&gt;: nop 0x0040183c &lt;+828&gt;: slt v0,v0,v1 # 要求 v0 &gt;= v1， 肉眼看感觉很费脑筋啊，display *(*($s8+32)) 和 display *(*( (*($s8+32))+8 ))一下，第二个变量一直是725应该我的分支要求，现在就是看第一个怎么得来的 0x00401840 &lt;+832&gt;: beqz v0,0x401854 &lt;phase_6+852&gt; # 这里爆炸 0x00401844 &lt;+836&gt;: nop 0x00401848 &lt;+840&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x0040184c &lt;+844&gt;: nop 0x00401850 &lt;+848&gt;: lw gp,16(s8) 0x00401854 &lt;+852&gt;: lw v0,32(s8) # v0 = 取链表指针数组头的地址 0x00401858 &lt;+856&gt;: nop 0x0040185c &lt;+860&gt;: lw v0,8(v0) # v0 = 取链表指针数组头.next的地址 0x00401860 &lt;+864&gt;: nop 0x00401864 &lt;+868&gt;: sw v0,32(s8) # 存到32(s8) 0x00401868 &lt;+872&gt;: lw v0,28(s8) 0x0040186c &lt;+876&gt;: nop 0x00401870 &lt;+880&gt;: addiu v0,v0,1 0x00401874 &lt;+884&gt;: sw v0,28(s8) 0x00401878 &lt;+888&gt;: lw v0,28(s8) # 又一个循环 0x0040187c &lt;+892&gt;: nop 0x00401880 &lt;+896&gt;: slti v0,v0,5 # 这一次是从[0~5)，4次 0x00401884 &lt;+900&gt;: bnez v0,0x4017b4 &lt;phase_6+692&gt; # 这一循环是判重排链表非递减序 0x00401888 &lt;+904&gt;: nop 0x0040188c &lt;+908&gt;: move sp,s8 0x00401890 &lt;+912&gt;: lw ra,92(sp) 0x00401894 &lt;+916&gt;: lw s8,88(sp) 0x00401898 &lt;+920&gt;: addiu sp,sp,96 0x0040189c &lt;+924&gt;: jr ra 0x004018a0 &lt;+928&gt;: nopEnd of assembler dump.读入:%d %d %d %d %d %d要求链表重排链表节点node1~6 大小分别是 253,725,301,997,212,432最后的顺序是node5_node1_node3_node6_node2_node4要求重排成这个样子重排程序中，对于第i个数，1~6个数中有多少个小于num[i]，就取node几+1（因为执行了那么多次next()）那么第一个数应取node5，即执行4次next()，为5的时候有4个数小于5，第一个数取5剩下同理第六关答案为5 1 3 6 2 4secret_phase找到这个隐藏关卡，要在phase_defused里看到触发条件phase_defused探秘1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283Dump of assembler code for function phase_defused: 0x00402264 &lt;+0&gt;: addiu sp,sp,-120 0x00402268 &lt;+4&gt;: sw ra,116(sp) 0x0040226c &lt;+8&gt;: sw s8,112(sp) 0x00402270 &lt;+12&gt;: move s8,sp 0x00402274 &lt;+16&gt;: lui gp,0x42 0x00402278 &lt;+20&gt;: addiu gp,gp,-20080 0x0040227c &lt;+24&gt;: sw gp,16(sp) 0x00402280 &lt;+28&gt;: lui v0,0x41 0x00402284 &lt;+32&gt;: lw v1,12864(v0) 0x00402288 &lt;+36&gt;: li v0,6 0x0040228c &lt;+40&gt;: bne v1,v0,0x402374 &lt;phase_defused+272&gt; # 非第六关的完成，就直接跳272，否则继续 0x00402290 &lt;+44&gt;: nop 0x00402294 &lt;+48&gt;: lw v0,-32680(gp) 0x00402298 &lt;+52&gt;: nop 0x0040229c &lt;+56&gt;: addiu a0,v0,240 # 读入指针打到第三关（0 120 240） 0x004022a0 &lt;+60&gt;: lui v0,0x40 0x004022a4 &lt;+64&gt;: addiu v1,v0,10408 0x004022a8 &lt;+68&gt;: addiu v0,s8,104 0x004022ac &lt;+72&gt;: move a1,v1 0x004022b0 &lt;+76&gt;: move a2,v0 0x004022b4 &lt;+80&gt;: addiu v0,s8,24 0x004022b8 &lt;+84&gt;: move a3,v0 0x004022bc &lt;+88&gt;: lw v0,-32636(gp) 0x004022c0 &lt;+92&gt;: nop 0x004022c4 &lt;+96&gt;: move t9,v0 0x004022c8 &lt;+100&gt;: jalr t9 0x004022cc &lt;+104&gt;: nop 0x004022d0 &lt;+108&gt;: lw gp,16(s8) 0x004022d4 &lt;+112&gt;: move v1,v0 0x004022d8 &lt;+116&gt;: li v0,2 0x004022dc &lt;+120&gt;: bne v1,v0,0x402354 &lt;phase_defused+240&gt; # 判断读入了不等于两个参数，到+240行出函数 0x004022e0 &lt;+124&gt;: nop 0x004022e4 &lt;+128&gt;: addiu v0,s8,24 0x004022e8 &lt;+132&gt;: move a0,v0 0x004022ec &lt;+136&gt;: lui v0,0x40 0x004022f0 &lt;+140&gt;: addiu a1,v0,10416 0x004022f4 &lt;+144&gt;: jal 0x401cf8 &lt;strings_not_equal&gt; 0x004022f8 &lt;+148&gt;: nop 0x004022fc &lt;+152&gt;: lw gp,16(s8) 0x00402300 &lt;+156&gt;: bnez v0,0x402354 &lt;phase_defused+240&gt; # v0 = &lt;strings_not_equal&gt;返回值不等于0的话就跳过隐藏关，否则顺着下去+228就能进隐藏关 0x00402304 &lt;+160&gt;: nop 0x00402308 &lt;+164&gt;: lui v0,0x40 0x0040230c &lt;+168&gt;: addiu a0,v0,10432 0x00402310 &lt;+172&gt;: lw v0,-32712(gp) 0x00402314 &lt;+176&gt;: nop 0x00402318 &lt;+180&gt;: move t9,v0 0x0040231c &lt;+184&gt;: jalr t9 0x00402320 &lt;+188&gt;: nop 0x00402324 &lt;+192&gt;: lw gp,16(s8) 0x00402328 &lt;+196&gt;: lui v0,0x40 0x0040232c &lt;+200&gt;: addiu a0,v0,10472 0x00402330 &lt;+204&gt;: lw v0,-32712(gp) 0x00402334 &lt;+208&gt;: nop 0x00402338 &lt;+212&gt;: move t9,v0 0x0040233c &lt;+216&gt;: jalr t9 0x00402340 &lt;+220&gt;: nop 0x00402344 &lt;+224&gt;: lw gp,16(s8) 0x00402348 &lt;+228&gt;: jal 0x401990 &lt;secret_phase&gt; # 进入隐藏关 0x0040234c &lt;+232&gt;: nop 0x00402350 &lt;+236&gt;: lw gp,16(s8) 0x00402354 &lt;+240&gt;: lui v0,0x40 # 出phase_defused咯 0x00402358 &lt;+244&gt;: addiu a0,v0,10528 0x0040235c &lt;+248&gt;: lw v0,-32712(gp) 0x00402360 &lt;+252&gt;: nop 0x00402364 &lt;+256&gt;: move t9,v0 0x00402368 &lt;+260&gt;: jalr t9 0x0040236c &lt;+264&gt;: nop 0x00402370 &lt;+268&gt;: lw gp,16(s8) 0x00402374 &lt;+272&gt;: move sp,s8 0x00402378 &lt;+276&gt;: lw ra,116(sp) 0x0040237c &lt;+280&gt;: lw s8,112(sp) 0x00402380 &lt;+284&gt;: addiu sp,sp,120 0x00402384 &lt;+288&gt;: jr ra 0x00402388 &lt;+292&gt;: nopEnd of assembler dump.# 也就是说，在第6关完成时，会判断一下第4关是否读入了两个参数，找一下汇编源码常量，发现有&quot;%d %s&quot;没用过，还有常量$LC27&quot;austinpowers&quot;没用过第4关答案改为6 austinpowers在完成第6关时进入隐藏关卡正式进入secret_phase123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566Dump of assembler code for function secret_phase: 0x00401990 &lt;+0&gt;: addiu sp,sp,-40 0x00401994 &lt;+4&gt;: sw ra,36(sp) 0x00401998 &lt;+8&gt;: sw s8,32(sp) 0x0040199c &lt;+12&gt;: move s8,sp 0x004019a0 &lt;+16&gt;: lui gp,0x42 0x004019a4 &lt;+20&gt;: addiu gp,gp,-20080 0x004019a8 &lt;+24&gt;: sw gp,16(sp) 0x004019ac &lt;+28&gt;: jal 0x401fec &lt;read_line&gt; # 读一行 0x004019b0 &lt;+32&gt;: nop 0x004019b4 &lt;+36&gt;: lw gp,16(s8) 0x004019b8 &lt;+40&gt;: sw v0,28(s8) # 28(s8) = v0 0x004019bc &lt;+44&gt;: lw v0,28(s8) # v0 = 28(s8) 0x004019c0 &lt;+48&gt;: nop 0x004019c4 &lt;+52&gt;: move a0,v0 # a0 = v0 0x004019c8 &lt;+56&gt;: move a1,zero # a1 = 0 0x004019cc &lt;+60&gt;: li a2,10 # a2 = 10 0x004019d0 &lt;+64&gt;: lw v0,-32656(gp) # v0 = strtol的地址 0x004019d4 &lt;+68&gt;: nop 0x004019d8 &lt;+72&gt;: move t9,v0 0x004019dc &lt;+76&gt;: jalr t9 0x004019e0 &lt;+80&gt;: nop 0x004019e4 &lt;+84&gt;: lw gp,16(s8) 0x004019e8 &lt;+88&gt;: sw v0,24(s8) 0x004019ec &lt;+92&gt;: lw v0,24(s8) 0x004019f0 &lt;+96&gt;: nop 0x004019f4 &lt;+100&gt;: addiu v0,v0,-1 0x004019f8 &lt;+104&gt;: sltiu v0,v0,1001 0x004019fc &lt;+108&gt;: bnez v0,0x401a10 &lt;secret_phase+128&gt; # strtol的返回值-1之后保证小于1001，因为是unsgined，故输入是小于等于1001大于0的一个数字字符串 0x00401a00 &lt;+112&gt;: nop 0x00401a04 &lt;+116&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00401a08 &lt;+120&gt;: nop 0x00401a0c &lt;+124&gt;: lw gp,16(s8) 0x00401a10 &lt;+128&gt;: lui v0,0x41 # v0 = 0x41 0x00401a14 &lt;+132&gt;: addiu a0,v0,12676 # a0 指向对象为n1 0x00401a18 &lt;+136&gt;: lw a1,24(s8) # a1 = 输入字符串截取的前半部分数字 0x00401a1c &lt;+140&gt;: jal 0x4018a4 &lt;fun7&gt; # 进fun7 0x00401a20 &lt;+144&gt;: nop 0x00401a24 &lt;+148&gt;: lw gp,16(s8) 0x00401a28 &lt;+152&gt;: move v1,v0 # 从fun7回来，将返回值放到v1 0x00401a2c &lt;+156&gt;: li v0,7 0x00401a30 &lt;+160&gt;: beq v1,v0,0x401a44 &lt;secret_phase+180&gt; # 现在就是v1要==7的意思 0x00401a34 &lt;+164&gt;: nop 0x00401a38 &lt;+168&gt;: jal 0x4021f0 &lt;explode_bomb&gt; 0x00401a3c &lt;+172&gt;: nop 0x00401a40 &lt;+176&gt;: lw gp,16(s8) 0x00401a44 &lt;+180&gt;: lui v0,0x40 0x00401a48 &lt;+184&gt;: addiu a0,v0,10168 0x00401a4c &lt;+188&gt;: lw v0,-32712(gp) 0x00401a50 &lt;+192&gt;: nop 0x00401a54 &lt;+196&gt;: move t9,v0 0x00401a58 &lt;+200&gt;: jalr t9 0x00401a5c &lt;+204&gt;: nop 0x00401a60 &lt;+208&gt;: lw gp,16(s8) 0x00401a64 &lt;+212&gt;: jal 0x402264 &lt;phase_defused&gt; 0x00401a68 &lt;+216&gt;: nop 0x00401a6c &lt;+220&gt;: lw gp,16(s8) 0x00401a70 &lt;+224&gt;: move sp,s8 0x00401a74 &lt;+228&gt;: lw ra,36(sp) 0x00401a78 &lt;+232&gt;: lw s8,32(sp) 0x00401a7c &lt;+236&gt;: addiu sp,sp,40 0x00401a80 &lt;+240&gt;: jr ra 0x00401a84 &lt;+244&gt;: nopEnd of assembler dump.引入fun7看看什么时候返回值为71234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495Dump of assembler code for function fun7: 0x004018a4 &lt;+0&gt;: addiu sp,sp,-32 0x004018a8 &lt;+4&gt;: sw ra,28(sp) 0x004018ac &lt;+8&gt;: sw s8,24(sp) 0x004018b0 &lt;+12&gt;: move s8,sp 0x004018b4 &lt;+16&gt;: sw a0,32(s8) 0x004018b8 &lt;+20&gt;: sw a1,36(s8) # 36(s8) = a1 传参 0x004018bc &lt;+24&gt;: lw v0,32(s8) # v0 = 32(s8) = n1对象 0x004018c0 &lt;+28&gt;: nop 0x004018c4 &lt;+32&gt;: bnez v0,0x4018d8 &lt;fun7+52&gt; # v0 != null才跳+52 0x004018c8 &lt;+36&gt;: nop 0x004018cc &lt;+40&gt;: li v0,-1 # 返回值v0 = -1 0x004018d0 &lt;+44&gt;: b 0x401978 &lt;fun7+212&gt; # 跳+212行，212行是return # 这里的意思是若v0==null就返回-1 0x004018d4 &lt;+48&gt;: nop 0x004018d8 &lt;+52&gt;: lw v0,32(s8) # v0 = 32(s8) = n1对象 0x004018dc &lt;+56&gt;: nop 0x004018e0 &lt;+60&gt;: lw v1,0(v0) # v1 = v0的第一个成员变量 0x004018e4 &lt;+64&gt;: lw v0,36(s8) # v0 = 36(s8) = 传参 0x004018e8 &lt;+68&gt;: nop 0x004018ec &lt;+72&gt;: slt v0,v0,v1 # v0 &gt; v1 则 v0 = 1 0x004018f0 &lt;+76&gt;: beqz v0,0x401924 &lt;fun7+128&gt; # 传参 &lt;= v1就跳+128 0x004018f4 &lt;+80&gt;: nop 0x004018f8 &lt;+84&gt;: lw v0,32(s8) 0x004018fc &lt;+88&gt;: nop 0x00401900 &lt;+92&gt;: lw v0,4(v0) # v0的第二个成员变量 0x00401904 &lt;+96&gt;: nop 0x00401908 &lt;+100&gt;: move a0,v0 0x0040190c &lt;+104&gt;: lw a1,36(s8) 0x00401910 &lt;+108&gt;: jal 0x4018a4 &lt;fun7&gt; # 进入递归 0x00401914 &lt;+112&gt;: nop 0x00401918 &lt;+116&gt;: sll v0,v0,0x1 # 将fun7递归回来的返回值*2 0x0040191c &lt;+120&gt;: b 0x401978 &lt;fun7+212&gt; 0x00401920 &lt;+124&gt;: nop # 传参 &lt; v0的第一个成员变量，就递归fun7，从递归回来后进入212行，212行是return， # 传参 &lt; v0的第一个成员变量，就return fun7(v0的第二个成员变量)*2 0x00401924 &lt;+128&gt;: lw v0,32(s8) 0x00401928 &lt;+132&gt;: nop 0x0040192c &lt;+136&gt;: lw v1,0(v0) # v1 = v0的第一个成员变量 0x00401930 &lt;+140&gt;: lw v0,36(s8) # v0 = 36(s8) = 传参 0x00401934 &lt;+144&gt;: nop 0x00401938 &lt;+148&gt;: slt v0,v1,v0 # v1 &gt; v0 0x0040193c &lt;+152&gt;: beqz v0,0x401974 &lt;fun7+208&gt; # v1 &lt;= 传参就跳+208行，208行是return 0，结合从+76过来的条件，&lt;=和&gt;=就是等于 # v0的第一个成员变量==传参，就return 0 0x00401940 &lt;+156&gt;: nop 0x00401944 &lt;+160&gt;: lw v0,32(s8) 0x00401948 &lt;+164&gt;: nop 0x0040194c &lt;+168&gt;: lw v0,8(v0) 0x00401950 &lt;+172&gt;: nop 0x00401954 &lt;+176&gt;: move a0,v0 0x00401958 &lt;+180&gt;: lw a1,36(s8) 0x0040195c &lt;+184&gt;: jal 0x4018a4 &lt;fun7&gt; 0x00401960 &lt;+188&gt;: nop 0x00401964 &lt;+192&gt;: sll v0,v0,0x1 # v0 *= 2 0x00401968 &lt;+196&gt;: addiu v0,v0,1 # v0 + 1 0x0040196c &lt;+200&gt;: b 0x401978 &lt;fun7+212&gt; # 跳到212返回v0 0x00401970 &lt;+204&gt;: nop # 传参 &gt; v0的第一个成员变量，就return fun7(v0的第三个成员变量)*2+1 0x00401974 &lt;+208&gt;: move v0,zero # 返回值为0 0x00401978 &lt;+212&gt;: move sp,s8 0x0040197c &lt;+216&gt;: lw ra,28(sp) 0x00401980 &lt;+220&gt;: lw s8,24(sp) 0x00401984 &lt;+224&gt;: addiu sp,sp,32 0x00401988 &lt;+228&gt;: jr ra 0x0040198c &lt;+232&gt;: nopEnd of assembler dump.可以发现fun7是对一个搜索树(链表描述):这棵树从汇编源码中更易得到 36 8 50 6 22 45 1071 7 20 35 40 47 99 1001 左小右大，是二叉搜索树fun7翻译一下就是：int fun7(传参){ if(current==null) return -1; if(current==传参) return 0; else if(current&gt;传参) current=current.leftChild, return fun7(传参)*2; else current=current.rightChild, return fun7(传参)*2+1;}二叉搜索树的搜索节点算法，有节点返回路径，无节点返回-1比如搜索1001返回7，7的二进制是00000111，1代表往右子树，0代表往左子树，二进制从右往左数念h-1位（树的高度-1）就是&quot;右 右 右&quot;，代表从根到被搜索节点的路径。那么隐藏关卡答案就是：1001","link":"/CS/Solving-In-Binary-Bomb-Assigment/"},{"title":"关于阿瓦隆桌游（类狼人杀游戏）的碎碎念","text":"阿瓦隆 (Avalon) 是一款非常适合多人线下聚会场景的桌游（类狼人杀游戏）。前言&emsp;&emsp;我第一次玩狼人杀的契机是，我得知并觉得狼人杀是一个非常锻炼聆听他人/语言沟通/逻辑思维/佯装表达/头脑风暴/团队协作等能力的游戏。&emsp;&emsp;于是我开始有意识地去学着玩线上的狼人杀，然而我逐渐发现，狼人杀对玩家的要求还蛮高的，以我的能力（上述说的那几项），玩着吃力，并且游戏体验并没有特别的好。&emsp;&emsp;但是我始终觉得是有必要的，先不说狼人杀趣味性我能不能领会到，反而正是我学习基本规则和套路后，仍没有玩好玩得流畅，我才深刻地发现，在逻辑表达和聆听他人的能力方面，我还不太够。所以说明了这个游戏于我很合适，需要去玩。&emsp;&emsp;但是我知道，热爱有时候会让你事半功倍，痴迷狼人杀的玩家那么多应该不是没有道理的。于是决定先开始当一阵子云玩家，看知乎上毕导写的狼人杀攻略，看小破站上老骚豆腐的直播（让我粉上了豆腐），看 JY 大神在 Godlie 大杀四方。隐隐约约觉得自己感受到乐趣了。而终于让我有线下机会玩类狼人杀游戏 —— 阿瓦隆，并且感觉到乐趣，还是昨天 (๑*◡*๑)。First&emsp;&emsp;昨天和小伙伴去玩剧本杀后（那个本没之前的有意思，失望ed），时间还有就凑了局阿瓦隆。玩了一晚上阿瓦隆，真是欢乐+烧脑，非常 nice。&emsp;&emsp;阿瓦隆作为 “类狼人杀游戏”，实际上它比狼人杀好玩，准确地说更适合线下玩耍，有以下几点：不会死人。即不会像狼人杀一样，玩家出局后再无游戏参与感，只能旁观，换句话说就是所有玩家都能一起参与到最后。没有工具人。不同于狼人杀中玩家拿到预言家牌，只需要当工具人完成上警报验人、表水争警徽、留警徽流等事情后就可以安然等着被刀（常规 10/12 人板子）。在阿瓦隆中，梅林需要藏住自己的身份，不需要裁判。可以找一位玩家负责天黑喊口令即可，不需要像狼人杀那样需要记录信息/判断阵营/宣布死亡。规则或道具可以更简单。狼人杀或更需要一些道具比如眼罩或面具或身份牌之类，因为其角色/技能啥的都愈加复杂，而阿瓦隆角色太简单，以至于拿扑克牌也能勉强玩 (*･ω-q) ？&emsp;&emsp;所以阿瓦隆非常适合线下朋友聚会玩，我们玩得就还挺欢乐/痛快的。那，阿瓦隆是没有缺点的吗？当然有：角色名字难记。如果像狼人杀一样主推代号的话（比如女巫和白狼王，有百分之多少玩家记得他们的名字是梅琳娜、沃丁），估计更吸引人。没有操纵感。之前在知乎看为什么狼人杀比阿瓦隆火，其中有一个回答就是说狼人/预言家/女巫/奇迹商人可以刀人/验人/救人/毒人/赠人，而阿瓦隆只能投票，所以狼人杀的火不关乎宣传/难度啥的，更多是有人性在里面。这个回答让我印象深刻。未完待续，等我多玩玩再来说说，嘻嘻…","link":"/Life/Thoughts-In-Avalon-Game/"},{"title":"编译原理-学习笔记","text":"编译原理…国科大的 PPT 真好看… i 了 i 了第一章 引论什么是编译程序翻译程序(Translator)：把某一种语言程序(称为源语言程序)等价地转换成另一种语言程序(称为目标语言程序)的程序编译程序(Compiler)：把某一种高级语言程序等价地转换成另一种低级语言程序(如汇编语言或机器语言程序)的程序 * 运行编译程序的计算机：宿主机 * 运行目标程序的计算机：目标机 * 根据用途和侧重，编译程序可分为： 诊断编译程序(Diagnostic Compiler) 优化编译程序(Optimizing Compiler) 交叉编译程序(Cross Compiler)：编译程序产生不同于其宿主机的目标代码 可变目标编译程序(Retargetable Compiler：不需要重写编译程序中与机器无关的部分。解释程序(Interpreter)：把源语言写的源程序作为输入，但不产生目标程序，而是边解释边执行源程序为什么要学习编译原理理解计算系统，注意不是计算机系统。设计计算系统计算思维 Computational Thinking)计算思维是运用计算机科学的基础概念去求解问题、设计系统和理解人类的行为，它包括了一系列广泛的计算机科学的思维方法计算思维和阅读、写作和算术一样，是21世纪每个人的基本技能，而不仅仅属于计算机科学家包括抽象自动化问题分解递归权衡保护、冗余、容错、纠错和恢复利用启发式推理来寻求解答在不确定情况下的规划、学习和调度编译过程词法分析输入源程序字符串，扫描哪些字符构成了标识符，哪些字符构成了常数依循的原则：构词规则描述工具：有限自动机12for i := 1 to 100 do基本字 标识符 赋值号 整常数 基本字 整常数 基本字语法分析在词法分析的基础上，根据语法规则把单词符号串分解成各类 语法单位(语法范畴)，如下图得到了一棵语法树。依循的原则：语法规则描述工具：上下文无关文法中间代码产生对各类语法单位按语言的语义进行初步翻译依循的原则：语义规则描述工具：属性文法中间代码：三元式、四元式，树，…优化对前阶段产生的中间代码进行加工变换，以期在最后阶段产生更高效的目标代码依循的原则：程序的等价变换原则比如下图的憨憨程序就可以被编译器优化得很优秀目标代码产生把中间代码变换成特定机器上的目标代码依赖于硬件系统结构和机器指令的含义目标代码三种形式汇编指令代码: 需要进行汇编绝对指令代码: 可直接运行可重新定位指令代码: 需要链接编译程序的结构编译程序总框出错处理发现源程序中的错误，把有关错误信息报告给用户语法错误源程序中不符合语法（或词法）规则的错误非法字符、括号不匹配、缺少；、…语义错误源程序中不符合语义规则的错误说明错误、作用域错误、类型不一致、…遍 (pass)所谓的 “遍”，就是对源程序或源程序的中间表示从头到尾扫描一遍编译程序的五个阶段，当然可以实现为五“遍”，也就是每个阶段都接受上一阶段的输出，然后完成本阶段的变换，生成本阶段完整的输出，每个阶段的输出都是源程序的一个完整表示，如一个完整的单词序列、一个完整的语法分析树、一个完整的中间代码表示、甚至是目标代码表示 等等阶段与遍是不同的概念一遍可以由若干段组成在实际工作中，从程序效率和软件设计的角度考虑，我们往往会把若干联系非常紧密的阶段，合成一遍处理，比如说我们通常把词法分析、语法分析、中间代码生成这三个阶段合成一遍处理。把词法分析和中间代码产生实现为一些子程序，也就是词法分析子程序或者是语义子程序，这两类子程序由语法分析模块来驱动或者调用。在这个过程中，语法分析起主导作用，在语法分析的驱动下，词法分析 语法分析和中间代码生成三个阶段穿插进行，当词法分析完成最后一个单词的识别的时候，整个分析树也就很快得到了，同时所有的语法单位的翻译也就完成了，三个阶段合成一遍完成一个阶段也可以分若干遍来完成有些情况下一个阶段也可以分若干遍来实现，优化就是这样的例子，通常来说优化这个阶段被分成了很多遍，比如说 可以先对中间代码扫描一遍识别程序的基本结构，再扫描一遍完成简单的优化，再扫描一遍完成循环的优化，有时循环优化还有可能分成很多遍编译前端和后端编译前端与源语言有关，如词法分析，语法分析，语义分析与中间代码产生，与机器无关的优化编译后端与目标机有关，与目标机有关的优化，目标代码产生带来的好处程序逻辑结构清晰优化更充分，有利于移植编译程序的生成工具：以汇编语言和机器语言为工具优点: 可以针对具体的机器，充分发挥计算机的系统功能；生成的程序效率高缺点: 程序难读、难写、易出错、难维护、生产的效率低以高级程序设计语言为工具程序易读、易理解、容易维护、生产的效率高 上图表示已经有了 I 这种高级语言的实现和编译器，用 I 语言实现将 S 语言编译为 T 语言的编译器高级语言书写：利用有的某种语言的编译程序实现另一种语言的编译程序下图表示利用 P1 编译器，将 L1 语言写的 P2 编译器，编译成 A 代码写的 P2 编译器移植方法：把一种机器上的编译程序移植到另一种机器上，跨机器自编译方式你通过低级语言实现 L 语言的一部分 L1，然后拿 L1 和低级语言去实现 L1+L2，然后拿 L1+L2 去实现 L1+L2+L3，依次类推。编译程序自动产生：编译程序-编译程序，也叫编译程序产生器，也叫编译程序书写系统LEX：词法分析程序产生器YACC：语法分析程序产生器第二章 高级程序设计语言定义与语法描述程序设计语言的定义语法：一组规则，用它可以形成和产生一个合式 (well-formed) 的程序词法规则：单词符号的形成规则单词符号是语言中具有独立意义的最基本结构一般包括：常数、标识符、基本字、算符、界符等描述工具：有限自动机语法规则：语法单位的形成规则语法单位通常包括：表达式、语句、分程序、过程、函数、程序等;描述工具：上下文无关文法例子：$E\\rightarrow i$：一个算术表达式可以由一个标识符构成；$E\\rightarrow E+E$：一个算术表达式可由两个算术表达式（也叫子表达式）通过 ‘+’ 号连接构成；$E\\rightarrow EE$：一个算术表达式可由两个算术表达式通过 ‘\\‘（星号，而不特指乘号）号连接构成；$E\\rightarrow (E)$：一个算术表达式外加括号，还是算术表达式；语法规则和词法规则定义了程序的形式结构定义语法单位的意义属于语义问题语义：一组规则，用它可以定义一个程序的意义描述方法自然语言描述二义性、隐藏错误和不完整性形式描述操作语义指称语义代数语义程序，本质上是描述一定数据的处理过程；程序语言的基本功能：描述数据和对数据的运算；程序的层次结构：静态绑定：发生在程序编译过程中间的绑定，包括变量声明、类型定义、函数定义动态绑定：发生在程序运行过程中间的绑定，包括 C++ 中的多态性虚函数表达式：表达式由运算量（也称操作数，即数据引用或函数调用）和算符（运算符，操作符）组成形式：中缀、前缀、后缀赋值语句A := B名字的左值：该名字代表的存储单元的地址名字的右值：该名字代表的存贮单元的内容C 语言中，a+5 只有右值没有左值，因为该值只能用在赋值号右边程序设计语言的描述上下文无关文法文法：描述语言的语法结构的形成规则如 He gave me a book. 这句自然语言的文法规则为： 相关概念：字母表：一个有穷字符集，记为 $\\sum $字母表中每个元素称为字符$\\sum$ 上的字（也叫字符串）是指由 $\\sum$ 中的字符所构成的一个有穷序列不包含任何字符的序列称为空字，记为 $\\varepsilon $用 $\\sum^※$ 表示 $\\sum$ 上的所有字的全体，包含空字 $ \\varepsilon $例如：设 $\\sum = {a, b}$，则 $\\sum^※ = {\\varepsilon, a, b,aa,ab,ba,bb,aaa,\\cdots }$$\\sum^※ $ 的子集 $U$ 和 $V$ 的连接（积）定义为 $UV = {\\alpha \\beta \\ | \\ \\alpha \\in U \\and \\beta \\in V} $例如：设 $U={a,aa}, V={b,bb}$，则 $UV ={ab,abb,aab,aabb}$，并且此时 $UV \\not = VU $$V$ 自身的 $n$ 次积记为 $V^n = \\underbrace{V\\cdots V}_{\\text{n个}} $$V^0={\\varepsilon}$$V^※ $ 是 $V$ 的闭包：$V^※ = V^0 \\cup V^1\\cup V^2\\cup V^3\\cup \\cdots $$V^+ $ 是 $V$ 的正规闭包： $V^+ = V V^※$正规闭包与闭包的区别：如果 V 中原来没有空字，那么闭包有空字，正规闭包没空字例如：设 $U={a,aa}$，那么 $U^※ = {\\varepsilon ,a,aa,aaa,aaaa,\\cdots }, U^+ = {a,aa,aaa,aaaa,\\cdots }$上下文无关文法：上下文无关文法 $ G$ 是一个四元组 $G=(V_T,V_N,S,P) $，其中$V_T$：终结符 (Terminal) 集合 (非空)不能再分解的$V_N$：非终结符 (Noterminal) 集合(非空)，且$V_T ∩ V_N=∅$能再分解，比如上图中的 “主语”、”谓语”非终结符可由终结符和非终结符构成$S$：文法的开始符号，$S∈V_N$是一个特殊的非终结符，它代表所定义的语言最终感兴趣的语法单位比如英语中的 “句子”，编程中的 “程序”$P$：产生式集合(有限)，每个产生式形式为$P→α， P∈V_N， α ∈ (V_T ∪ V_N)^※$上式读成 “P 定义为 α”，即左边的终结符 P，是被定义的句法单位，右边的 α 是构成这个句法单位的一种组合。$(V_T ∪ V_N)$ 代表终结符和非终结符组成的字符集合，再打上 * 做闭包，代表该集合中的符号组成的字的全体开始符 $S$ 至少必须在某个产生式的左部出现一次例如，定义只含 +, * 的算术表达式的文法：G=&lt; {i, +, *, (, )}, {E}, E, P &gt;，其中，P 由下列产生式组成：$E\\rightarrow i$$E\\rightarrow E+E$$E\\rightarrow E*E$$E\\rightarrow (E)$巴科斯范式：”-&gt;” 用 “::=” 来表示上下文无关文法约定 $\\begin{cases}P\\rightarrow \\alpha_1 \\ P\\rightarrow \\alpha_2\\\\cdots \\ P\\rightarrow \\alpha_n\\end{cases} \\overset{缩写为}{\\rightarrow} P\\rightarrow \\alpha_1 | \\alpha_2 |\\cdots |\\alpha_n$其中 “|” 读成 “或”，称 $\\alpha_1$ 为 $P$ 的一个候选式表示一个文法时，通常只给出开始符号和产生式例如，定义只含 +, * 的算术表达式的文法可以缩写为：$G(E) : E\\rightarrow i \\ |\\ E+E \\ | \\ E*E\\ |\\ (E) $文法与语言推导：定义：称 $\\alpha A\\beta$ 直接推出 $\\alpha \\gamma \\beta$，即 $\\alpha A\\beta \\Rightarrow \\alpha \\gamma \\beta$ ，仅当 $A\\rightarrow \\gamma $ 是一个产生式，且 $\\alpha, \\beta \\in (V_T\\cup V_n)^※$如果$α_1 \\Rightarrow α_2 \\Rightarrow … \\Rightarrow α_n$，则我们称这个序列是从 $α_1$ 到 $α_n$ 的一个推导。若存在一个从 $α_1$ 到$α_n$ 的推导，则称 $α_1$ 可以推导出 $α_n $ 。对文法 $G(E) : E\\rightarrow i \\ |\\ E+E \\ | \\ E*E\\ |\\ (E) $，则 $E\\Rightarrow (E)\\Rightarrow (E+E)\\Rightarrow (i+E)\\Rightarrow (i+i)$称 $\\alpha_1 \\overset{*}{\\Rightarrow} \\alpha_n$ 从 $\\alpha_1$ 经过 0 步或若干步推出 $\\alpha_n$称 $\\alpha_1 \\overset{+}{\\Rightarrow} \\alpha_n$ 从 $\\alpha_1$ 经过 1 步或若干步推出 $\\alpha_n$$\\alpha_1 \\overset{*}{\\Rightarrow} \\alpha_n$ 即 $\\alpha=\\beta$ 或 $ \\alpha_1 \\overset{+}{\\Rightarrow} \\alpha_n$句型：假定 G 是一个文法， S 是它的开始符号，如果 $S \\overset{*}{\\Rightarrow} \\alpha_n$，则称 $\\alpha$ 是一个句型$S \\overset{*}{\\Rightarrow} S$，所以 S 也是句型句子：仅含终结符号的句型是一个句子。语言：文法 G 所产生的句子的全体是一个语言，记为 $L(G)$$L(G)= {\\alpha \\ | \\ S \\overset{+}{\\Rightarrow}\\alpha, \\alpha \\in V_T^※ }$，即 $L(G)$ 是由 $\\alpha$ 构成的集合， $\\alpha$ 属于终结符的闭包，且能由 S 推导得来。语法树与二义性最左推导和最右推导：从一个句型到另一个句型的推导往往不唯一$E+E \\Rightarrow i+E \\Rightarrow i+i \\ E+E \\Rightarrow E+i \\Rightarrow i+i $最左推导：任何一步 $\\alpha\\Rightarrow \\beta$ 都是对 $\\alpha $ 中的最左非终结符进行替换最右推导：任何一步 $\\alpha\\Rightarrow \\beta$ 都是对 $\\alpha$ 中的最右非终结符进行替换语法树：用一张图表示一个句型的推导，称为语法树一棵语法树是不同推导过程的共性抽象最左推导所对应的语法树的生长顺序是从上往下、从左往右二义性 ambiguity：文法的二义性：如果一个文法存在某个句子对应两棵不同的语法树，则说这个文法是二义的G(E)： E → i|E+E|E*E|(E) 是二义文法，对于 $i*i +i$ 可以画出两棵语法树语言的二义性：一个语言是二义的，如果对它不存在无二义的文法对于语言 L，可能存在 G 和 G’，使得 L(G)=L(G’)=L，有可能其中一个文法为二义的，另一个为无二义的自然语言的二义性举例 John saw Mary in a boat二义问题是不可判定问题，即不存在一个算法，它能在有限步骤内，确切地判定一个文法是否是二义的可以找到一组无二义文法的充分条件形式语言鸟瞰乔姆斯基于1956年建立形式语言体系，他把文法分成四种类型：0，1，2，3型与上下文无关文法一样，它们都由四部分组成，但对产生式的限制有所不同0 型（短语文法，图灵机）：产生式形如：$\\alpha \\rightarrow \\beta$其中：$\\alpha \\in (V_T \\cup V_N)^※ $ 且至少含有一个非终结符；$\\beta \\in(V_T\\cup V_N)^※$乔姆斯基文法体系中，最通用，也是描述能力最强、最一般的文法，产生式的约束最弱1 型（上下文有关文法，线性界限自动机）:产生式形如：$\\alpha \\rightarrow \\beta$其中：$|\\alpha| \\le |\\beta|$，仅 $S\\rightarrow \\varepsilon $ 例外上下文有关文法非常复杂，等下会提到2 型(上下文无关文法，非确定下推自动机)：产生式形如： $A → β$其中：$A∈ V_N$；$β∈ (V_T ∪ V_N)^※$3 型 (正规文法，有限自动机)产生式形如： $A → αB $ 或 $A → α $，终结符要么没有要么出现在右式最右边（右线性文法其中： $α∈ V_T^※$；$A，B∈V_N^※$产生式形如： $A → Bα$ 或 $A → α$ （左线性文法其中： $α∈ V_T^※$；$A，B∈V_N$四种类型文法的描述能力：$L_5={a^nb^n\\ |\\ n≥1}$ 不能由正规文法产生，但可由上下文无关文法产生$G_5(S): S\\rightarrow aSb \\ | \\ ab$$L_6={a^nb^nc^n|n≥1}$不能由上下文无关文法产生，但可由上下文有关文法产生程序设计语言不是上下文无关语言，甚至不是上下文有关语言$L_7={αcα| α∈{a,b}^※}$不能由上下文无关文法产生，甚至连上下文有关文法也不能产生，只能由0型文法产生标识符引用。比如编程语言中要求使用的变量必须前面声明过过程调用过程中，“形-实参数的对应性”(如个数，顺序和类型一致性)对于现今程序设计语言，在编译程序中，仍然采用上下文无关文法来描述其语言结构 （上下文无关文法的成熟高效）第三章 词法分析词法分析器的设计词法分析器词法分析的任务：从左至右逐个字符地对源程序进行扫描，产生一个个单词符号词法分析器 (Lexical Analyzer)：扫描器(Scanner)执行词法分析的程序功能：输入源程序、输出单词符号单词符号的种类：基本字：如begin，repeat，for，…标识符：用来表示各种名字，如变量名、数组名和过程名常数：各种类型的常数运算符：+，-，*，/，…界符：逗号、分号、括号和空白词法分析器的输出：输出的单词符号的表示形式：&lt;单词种别， 单词自身的值&gt;单词种别通常用整数编码表示若一个种别只有一个单词符号，则种别编码就代表该单词符号。假定基本字、运算符和界符都是一符一种。若一个种别有多个单词符号，则对于每个单词符号，给出种别编码和自身的值。标识符单列一种；标识符自身的值表示成按机器字节划分的内部码常数按类型分种；常数的值则表示成标准的二进制形式词法分析器作为一个独立子程序：词法分析作为一个独立的阶段结构简洁、清晰和条理化，有利于集中考虑词法分析一些枝节问题但不一定不作为单独的一遍将其处理为一个子程序词法分析器的结构（分解的思想）：扫描缓冲区，分成两个半区互补使用，一个半区也即单词的最大长度超前搜索超前搜索：有些语言（FORTRAN）允许基本字作为标识符，比如 IF 作为数组名这给基本字的识别带来麻烦：IF(5.EQ.M)GOTO5 // 条件判断+跳转IF(5)=55 // 给数组赋值这需要超前搜索来确定基本字标识符识别、常数识别算符、界符的识别超前搜索又涉及到回退，十分麻烦现代高级语言的几点限制 —— 不必使用超前搜索：所有基本字都是保留字;用户不能用它们作自己的标识符基本字作为特殊的标识符来处理，使用保留字表如果基本字、标识符和常数(或标号)之间没有确定的运算符或界符作间隔，则必须使用一个空白符作间隔状态转换图状态转换图：状态转换图是一张有限方向图结点代表状态，用圆圈表示状态之间用箭弧连结，箭弧上的标记(字符)代表射出结状态下可能出现的输入字符或字符类一张转换图只包含有限个状态，其中有一个为初态，至少要有一个终态状态转换图可用于识别 (或接受) 一定的字符串若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于 α，则称α 被该状态转换图所识别(接受) 状态转换图的实现：变量 curState 用于保存现有的状态用二维数组表示状态图：stateTrans[state][ch]1234567891011curState = 初态GetChar();while( stateTrans[curState][ch] 有定义 ) { // 存在后继状态，读入、拼接 Concat(); // 转换入下一状态，读入下一字符 curState = stateTrans[curState][ch]; if curState 是终态 then 返回 strToken中的单词 GetChar();}正规表达式与有限自动机正规式和正规集正规式和正规集：正规集可以用正规式表示（正规式是表示正规集的一种方法）程序设计语言定义的合法的单词的集合都是正规集，每个正规集可以抽象成正规式来表示一个字集合是正规集当且仅当它能用正规式表示正规式和正规集的递归定义：对于给定的字母表 $\\sum$$\\varepsilon $ 和 $\\O $ 都是 $\\sum$ 上的正规式，它们所表示的正规集为 ${\\varepsilon }$ 和 $\\O$任何 a $\\in \\sum$ ，a 是 $\\sum$ 上的正规式，它所表示的正规集为 {a}假定 $e_1$ 和 $e_2$ 都是 $\\sum$ 上的正规式，它们所表示的正规集为 $L(e_1)$ 和 $L(e_2)$ ，则$(e_1|e_2)$ 为正规式，它所表示的正规集为 $L(e_1)\\cup L(e_2)$$(e_1·e_2)$ 为正规式，它所表示的正规集为 $L(e_1) L(e_2)$ （两个正规集的连接还是正规集）$(e_1)^※$ 为正规式，它所表示的正规集为 $(L(e_1))^※$ （一个正规集的闭包还是正规集）仅由有限次使用上述三步骤而定义的表达式才是 Σ 上的正规式，仅由这些正规式表示的字集才是Σ上的正规集。正规集的等价性：若两个正规式所表示的正规集相同，则称这两个正规式等价。如 b(ab)*=(ba)*b正规式的性质：e1|e2 = e2|e1 交换律e1 |(e2|e3) = (e1|e2)|e3 结合律e1(e2e3) = (e1e2)e3 结合律e1(e2|e3) = e1e2|e1e3 分配律(e2|e3)e1 = e2e1|e3 e1 分配律eε = εe = e e1e2 &lt;&gt; e2e1有限自动机确定有限自动机对状态图进行初始化定义 (描述)，得到确定有限自动机 (Deterministic Finite Automata， DFA)M 是一个五元式 $M=(S, \\sum, f, S_0, F)$ 其中S：有穷状态集$\\sum$ ：输入字母表 (有穷)f ：状态转换函数，为 $S\\times \\sum \\rightarrow S $ 的单值部分映射。$f(s,a)=s’$ 表示当现行状态为 s，输入字符为 a 时，状态转移到 s’。$S_0 \\in S$ 是唯一的一个初态$F\\subseteq S$：终态集 (可空)DFA表示为状态转换图假定DFA M含有m个状态和n个输入字符对应的状态转换图含有m个状态结点，每个结点顶多含有n条箭弧射出，且每条箭弧用Σ上的不同的输入字符来作标记对于Σ*中的任何字α，若存在一条从初态到某一终态的道路，且这条路上所有弧上的标记符连接成的字等于α，则称α为DFA M所识别(接收)DFA M所识别的字的全体记为L(M)非确定有限自动机 （NFA）定义：一个非确定有限自动机 (Nondeterministic Finite Automata, NFA) M一个五元式 $M=(S, \\sum, f, S_0, F)$ 其中S：有穷状态集$\\sum$ ：输入字母表 (有穷)f ：状态转换函数，为 $S\\times \\sum^※ \\rightarrow 2^S $ 的部分映射$f(S, \\alpha)=S’$，识别 $\\alpha$ （字、正规式都行）后转移到 S’ 这个状态集合中的某个状态$S_0 \\subseteq S$ 是非空的初态集 （即初态可能不唯一）$F\\subseteq S$：终态集 (可空)非确定性：初始状态不唯一、识别一个字后所到达的后续状态不唯一从状态图看 NFA 和 DFA 的区别NFA 可以有多个初态弧上的标记可以是 Σ* 中的一个字(甚至可以是一个正规式)，而不一定是单个字符同一个字可能出现在同状态射出的多条弧上DFA 是 NFA 的特例有限自动机的等价性DFA 与 NFA 的等价性定义：对于任何两个有限自动机 M 和 M’，如果 L(M)=L(M’)，则称 M 与 M’ 等价自动机理论中一个重要的结论：判定两个自动机等价性的算法是存在的对于每个 NFA M 存在一个 DFA M’，使得 L(M)=L(M’)DFA 与 NFA 识别能力相同!NFADFA初始状态不唯一唯一弧上的标记字 (单字符字、 $ \\varepsilon $)字符转换关系非确定确定其他NFA 易于设计DFA 易于实现NFA 转换为 DFA假定 NFA $M=&lt;S, \\sum, \\delta, S_0, F&gt;$ ，我们对 M 的状态转换图进行以下改造引进新的初态节点 X 和终态结点 Y，$X,Y\\not\\in S$，从 X 到 $S_0$ 中任意状态结点连一条 $\\varepsilon$ 箭弧，从 F 中任意状态结点连一条 $\\varepsilon $ 箭弧到 Y。(解决初始状态唯一性)对 M 的状态转换图进一步施行替换，其中 k 是新引入的状态。(简化弧上的标记)逐步把这个图转变为每条弧只标记为Σ上的一个字符或ε，最后得到一个NFA M’，显然 L(M’)=L(M)NFA 确定化 —— 子集法 (解决 $\\varepsilon $ 弧和转换关系)设 I 是状态集的一个子集，定义 I 的 $\\varepsilon $ 闭包 $\\varepsilon\\text{-closure(I)} $ 为：若 $s\\in I$，则 $s\\in \\varepsilon\\text{-closure(I)} $若 $s\\in I$，则从 s 出发经过任意条 $\\varepsilon $ 弧而能到达的任何状态 s’ 都属于 $\\varepsilon\\text{-closure(I)} $即 $\\varepsilon\\text{-closure(I)} = I \\cup {s’ | \\text{从某个s}\\in I \\text{出发经过任意条}\\varepsilon 弧能到达s’ }$设 a 是 $\\sum$ 中的一个字符，定义 $I_a = \\varepsilon\\text{-closure(J)}$其中 J 为 I 中的某个状态出发经过一条 a 弧而到达的状态集合确定化：不失一般性，设字母表只包含两个 a 和b，我们构造一张计算状态集的转换表首先，置 表(1,1) 为 $ \\varepsilon\\text{-closure({X})}$ 求出这一列的 $I_a, I_b$然后，检查这两个 $I_a, I_b$，看它们是否已在表中的第一列中出现，把未曾出现的填入后面的空行的第 1 列，求出每行第 2, 3 列上的集合…重复上述过程。例子如下图经过确定化，得到了状态集之间的关系（状态集的转换表）哦，状态集还可以编号，以免写的太麻烦 把经过确定化得到的表看作 状态转换矩阵，子集视为状态转换表唯一刻画了一个确定的有限自动机 M初态是 $ \\varepsilon\\text{-closure({X})}$终态是 含有原终态 Y 的子集不难看出，这个 DFA M 与 M’ 等价对于每个 NFA M 存在一个 DFA M’，使得 L(M)=L(M’)DFA 的化简—— 状态的等价性DFA 的化简(最小化)：对于给定的 DFA M，寻找一个状态数比 M 少的 DFA M’，使得 L(M)=L(M’)状态的等价性假设 s 和 t 为 M 的两个状态，称 s 和 t 等价：如果从状态出发能读出某个字 α 而停止于终态，那么同样，从t 出发也能读出 α 而停止于终态（两个终态可以不是同一个）反之亦然。两个状态不等价，则称它们是可区别的基本思想把 M 的状态集划分为一些不相交的子集，使得任何两个不同子集的状态是可区别的，而同一子集的任何两个状态是等价的。(不断地不断地细分)最后，让每个子集选出一个代表，同时消去其他状态。举例，按照上述原则对DFA的状态集合S进行第一次划分，正确的分法是（B. 终态和非终态）可以 $\\varepsilon$ 为例，终态识别 $\\varepsilon$ 后仍为终态，非终态识别 $\\varepsilon$ 后仍为非终态化简算法 —— 最小化算法推导首先把 S 划分为终态和非终态两个子集，形成基本划分 $\\prod $假定状态 s1 和 s2 是I(i)={s1,s2, …,sk}中的两个状态，它们经 α 弧分别到达 t1 和 t2，而 t1和 t2 属于现行 Π 中的两个不同子集说明有一个字 α， t1 读出 α 后到达终态，而 t2 读出 α 后不能到达终态，或者反之那么对于字 aα ， s1 读出 aα 后到达终态，而 t2 读出 aα 不能到达终态，或者反之所以 s1 和 s2 不等价所以可以将 $I^{(i)}$ 分成两半，一半含有 s1，一半含有 s2广义上的算法对某个 a 和 $I^{(i)}$，若 $I_a^{(i)}$ 落入现行 Π 中 N 个不同子集，则应把 $I^{(i)}$ 划分成 N 个不相交的组，使得每个组 J 的 $J_a$ 都落入的 Π 同一子集。重复上述过程，直到 Π 所含子集数不再增长选取每个子集 I 中的一个状态代表其他状态，则可得到化简后的 DFA M’举例$I^{(1)}={0,1,2}、I^{(2)}={3,4,5,6}$对于 $I^{(1)}={0,1,2}$，有 $I_a^{(1)}={1,3}$，所以 0,2 要和 1 分开，即得到$I^{(11)}={0,2}、I^{(12)}={1}$对于 $I^{(11)}={0,2}$，有 $I_a^{(11)}={1}、I_b^{(11)}={2,4}$，所以 0 要和 2 分开$I^{(111)}={0}、I^{(112)}={2}$而对于 $I^{(2)}={3,4,5,6}$，有 $I_a^{(2)}={3,6}、I_b^{(2)}={4,5}$ 都在 $I^{(2)}$ 里，故不需要分最终为：$I^{(111)}={0}、I^{(112)}={2}、I^{(12)}={1}、I^{(2)}={3,4,5,6}$缩写为：{0}{1}{2}{3,4,5,6}{3,4,5,6} 可以选出 3 作代表，结果如下正规式与有限自动机的等价性正规式与有限自动机的等价性一个正规式 r 与一个有限自动机 M 等价L(r) = L(M)，即正规式对应的正规集 = 有限自动机所识别的字的整体FA -&gt; 正规式（FA 转正规式）对任何 FA M，都存在一个正规式 r，使得 L(r) = L(M)正规式 -&gt; FA（正规式转 FA）对于任何正规式 r，都存在一个 FA M，使得 L(M)=L(r)为 NFA 构造正规式为了证明正规式与有限自动机的等价性，我们先拓展状态转换图的概念，令每条弧可用一个正规式作标记。弧上的 r 指：识别了 r 这个正规式对应的正规集中的某个字定理：对于 ∑ 上任一 NFA M，都存在一个 ∑ 上的正规式 r ，使得 L(r) = L(M)假定 NFA M，我们对 M 状态转换图做以下改造：在 M 的转换图上加进两个状态 X 和 Y，X 用 ε 弧连所有初态节点，所有终态节点用 ε 弧连 Y反复运用下图三条规则，逐步消去节点，直到只剩下 X 和 Y最后，X 到 Y 的弧上标记的正规式即为所构造的正规式 r得证：对 Σ 上任一 NFA M，都存在一个 Σ 上的正规式 r，使得 L(r)=L(M)为正规式构造 NFA对给定正规式r中的运算符数目进行归纳验证r中的运算符数目为0时，结论成立。假设结论对于运算符数目少于k(k≥1)的正规式成立基于该假设，证明结论对于运算符数目为k的正规式成立。当r具有零个运算符，则r=ε或r=φ或r=a，其中a∈Σ。当r中含有k个运算符时，r有三种情形：证明过程中的形式化描述被省略了，可以看PPT转换算法，构造Σ上的NFA M’ 使得L(r)=L(M’)：首先，把r表示成 按下面的三条规则对r进行分裂逐步把这个图转变为每条弧只标记为Σ上的一个字符或ε，最后得到一个NFA M’，显然L(M’)=L(r)NFA 还可以转换为 DFA。 DFA 再经过最小化可以得到一个化简的 DFA。词法分析器的自动产生 —— LEXLEX的工作过程对每条识别规则 Pi 构造一个相应的非确定有限自动机 Mi；引进一个新初态 X，通过 ε 弧，将这些自动机连接成一个新的 NFA；把 M 确定化、最小化，生成该 DFA 的状态转换表和控制执行程序第四章 语法分析-自上而下语法分析基本概念语法分析的任务语法分析的任务：分析一个文法的句子的结构语法分析器的功能：按照文法的产生式 (语言的语法规则)，识别输入符号串是否为一个句子 (合式程序)语法分析器在编译器中的地位语法分析的方法自下而上：从输入串开始，逐步进行归约，直到文法的开始符号归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号从树叶节点开始，构造语法树算符优先分析法、LR 分析法自上而下：从文法的开始符号出发，反复使用各种产生式，寻找”匹配”的推导推导：根据文法的产生式规则，把串中出现的产生式的左部符号替换成右部从树的根开始，构造语法树常用方法：递归下降分析法、预测分析程序自上而下分析的基本问题文法左递归问题一个文法是含有左递归的，如果存在非终结符 P直接左递归的消除假定 P 关于的全部产生式是 $\\begin{align}\\mathrm{P} \\rightarrow \\mathrm{P} \\alpha_{1}\\left|\\mathrm{P} \\alpha_{2}\\right| \\ldots\\left|\\mathrm{P} \\alpha_{\\mathrm{m}}\\right| \\beta_{1}\\left|\\beta_{2}\\right| \\ldots | \\beta_{\\mathrm{n}}\\end{align}$左递归变右递归：$\\begin{align}\\begin{array}{c}\\mathrm{P} \\rightarrow \\beta_{1} \\mathrm{P}^{\\prime}\\left|\\beta_{2} \\mathrm{P}^{\\prime}\\right| \\ldots\\left|\\beta_{\\mathrm{n}} \\mathrm{P}^{\\prime}\\right| \\\\mathrm{P}^{\\prime} \\rightarrow \\alpha_{1} \\mathrm{P}^{\\prime}\\left|\\alpha_{2} \\mathrm{P}^{\\prime}\\right| \\ldots\\left|\\alpha_{\\mathrm{m}} \\mathrm{P}^{\\prime}\\right| \\varepsilon\\end{array}\\end{align}$例题：间接左递归的消除基本思路：把候选中开头的非终结符替换成它的定义，逐步减少定义的圈中的结点，最后变成一个自圈，然后打破定义上的圈消除左递归的算法把文法 G 的所有非终结符按任一种顺序排列 $P_1，P_2，\\cdots，P_n$FOR i:=1 TO n DOFOR j:=1 TO i-1 DO 把形如 $P_i \\rightarrow P_j \\gamma$ 的规则改写成 $P_i \\rightarrow \\delta_1 \\gamma | \\delta_2 \\gamma|\\cdots|\\delta_k \\gamma $ （其中 $P_j \\rightarrow \\delta_1 | \\delta_2|\\cdots|\\delta_k$） 消除关于 $P_i$ 规则的直接左递归性化简由 2 所得的文法，去除从开始符号出发永远无法到达的非终结符的产生规则习题：消除文法 G(s) 的左递归 $\\begin{align}\\begin{aligned}&amp;S \\rightarrow Q c | c\\&amp;Q \\rightarrow R b | b\\&amp;R \\rightarrow S a | a\\end{aligned}\\end{align}$排序 R、Q、S （不同的排序产生的文法是等价的）先看 R，$R \\rightarrow Sa|a$，其中 S 排在 R 的后面，没关系再看 Q，$Q\\rightarrow Rb|b$，其中 R 排在 Q 的前面，对其进行替换 $Q\\rightarrow Sab|ab | b$此时文法变为 $\\begin{align}\\begin{aligned}&amp;S \\rightarrow Q c | c\\&amp;Q\\rightarrow Sab|ab | b\\&amp;R \\rightarrow S a | a\\end{aligned}\\end{align}$再看 S，$S \\rightarrow Q c | c$ ，其中 Q 排在 S 的前面，对其进行替换 $S \\rightarrow Sabc|abc|bc|c $出现了直接左递归，消除掉 $\\begin{align}\\begin{aligned}&amp;S \\rightarrow abcS’|bcS’|cS’\\ &amp; S’ \\rightarrow abcS’ | \\varepsilon \\\\end{aligned}\\end{align}$此时文法为 $\\begin{align}\\begin{aligned}&amp;S \\rightarrow abcS’|bcS’|cS’\\ &amp; S’ \\rightarrow abcS’ | \\varepsilon \\&amp;Q\\rightarrow Sab|ab | b\\&amp;R \\rightarrow S a | a\\end{aligned}\\end{align}$，消除掉从开始符号出发永远无法到达的非终结符的产生规则$\\begin{align}\\begin{aligned}&amp;S \\rightarrow abcS’|bcS’|cS’\\ &amp; S’ \\rightarrow abcS’ | \\varepsilon \\\\end{aligned}\\end{align}$回溯问题分析过程中，当一个非终结符用某一个候选匹配成功时，这种匹配可能是暂时的出错时，不得不“回溯”消除回溯为了消除回溯必须保证：对文法的任何非终结符，当要它去匹配输入串时，能够根据它所面临的输入符号准确地指派它的一个候选去执行任务，并且此候选的工作结果应是确信无疑的。FIRST 集合令 G 是一个不含左递归的文法，对G的所有非终结符的每个候选 α 定义它的终结首符集 FIRST(α) 为：$$F I R S T(\\alpha)=\\left{a | \\alpha \\overset{\\*}{\\Rightarrow} a \\cdots, a \\in V_{T}\\right}$$特别是，若 $\\alpha \\overset{\\*}{\\Rightarrow} \\varepsilon$，则规定 $\\varepsilon \\in F I R S T(\\alpha)$如果非终结符 A 的所有候选首符集两两不相交，即 A 的任何两个不同候选 αi 和 αj，$\\begin{align}\\mathrm{FIRST}\\left(\\alpha_{i}\\right) \\cap \\mathrm{FIRST}\\left(\\alpha_{j}\\right)=\\phi\\end{align} $当要求 A 匹配输入串时，A 能根据它所面临的第一个输入符号 a，准确地指派某一个候选去执行任务。这个候选就是那个终结首符集含 a 的 α。提取公共左因子：假定关于 A 的规则是 $\\begin{align}A \\rightarrow \\delta \\beta_{1}\\left|\\delta \\beta_{2}\\right| \\ldots\\left|\\delta \\beta_{n}\\right| \\gamma_{1}\\left|\\gamma_{2}\\right| \\ldots | \\gamma_{m}\\end{align}$那么，可以把这些规则改写成 $\\begin{align}\\begin{array}{c}A \\rightarrow \\delta A^{\\prime}\\left|\\gamma_{1}\\right| \\gamma_{2}|\\ldots| \\gamma_{m} \\A^{\\prime} \\rightarrow \\beta_{1}\\left|\\beta_{2}\\right| \\ldots | \\beta_{n}\\end{array}\\end{align}$经过反复提取左因子，就能够把每个非终结符(包括新引进者)的所有候选首符集变成为两两不相交FOLLOW 集合如果一个非终结符 A ，有多个候选，当面临着输入符号 a 要用 A 去匹配的时候，如果这个 a 又不在任何一个候选的首符集里面，但是，有一个候选是 $\\varepsilon $ 。当前如果 a 在某个句型中能够跟在 A 的后面时，才能选择 A 的 $\\varepsilon $ 去匹配这个 A。假定S是文法G的开始符号，对于G的任何非终结符A，我们定义A的FOLLOW集合$$\\begin{align}F O L L O W(A)=\\left{a | S \\overset{\\}{\\Rightarrow} \\cdots A a \\cdots, a \\in V_{T}\\right}\\end{align*}$$特别是，若 $S \\overset{\\*}{\\Rightarrow} \\cdots A$，则规定 $# \\in F O L L O W(A)$现在表述改为：当 a 要扩展 A 时，a 不出现在任何候选的 FIRST 集合里，而且有个 $\\varepsilon $ 候选，如果 a 在 A 的 FOLLOW 集合里面，就把 A 替换成 $\\varepsilon $ 。LL(1)文法LL(1)文法的条件构造不带回溯的自上而下分析的文法条件：文法不含左递归对于文法中每一个非终结符A的各个产生式的候选首符集两两不相交。即，若 $A \\rightarrow \\alpha_{1}\\left|\\alpha_{2}\\right| \\dots | \\alpha_{n}$，则 $FIRST \\left(\\alpha_{i}\\right) \\cap \\operatorname{FIRST}\\left(\\alpha_{j}\\right)=\\phi$对文法中的每个非终结符A，若它存在某个候选首符集包含ε，则 $\\text{FIRST(A)} \\cap \\text{FOLLOW(A)}=\\phi, \\quad i=1,2, \\dots, n$如果一个文法 G 满足以上条件，则称该文法为 LL(1) 文法L：从左到右扫描输入串L：最左推导1：每一步只需向前查看一个符号LL(1)分析法对于 LL(1) 文法，可以对其输入串进行有效的无回溯的自上而下分析假设要用非终结符 A 进行匹配，面临的输入符号为 a，A 的所有产生式为$A \\rightarrow \\alpha_{1}\\left|\\alpha_{2}\\right| \\dots | \\alpha_{n}$若 $a \\in F IRST\\left(\\alpha_{i}\\right)$，则指派 $\\alpha_i$ 执行匹配任务；若 a 不属于任何一个候选首符集，则(1) 若 ε 属于某个 FIRST(αi ) 且 a∈FOLLOW(A)， 则让 A 与 ε 自动匹配。(2) 否则，a 的出现是一种语法错误。FIRST 集和 FOLLOW 集的构造思想：把对无穷推导空间的可能的考察，转换成对有限产生式的反复扫描构造 FIRST(α)$$F I R S T(\\alpha)=\\left{a | \\alpha \\overset{\\*}{\\Rightarrow} a \\cdots, a \\in V_{T}\\right}$$文法符号：$\\alpha=X, \\quad X \\in V_{T} \\cup V_{N}$符号串：$\\alpha=X_{1} X_{2} \\ldots X_{n}, \\quad X_{i} \\in V_{T} \\cup V_{N}$构造每个文法符号的 FIRST 集合：对每一 $X \\in V_{T} \\cup V_{N}$，连续使用下面的规则，直至每个集合 FIRST 不再增大为止：若 $X \\in V_{T}$，则 $F IRST(X)={X}$若 $X \\in V_{N}$，且有产生式 $X\\rightarrow a \\cdots$，则把 a 加入到 $F IRST(X)$ 中；若 $X\\rightarrow \\varepsilon$ 也是一条产生式，则把 $\\varepsilon$ 也加到 $F IRST(X)$ 中若 $X\\rightarrow Y \\cdots$ 是一个产生式且 $Y\\in V_N$ ，则把 $F IRST(Y)$ 中的所有非 $\\varepsilon$ 也加到 $F IRST(X)$ 中若 $X \\rightarrow Y_{1} Y_{2} \\ldots Y_{i-1} Y_{i} \\ldots Y_{k}$ 是一个产生式，$Y_{1}, Y_{2} ,\\cdots ,Y_{i-1}$ 都是非终结符对于任何 j，$1 \\leq j \\leq i-1$，$FIRST \\left(Y_{j}\\right)$ 都含有 $\\varepsilon$ （$Y_{1} \\cdots Y_{i-1} \\overset{\\*}{\\Rightarrow} \\varepsilon$），则把 $FIRST \\left(Y_{i}\\right)$ 中的所有非 $\\varepsilon$ 也加到 $FIRST(X)$ 中若所有的 $FIRST \\left(Y_{j}\\right)$ 都含有 $\\varepsilon$ ，j=1,2,…,k，则把 $\\varepsilon$ 加到 $FIRST(X)$ 中构造任何符号串的 FIRST 集合：对文法 G 的任何符号串 $\\alpha=X_{1} X_{2} \\cdots X_{n}$ 构造集合 $FIRST \\left(\\alpha\\right) $置 $\\mathrm{FIRST}(\\alpha)=\\mathrm{FIRST}\\left(\\mathrm{X}_{1}\\right) \\backslash{\\varepsilon}$，斜杠表示集合去掉某个元素若对任何 $1 \\leq j \\leq i-1 $ ，$\\varepsilon \\in \\mathrm{FIRST}\\left(\\mathrm{X}{\\mathrm{j}}\\right)$，则把 $\\mathrm{FIRST}\\left(\\mathrm{X}{i}\\right) \\backslash{\\varepsilon}$ 加至 $\\mathrm{FIRST}(\\alpha)$ 中；特别是，若所有的 $ \\mathrm{FIRST}\\left(\\mathrm{X}_{\\mathrm{j}}\\right)$ 都含 $\\varepsilon$ （$1 \\leq j \\leq n$），则把 $\\varepsilon$ 也加至 $\\mathrm{FIRST}(\\alpha)$ 中。显然，若 $\\alpha = \\varepsilon$ 则 $\\mathrm{FIRST}(\\alpha)={\\varepsilon }$构造 FOLLOW(A)$$\\begin{align}F O L L O W(A)=\\left{a | S \\overset{\\}{\\Rightarrow} \\cdots A a \\cdots, a \\in V_{T}\\right}\\end{align*}$$构造每个非终结符的 FOLLOW 集合：对于文法 G 的每个非终结符 A 构造 FOLLOW(A) 的办法是，连续使用下面的规则，直至每个 FOLLOW 不再增大为止：对于文法的开始符号 S，置＃于 FOLLOW(S) 中；若 A→αBβ 是一个产生式，则把 FIRST(β)\\{ε} 加至 FOLLOW(B) 中；若（ A→αB 是一个产生式）或（ A→αBβ 是一个产生式而 ε ∈ FIRST(β) ），则把 FOLLOW(A) 加至 FOLLOW(B) 中例题：递归下降分析程序概念：分析程序由一组子程序组成， 对每一语法单位(非终结符)构造一个相应的子程序，识别对应的语法单位通过子程序间的相互调用实现对输入串的识别例如，A → B c D文法的定义通常是递归的，通常具有递归结构定义全局过程和变量：ADVANCE，把输入串指示器IP指向下一个输入符号，即读入一个单词符号SYM，IP当前所指的输入符号ERROR，出错处理子程序例子：例子：$\\begin{align}\\begin{aligned}&amp;E \\rightarrow T E^{\\prime}\\&amp;E^{\\prime} \\rightarrow+T E^{\\prime} | \\varepsilon\\&amp;T \\rightarrow F T^{\\prime}\\&amp;T^{\\prime} \\rightarrow \\text{} F T^{\\prime} | \\varepsilon\\&amp;F \\rightarrow(E) | i\\end{aligned}\\end{align*}$ 的递归下降子程序为扩充的巴科斯范式在元符号“→”或“::=”和“|”的基础上，扩充几个元语言符号：用花括号 {α} 表示闭包运算 α*。用表示 ${α}_0^n$ 可任意重复 0 次至 n 次。用方括号 [α] 表示 ${α}_0^1$ ，即表示 α 的出现可有可无 (等价于 α|ε )。例如，通常的 “实数” 可定义为：Decimal→ [Sign]Integer.{digit}[Exponent]Exponent→ E[Sign]IntegerInteger→ digit{digit}Sign→ + | -用扩充的巴科斯范式来描述语法，直观易懂，便于表示左递归消去和因子提取。例如，$\\begin{align}\\begin{aligned}&amp;E \\rightarrow T | E+T\\&amp;T \\rightarrow F | T^{\\star} F\\&amp;F \\rightarrow i |(E)\\end{aligned}\\end{align} $ 可表示成 $\\begin{align}\\begin{aligned}&amp;E \\rightarrow T{+T}\\&amp;T \\rightarrow F{\\star F}\\&amp;F \\rightarrow i |(E)\\end{aligned}\\end{align} $，其语法图和递归下降子程序如下 预测分析程序预测分析程序构成总控程序，根据现行栈顶符号和当前输入符号，执行动作分析表 $M[A，a]$ 矩阵，$A ∈ V_N ，a ∈ V_T$ 是终结符或 ‘＃’分析栈 STACK 用于存放文法符号预测分析过程总控程序根据当前栈顶符号X和输入符号a，执行下列三动作之一：若 X＝a＝‘＃’，则宣布分析成功，停止分析。若 X＝a ≠‘＃’，则把 X 从 STACK 栈顶逐出，让 a 指向下一个输入符号。若 X 是一个非终结符，则查看分析表 M。若 M[X，a] 中存放着关于 X 的一个产生式，把 X 逐出 STACK 栈顶，把产生式的右部符号串按反序一一推进 STACK 栈 (若右部符号为ε ，则意味不推什么东西进栈)。若 M[X，a] 中存放着“出错标志”，则调用出错诊察程序 ERROR。12345678910111213141516171819BEGIN 首先把‘＃’然后把文法开始符号推进STACK栈； 把第一个输入符号读进a； FLAG:=TRUE; WHILE FLAG DO BEGIN 把STACK栈顶符号上托出去并放在X中； IF X∈VT THEN IF X= a THEN 把下一输入符号读进a ELSE ERROR ELSE IF X=‘#’ THEN IF X=a THEN FLAG:=FALSE ELSE ERROR ELSE IF M[X,a]={X→X1X2…Xk}THEN 把Xk,Xk-1,…,X1一一推进STACK栈 /* 若X1X2…Xk=ε，不推什么进栈*/ ELSE ERROR END OF WHILE; STOP /*分析成功，过程完毕*/END例子：对于 $\\begin{align}\\begin{aligned}&amp;E \\rightarrow T | E+T\\&amp;T \\rightarrow F | T^{\\star} F\\&amp;F \\rightarrow i |(E)\\end{aligned}\\end{align} $ ，输入串为 $i_1* i_2+i_3$ ，利用分析表进行预测预测分析表的构造分析表 M[A，a] 的构造：构造 FIRST(α) 和 FOLLOW(A)构造分析表 M[A，a]构造 G 的分析表 M[A，a]， 确定每个产生式A→α在表中的位置：对文法 G 的每个产生式 A→α 执行第 2 步和第 3 步；对每个终结符 a∈FIRST(α)，把 A→α 加至 M[A，a] 中；若 ε∈FIRST(α)，则对任何 b∈FOLLOW(A) 把 A→α 加至 M[A，b] 中。把所有无定义的 M[A，a] 标上“出错标志”。LL(1)文法与二义性如果 G 是左递归或二义的，那么，M 至少含有一个多重定义入口。因此，消除左递归和提取左因子将有助于获得无多重定义的分析表 M。可以证明，一个文法 G 的预测分析表 M 不含多重定义入口，当且仅当该文法为 LL(1) 的。LL(1) 文法不是二义的。第五章 语法分析-自下而上基本概念语法分析的方法自下而上：从输入串开始，逐步进行归约，直到文法的开始符号归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号从树叶节点开始，构造语法树算符优先分析法、LR 分析法自上而下：从文法的开始符号出发，反复使用各种产生式，寻找”匹配”的推导推导：根据文法的产生式规则，把串中出现的产生式的左部符号替换成右部从树的根开始，构造语法树常用方法：递归下降分析法、预测分析程序自下而上分析示例自下而上分析的基本思想采用 “移进－归约” 思想进行自下而上分析基本思想用一个寄存符号的先进后出栈，把输入符号一个一个地移进到栈里，当栈顶形成某个产生式的候选式时，即把栈顶的这一部分替换成(归约为)该产生式的左部符号。移进－归约分析示例设文法G(S)：(1) S → aAcBe(2) A → b(3) A → Ab(4) B → d试对 abbcde 进行 “移进－归约” 分析自下而上分析过程：边输入单词符号，边归约核心问题：识别可归约串分析树和语法树不一定一致短语定义：令 G 是一个文法，S 是文法的开始符号，假定 αβδ 是文法 G 的一个句型，如果有 $\\large \\mathrm{S} \\overset{*}{\\Rightarrow} \\alpha \\mathrm{A} \\delta \\ \\ \\text{且}\\ \\ \\mathrm{A} \\overset{+}{\\Rightarrow} \\beta $，则 β 称是句型 αβδ 相对于非终结符 A 的短语。如果有 $A\\rightarrow β$，则称 β 是句型 αβδ 相对于规则 A→ β的直接短语。（一步推出则短语是直接短语）例子：考虑文法 G(E)：E → T | E+TT → F | T*FF → (E) | i和句型 i1*i2+i3：短语：i1，i2，i3， i1*i2， i1*i2+i3直接短语：i1，i2，i3在一个句型对应的语法树中以某非终结符为根的两代以上的子树的所有末端结点从左到右排列就是相对于该非终结符的一个短语如果子树只有两代，则该短语就是直接短语算符优先文法按照算符的优先关系和结合性质进行语法分析适合分析表达式算符优先级下图中两个文法，左文法没有体现先乘除后加减同级从左到右的约定。右文法的非终结符的定义关系中，进一步体现了算符在规约上的优先关系。优先关系任何两个可能相继出现的终结符 a 与 b 可能三种优先关系$a\\lessdot b$，a的优先级低于b$a \\eqcirc b$，a的优先级等于b$a \\gtrdot b$，a的优先级高于b算符优先关系与数学上的 &lt;&gt;= 不同$+ \\lessdot +$$a \\lessdot b$，并不意味着 $b \\gtrdot a$，如 $(\\ \\lessdot +$ 和 $+ \\lessdot\\ ($算符文法概念：一个文法，它的任一产生式的右部都不含两个相继 (并列) 的非终结符，即不含 …QR… 形式的产生式右部约定：a、b 代表任意终结符P、Q、R 代表任意非终结符‘…’ 代表由终结符和非终结符组成的任意序列，包括空字算符优先文法假定 G 是一个不含 ε-产生式的算符文法。对于任何一对终结符 a、b，我们说：$a \\eqcirc b$ ，当且仅当文法 G 含有形如 P→…ab… 或 P→…aQb… 的产生式$a \\lessdot b$ ，当且仅当文法 G 含有形如 P→…aR… 的产生式 ，而 $R\\overset{+}{\\Rightarrow} b…$ 或 $R\\overset{+}{\\Rightarrow} Rb…$$a \\gtrdot b$ ，当且仅当文法 G 含有形如 P→…Rb… 的产生式 ，而 $R\\overset{+}{\\Rightarrow} a…$ 或 $R\\overset{+}{\\Rightarrow} aQ…$如果一个算符文法 G 中的任何终结符对 (a, b) 至多只满足 $a \\eqcirc b、a \\lessdot b、a \\gtrdot b$ 这三个关系之一，则称 G 是一个算符优先文法优先关系表考虑下面的文法G(E)：(1) E→E+T | T(2) T→T*F | F(3) F→P ↑ F | P(4) P→(E) | i根据优先关系的定义，可以计算优先关系如下将所有的优先关系用一个 n×n 的表格表示，(1, 1) 这个格子表示左边的加号优先级高于右边的加号优先关系表的前提确定满足关系 $a \\eqcirc b$ 的所有终结符对$a \\eqcirc b$，当且仅当文法G中含有形如 P→…ab… 或 P→…aQb… 的产生式通过检查 G 的每个产生式的每个候选式，可找出所有满足 $a \\eqcirc b$ 的终结符对只要检查产生式，无需考虑推导，就能计算所有可能的优先级相等关系确定满足关系 $\\lessdot、\\gtrdot$ 的所有终结符对$a \\lessdot b$ ，当且仅当文法 G 含有形如 P→…aR… 的产生式 ，而 $R\\overset{+}{\\Rightarrow} b…$ 或 $R\\overset{+}{\\Rightarrow} Rb…$$a \\gtrdot b$ ，当且仅当文法 G 含有形如 P→…Rb… 的产生式 ，而 $R\\overset{+}{\\Rightarrow} a…$ 或 $R\\overset{+}{\\Rightarrow} aQ…$FIRSTVT 集：$FIRSTVT(P) = {a\\ |\\ P \\overset{+}{\\Rightarrow}a…或P \\overset{+}{\\Rightarrow}Qa…，a\\in V_T 且 Q\\in V_N }$LASTVT 集：$LASTVT(P) = {a\\ |\\ P \\overset{+}{\\Rightarrow}…a或P \\overset{+}{\\Rightarrow}…aQ，a\\in V_T 且 Q\\in V_N }$构造集合FIRSTVT(P)的算法反复使用下面两条规则构造集合 FIRSTVT(P)若有产生式P→a…或P→Qa…，则a∈FIRSTVT(P)若a∈FIRSTVT(Q)，且有产生式P→Q…，则a∈FIRSTVT(P)算法的一种实现（利用栈）：1234567891011121314151617181920PROCEDURE INSERT(P，a)IF NOT F[P，a] THENBEGIN F[P，a]:=TRUE； 把(P，a)下推进STACK栈END；主程序：BEGIN FOR 每个非终结符P和终结符a DO F[P，a]:=FALSE； FOR 每个形如P→a…或P→Qa…的产生式DO INSERT(P，a)； WHILE STACK 非空DO BEGIN 把STACK的顶项，记为(Q，a)，上托出去； FOR 每条形如P→Q…的产生式DO INSERT(P，a)； END OF WHILE；END构造集合LASTVT(P)的算法反复使用下面两条规则构造集合 LASTVT(P)若有产生式P→… a或P→ … aQ，则a∈LASTVT(P)若a∈LASTVT(Q)，且有产生式P→… Q，则a∈LASTVT(P)构造优先关系表的算法：示例：是算符优先文法，因为表里没有冲突项，任何一对终结符之间最多只有一种优先关系。最左素短语概念：素短语：一个文法 G 的句型的素短语是指这样一个短语，它至少含有一个终结符，并且，除它自身之外不再含任何更小的素短语最左素短语：处于句型最左边的那个素短语示例：语法树可以看出短语和素短语，但是我们没有语法树，语法分析的结果是分析树，检测短语和素短语是语法分析的过程，所以要有其他的方法来检测短语和素短语。最左素短语定理：算符优先文法句型(括在两个＃之间)的一般形式：$#N_1a_1N_2a_2…N_na_nN_{n+1}#$其中，ai 都是终结符，Ni是可有可无的非终结符。定理：一个算符优先文法 G 的任何句型的最左素短语是满足如下条件的最左子串 $N_ja_j\\cdots N_ia_iN_{i+1}$，$a_{j-1} \\lessdot a_j，\\ a_{j} \\eqcirc a_{j+1}，\\cdots，a_{i-1} \\eqcirc a_i，\\ a_i \\gtrdot a_{i+1} $算符优先分析算法使用一个符号栈 S，用它寄存终结符和非终结符，k 代表符号栈 S 的使用深度在正确的情况下，算法工作完毕时，符号栈 S 应呈现：# N #分析树与语法树：LR分析法自下而上的思想基本思想从输入串开始，逐步归约，直到文法的开始符号归约：根据文法的产生式规则，把串中出现的产生式的右部替换成左部符号从树叶节点开始，构造语法树算符优先分析法按照算符的优先关系和结合性质进行语法分析适合分析表达式LR 分析法规范规约：句柄作为可规约串句柄与规范规约概念：短语：令 G 是一个文法，S 是文法的开始符号，假定 αβδ 是文法 G 的一个句型，如果有 $\\large \\mathrm{S} \\overset{*}{\\Rightarrow} \\alpha \\mathrm{A} \\delta \\ \\ \\text{且}\\ \\ \\mathrm{A} \\overset{+}{\\Rightarrow} \\beta $，则 β 称是句型 αβδ 相对于非终结符 A 的短语。直接短语：如果有 $A\\rightarrow β$，则称 β 是句型 αβδ 相对于规则 A→ β的直接短语。（一步推出则短语是直接短语）句柄：一个句型的最左直接短语（感觉是语法树最左两代子树末端 / 最底的两层）例子：规范规约：定义：假定 α 是文法 G 的一个句子，我们称序列 $\\alpha_{n}, \\alpha_{n-1}, \\cdots, \\alpha_0$ 是 α 的一个规范归约，如果此序列满足：$\\alpha_n = \\alpha$$\\alpha_0$ 为文法的开始符号，即 $\\alpha_0 = S$对任何 $i, 0\\le 1\\le n$，$\\alpha_{i-1} $ 是从 $\\alpha_i$ 经把句柄替换成相应产生式左部符号而得到算符优先分析一般不等价于规范规约：规范句型：规范归约是最左归约规范归约的逆过程就是最右推导 $S \\Rightarrow aAcBe \\Rightarrow aAcde \\Rightarrow aAbcde \\Rightarrow abbcde $最右推导也称为规范推导由规范推导推出的句型称为规范句型LR 分析表规范归约的关键问题是寻找句柄：历史：已移入符号栈的内容展望：根据产生式推测未来可能遇到的输入符号现实：当前的输入符号LR 分析方法：把”历史”及”展望”综合抽象成状态；由栈顶的状态和现行的输入符号唯一确定每一步工作LR 分析器结构：LR 分析器的核心是一张分析表：ACTION[s，a]：当状态 s 面临输入符号 a 时，应采取什么动作GOTO[s，X]：状态 s 面对文法符号 X 时，下一状态是什么LR 分析表的使用（根据 $ACTION(s_m , a_i)$确定下一步动作）：$(s_0\\ s_1\\ s_m\\ ,\\quad #\\ X_1 \\cdots X_m\\ ,\\quad a_i \\ a_{i+1} \\cdots a_n # ) $若 $ACTION(s_m , a_i)$ 为移进，且 s 为下一状态，则格局变为:$(s_0\\ s_1\\ s_m\\ s ,\\quad #\\ X_1 \\cdots X_m\\ a_i,\\quad a_{i+1} \\cdots a_n # ) $若 $ACTION(s_m , a_i)$ 为按 $A \\rightarrow \\beta$ 归约，格局变为：$(s_0\\ s_1\\ s_{m-r}\\ s ,\\quad #\\ X_1 \\cdots X_{m-r}\\ A ,\\quad a_i \\ a_{i+1} \\cdots a_n # ) $此处，$s=GOTO(s_{m-r}, A)$，r 为 $\\beta$ 的长度，$\\beta = X_{m-r+1}\\cdots X_m$若 $ACTION(s_m , a_i)$ 为 “接受”，则格局变化过程终止，宣布分析成功。若 $ACTION(s_m , a_i)$ 为 “报错”，则格局变化过程终止，报告错误。“移进-规约” 的过程（LR 分析表的使用）：LR 文法：定义：对于一个文法，如果能够构造一张分析表，使得它的每个入口均是唯一确定的，则这个文法就称为 LR 文法。定义：一个文法，如果能用一个每步顶多向前检查 k 个输入符号的 LR 分析器进行分析，则这个文法就称为 LR(k) 文法.LR 文法不是二义的，二义文法肯定不会是 LR 的LR 文法 ⊂ 无二义文法非 LR 结构：S → iCtS | iCtSeSLR(0) 分析表的构造概念前缀、活前缀：字的前缀：是指字的任意首部，如字 abc 的前缀有 ε，a，ab，abc活前缀：是指规范句型的一个前缀，这种前缀不含句柄之后的任何符号。即，对于规范句型 αβδ，β为句柄，如果αβ=u1u2…ur，则符号串 u1u2…ui(1≤i≤r) 是 αβδ 的活前缀。(δ必为终结符串)规范归约过程中，保证分析栈中总是活前缀，就说明分析采取的移进/归约动作是正确的拓广文法：构造文法 G′，它包含了整个 G，并引进不出现在 G 中的非终结符 S′、以及产生式 S′→S，S′ 是 G′ 的开始符号LR(0) 项目：在每个产生式的右部添加一个圆点，表示我们在分析过程中看到了产生式多大部分比如：A→XYZ有四个项目 A→ •XYZ、A→X•YZ、A→XY•Z、A→XYZ•A→α• 称为”归约项目”归约项目 S′→α • 称为”接受项目”A→α•aβ (a∈$V_T $) 称为”移进项目”A→α•Bβ (B∈$V_N $) 称为”待约项目”LR(0) 项目包括拓广文法在内的所有项目。例子：构造识别活前缀的 DFA构造识别活前缀的 DFA：构造识别文法所有活前缀的 NFA若状态 $i$ 为$\\begin{align}X \\rightarrow X_{1} \\cdots X_{i-1} \\bullet X_{i} \\cdots X_{n}\\end{align}$ ，状态 $j$ 为 ，$\\begin{align}X \\rightarrow X_{1} \\cdots X_{i-1} X_{i}\\bullet X_{i+1} \\cdots X_{n}\\end{align}$，则画一条边 $\\langle i, j,X_i\\rangle$若状态 $i$ 为 $X\\rightarrow \\alpha \\bullet A\\beta$，A 为非终结符，则从 i 画一条 ε 边到所有状态 A→•γ例子：把 NFA 确定化例子：LR(0) 项目集规范族：构成识别一个文法活前缀的 DFA 的项目集/状态 的全体称为文法的 LR(0) 项目集规范族。例如上图中 0~11 状态的每个方框通过计算项目集规范族构造识别活前缀的 DFA利用有效项目的概念，直接计算出项目集规范族，从而来构造 DFA有效项目：项目 A→ β1•β2 对活前缀 αβ1 是有效的，其条件是存在规范推导 $\\Large \\begin{align}\\mathrm{S}^{\\prime} \\overset{}{\\Rightarrow_{R}} \\alpha A \\omega \\Rightarrow_{R} \\alpha \\beta_{1} \\beta_{2} \\omega\\end{align*}$在任何时候，分析栈中的活前缀 X1X2 … Xm 的有效项目集正是从识别活前缀的 DFA 的初态出发，读出 X1X2 … Xm 后到达的那个项目集(状态)。有效项目的性质：若项目 A→α•Bβ 对活前缀 η=δα 是有效的且 B→γ 是一个产生式，则项目 B → •γ 对 η=δα 也是有效的。证明若项目 A→α•Bβ 对活前缀 η=δα 是有效的，则有 $\\large \\begin{align}S^{\\prime} \\overset{}{\\Rightarrow}{R} \\delta A \\omega \\Rightarrow{R} \\delta \\alpha B \\beta \\omega\\end{align*} $设 $\\large \\begin{align}\\beta \\omega \\overset{}{\\Rightarrow_{R}} \\varphi \\omega\\end{align}$，那么 $\\large \\begin{align}S^{\\prime} \\overset{}{\\Rightarrow}{R} \\delta A \\omega \\Rightarrow{R} \\delta \\alpha B \\beta \\omega \\Rightarrow_{R} \\delta \\alpha B \\varphi \\omega \\overset{}{\\Rightarrow}_{R} \\delta \\alpha \\gamma \\varphi \\omega\\end{align*}$所以，项目 B → •γ 对 η=δα 也是有效的。LR(0) 项目集规范族的构造:将文法 G(S) 拓广为 G′(S′)构造文法 G′，它包含了整个 G，并引进不出现在 G 中的非终结符 S′、以及产生式 S′→S，S′ 是G′ 的开始符号G′ 唯一的 “接受” 态：仅含项目 S′→S• 的状态项目集的闭包 CLOSURE：假定 I 是文法 G’ 的任一项目集，定义和构造 I 的闭包 CLOSURE(I) 如下：I 的任何项目都属于 CLOSURE(I)；若 A→α•Bβ 属于 CLOSURE(I)，那么，对任何关于 A 的产生式 B→γ，项目 B→•γ 也属于 CLOSURE(I)；重复执行上述两步骤直至 CLOSURE(I) 不再增大为止。状态转换函数：为了识别活前缀，我们定义一个状态转换函数 GOI 是一个项目集，X 是一个文法符号。函数值 GO(I，X) 定义为：$GO(I，X)＝CLOSURE(J)$其中 J＝{ 任何形如 A→α•Bβ 的项目 | A→α•Bβ 属于I }直观上说，若 I 是对某个活前缀 γ 有效的项目集，那么，GO(I，X) 便是对 γX 有效的项目集LR(0) 项目集规范族的构造算法：123456789PROCEDURE ITEMSETS(G&apos;)；BEGIN C:={CLOSURE({S‘→•S})}； REPEAT FOR C中每个项目集I和G&apos;的每个符号X DO IF GO(I，X)非空且不属于C THEN 把GO(I，X)放入C族中; UNTIL C 不再增大END例子：文法G(S′)S′→EE→aA|bBA→cA|dB→cB|d如果可以，约定作图原则为连线不造成封闭区域、每个点入度为 1 （下图是我的作业题）LR(0) 分析表构造假若一个文法G的拓广文法G′的活前缀识别自动机中的每个状态(项目集)不存在下述情况：既含移进项目又含归约项目；含有多个归约项目；则称G是一个LR(0)文法。LR(0) 分析表的 ACTION 和 GOTO 子表构造若项目 A→α•aβ 属于 $I_k$ 且 $GO(I_k, a)＝I_j$，a 为终结符，则置 ACTION[k, a] 为 “sj”。若项目 A→α• 属于 $I_k$ ，那么，对任何终结符a(或结束符#)，置 ACTION[k, a]为“rj” (假定产生式 A→α 是文法 G′ 的第 j 个产生式)。若项目 S′→S• 属于 $I_k$，则置 ACTION[k,#] 为 “acc”。若 $GO(I_k, A)＝I_j$，A 为非终结符，则置 GOTO[k, A]=j。分析表中凡不能用规则 1 至 4 填入信息的空白格均置上“报错标志”。更强的 LR 分析LR(0) 文法是非常简单的，稍微有些实际意义的文法，很可能就不属于 LR(0) 了SLR(1) 冲突解决办法假定LR(0)规范族的一个项目集 $I={A_1→α•a_1β_1，A_2→α•a_2β_2，…，A_m→α•a_mβ_m，B_1→α•，B_2→α•，…，B_n→α• } $如果集合 ${a_1，…，a_m}，FOLLOW(B_1)，…，FOLLOW(B_n)$ 两两不相交 (包括不得有两个 FOLLOW 集合有#)，则当状态 I 面临任何输入符号 a 时：若 a 是某个 $a_i，i=1,2,…,m$，则移进；若 $a∈FOLLOW(B_i)，i=1,2,…,n$，则用产生式 $B_i→α$ 进行归约；此外，报错。SLR(1) 解决办法： S 指 Simple， 1 指 最多向前看一个单词SLR(1) 分析表的 ACTION 和 GOTO 子表构造（与 LR(0) 的不同在红字标出）：若项目 A→α•aβ 属于 $I_k$ 且 $GO(I_k, a)＝I_j$，a 为终结符，则置 ACTION[k, a] 为 “sj”。若项目 A→α• 属于 $I_k$ ，那么，对任何终结符 $a\\in FOLLOW(A)$ ，置 ACTION[k, a]为“rj” (假定产生式 A→α 是文法 G′ 的第 j 个产生式)。若项目 S′→S• 属于 $I_k$，则置 ACTION[k,#] 为 “acc”。若 $GO(I_k, A)＝I_j$，A 为非终结符，则置 GOTO[k, A]=j。分析表中凡不能用规则 1 至 4 填入信息的空白格均置上“报错标志”。SLR(1) 文法：按上述方法构造出的 ACTION 与 GOTO 表如果不含多重入口，则称该文法为 SLR(1) 文法。使用 SLR 表的分析器叫做一个 SLR 分析器。每个 SLR(1) 文法都是无二义的。但也存在许多无二义文法不是 SLR(1) 的。LR(0) ⊂ SLR(1) ⊂ 无二义文法SLR 冲突消解存在的问题SLR 在方法中，如果项目集 $I_i$ 含项目 A→α• 而且下一输入符号 $a∈FOLLOW(A)$，则状态 i 面临 a 时，可选用 “用A→α归约” 动作但在有些情况下，当状态 i 显现于栈顶时，当前单词是 a，栈里的活前缀 βα 未必允许把 α 归约为 A，因为可能根本就不存在一个形如 “βAa” 的规范句型在这种情况下，用 “A→α” 归约不一定合适，为什么 SLR 会犯这种错误？因为 FOLLOW 集合提供的信息太泛，它提供了所有可能跟在 A 后面的终结符LR(1) 分析表构造LR(k) 项目：LR(k) 项目：扩展 LR(0) 项目，附带有 k 个终结符 [A→α•β, a1a2…ak]，a1a2…ak 称为向前搜索符串(或展望串)。归约项目 [A→α•，a1a2…ak] 的意义：当它所属的状态呈现在栈顶且后续的 k 个输入符号为 a1a2…ak 时，才可以把栈顶上的 α 归约为 A对于任何移进或待约项目 [A→α•β, a1a2…ak], β≠ε，搜索符串 a1a2…ak 没有直接作用有效项目：形式上我们说一个 LR(1) 项目 [A→α•β, a] 对于活前缀 γ 是有效的，如果存在规范推导$\\Large \\begin{align}\\mathrm{S}^{\\prime} \\overset{}{\\Rightarrow_{R}} \\delta A \\omega \\Rightarrow_{R} \\delta \\alpha \\beta \\omega\\end{align*}$其中，1) γ＝δα；2) a 是 ω 的第一个符号，或者 a 为 # 而 ω 为 ε。性质：[A→α•Bβ, a] 对活前缀 γ＝δα 是有效的，则对于每个形如 B→ξ 的产生式， 对任何 b∈FIRST(βa)，[B→•ξ, b] 对 γ 也是有效的。若项目 [A→α•Bβ, a]对γ＝δα 有效， 则有 $\\large \\begin{align}\\mathrm{S}^{\\prime} \\overset{}{\\Rightarrow_{R}} \\delta A \\omega \\Rightarrow_{R} \\delta \\alpha \\beta \\omega\\end{align*}$∵ b∈FIRST(βa)∴ $𝛽𝑎𝜔 \\overset{*}{\\Rightarrow_{R}} 𝑏𝜑 $若B→ξ是产生式，则 $\\begin{align}S \\overset{}{\\Rightarrow_{R}} \\delta \\alpha B \\beta a \\omega \\overset{}{\\Rightarrow_{R}} \\delta \\alpha B b \\varphi \\Rightarrow_{R} \\delta \\alpha \\xi b \\varphi\\end{align}$∴ 项目 [B→•ξ, b] 对 γ＝δα 是有效的项目集的闭包 CLOSURE：假定 I 是文法 G′ 的任一项目集，定义和构造 I 的闭包 CLOSURE(I) 如下：I 的任何项目都属于 CLOSURE(I)。若项目 [A→α•Bβ, a] 属于 CLOSURE(I)，B→ξ 是一个产生式，那么，对于 FIRST(βa) 中的每个终结符b，如果 [B→•ξ, b] 原来不在 CLOSURE(I) 中，则把它加进去。重复执行步骤2，直至 CLOSURE(I) 不再增大为止。LR(1) 项目集规范族的构造算法：12345678BEGIN C:={ CLOSURE( { [S′→•S，#] } ) }; REPEAT FOR C中每个项目集 I 和文法 G′ 的每个符号 X DO IF GO(I，X) 非空且不属于 C，THEN 把 GO(I，X) 加入 C 中 UNTIL C不再增大ENDLR(1) 分析表的 ACTION 和 GOTO 子表构造（与 LR(0) 的不同在红字标出）：若项目 A→α•aβ 属于 $I_k$ 且 $GO(I_k, a)＝I_j$，a 为终结符，则置 ACTION[k, a] 为 “sj”。若项目 [A→α•，a] 属于 Ik，则置 ACTION[k, a] 为 “rj”；其中假定 A→α 为文法 G′ 的第 j 个产生式。若项目 [S′→S•, #] 属于 Ik，则置 ACTION[k, #] 为“acc”。若 $GO(I_k, A)＝I_j$，A 为非终结符，则置 GOTO[k, A]=j。分析表中凡不能用规则 1 至 4 填入信息的空白格均置上“报错标志”。LR(1) 分析表和 LR(1) 文法：按上述算法构造的分析表，若不存在多重定义的入口(即，动作冲突)的情形，则称它是文法 G 的一张规范的 LR(1) 分析表。具有规范的 LR(1) 分析表的文法称为一个 LR(1) 文法。使用 LR(1) 分析表的分析器叫做一个规范的 LR 分析器。LR(1) 状态比 SLR(1) 多LR(0) ⊂ SLR(1) ⊂ LR(1) ⊂ 无二义文法示例：LR(1)分析表的构造 LALR 分析书上直接构造 LALR(1) 的算法是错的，得先构造 LR(1) 再合并同心项集。基本思想：寻找具有相同核心的 LR (1) 项集，并将这些项集合并为一个项集。所谓项集的核心就是其第一分量的集合然后根据合并后得到的项集族构造语法分析表如果分析表中没有语法分析动作冲突，给定的文法就称为 LALR (1) 文法，就可以根据该分析表进行语法分析如下图中：$I_{10}、I_8$ 合并$I_{11}、I_4$ 合并$I_{12}、I_5$ 合并$I_{13}、I_7$ 合并得到：合并同心项集时产生归约-归约冲突的例子：合并同心项集后，可能不产生冲突，但可能会推迟错误的发现LALR (1) 的特点：形式上与 LR(1) 相同大小上与 LR(0)/SLR 相当分析能力介于 SLR 和 LR(1) 二者之间 SLR&lt;LALR(1)&lt;LR(1)合并后的展望符集合仍为 FOLLOW 集的子集第七章 语义分析和中间代码生成中间语言特点和作用特点：独立于机器复杂性界于源语言和目标语言之间引入中间语言的优点：使编译程序的结构在逻辑上更为简单明确便于进行与机器无关的代码优化工作易于移植常见的中间语言：后缀式，逆波兰表示图表示： 抽象语法树(AST)、有向无环图(DAG)三地址代码三元式四元式间接三元式后缀式后缀式，又称逆波兰表示法，定义：如果 E 是一个变量或常量，则 E 的后缀式是 E 自身。如果 E 是 E1 op E2 形式的表达式，其中 op 是任何二元操作符，则 E 的后缀式为 E1′ E2′ op，其中 E1′ 和E2′ 分别为 E1 和 E2 的后缀式。如果 E 是 (E1) 形式的表达式，则 E1 的后缀式就是 E 的后缀式。中缀表达式翻译成后缀式的翻译模式：数组 POST 存放后缀式：k 为下标，初值为 1a+b+c 的分析和翻译：图表示三地址代码三地址代码可以看成是抽象语法树或有向无环图的一种线性表示三地址语句的种类：x:=y op zx:=op yx:=ygoto Lif x relop y go L或if a goto L传参、转子：param x、call p,n返回语句：return y地址和指针赋值：x:=&amp;y、x:=*y、*x:=y索引赋值：x:=y[i]、x[i]:=四元式一个带有四个域的记录结构，这四个域分别称为 op, arg1, arg2 及 resulta:=b*(-c)+b*(-c)的四元式形式三元式用三个域表示：op、arg1 和 arg2计算结果引用：引用计算该值的语句的位置a:=b*(-c)+b*(-c) 的三元式形式x[i] := yx := y[i]间接三元式思想：三元式表+间接码表间接码表一张指示器表，按运算的先后次序列出有关三元式在三元式表中的位置优点：方便优化，节省空间a:=b*(-c)+b*(-c) 的间接三元式形式：语句 X:=(A+B)*C; Y:=D↑(A+B) 的间接三元式：赋值语句的翻译构造语义和适合一遍扫描的翻译模式用属性文法描述语义赋值赋值语句的属性文法和翻译模式简单算术表达式及赋值语句：赋值语句的形式id:=E赋值语句的意义 (功能)对表达式 E 求值并置于变量 T 中id.place:=T赋值语句生成三地址代码的 S-属性文法：非终结符号 S 有综合属性 S.code它代表赋值语句 S 的三地址代码非终结符号 E 有两个属性E.place ：存放 E 值的单元的名字 (地址)E.code ：对 E 求值的三地址语句序列函数 newtemp 功能：返回一个不同的临时变量名字，如 T1, T2, …过程 emit ：将三地址代码送到输出文件中 产生式语义规则翻译模式S→id:=ES.code := E.code || gen(id.place ‘:=’ E.place){ p:=lookup(id.name);if p≠nil then emit(p ‘:=’ E.place)else error }E→E1+E2E.place:=newtemp;E.code:=E1.code || E2.code || gen(E.place ‘:=’ E1.place ‘+’ E2.place){ E.place:=newtemp;emit(E.place ‘:=’ E1.place ‘+’ E2.place)}E→E1*E2E.place:=newtemp;E.code:=E1.code || E2.code || gen(E.place ‘:=’ E1.place ‘*’ E2.place){ E.place:=newtemp;emit(E.place ‘:=’ E1.place ‘*’ E2.place)}E→-E1E.place:=newtemp;E.code:=E1.code || gen(E.place ‘:=’ ‘uminus’ E1.place){ E.place:=newtemp;emit(E.place‘:=’ ‘uminus’ E 1.place)}E→ (E1)E.place:=E1.place;E.code:=E1.code{ E.place:=E1.place }E→idE.place:=id.place;E.code=‘ ’{ p:=lookup(id.name);if p≠nil then E.place:=pelse error }数组元素引用的翻译数组元素引用：$X := A[i_1,i_2,\\cdots,i_k] + Y$$A[i_1,i_2,\\cdots,i_k] := X + Y $数组元素地址的计算：设 A 为 n 维数组，按行存放，每个元素宽度为 w$low_i$ 为第 i 维的下界$up_i$ 为第 i 维的上界$n_i$ 为第i维可取值的个数 $(n_i = up_i -low_i + 1)$$base$ 为 A 的第一个元素相对地址元素 $A[i_1,i_2,\\cdots,i_k]$ 相对地址公式：不变部分：$\\text{base-}\\left(\\left(\\ldots\\left(\\left(low_{1}, n_{2}+ lo w_{2}\\right) n_{3}+lo w_{3}\\right) \\dots\\right) n_{k}+lo w_{k}\\right) \\times w $加可变部分 $\\left.\\left(\\left(\\ldots i_{1} n_{2}+i_{2}\\right) n_{3}+i_{3}\\right) \\ldots\\right) n_{k}+i_{k} j \\times w$id 出现的地方也允许下面产生式中的 L 出现L → id [ Elist ] | idElist → Elist,E | E为了便于处理，文法改写为L → Elist ] | idElist → Elist, E | id [ E引入下列语义变量或语义过程Elist.ndim：下标个数计数器Elist.place：保存临时变量的名字，这些临时变量存放已形成的 Elist 中的下标表达式计算出来的值Elist.array：保存数组名limit(array，j) ：函数过程，它给出数组 array 的第 j 维的长度代表变量的非终结符 L 有两项语义值L.place若 L 为简单变量 i, 指变量 i 的符号表入口若 L 为下标变量，指存放不变部分的临时变量的名字L.offset若 L 为简单变量，null若 L 为下标变量，指存放可变部分的临时变量的名字产生式翻译模式S→L:=E{ if L.offset=null then emit(L.place ‘:=’ E.place) （即 L是简单变量）else emit( L.place ‘ [’ L.offset ‘]’ ‘:=’ E.place)}E→E1 +E2{ E.place:=newtemp;emit(E.place ‘:=’ E 1.place ‘+’ E 2.place)}E→(E1){E.place:=E1.place}E→L{ if L.offset=null then E.place:=L.place （即 L 是简单变量）else beginE.place:=newtemp;emit(E.place ‘:=’ L.place ‘[’ L.offset ‘]’ )end }Elist→id [ E{ Elist.place:=E.place;Elist.ndim:=1;Elist.array:=id.place }Elist→ Elist1, E{ t:=newtemp;m:=Elist1.ndim+1;emit(t ‘:=’ Elist1.place ‘*’ limit(Elist1.array,m) );emit(t ‘:=’ t ‘+’ E.place);Elist.place:=t;Elist.ndim:=mElist.array:= Elist1.array; }L→Elist ]{ L.place:=newtemp;emit(L.place ‘:=’ Elist.array ‘－’ C);L.offset:=newtemp;emit(L.offset ‘:=’ w ‘*’ Elist.place) }L→id{ L.place:=id.place; L.offset:=null }类型转换例子：x := y＋i*j，其中 x、y 为实型；i、j 为整型该赋值句产生的三地址代码为：1234T1 := i int* jT3 := inttoreal T1T2 := y real+ T3x := T2类型转换：用 E.type 表示非终结符 E 的类型属性产生式 E→E1 op E2 的语义动作中关于 E.type 的语义规则可定义为：{ if E1.type=integer and E2.type=integerE.type:=integerelse E.type:=real }产生式 E→E1＋E2 的语义动作：12345678910111213141516171819202122{ E.place:=newtemp; if E1.type=integer and E2.type=integer then begin emit (E.place ‘:=’ E 1.place ‘int+’ E 2.place); E.type:=integer end else if E1.type=real and E2.type=real then begin emit (E.place ‘:=’ E 1.place ‘real+’ E 2.place); E.type:=real end else if E1.type=integer and E2.type=real then begin u:=newtemp; emit (u ‘:=’ ‘inttoreal’ E 1.place); emit (E.place ‘:=’ u ‘real+’ E 2.palce); E.type:=real end else if E1.type=real and E2.type=integer then begin u:=newtemp; emit (u ‘:=’ ‘inttoreal’ E 2.place); emit (E.place ‘:=’ E 1.place ‘real+’ u); E.type:=real end else E.type:=type_error}布尔表达式的翻译文法：E → E or E | E and E | not E | (E) | i rop i | i用途：用于逻辑演算，计算逻辑值；用于控制语句的条件式数值表示法如果计算算术表达式一样一步步算，例子：A or B and C&gt;D 翻译成a&lt;b 的关系表达式可等价地写成 if a&lt;b then 1 else 0，翻译成100: if a&lt;b goto 103101: T := 0102: goto 104103: T := 1104:翻译模式：过程 emit 将三地址代码送到输出文件中nextstat：输出序列中下一条三地址语句的地址索引过程 emit 每产生一条指令，nextstat 加 1产生式翻译模式E→E1 or E2{ E.place:=newtemp;emit(E.place ‘:=’ E 1.place ‘or’ E2.place)}E→E1 and E2{ E.place:=newtemp;emit(E.place ‘:=’ E 1.place ‘and’ E2.place)}E→not E1{ E.place:=newtemp;emit(E.place ‘:=’ ‘not’ E 1.place) }E→(E1){ E.place:=E1.place }E→id1 relop id2{ E.place:=newtemp;emit(‘if’ id1.place relop.op id2.place ‘goto’ nextstat+3);emit(E.place ‘:=’ ‘0’);emit(‘goto’ nextstat+2);emit(E.place‘:=’ ‘1’) }E→id{ E.place:=id.place }布尔表达式 a&lt;b or c&lt;d and e&lt;f 的翻译结果：100: if a&lt;b goto 103101: T1:=0102: goto 104103: T1:=1104: if c&lt;d goto 107105: T2:=0106: goto 108107: T2:=1108: if e&lt;f goto 111109: T3:=0110: goto 112111: T3:=1112: T4:=T2 and T3113: T5:=T1 or T4带优化的翻译法适用于作为条件表达式的布尔表达式使用，例子：把 A or B 解释成 if A then true else B把 A and B 解释成 if A then B else false把 not A 解释成 if A then false else true作为条件控制的布尔式翻译：条件语句 if E then S1 else S2赋予E 两种出口:一真一假条件语句的翻译：if a&gt;c or b &lt;d then S1 else S2 翻译成三地址代码布尔表达式的属性文法：语义函数 newlabel，返回一个新的符号标号对于一个布尔表达式 E，设置两个继承属性E.true 是 E 为 ‘真’ 时控制流转向的标号E.false 是 E 为 ‘假’ 时控制流转向的标号E.code 记录 E 生成的三地址代码序列产生式语义规则E→E1 or E2E1.true:=E.true;E1.false:=newlabel;E2.true:=E.true;E2.false:=E.false;E.code:=E1.code || gen(E1.false ‘:’) || E2.codeE→E1 and E2E1.true:=newlabel;E1.false:=E.false;E2.true:=E.true;E2.false:=E.fasle;E.code:=E1.code || gen(E1.true ‘:’) || E2.codeE→not E1E1.true:=E.false;E1.false:=E.true;E.code:=E1.codeE→ (E1)E1.true:=E.true;E1.false:=E.false;E.code:=E1.codeE→id1 relop id2E.code:=gen(‘if ’ id1.place relop.op id2.place ‘goto’ E.true) || gen(‘goto’ E.false)E→trueE.code:=gen(‘goto’ E.true)E→falseE.code:=gen(‘goto’ E.false)例子：翻译 a&lt;b or c&lt;d and e&lt;f假定整个表达式的真假出口已分别置为 Ltrue 和 Lfalse。一遍扫描的翻译模式布尔表达式的翻译：两遍 (多遍) 扫描为给定的输入串构造一棵语法树遍历语法树，进行语义规则中规定的翻译一遍扫描以四元式为中间语言四元式存入一个数组中，数组下标代表四元式的标号约定四元式(jnz, a, -, p) 表示 if a goto p四元式 (jrop, x, y, p) 表示 if x rop y goto p四元式 (j, -, -, p) 表示 goto p过程 emit 将四元式代码送到输出数组中回填：产生跳转四元式时，它的转移地址无法立即知道 （例如上图中的 100 一开始并不知道第四区段要填 104）需要以后扫描到特定位置时才能回过头来确定把这些未完成的四元式地址作为 E 的语义值保存, 待机 “回填”为非终结符 E 赋予两个综合属性 E.truelist 和 E.falselist。它们分别记录布尔表达式 E 所对应的四元式中需回填 “真”、“假” 出口的四元式的标号所构成的链表例如，假定 E 的四元式中需要回填 “真” 出口的 p，q，r 三个四元式，则 E.truelist 为下列链:引入语义变量和过程变量 nextquad它指向下一条将要产生但尚未形成的四元式的地址 (标号)nextquad 的初值为1，每当执行一次emit之后，nextquad 将自动增1函数 makelist(i)它将创建一个仅含 i 的新链表，其中 i 是四元式数组的一个下标 (标号)；函数返回指向这个链的指针函数 merge(p1,p2)把以 p1 和 p2 为链首的两条链合并为一，作为函数值，回送合并后的链首过程 backpatch(p, t)其功能是完成“回填”，把 p 所链接的每个四元式的第四区段都填为 t布尔表达式的翻译模式：产生式翻译模式(7) M→ε{ M.quad:=nextquad }(1) E→E1 or M E2{ backpatch(E1.falselist, M.quad);E.truelist:=merge(E1.truelist, E2.truelist);E.falselist:=E2.falselist }(2) E→E1 and M E2{ backpatch(E1.truelist, M.quad);E.truelist:=E2.truelist;E.falselist:=merge(E1.falselist,E2.falselist) }(3) E→not E1{ E.truelist:=E1.falselist;E.falselist:=E1.truelist}(4) E→(E1){ E.truelist:=E1.truelist;E.falselist:=E1.falselist}(5) E→id1 relop id2{ E.truelist:=makelist(nextquad);E.falselist:=makelist(nextquad+1);emit(‘j’ relop.op ‘,’ id 1.place ‘,’ id 2.place‘,’ ‘0’);emit(‘j, －, －, 0’) }(6) E→id{ E.truelist:=makelist(nextquad);E.falselist:=makelist(nextquad+1);emit(‘jnz’ ‘,’ id .place ‘,’ ‘－’ ‘,’ ‘0’)；emit(‘ j, -, -, 0’) }例子：翻译 a&lt;b or c&lt;d and e&lt;f课本上更详细的版本：控制语句的翻译常见控制语句：S → if E then S1S → if E then S1 else S2S → while E do S1属性文法与属性计算产生式语义规则S → if E then S1E.true:=newlabel;E.flase:=S.next;S1.next:=S.nextS.code:=E.code || gen(E.true ‘:’) || S1.codeS → if E then S1 else S2E.false:=newlabel;S1.next:=S.nextS2.next:=S.next;S.code:=E.code || gen(E.true ‘:’) || S1.code || gen(‘goto’ S.next) || gen(E.false ‘:’) || S2.codeS → while E do S1S.begin:=newlabel;E.true:=newlabel;E.false:=S.next;S1.next:=S.begin;S.code:=gen(S.begin ‘:’) || E.code || gen(E.true ‘:’) || S1.code || gen(‘goto’ S.begin)例子，翻译：while a&lt;b doif c&lt;d then x:=y+z else x:=y-z一遍扫描翻译控制语句和自下而上结合的一遍扫描翻译控制语句if 语句的文法与翻译模式：相关产生式S → if E then S1S → if E then S1 else S2改写后的产生式S → if E then M S1S → if E then M1 S1 N else M2 S2M → εN → ε产生式翻译模式3. M→ε{ M.quad:=nextquad }4. N→ε{ N.nextlist:=makelist(nextquad);emit(‘j,－,－,－’) }1. S→if E then M S1{ backpatch(E.truelist, M.quad);S.nextlist:=merge(E.falselist, S1.nextlist) }2. S→if E then M1 S1 N else M2 S2{ backpatch(E.truelist, M1.quad);backpatch(E.falselist, M2.quad);S.nextlist:=merge(S1.nextlist, N.nextlist, S2.nextlist) }if 语句的文法与翻译模式：相关产生式S → while E do S1改写后的产生式S → while M1 E do M2 S1M → ε产生式翻译模式2. M → ε{ M.quad := nextquad }1. S → while M1 E do M2 S1{ backpatch(E.truelist, M2.quad);backpatch(S1.nextlist, M1.quad);S.nextlist := E.falselist;emit(‘j,－,－,’ M1.quad) }复合语句的文法：相关产生式S → begin L endL → L ; S | S改写后的产生式S → begin L endL → L1; M S | SM → ε产生式翻译模式3. M → ε{ M.quad := nextquad }2. L → L1; M S{ backpatch(L1.nextlist, M.quad);L.nextlist := S.nextlist }1. S → begin L end{ S.nextlist := L.nextlist }其它几个语句的翻译：S → A { S.nextlist := makelist( ) }L → S { L.nextlist := S.nextlist }例子 7.6，翻译：while a&lt;b doif c&lt;d then x:=y+z else x:=y-z第十章 优化优化的基本概念优化：对程序进行各种等价变换，使得从变换后的程序出发，能生成更有效的目标代码。等价：不改变程序的运行结果有效：目标代码运行时间短，占用存储空间小目的：产生更高效的代码遵循的原则：等价原则：优化不应改变程序运行的结果有效原则：使优化后所产生的目标代码运行时间较短，占用的存储空间较小合算原则：应尽可能以较低的代价取得较好的优化效果优化的级别：局部优化、循环优化、全局优化优化的种类：删除多余运算(删除公用子表达式)合并已知量复写传播删除无用赋值代码外提强度消弱变换循环控制条件优化的实例：123456789101112131415161718void quicksort (m, n);int m, n;{ int i, j; int v, x; if (n&lt;=m) return; /* fragment begins here*/ i=m-1; j=n; v=a [n]; while (1) { do i=i+1; while (a [i]&lt;v); do j=j-1; while (a [ j]&gt;v); if (i&gt;=j) break; x=a [i]; a[i]=a [ j]; a[ j]=x; } x=a[i]; a[i]=a [n]; a [n]=x; /*fragment ends here*/ quicksort (m, j); quicksort (i+1, n);}中间代码程序段： 复写传播后：删除无用赋值后：强度削弱后：删除归纳变量后：优化类型：局部优化局限于基本块范围内的优化循环优化可能反复执行的代码序列全局优化局部优化基本块：程序中一顺序执行语句序列，其中只有一个入口和一个出口。入口就是其中第一个语句，出口就是其中最后一个语句对三地址语句为 x:=y+z，称对 x 定值并引用 y 和 z基本块中的一个名字在程序中的某个给定点是活跃的，是指如果在程序中 (包括在本基本块或在其它基本块中) 它的值在该点以后被引用基本块划分算法：找出中间语言 (三地址语句) 程序中各个基本块的入口语句：程序第一个语句或能由条件转移语句或无条件转移语句转移到的语句或紧跟在条件转移语句后面的语句对以上求出的每个入口语句，确定其所属的基本块。它是由 该入口语句到下一入口语句 (不包括该入口语句)或 一转移语句 (包括该转移语句)或 一停语句 (包括该停语句)之间的语句序列组成的凡未被纳入某一基本块中的语句，可以从程序中删除基本块划分示例、流图：流图以基本块为结点构成流图，前驱和后继的概念基本块的 DAG 表示：扩充，增加标记和附加信息图的叶结点以一标识符或常数作为标记，表示该结点代表该变量或常数的值图的内部结点以一运算符作为标记，表示该结点代表应用该运算符对其后继结点所代表的值进行运算的结果各个结点上可能附加一个或多个标识符 (称附加标识符) 表示这些变量具有该结点所代表的值四元式DAG 图0型: A:=B( :=，B，-，A)1型: A:=op B(op，B，-，A)2型: A:=B op C(op，B，C，A)2型: A:=B[C](=[]，B，C，A)2型: if B rop C goto (s)( jrop，B，C，(s))3型: D[C]:=B([]=，B，D，C)0型: goto (s)( j，-，-，(s))基本块的优化算法：一个基本块，可用一个DAG来表示对基本块中每一条四元式代码，依次构造对应的 DAG 图，最后基本块中所有四元式构造出来 DAG 连成整个基本块的 DAG步骤：准备操作数的结点如果 NODE(B) 无定义，则构造一标记为 B 的叶结点并定义 NODE(B) 为这个结点;如果当前四元式是 0 型，则记 NODE(B) 的值为 n，转 4。如果当前四元式是 1 型，则转 2(1)如果当前四元式是 2 型，则 (i) 如果 NODE(C) 无定义，则构造一标记为 C 的叶结点并定义NODE(C)为这个结点；(ii) 转2(2)合并已知量(1) 如果 NODE(B) 是标记为常数的叶结点，则转 2(3)；否则，转 3(1)(2) 如果 NODE(B) 和 NODE(C) 都是标记为常数的叶结点，则转2(4)；否则，转3(2)(3) 执行 op B (即合并已知量)。令得到的新常数为 P。如果 NODE(B) 是处理当前四元式时新构造出来的结点，则删除它。如果 NODE(P) 无定义，则构造一用P作标记的叶结点 n。置 NODE(P)=n，转4(4)执行 B op C (即合并已知量)。令得到的新常数为P。如果 NODE(B) 或 NODE(C) 是处理当前四元式时新构造出来的结点，则删除它。如果 NODE(P) 无定义，则构造一用P作标记的叶结点n。置 NODE(P)=n，转4删除公共子表达式(1) 检查 DAG 中是否已有一结点，其唯一后继为 NODE(B) 且标记为 op(即公共子表达式)。如果没有，则构造该结点 n，否则，把已有的结点作为它的结点并设该结点为 n。转4。(2) 检查 DAG中是否已有一结点，其左后继为 NODE(B)，右后继为 NODE(C)，且标记为 op(即公共子表达式)。如果没有，则构造该结点n，否则，把已有的结点作为它的结点并设该结点为 n。转4。删除无用赋值如果 NODE(A) 无定义，则把 A 附加在结点 n 上并令 NODE(A)=n; 否则，先把 A 从 NODE(A) 结点上的附加标识符集中删除(注意，如果 NODE(A) 是叶结点，则其 A 标记不删除)。把 A 附加到新结点 n 上并置 NODE(A)=n。转处理下一四元式。从 DAG 中得到的优化信息：在基本块外被定值并在基本块内被引用的所有标识符，就是作为叶子结点上标记的那些标识符在基本块内被定值并且该值在基本块后面可以被引用的所有标识符，就是 DAG 各结点上的那些标记或者附加标识符循环循环优化的措施：代码外提强度消弱删除归纳变量(变换循环控制条件)循环展开循环合并代码外提：所谓变量 A 在某点 d 的定值到达另一点 u（或称变量 A 的定值点 d 到达另一点 u），是指流图中从 d 有一通路到达 u 且该通路上没有 A 的其它定值循环不变运算：对四元式 A:=B op C，若 B 和 C 是常数，或者到达它们的 B 和 C 的定值点都在循环外 * 查找循环中不变运算的算法： * 依次查看 L 中各基本块的每个四元式，如果它的每个运算对象或为常数，或者定值点在 L 外，则将此四元式标记为 \"不变运算\"; * 重复第 3 步直至没有新的四元式被标记为 \"不变运算\" 为止; * 依次查看尚未被标记为 \"不变运算\" 的四元式，如果它的每个运算对象或为常数，或定值点在 L 之外，或只有一个到达-定值点且该点上的四元式已被标记为 \"不变运算\"，则把被查看的四元式标记为\"不变运算\"。 把循环不变运算提到循环体外（前置结点）简单的代码外提示例：更复杂的情况下无法如此四元式 S(A:=B OP C）外提的条件强度削弱：把程序中执行时间较长的运算转换为执行时间较短的运算通常是针对循环控制变量有线性关系的变量赋值进行经过强度消弱后，循环中可能出现一些新的无用赋值对于消弱下标变量地址计算的强度非常有效示例：删除归纳变量：如果循环中对变量 I 只有唯一的形如 I:=I±C 的赋值，且其中 C 为循环不变量，则称 I 为循环中的基本归纳变量如果 I 是循环中一基本归纳变量，J 在循环中的定值总是可化归为 I 的同一线性函数也即 J=C1*I± C2，其中 C1 和 C2 都是循环不变量，则称 J 是归纳变量，并称它与 I 同族。基本归纳变量也是归纳变量删除归纳变量在强度削弱后进行示例：强度削弱和删除归纳变量可以统一算法框架第十一章 目标代码生成概述任务：把分析、翻译、优化后的中间代码变换成目标代码输入：源程序的中间表示，以及符号表中的信息类型检查输出：绝对指令代码：能够立即执行的机器语言代码，所有地址已经定位可重新定位指令代码：待装配的机器语言模块，执行时，由连接装配程序把它们和某些运行程序连接起来，转换成能执行的机器语言代码汇编指令代码：需要经过汇编程序转换成可执行的机器语言代码目标代码生成要考虑的问题：如何充分利用计算机的寄存器，减少目标代码中访问存贮单元的次数在寄存器分配期间，为程序的某一点选择驻留在寄存器中的一组变量在随后的寄存器指派阶段，挑出变量将要驻留的具体寄存器目标机器模型引入：具有多个通用寄存器，可用作累加器和变址器运算必须在某个寄存器中进行含有四种类型的指令形式 目标代码生成最简单的代码生成不考虑代码执行效率以基本块为单位生成目标代码依次把四元式的中间代码变换成目标代码在基本块的范围内考虑如何充分利用寄存器进入基本块时，所有寄存器空闲离开基本块时，把存在寄存器中的现行的值存回主存中，释放所有寄存器不特别说明，所有说明变量在基本块出口之后均为非活跃变量在一个基本块的范围内考虑充分利用寄存器待用信息和活跃信息的表示：二元组 (x, x) 表示变量的待用信息和活跃信息第 1 元：i 表示待用信息， ^ 表示非待用第 2 元：y 表示活跃，^ 表示非活跃待用信息和活跃信息的变化(x，x)→(x，x)，用后者更新前者计算算法：把基本块中各变量的符号表中的待用信息栏填为“非待用”，并根据该变量在基本块出口之后是不是活跃的，把其中的活跃信息栏填为“活跃”或“非活跃”；从基本块出口到入口由后向前依次处理各个四元式 i:A:=B op C：1) 把符号表中变量 A 的待用信息和活跃信息附加到四元式i上；2) 把符号表中 A 的待用信息和活跃信息分别置为 “非待用” 和 “非活跃”；3) 把符号表中变量 B 和 C 的待用信息和活跃信息附加到四元式i上；4) 把符号表中 B 和 C 的待用信息均置为 i，活跃信息均置为 “活跃”；计算示例：变量地址描述和寄存器描述：变量地址描述数组 AVALUE动态记录各变量现行值的存放位置AVALUE[A]={R1, R2, A}寄存器描述数组RVALUE动态记录各寄存器的使用信息RVALUE[R]={A,B}表明 AB 变量值相同存在 R对于四元式 A:=B如果 B 的现行值在某寄存器 Ri 中，则无须生成目标代码只须在 RVALUE(Ri) 中增加一个 A，(即把 Ri 同时分配给 B 和 A)，并把 AVALUE(A) 改为 Ri记录这些的作用是，尽量先不存数，减少指令的生成，如果变量后面要用再存（延迟）带寄存器分配优化的代码生成算法，对每个四元式: i: A:=B op C，依次执行：以四元式 : i: A:=B op C 为参数，调用函数过程 GETREG(i: A:=B op C)，返回一个寄存器 R，用作存放 A 的寄存器利用 AVALUE[B] 和 AVALUE[C]，确定 B 和 C 现行值的存放位置 B’ 和 C’。如果其现行值在寄存器中，则把寄存器取作 B’ 和 C’如果 B’≠R，则生成目标代码：LD R, B’op R, C’否则生成目标代码 op R, C’如果 B’ 或 C’ 为 R，则删除 AVALUE[B] 或 AVALUE[C] 中的 R令 AVALUE[A]={R}, RVALUE[R]={A}若 B 或 C 的现行值在基本块中不再被引用，也不是基本块出口之后的活跃变量，且其现行值在某寄存器 Rk 中，则删除 RVALUE[Rk] 中的 B 或 C 以及 AVALUE[B] 或 AVALUE[C] 中的 Rk ，使得该寄存器不再为 B 或 C 占用寄存器分配算法 GETREG(i: A:=B op C)返回一个用来存放 A 的值的寄存器策略：尽可能用 B 独占的寄存器尽可能用空闲寄存器抢占非空闲寄存器(1) 如果 (B 的现行值在某个寄存器 Ri 中 &amp;&amp; RVALUE[Ri] 中只包含 B) &amp;&amp; (B 与 A 是同一个标识符 || B 的现行值在执行四元式 A:=B op C 之后不会再引用)则选取 Ri 为所需要的寄存器 R，并转 (4)(2) 如果有尚未分配的寄存器，则从中选取一个 Ri 为所需要的寄存器 R，并转 (4)(3) 从已分配的寄存器中选取一个 Ri 为所需要的寄存器 R。尽量满足(占用 Ri 的变量的值也同时存放在该变量的贮存单元中 || 在基本块中要在最远的将来才会引用到或不会引用到)为 Ri 中的变量生成必要的存数指令。(4) 给出 R，返回生成存数指令 （针对 GETREG(i: A:=B op C)）对 RVALUE[Ri] 中每一变量 M需要存数的条件： ( M 不是 A || ( M 是 A 又是 C &amp;&amp; M 不是 B &amp;&amp; B 不在 RVALUE[Ri] 中存数的操作：(1) 如果 AVALUE[M] 不包含 M，则生成目标代码 ST Ri, M(2) 如果 M 是 B || (M 是 C &amp;&amp; B 在 RVALUE[Ri] 中)，则令 AVALUE[M]={M， Ri} ，否则令 AVALUE[M]={M}(3) 删除 RVALUE[Ri] 中的 M示例：DAG 的目标代码引入：假设可用寄存器为 $R_0$ 和 $R_1$，$T_4$ 是基本块出口的活跃变量从上图中看出，经过 DAG 图后重构的四元式序列顺序，造成了不同的目标代码长度因为，执行的顺序省去了存值指令不难发现，$T_4 := A+B-(E-(C+D))$ ，左边的四元式序列对应着从左往右算，右边的则对应从右往左算基本块中间代码序列重排 - 算法：设 DAG 有 N 个内部结点，T 是一个线性表，它共有 N 个登记项，算法的步骤如下。12345678910111213// 置初值FOR k:=1 TO NDO T[k]:=null;i := N;WHILE 存在未列入T的内部节点 : 选取一个 未列入T但其全部父节点均已列入T 或者 没有父节点的内部节点 n; T[i]:=n; i:=i-1; // 把 n 列入 T 中 WHILE n的最左子节点m不是叶子且其全部父节点均已列入T中 : T[i]:=m; i:=i-1; n:=m; // 最后T[1], T[2], ..., T[n]就是所求的节点顺序例子：","link":"/CS/Compilation-Principles-Study-Notes/"},{"title":"计算机图形学-学习笔记","text":"第1章 绪论全书概述图形学基本知识光栅图形学扫描转换、区域填充、裁减、反走样、消隐二维、三维图形变换及观察准均匀 B 样条曲线几何造型参数曲线曲面基本概念、Bezier曲线曲面、B样条曲线等真实感图形学颜色模型、简单光照模型、纹理映射、光线跟踪计算机图形学定义计算机图形学计算机图形是计算机产生的图像。计算机图形学就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理和算法。IEEE定义：Comput graphics is the art or science of producing graphical images with the aid of computer.计算机图形学的发展和应用在某种意义上已成为计算机软、硬件发展水平的标志。计算机图形学研究内容主要研究内容如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法，构成了计算机图形学的主要研究内容。计算机生成一副表示物体的图形的三个步骤造型技术在计算机中建立所要生成图像的物体的模型，即给出表示该物体的几何数据和拓扑关系比如教室里的桌子、椅子、墙，用圆柱、平面等表示出来。光照模型希望用一些简单的数学模型来近似、代替那些物理学的模型，为模拟物体表面的光照物理现象的数学模型叫光照模型。绘制（渲染）技术选择适当的绘制算法来把这个场景画 (渲染) 出来。绘制一幅三维物体图像所涉及的知识，实际上就是计算机图形中每个像素看上去应该是什么颜色的问题。计算机图形的发展方向准确性 -&gt; 真实性 -&gt; 实时性计算机图形学的发展历史1950年，第一台图形显示器作为美国麻省理工学院 (MIT) 旋风 I 号计算机的附件诞生。1963年，Suther land 发表博士论文。其中第一次提出了 graphics 这个词。Suther land 被公认为开创交互式图形技术的奠基人，被称为 “计算机图形学之父”，并于 1988 年获 “图灵奖”。1962年，雷诺汽车公司的工程师 Bezier 提出 Bezier 曲线、曲面的理论，成为 CAGD (计算机辅助几何设计) 的先驱。1964年，MIT教授 Steven A. Coons 提出了超限插值的新思想，通过插值四条任意的边界曲线来构造曲面。70年代，光栅显示器出现了。光栅显示器屏幕是由像素组成的，由此诞生了大量算法，如区域填充、裁剪、消隐等基本图形概念、及其相应算法。真实感图形和几何造型技术这个时候也开始出现了。1975年，Phong 提出了著名的简单光照模型 - Phong模型 (标志着真实感图形的出现和实用化，直到现在 Phong 模型还被大量的采用)1980年，Whitted 提出了光透视模型 - Whitted 模型，成为第一次提出光线跟踪算法的范例。几何造型技术：通俗地讲，该技术就像小孩搭积木，用简单的一些体素来构建复杂的模型。计算机图形学的应用领域人机交互和图形用户界面最理想的是开发 “能听、能说、能理解人类语言” 的计算机，人们可以和计算机交谈，而不像现在这样仅限于窗口、图标、鼠标、指针 (WIMP) 界面。计算机辅助设计与制造 (CAD/CAM)CAD/CAM 是计算机图形学在工业界最广泛、最活跃的应用领域。飞机、汽车、船舶、宇宙飞船的外形设计发电厂、化工厂等的布局真实感图形实时绘制与自然景物仿真计算机中重现真实世界的场景叫做真实感绘制。计算机动画、游戏、电影计算机艺术计算机艺术是科学与技术相结合的一门新兴的交叉学科，是计算机应用的一个崭新、富有时代气息的领域。计算机仿真计算机仿真是计算机技术建立被仿真系统的模型，并在某些实验条件下对模型进行动态实验的一门综合性技术。科学计算可视化虚拟现实虚拟现实是利用计算机模拟现实的场景，使参与者获得与现实一样的感觉。准确地说，是利用电脑模拟产生一个三维空间的虚拟世界，提供使用者关于视觉、听觉、触觉等感官的模拟，让使用者如同身历其境一般，可以及时、没有限制地观察三度空间内的事物。地理信息系统地理信息系统是建立在地理图形之上的关于各种资源的综合信息管理系统，是计算机图形学的一个重要应用领域。农业上的应用借助计算机图形生成技术来保存和再现不同作物种类和不同生长时期的植物形态，模拟植物的生长过程，从而合理地进行选种、播种、田间管理以及收获等。计算机图形系统组成五大功能一个交互式计算机图形系统应具有计算、存储、对话、输入和输出等 5 个方面的功能。图形系统图形软件图形应用数据结构：对应一组图形数据文件，其中存放着欲生成的图形对象的全部描述信息。图形应用软件解决某种应用问题的图形软件，是图形系统中的核心部分，包括了各种图形生成和处理技术。如：photoshop、3Dmax等。图形支撑软件：大多数图形应用程序是建立在一定的图形支撑软件上。图形支撑软件需具有规范接口。图形硬件图形显示设备阴级射线管使用广泛：现在的图形显示设备绝大多数是基于阴极射线管 (CRT) 的显示器。阴极射线管的技术指标分辨率：一个阴极射线管在水平和垂直方向单位长度上能识别出的最大光点数称之为分辨率。光点亦称之为像素 (pixel)。显示速度要保持荧光屏上有稳定的图像就必须不断地发射电子束。只有刷新频率高到一定值后，图像才能稳定显示。大约达到每秒 60 帧即 60Hz 时，人眼才能感觉到屏幕不闪烁，要人眼觉得舒服，一般必须有 85Hz 以上的刷新频率。彩色阴极射线管三只电子枪，分别涂有红、绿、蓝三种颜色的光。CRT图形显示器随机扫描的图形显示器 (画线设备)电子束的扫描轨迹随显示内容而变化，只在需要的地方扫描，而不必全屏扫描，因此速度快，图像清晰。一条线一条线地画图，因此也称为向量显示器。随机扫描系统是为画线应用设计的，因此不能显示逼真的有阴影场景。光栅扫描显示器 (画点设备)不能直接从一个可编地址的像素画一条直线到另一个可编地址的像素，只可能用尽可能靠近这条直线路径的像素点来近似地表示这条直线。在光栅扫描系统中，电子束横向扫描屏幕，一次一行，从上到底顺次进行。当电子束横向沿每一行移动时，电子束的强度不断变化来建立亮点的图案。由于光栅扫描系统具有存储每一个屏幕点亮度信息的能力，所以，最适合显示浓淡和色彩图形。例题：显卡有 2MB 显存，当分辨率为 1024×768 时，可支持的色彩数是多少？$2MB = 2\\times 1024 \\times 1024 =2097152 (字节)$$1024\\times 768 = 786432 (个像素) $每个像素如果需要 3 个字节表示，将超过 2MB 显存，最多只需要 2 个字节表示，故只能支持 64K 色彩数图形学相关概念分辨率光点光点指电子束打在显示器荧光屏上，显示器能够显示的最小的发光点，一般用其直径来表明光点的大小。像素点像素点是指图形显示在屏幕上时候，按当前的图形显示分辨率所能提供的最小元素点。屏幕分辨率屏幕上显示的像素个数，以 (水平像素数 * 垂直像素数) 表示。显示分辨率是计算机显示控制器所能够控制的显示模式分辨率，简称显示模式。对于文本显示方式，显示分辨率用水平和垂直方向上所能显示的字符总数的乘积来表示。对于图形显示方式，则用水平和垂直方向上所能显示的像素点总数的乘积来表示。显卡分辨率显卡分辨率就是表示显卡输出给显示器，并能在显示器上描绘像素点的数量。一台电脑的最高分辨率是由显卡和显示器共同决定的。显示器最高分辨率是可以显示出来的最大分辨率。显卡的最大分辨率是最大能支持多少分辨率。电脑的最高分辨率取决于显卡和显示器最低的一个。显示器的点距指相邻像素点之间的距离。两点之间的距离越小越好。15寸显示器，点距达到0.28mm就足够。17寸显示器，需要0.27mm、0.25mm等。显示卡的作用与性能指标显示卡的基本作用就是显示图文，显示卡和显示器构成了计算机的显示系统。除了CPU和内存外，显卡对计算机的显示性能起着决定性的作用。图形图像的区别及存储格式图形图像的区别说法一图形是由计算机绘制而成的，而图像则是人为的用外部设备所捕捉到的外部的景象。说法二图形是矢量图，而图像是位图 (点阵图)图形 (像) 的构成属性几何属性刻画对象的轮廓、形状。包括点、线、面、体等。非几何属性视觉属性，刻画对象的颜色、材质等。包括明暗、色彩、纹理、透明性、线型、线宽。从构图要素上看，将图形分为两类几何属性有突出作用：工程图、等高线地图、曲面的线框图非几何属性有突出作用 (明暗图)：真实感图形位图和矢量图定义位图 (点阵图)点阵图或像素图，计算机屏幕上的图是由屏幕上的像素构成的，每个点用二进制数据来描述其颜色与亮度等信息。矢量图面向对象的图形或绘图图形，是用数学方式描述的曲线及曲线围成的色块制作的图形。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。位图和矢量图区别存储方式的区别点阵文件存储图的各个像素点的位置信息、颜色信息以及灰度信息。矢量文件是用数学方程、数学形式对图形进行描述，通常使用图形的形状参数和属性参数来表示图形。因此，点阵文件存储空间比矢量文件大。缩放的区别点阵文件与分辨率有关，即在一定面积的图像上包含有固定数量的像素。矢量图形与分辨率无关，可以将它缩放到任意大小和以任意分辨率在输出设备上打印出来，不会影响清晰度。存储格式的区别位图存储格式：BMP、TIFF、GIF、JPEG、PNG矢量图存储格式：DXF、SVG、EPS、WMF、EMF总结位图矢量图存储内容各像素点位置信息、颜色信息以及灰度信息数学方程存储空间大小常见存储格式BMP、TIFF、GIF、JPEG、PNGDXF、SVG、EPS、WMF、EMF图形缩放失真不失真真实感图形效果容易实现不容易实现第2章 光栅图形学直线段的扫描转换数值微分法（DDA）对于线段 $ (x_0, y_0) \\rightarrow (x_1, y_1)$，其斜率为 $k = \\frac{y_1-y_0}{x_1-x_0}$ 。从点 $(x_0, y_0) \\rightarrow (x_0+\\Delta x, y_0+k \\Delta x) \\rightarrow (x_0+2\\Delta x, y_0+2k \\Delta x) \\rightarrow \\cdots \\rightarrow (x_i,y_i) \\rightarrow \\cdots \\rightarrow (x_1, y_1)$ 逐步绘点12345678void DDALine(int x0, int y0, int x1, int y1, Color PIXEL_COLOR){ int x; float dx = x1-x0, dy = y1-y0; float k = dy/dx, y = y0; for(x=x0;x&lt;=x1;x++,y+=k) drawPixel(x, int(y+0.5), PIXEL_COLOR); // int(y+0.5)是四舍五入,找到离交点更近的整点}需要注意的是——斜率问题，上述算法仅在斜率 $|k| \\le 1 $ 的情况适用，因为这种情况下，$x $每次增加1，$y $每次最多增加1。当 $|k| \\gt 1 $时，可以举例看到 $ (0, 0) \\rightarrow (2, 5) $以及 $ (0, 0) \\rightarrow (2, 100)$ 都将只有三个点绘成！这种情况下，只要把 $x、y$ 的地位互换即可。12345678910void DDALine(int x0, int y0, int x1, int y1, Color PIXEL_COLOR){ if(x0 &gt; x1) swap(x0, x1), swap(y0, y1); // (x0,y0)-&gt;(x1,y1) bool bigK = abs(y1-y0)&gt;x1-x0; // 斜率|k|&gt;1 if(bigK) swap(x0, y0), swap(x1, y1); // x,y地位互换 float k = (y1-y0)*1.0f/(x1-x0), y = y0; for(int x=x0;x&lt;=x1;x++,y+=k) if(bigK) drawPixel(int(y+0.5), x, PIXEL_COLOR); else drawPixel(x, int(y+0.5), PIXEL_COLOR);}注意，代码中没有特判处理 $k=0$ 情况。中点画线法在DDA画直线过程中，当前点 $(x_0, y_0) $，下一个点可能是 $(x_0+1, y_0) $ 或 $(x_0+1, y_0+1) $ ，所以采用四舍五入进行抉择，本质上来说，真实交点在中点 $M(x_0+1, y_0+0.5) $ 上方，则选 $(x_0+1, y_0+1) $ ，下方则选 $(x_0+1, y_0) $ 。中点画线法，就是基于这种思想，判断交点与中点的位置关系，替代原本四舍五入这一涉及浮点数的方法去做抉择，并且核心是从斜截式方程改为一般式方程。对于线段 $ (x_0, y_0) \\rightarrow (x_1, y_1)$，其一般式方程为 $F(x,y) = ax+by+c $，其中$a =y_0-y_1，b=x_1-x_0，c=x_0y_1-x_1y_0 $ 。将中点带入方程，构建判别式 $d = F(M) = F(x_p+1, y_p+0.5) = a(x_p+1)+b(y_p+0.5)+c$，若 $d \\ge 0$， 则交点在中点下方，画点 $(x_p+1,y_p)$，下一次 $d ‘ = F(x_p+2,y_p+0.5) = d+a$，增量为 $a$；若 $d \\lt 0$， 则交点在中点上方，画点 $(x_p+1,y_p+1)$，下一次 $d ‘ = F(x_p+2,y_p+1.5) = d+a+b$，增量为 $a+b$；从 $(x_0,y_0) $ 开始画线时候，$d $ 的初值 $d_0 = F(x_0+1,y_0+0.5) = F(x_0, y_0) + a + 0.5b = a+0.5b$，涉及浮点数，故采用 $2d $ 替代 $d$ 摆脱浮点数，此时，算法仅包含整数运算。1234567891011121314void MidPointLine(int x0, int y0, int x1, int y1, Color PIXEL_COLOR){ int a,b,d1,d2,d,x,y; a = y0-y1, b = x1-x0, d=2*a+b; d1 = 2*a, d2 = 2*(a+b); x = x0, y = y0; drawPixel(x, y, PIXEL_COLOR); while(x &lt; x1) { if(d &lt; 0) x++, y++, d+=d2; else x++, d+=d1; drawPixel(x, y, PIXEL_COLOR); }}注意，代码仅处理了 $ 0 \\le k \\le 1$ 情况。Bresenham算法Bresenham算法类似于中点法，由误差项符号决定下一个像素取右边点或右上点。对于线段 $ (x_0, y_0) \\rightarrow (x_1, y_1)$，其斜截式为 $y = kx+b$，对于 $(x_0, y_0) $ 的下一个点理应为 $(x_0+1, \\text{round}(y_0+k)) $，即将 $y_0+k $ 四舍五入，又因为其中 $y_0 $为整数，故只需要判断 $k $ 与 $0.5 $ 的大小关系。同理，下下个点 $(x_0+2, \\text{round}(y_0+2k)) $，决定因素是 $2k $，或者说 $2k $ 的小数部分，故增量为 $k$，注意模1。我们接下来用 $e$ 表示当前误差项。第一个优化：将判断 $e $ 与 $0.5 $ 的大小关系，优化为判断 $e-0.5 $ 与 $0 $ 的大小关系，即 $e $ 的初值设置。1234567891011void bresenhamLine(int x0, int y0, int x1, int y1, Color PIXEL_COLOR){ int x = x0, y = y0; float k = (y1-y0)*1.0/(x1-x0), e = -0.5; for(int i=0;i&lt;=x1-x0;i++) { drawPixel(x, y, PIXEL_COLOR); x++; e+=k; if(e &gt;= 0) y++, e--; }}第二个优化：将 $e$ 整数化，由于算法中只用到误差项的符号，原增量 $k · \\Delta= \\frac{y_1-y_0}{x_1-x_0} · \\Delta $，移项后 $k· (x_1-x_0)\\Delta = (y_1-y_0) \\Delta $，考虑上 $e $ 的初值设置，故将增量换成 $k ‘ = k· (x_1-x_0) \\Delta=(y_1-y_0) \\Delta $，$e_0 = \\Delta · -(x_1-x_0)/2$。要完全去浮点数，取 $ \\Delta = 2 $ 即可。1234567891011void bresenhamLine(int x0, int y0, int x1, int y1, Color PIXEL_COLOR){ int x = x0, y = y0, dx = x1-x0, dy = y1-y0; int e = -dx; for(int i=0;i&lt;=dx;i++) { drawPixel(x, y, PIXEL_COLOR); x++; e+=2*dy; if(e &gt;= 0) y++, e-=2*dx; }}同时注意，算法中仅处理了$ 0 \\le k \\le 1$ 情况。第三个优化：处理斜率 $k \\ge 1$ 情况，和DDA方法一样，将$x、y $ 地位互换。1234567891011121314void bresenhamLine(int x0, int y0, int x1, int y1, Color PIXEL_COLOR){ if(x0 &gt; x1) swap(x0, x1), swap(y0, y1); // (x0,y0)-&gt;(x1,y1) bool bigK = y1-y0&gt;x1-x0; // 斜率k&gt;1 if(bigK) swap(x0, y0), swap(x1, y1); int x = x0, y = y0, dx = x1-x0, dy = y1-y0; int e = -dx; for(int i=0;i&lt;=dx;i++) { drawPixel(bigK?y:x, bigK?x:y, PIXEL_COLOR); x++; e+=2*dy; if(e &gt;= 0) y++, e-=2*dx; }}第四个优化：处理斜率为负数情况，将线段沿着 $x $ 轴对称后做上述算法，画点时 $y $ 值注意乘-1。12345678910111213141516void bresenhamLine(int x0, int y0, int x1, int y1, Color PIXEL_COLOR){ if(x0 &gt; x1) swap(x0, x1), swap(y0, y1); // (x0,y0)-&gt;(x1,y1) bool negK = y1&lt;y0; // 负斜率 if(negK) y0=-y0, y1=-y1; bool bigK = y1-y0&gt;x1-x0; // 斜率|k|&gt;1 if(bigK) swap(x0, y0), swap(x1, y1); int x = x0, y = y0, dx = x1-x0, dy = y1-y0; int e = -dx; for(int i=0;i&lt;=dx;i++) { drawPixel(bigK?y:x, negK?(bigK?-x:-y):(bigK?x:y), PIXEL_COLOR); x++; e+=2*dy; if(e &gt;= 0) y++, e-=2*dx; }}圆弧的扫描转换圆的八对称性$(x,y)、(y,x)、(-x,y)、(y,-x)、(x,-y)、(-y,x)、(-x,-y)、(-y,-x) $ 对称。123456789101112void drawEightCirclePoints(int x, int y, Color c, int size=1){ glPointSize(size); glColor3f(c.r, c.g, c.b); glBegin(GL_POINTS); glVertex3f(cx+x, cy+y, 0.0f); glVertex3f(cx+y, cy+x, 0.0f); glVertex3f(cx-x, cy+y, 0.0f); glVertex3f(cx+y, cy-x, 0.0f); glVertex3f(cx+x, cy-y, 0.0f); glVertex3f(cx-y, cy+x, 0.0f); glVertex3f(cx-x, cy-y, 0.0f); glVertex3f(cx-y, cy-x, 0.0f); glEnd(); glFlush();}中点画圆法由于中点画圆法与Bresenham画线法有相似之处，故又被称为Bresenham画圆法。圆：$F(x,y) = x^2+y^2-R^2$，圆内的点 $F(x,y) \\lt 0 $，圆外的点 $F(x,y) \\gt 0$。构建判别式：$d = F(M) = F(x_p+1, y_p-0.5) = (x_p+1)^2+(y_p-0.5)^2-R^2 $。若 $d \\lt 0 $，画点 $P_1(x_p+1,y_p)$，下一像素判别式 $d_1 = F(x_p+2, y_p-0.5)=d+2x_p+3$若 $d \\gt 0 $，画点 $P_2(x_p+1,y_p-1) $，下一像素判别式 $d_1 = F(x_p+2, y_p-1.5)=d+2(x_p-y_p)+5 $从$(0,R) $开始顺时针画圆，$ d $ 的初始值 $d_0 = F(1,R-0.5) = 1.25-R $1234567891011121314void bresenhamDrawCircle(int cx, int cy, int r){ int x, y; float d; x = 0; y = r; d = 1.25-r; drawEightCirclePoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE); while(x &lt;= y) { if(d &lt; 0) d+=2*x+3; else d+=2*(x-y)+5, y--; x++; drawEightCirclePoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE); }}考虑优化掉浮点数，优化乘法为加法。中点画椭圆法与中点画圆法类似，参照则写即可。椭圆：$F(x,y) = b^2 x^2+a^2 y^2-a^2 b^2$构建判别式：$d = F(M) = F(x_p+1\\Delta, y_p-0.5\\Delta) = b^2 (x_p+\\Delta)^2+ a^2 (y_p-0.5\\Delta)^2 - a^2 b^2 $。若 $d \\lt 0 $，画点 $P_1(x_p+1\\Delta,y_p)$，下一像素判别式 $d_1 = F(x_p+2\\Delta, y_p-0.5\\Delta)=d+(2 x_p \\Delta + 3 \\Delta ^2)b^2$若 $d \\gt 0 $，画点 $P_2(x_p+1\\Delta,y_p-1\\Delta) $，下一像素判别式$d_1 = F(x_p+2\\Delta, y_p-1.5\\Delta)=d+(2 x_p \\Delta + 3 \\Delta ^2)b^2 + (-2y_p \\Delta + 2\\Delta^2)a^2 $从$(0,b) $开始顺时针利用四对称性画椭圆，$ d $ 的初始值 $d_0 = F(1\\Delta,b-0.5\\Delta) = 0.25 a^2 \\Delta^2 + b^2 \\Delta^2 - a^2 b \\Delta $。其中 $\\Delta $ 是网格单位距。1234567891011121314void bresenhamDrawOval(int cx, int cy, int a, int b){ int x, y; float d; x = 0; y = a; d = 4*b*b-2*a*b+a*a; drawFourOvalPoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE); while(y &gt;= 0) { if(d &lt; 0) d+=2*b*b*x+3*b*b; else d+=2*(b*b*x-a*a*y)+3*b*b+2*a*a, y--; x++; drawFourOvalPoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE); }}如果你认为上述代码能生成一个椭圆，那就错了！椭圆只有四对称性，极接近 $x $ 轴时，会出现切线斜率为 -1 的情况，这时主导地位应换为 $y $。即要分为两区域画图。在椭圆上过点 $P(x_0, y_0) $的切线斜率为：$k = -\\frac{b^2 x_0}{a^2 y_0}$ ，特判 $k\\le-1 $时退出第一区域。构建判别式：$d = F(M) = F(x_p+0.5\\Delta, y_p-1\\Delta) = b^2 (x_p+0.5\\Delta)^2+ a^2 (y_p-1\\Delta)^2 - a^2 b^2 $。若 $d \\lt 0 $，画点 $P_1(x_p+1\\Delta,y_p-1\\Delta)$，下一像素判别式 $d_1 = F(x_p+1.5, y_p-2)=d + (-2y_p\\Delta+3\\Delta^2)a^2 +(2x_p\\Delta+2\\Delta^2)b^2$若 $d \\gt 0 $，画点 $P_2(x_p,y_p-1\\Delta) $，下一像素判别式 $d_1 = F(x_p+0.5\\Delta, y_p-2\\Delta)=d+(-2y_p\\Delta+3\\Delta^2)a^2 $最终版：123456789101112131415161718192021222324void bresenhamDrawOval(int cx, int cy, int a, int b){ float x, y; float d; x = 0; y = b; d = 0.25*a*a + b*b - a*a*b; drawFourOvalPoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE); while(y &gt;= 0) { // 区域一 if(d &lt; 0) d+=2*b*b*x+3*b*b; else d+=2*(b*b*x-a*a*y)+3*b*b+2*a*a, y--; x++; drawFourOvalPoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE); // 如果斜率=-1 则跳出循环 if(-b*b*x / (a*a*y) &lt;= -1) break; } d = b*b*(x+0.5)*(x+0.5) + a*a*(y-1)*(y-1) - a*a*b*b; while(y &gt;= 0) { // 区域二 if(d &gt; 0) d+=(-2*y+3)*a*a; else d+=(-2*y+3)*a*a+(2*x+2)*b*b, x++; y--; drawFourOvalPoints(cx, cy, x, y, PIXEL_COLOR, PIXEL_SIZE); }}多边形的扫描转换多边形的两种表示：顶点表示：直观、几何意义强、占内存少、易进行几何变换，但不能直接用于面着色。点阵表示：便于帧缓冲器表示图形、面着色，但丢失了许多几何信息。多边形分为：凸、凹多边形，以及含内环的多边形。X-扫描线算法(活性边表法)从$y = y_{min} $ 到 $y = y_{max} $ ，每条扫描线 $y = y_i$ 与多边形的相交区间 $[L_1, R_1]、\\cdots、 [L_n, R_n]$指定颜色显示区间像素 ${(x, y_i) \\ | \\ x = L_1,L_1+1,\\cdots,R_1,L_2,\\cdots,R_n}$当扫描线与多边形顶点相交时，交点的取舍策略为保证交点数目偶数个：若共享顶点的两条边分别落在扫描线的两边，交点只算 1 个若共享顶点的两条边在扫描线的同一边，这时交点作为 0 个或 2 个上述算法（求交、排序、配对、填色）的重要思想是扫描线和增量，但求交的效率十分低，故算法需要优化，主要从3个方面考虑：与有效边求交：在处理一条扫描线时，仅对与它相交的多边形的边进行求交运算扫描线的连贯性：当前扫描线与各边的交点与下一条扫描线与各边的交点很可能相同或非常相似多边形的连贯性：当某条边与当前扫描线相交时，它很可能也与下一条扫描线相交引入数据结构 1 ——活性边表(AET)：活性边：与当前扫描线相交的边表：将活性边按交点 x 坐标升序存放在于链表节点内容$x $：活性边与扫描线的交点 x 坐标$ \\Delta x $ ：从”当前扫描线与活性边交点”到”下一条扫描线与活性边交点”间的 x 增量。由活性边斜率 $k = \\frac{y_{i+1}-y_i}{x_{i+1}-x_i} \\Rightarrow \\Delta x = \\frac{1}{k \\Delta } $，其中单个 $\\Delta $ 为扫描线增量。$y_{max} $：该活性边所交的最高扫描线的 y 坐标引入数据结构 2 ——新边表(NET)：表：按照扫描线第一次交于该边的高度，建立链表节点内容$y_{max} $：该边的最高 y 值$x_{min} $：该边较低点的 x 值，注意是较低点不是左点$1/k $：该边的斜率倒数上图扫描线$y = 1 $ 交的两条边$P_1P_2、P_1P_6 $ 即可以放入活性边表处理。每次做新的扫描线时，要对活性边进行三个处理：是否去除该活性边。若不去除，就更新其数据，$x = x + \\frac{1}{k \\Delta} $根据新边表判断有无新边进入，有则插入排序到活性边表。如此算法避免了求交，伪码如下：1234567891011121314151617void polyFill(polygon, color){ for (各条扫描线i) { 初始化新边表头指针NET[i]; 把ymin=i的边放进新边表NET[i]; } y = 最低扫描线号; 初始化活性边表AET为空; for (各条扫描线i) { 把NET[i]中的边结点用插入排序法插入AET表; 遍历AET表,把配对交点区间(左闭右开)上的象素(x,y)，用putpixel(x,y,color)改写象素颜色值; 遍历AET表，把ymax=i的结点从AET表中删除,并把ymax&gt;i的结点的x值递增Δx; 若允许多边形的边自相交，则用冒泡排序法对AET表重新排序; }}边界标志算法在帧缓冲器中对多边形的每条边进行直线扫描转换，即对多边形边界所经过的像素打上标记。从左到右逐个访问扫描线的像素，进行上色。边界标志算法更适合硬件实现，这时它的执行速度比有序边表算法快一至两个数量级。1234567891011121314void edgemarkFill(polydef, color){ 对多边形polydef每条边进行直线扫描转换; for (每条与多边形polydef相交的扫描线y) { bool inside = false; for (扫描线上的每个像素x) { if (像素x被打上边标记) inside = !inside; if (inside) drawPixel(x, y, color); else drawPixel(x, y, backgroudColor); } }}边缘填充算法一张图：栅栏填充算法对边缘填充算法的改进，栅栏指一条过多边形顶点且与扫描线垂直的直线，它把多边形分为两半。在处理每条边与扫描线的交点时，将交点与栅栏之间的像素取补。多边形的区域填充区域：已经表示成点阵形式的填充图形，是像素的集合区域填充：指将区域内的一点(常称种子点)赋予给定颜色，然后将这种颜色扩展到整个区域内的过程。区域填充算法(泛滥填充算法)DFS/BFS扫描线种子填充算法区域填充扫描线方法。上一算法从种子点开始DFS/BFS，其中多次入栈(队)，费时费内存效率不高。实际上知道了一个点，我们可以从该点向左向右循环填充直至碰触边界。扫描线种子填充算法就是用这个结合扫描线，解决了多次入栈(队)的问题。12345678910111213141516171819202122232425262728293031void ScanLineFill4(int x, int y, Color oldColor, Color newColor){ typedef struct{int x,y;} Seed; int xl, xr; bool spanNeedFill; stack&lt;Seed&gt; S; S.push({x, y}); while(!S.empty()) { Seed u = S.top(); S.pop(); x = u.x; y = u.y; for(xr=x;readPixelRGB(xr, y) == oldColor;xr++) drawPixel(xr, y, newColor); xr--; for(xl=x-1;readPixelRGB(xl, y) == oldColor;xl--) drawPixel(xl, y, newColor); xl++; // 分别处理上下两条扫描线 for(int yy=y-1;yy&lt;=y+1;yy+=2) { x = xl; while(x &lt;= xr) { spanNeedFill = false; for(;readPixelRGB(x, yy) == oldColor;x++) spanNeedFill = true; if(spanNeedFill) S.push({x-1, yy}); while(readPixelRGB(x, yy)!=oldColor &amp;&amp; x&lt;=xr) x++; } } }}扫描转换与区域填充的不同基本思想不同扫描转换：将多边形顶点转换为点阵表示。区域填充：只改变区域颜色，不改变区域的表示方法。基本条件不同扫描转换：从多边形的边界(顶点)信息出发，利用多种形式的连贯性进行填充点阵。区域填充：给定区域内一点作为种子点，然后从点根据连通性将新的颜色扩散到整个区域。目的不同扫描转换：知道多边形边界，求多边形内部的像素集。区域填充：知道边界、区域内一点，内部填色。反走样走样现象光栅图形缠身的阶梯型（锯齿形）小物体由于走样而消失动画序列中时隐时现，产生闪烁（仅在矩形覆盖像素中心时显示）反走样技术原理反走样(Antialiasing)提高设备分辨率：由于存储器代价、扫描转换时间代价、轰击屏幕电子枪的速度代价，所以不可取模糊：对于白色背景中黑色矩形，在矩形边界掺入灰色像素，柔化从黑到白的尖锐变化。从远处观察图像，人眼把这些缓和变化的暗影融合在一起，从而看到更平滑的边界。非加权区域采样方法方法：根据物体的覆盖率（某个像素区域被物体覆盖的比例）计算像素的颜色。两个缺点：像素亮度与相交区域面积成正比，而与相交区域在像素内的位置无关 -&gt; 仍有锯齿效应直线条上沿理想直线方向的相邻两个象素有时会有较大的灰度差（因为每个像素的权值都一样）加权区域采样方法在加权方法中，将像素亮度与相交区域在像素内的位置看作有关。思想：直线段对一个像素亮度的贡献正比于相交区域与像素中心的距离 $d $方法：设置相交区域面积与像素中心距离的权函数（高斯函数）反映相交面积对整个像素亮度的贡献大小，利用权函数积分求相交区域面积，再乘以最大亮度值即为像素实际亮度值。简化方案：将积分改为离散计算直线裁剪算法裁剪裁剪：确定图形哪些部分落于显示区之内/外。最简单的剪裁：转换为点的剪裁点的剪裁：判断 $\\begin{cases} x_{left} \\le x \\le x_{right} \\ y_{bottom} \\le y \\le y_{top} \\end{cases}$直线段的剪裁：判断 $\\begin{cases} 完全落在窗口内 \\ 完全落在窗口外 \\ 与窗口边界相交 \\end{cases} $Cohen-Sutherland算法又称编码裁剪算法。思想：对每条直线段分是三种情况若点 $p_1 $ 和 $p_2 $ 完全在剪裁窗口内：取之若点为下图四种之一：弃之其他情况，可以采用编码的方法：顶点编码$D_3D_2D_1D_0 $， $\\begin{cases} D_0 = x&lt;x_{left} \\ D_1 = x&gt;x_{right} \\ D_2 = y&lt;y_{bottom} \\ D_3 = y&gt;y_{top} \\ \\end{cases} $若 $p1 \\ |\\ p2 = 0 $，取之若 $p1 \\ &amp;\\ p2 \\not= 0$ ，丢之若上述都不满足，则依次按左、右、上、下的顺序求出线段与窗口的交点。然后在交点处把线段一分为二，根据上述两个原则舍/取一部分。特点较适合两种情况——大部分线可见、大部分线不可见。存在问题：下图线段要多次经过算交点才会被舍弃。中点分割算法与Cohen-Sutherland算法相似，需要对位置进行编码。思想：通过二分逼近来确定线段与窗口的交点完全在窗口内/外的情况和窗口有交点，构建线段中点若中点在窗口内，则不断构建交点与端点的中点若中点在窗口外，则把 (中点, 离窗口边界较远的端点) 部分去掉。以此逼近。Liang-Barsky算法线段 $(x_1,y_1) \\rightarrow (x_2,y_2) $特判：若 $x_1 = x_2 $，判断 $x_1-x_{left} \\lt 0$ 或 $x_{right}-x_1 \\lt 0$ 则线段不在窗口内若 $y_1=y_2$，判断 $y_1 - y_{bottom} \\lt 0 $ 或 $y_{top}-y_1 \\lt 0 $ 则线段不在窗口内思想：用参数方程表示直线段 $\\begin{cases} x = x_1 + u·(x_2-x_1) = x_1 + u·\\Delta x \\ y = y_1+u·(y_2-y_1)=y_1 + u·\\Delta y \\end{cases} ， 0 \\le u \\le1$将直线段看成一条有方向的线段（标记端点为绿色），把窗口的四条边及其延长线分成入边、出边两种。入边：直线由窗口外向内移动时和窗口边界相交的边（标记交点为红色）出边：直线由窗口内向外移动时和窗口边界相交的边（标记交点为红色）用 $u_1、u_2$ 分别表示线段 $(u_1 \\le u_2)$ 可见部分的开始和结束 $\\large \\begin{cases} u_1 = max(0,u_{left},u_{bottom}) \\ u_2 = min(1,u_{top},u_{right}) \\end{cases} $问题：问题1.如何判断哪两个边是入边，哪两个边是出边问题2.直线和窗口边界线四个交点参数 u 值如何求出将裁剪转换为不等式：$\\begin{cases} x_{left} \\le x_1 + u·\\Delta x \\le x_{right} \\ y_{bottom} \\le y_1+u·\\Delta y \\le y_{top} \\end{cases} \\Rightarrow \\begin{cases} u·(-\\Delta x) \\le x_1 - x_{left} \\ u·\\Delta x \\le x_{right} - x_1 \\ u·(-\\Delta y) \\le y_1 - y_{bottom} \\ u·\\Delta y \\le y_{top} - y_1 \\ \\end{cases} $将上面不等式看作 $u·p_k \\le q_k$，四个不等式参数意义一一对应。当不等式取等号时， $u = \\frac{q_k}{p_k} $即为直线和窗口四条边交点处的参数。（问题 2 解决）除此之外，对于问题 1 的解决，根据 $p_k$ 的符号判断：故，$u_1、u_2 $ 进一步得到为 $\\large \\begin{cases} u_1 = max(0,u_{k|p_k \\lt 0},u_{k|p_k \\lt 0}) \\ u_2 = min(1,u_{k|p_k \\gt 0},u_{k|p_k \\gt 0}) \\end{cases} $，若 $u_1 \\gt u_2$ 则在窗口外。例子：多边形裁剪一个简单的想法：多边形裁剪转换为直线的裁剪，然而会得到一些不连续直线段。然而目标却是：多边形边界的顶点序列Sutherland-Hodgeman多边形裁剪算法思想：将多边形边界作为一个整体每次用窗口的一条边对 被裁剪的多边形、中间结果多边形 进行裁剪（分治）顶点的舍取——以下图左边界裁剪多边形123456为例，考虑四种情况：都在不可见侧：都不加入。例如边12都不加入源S在不可见侧，目标T在可见侧：加入交点、T。例如边23加入2 ‘ 3都在可见侧：只加入目标T。例如边34加入4源S在可见侧，目标T在不可见侧：加入源点、交点。例如边56加入56’算法缺点：对凹多边形可能会得到多余线段文字裁剪文字裁剪分类：串精度裁剪：仅保留字符串全在窗口内的串字符精度裁剪：仅保留字符全在窗口内的字符笔划/像素精度裁剪：仅保留字符像素(笔画)在窗口内的部分消隐算法消隐：绘制时消除被遮挡的不可见的线或面，也称消除隐藏线和隐藏面。消除隐藏线、隐藏面，这里介绍的主要算法：Z缓冲区(Z-Buffer)算法扫描线Z-buffer算法区域子分割算法消隐的分类：按消隐对象分线消隐面消隐按消隐空间分物体空间：将场景中的 1 个物体与剩下的 n-1 个物体逐一比较，仅显示可见表面（常用线段图的消隐）图像空间：对屏幕窗口内的每个像素判断画家算法比较简单的想法：先画远的物体，再画近的物体，近物体会覆盖远物体。只能解决简单情况。Z缓冲区(Z-Buffer)算法能跟踪屏幕上每个像素的深度。维护两个数组：帧缓冲器，Intensity(x, y)——属性数组，图像空间每个可见像素的光强/颜色深度缓冲区，Depth(x, y)——深度数组，图像空间每个可见像素的 z 坐标算法思想：将 Z 缓冲器中各单元的初始值置为最小值当要改变某个像素的颜色值时，仅在当前 z 值大于原来 z 值时，才替换算法优点：简单、直观在像素级上以近物取代远物，而与物体的出现顺序无关，利于硬件实现内存容量不再是问题后，变得受欢迎算法缺点：占用空间大没有利用图形的相关性和连续性，这是严重缺陷像素级的算法，效率低算法改进——改进占用空间（去数组，时间换空间）：12345678910111213void Z-Buffer(){ 帧缓存全置为背景色 for(屏幕上的每个像素(i,j)) { 深度缓存遍历 zb = -INF; for(多面体上的每个多边形P_k) if(像素点(i,j)在P_k的投影在多边形内 &amp;&amp; P_k的depth(i,j)&gt;zb) zb = depth(i,j), indexp = k; if(zb != -INF) 计算P_indexp在(i, j)的光照颜色并显示 }}面的深度计算：$ax + by + cz + d = 0 \\Rightarrow depth = -\\frac{ai+bj+d}{c} $点与多边形的包含性射线法，缺点是计算量大、有误差不稳定弧长法，缺点是算弧长效率低以顶点符号为基础的弧长累加法该改进未解决像素级算法的本质，效率仍然低。区间扫描线算法考虑Z-Buffer没有利用图形的相关性和连续性的缺陷，该算法放弃了Z-Buffer的思想（一个像素可能被多个多边形覆盖，即一个像素要多次判别，效率极低），是消隐算法中最快的算法之一。思想：把扫描线和多边形的这些交点都求出来，对每个区间，只判一个像素的颜色，那么整个区间都是该颜色像素计算 -&gt; 逐段计算，效率大大提高。确定小区间的颜色：小区间无任何多边形，如[a4, a5]，用背景色显示小区间仅有一多边形，如[a1, a2]，显示该多边形颜色小区间存在两个以上多边形，如[a6, a7]，用深度检测问题：真实求交点？不用，利用增量算法简化求交每段区间上要求 z 值最大的面，如何得知区间与哪些多边形相关利用扫描线的两个特殊数据结构？？？Warnock消隐算法区域子分割算法，发明人Warnock，图像空间中非常经典的算法，其重要性不体现在其效率，而是体现在分治思想和堆栈数据结构的运用。思想：把物体投影到全屏幕窗口递归分割窗口，直到窗口内目标足够简单（可以显示）如何判断窗口内图形足够简单：仅包含一个多边形，即内含窗口与一个多边形相交，但窗口内无其他多边形（用直线方程作判别函数）窗口被一个多边形所包围窗口与一个多边形相分离若窗口仅像素那么大，但仍有两个以上的面，则不必再分割，取窗口内最近的可见面颜色或所有可见面平均颜色。第3章 二维图形几何变换本章内容：主要：向量、世界坐标系、用户坐标系、窗口与视区、齐次坐标、二维变换向量、矩阵以及它们的运算坐标系的概念和坐标系之间的变换 齐次坐标的概念二维图形的各种变换窗口与视区的变换向量基础图形学中，处理三维物体，在意绘制对象的形状、位置、方向。两大基本工具：向量分析、图形变换向量：点和方向的实体（没有位置）向量两种特殊线性组合（$w = a_1v_1 + a_2v_2+…+a_nv_n $）：仿射组合：线性组合的系数和等于 1，$ \\sum\\limits_{i=1}^n a_i = 1 $凸组合：线性组合的系数和等于 1，且各系数非负，$ \\sum\\limits_{i=1}^n a_i = 1 （a_i \\ge 0） $向量的运算，$a = (a_1, a_2)，b=(b_1,b_2) $：相加数乘点积：$a · b = a_1b_1+a_2b_2 = |a||b|cos\\langle a,b\\rangle $，用向量描述新闻，新闻相似，则向量夹角余弦接近于 1叉积：$a=(a_x,a_y,a_z)，b=(b_x,b_y,b_z)，a \\times b = \\begin{vmatrix} i &amp; j &amp; k \\ a_x &amp; a_y &amp; a_z \\ b_x &amp; b_y &amp; b_z \\end{vmatrix}=|a||b|sin\\langle a,b\\rangle $图形坐标系坐标系：建立图形和数之间对应联系的参考系数学坐标系分类：直角坐标系极坐标系圆柱坐标系球坐标系计算机图形学坐标系分类：世界坐标系：公共坐标系，现实中物体或场景的统一参照系建模坐标系：又称局部坐标系，每个物体(对象)有它自己的局部中心和坐标系观察坐标系：依据观察窗口的方向和形状在世界坐标系中定义的坐标系。观察坐标系用于指定图形的输出范围。设备坐标系：屏幕坐标，坐标单位是整数规范化坐标系：归一化后的坐标，坐标轴取值范围 0~1，二维图形变换原理变换：比例、旋转、镜像、错切、平移对于一个图形，可用顶点表描述图形的几何关系，用连边表来描述图形的拓扑关系。故对图形的变换，只变换图形的顶点表仿射变换：Affine Transformation平直性：直线变换后仍是直线平行性：平行线变换后仍平行二维仿射变换： $\\begin{cases} x ‘ = a_1x+b_1y+c_1 \\ y ‘ =a_2x+b_2y+c_2 \\end{cases}$二维仿射变换，矩阵形式：$\\left[ \\begin{matrix} x^* &amp; y^* \\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} a_1 &amp; a_2 \\ b_1 &amp; b_2 \\ c_1 &amp; c_2 \\end{matrix} \\right] $齐次坐标二维平面中用(x, y)表示一个点，不妨说是一个向量(x, y)表示一个点。所以可以用第3维为常数的(x, y, 1)表示二维平面上的向量这种n+1维表示n维的方法称为——齐次坐标表示法，n维向量 $(p_1,p_2,\\cdots,p_n)$ 表示为 $(hp_1,hp_2,\\cdots,hp_n, h)$，其中 $h $ 称为哑坐标，特别的 h=1 时称齐次坐标为规格化坐标。二维仿射变换，齐次坐标表示：$\\left[ \\begin{matrix} x^* &amp; y^*&amp;1 \\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} a_1 &amp; a_2 &amp;0 \\ b_1 &amp; b_2&amp;0 \\ c_1 &amp; c_2 &amp;1\\end{matrix} \\right] $不使用齐次坐标可以做比例、对称、旋转变换，但做不到平移变化，无法增加常数项。平移变换不产生变形而移动物体的刚体变换，即物体上的每个点移动相同数量的坐标坐标形式：$\\begin{cases} x^* = x+T_x \\ y^*=y + T_y \\end{cases} $齐次坐标形式：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\ 0&amp;1&amp;0 \\ T_x&amp;T_y&amp;1 \\end{matrix} \\right] $比例变换相对于坐标原点沿x方向放缩$S_x$倍，沿y方向放缩$S_y$倍。S &gt; 1放大，S &lt; 1 缩小。坐标形式：$\\begin{cases} x^* = x·S_x \\ y^*=y·S_y \\end{cases} $齐次坐标形式：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} S_x &amp; 0 &amp;0 \\ 0&amp;S_y&amp;0 \\ 0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x·S_x &amp; y·S_y &amp;1\\end{matrix}\\right] $当 $S_x =S_y $ 时，为整体比例变换，$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;S \\end{matrix} \\right] =\\left[ \\begin{matrix} \\frac{x}{S} &amp; \\frac{y}{S} &amp;1\\end{matrix}\\right] $，S&gt;1缩小，0&lt;S&lt;1缩小，S&lt;0发生关于原点的对称等比变换对称变换也称镜像变换。有关于x轴、y轴、原点、某条直线的对称变换关于 x 轴对称：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\ 0&amp;-1&amp;0 \\ 0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x&amp;-y&amp;1\\end{matrix}\\right] $关于 y 轴对称：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} -1 &amp; 0 &amp;0 \\ 0&amp;1&amp;0 \\ 0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} -x&amp;y&amp;1\\end{matrix}\\right] $关于原点对称：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} -1 &amp; 0 &amp;0 \\ 0&amp;-1&amp;0 \\ 0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} -x&amp;-y&amp;1\\end{matrix}\\right] $旋转变换将点绕原点旋转角度 $\\theta$ ，逆时针为正，顺时针为负坐标形式（逆时针）：$\\begin{cases} x^* =r·cos(\\alpha+\\theta)=r·cos\\alpha ·cos\\theta-r·sin\\alpha ·sin\\theta \\ y^* =r·sin(\\alpha+\\theta)=r·cos\\alpha ·sin\\theta + r·sin\\alpha ·cos\\theta\\end{cases} \\Rightarrow \\begin{cases} x^* =x ·cos\\theta-y ·sin\\theta \\ y^* =x ·sin\\theta + y ·cos\\theta\\end{cases} $齐次坐标形式（逆时针）：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} cos\\theta &amp; sin\\theta &amp;0 \\ -sin\\theta&amp;cos\\theta &amp; 0 \\ 0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x ·cos\\theta-y ·sin\\theta &amp; x ·sin\\theta + y ·cos &amp;1\\end{matrix}\\right] $顺时针只要将 $\\theta = -\\theta $ 即可。错切变换弹性物体的变形处理变换矩阵中的非对角元素起着把图形沿x或y方向错切的作用齐次坐标形式：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} 1 &amp; b &amp; 0 \\ c &amp;1 &amp;0 \\ 0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix}c+cy&amp;bx+y &amp;1\\end{matrix}\\right] $沿 x 方向错切，即 b=0 ：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} 1 &amp; 0 &amp; 0 \\ c &amp;1 &amp;0 \\ 0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix}c+cy&amp;y &amp;1\\end{matrix}\\right] $复合变换图形作大于一次的变换，$P^* = P · T = P·(T_1·T_2·\\cdots ·T_n) ，n\\gt 1$，矩阵相乘不可交换！二维复合平移：$T = T_{t1}·T_{t2} = \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\ 0&amp;1&amp;0 \\ T_{x1}&amp;T_{y1}&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\ 0&amp;1&amp;0 \\ T_{x1}&amp;T_{y1}&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\ 0&amp;1&amp;0 \\ T_{x1}+T_{x2}&amp;T_{y1}+T_{y2}&amp;1 \\end{matrix} \\right] $二维复合比例：$T = T_{s1}·T_{s2} = \\left[ \\begin{matrix} S_{x1} &amp; 0 &amp;0 \\ 0&amp;S_{y1}&amp;0 \\ 0&amp;0&amp;1 \\end{matrix} \\right]· \\left[ \\begin{matrix} S_{x2} &amp; 0 &amp;0 \\ 0&amp;S_{y2}&amp;0 \\ 0&amp;0&amp;1 \\end{matrix} \\right]=- C \\left[ \\begin{matrix} S_{x1}·S_{x2} &amp; 0 &amp;0 \\ 0&amp;S_{y1}·S_{y2}&amp;0 \\ 0&amp;0&amp;1 \\end{matrix} \\right] $二维复合旋转：$T = T_{r1}·T_{r2} = \\left[ \\begin{matrix} cos\\theta_1 &amp; sin\\theta_1 &amp;0 \\ -sin\\theta_1&amp;cos\\theta_1 &amp; 0 \\ 0&amp;0&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} cos\\theta_2 &amp; sin\\theta_2 &amp;0 \\ -sin\\theta_2&amp;cos\\theta_2 &amp; 0 \\ 0&amp;0&amp;1 \\end{matrix} \\right]=\\left[ \\begin{matrix} cos(\\theta_1+\\theta_2) &amp; sin(\\theta_1+\\theta_2) &amp;0 \\ -sin(\\theta_1+\\theta_2)&amp;cos(\\theta_1+\\theta_2) &amp; 0 \\ 0&amp;0&amp;1 \\end{matrix} \\right] $坐标系变换图形变换经常需要从一个坐标系变换到另一个坐标系，如下图从x0y变换到x ‘ 0 ‘ y ‘上图可以拆分成，$x ‘ 0 ‘ y ‘ \\xrightarrow{平移} x ‘ 0y ‘ \\xrightarrow{旋转} x0y $，注意是从目标到源$T = T_{t}·T_{r} = \\left[ \\begin{matrix} 1 &amp; 0 &amp;0 \\ 0&amp;1&amp;0 \\ -x_0&amp;-y_0&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} cos(-\\theta) &amp; sin(-\\theta) &amp;0 \\ -sin(-\\theta)&amp;cos(-\\theta) &amp; 0 \\ 0&amp;0&amp;1 \\end{matrix} \\right] $任意参考点的几何变换在以往的变换中，以 (0, 0) 为参考点，倘若以任意点为参考点，则：将参考点移到原点（平移）针对原点进行二维几何变换（变换）将原点移到参考点（反平移）二维变换矩阵二维空间中某点的变化可以表示成点的齐次坐标与 3 阶的二维变换矩阵 $T_{2d} $ 相乘$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} a&amp;b&amp;p \\ c&amp;d&amp;q \\ l&amp;m&amp;s \\end{matrix} \\right] $二维图形几何变换的计算点的变换：$\\left[ \\begin{matrix} x^* &amp; y^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; 1 \\end{matrix}\\right]· T $直线的变换（两端点的变换）：$\\left[ \\begin{matrix} x_1^* &amp; y_1^* &amp;1 \\ x_2^* &amp; y_2^* &amp;1\\end{matrix}\\right] =\\left[ \\begin{matrix} x_1 &amp; y_1 &amp;1 \\ x_2 &amp; y_2 &amp;1\\end{matrix}\\right] ·T $多边形的变换（每个顶点的变换）：$p =\\left[ \\begin{matrix} x_1^* &amp; y_1^* &amp;1 \\ x_2^* &amp; y_2^* &amp;1 \\ \\cdots&amp;\\cdots&amp;\\cdots \\ x_n^* &amp;y_n^*&amp;1\\end{matrix}\\right] $窗口、视图及变换窗口和视区窗口：世界坐标系中要显示的区域视区：窗口映射到显示器上的区域窗口定义显示什么；视区定义在何处显示世界坐标系中的一个窗口可以对应于多个视区$ 窗口\\xrightarrow{观察变换} 视区$观察变换Viewing Transformation变焦距效果窗口放大/缩小，视区不变，图形缩小/放大整体缩放效果窗口不变，视区放大/缩小，图形放大/缩小窗口到视区的变换窗口的点 -&gt; 视区的点保持比例的映射$\\begin{cases} sx = A\\times x+C \\ sy = B\\times y+D\\end{cases}$比例保持：$\\Large \\frac{x-w_{xl}}{w_{xr}-w_{xl}} = \\frac{sx-v_{xl}}{v_{xr}-v_{xl}} \\Rightarrow sx = \\frac{x-w_{xl}}{w_{xr}-w_{xl}}(v_{xr}-v_{xl})+v_{xl}$根据倍数关系：$\\large sx = \\frac{v_{xr}-v_{xl}}{w_{xr}-w_{xl}} x + (v_{xl}-\\frac{v_{xr}-v_{xl}}{w_{xr}-w_{xl}} w_{xl}) = Ax + C， \\ A = \\frac{v_{xr}-v_{xl}}{w_{xr}-w_{xl}}，C=v_{xl}-A\\times w_{xl} $同理，$\\large B= \\frac{v_{yt}-v_{yb}}{w_{yt}-w_{yb}}，D=v_{yb}-B\\times w_{yb} $第4章 三维图形几何变换主要关注：如何对三维物体进行方向、尺寸、形状的变换三维物体在二维输出变换有两种：几何变换、投影变换三维几何变换三维基本几何变换皆是相对于坐标原点和坐标轴进行的几何变换。$p ‘ = \\left[ \\begin{matrix} x^* &amp; y^* &amp; z^* &amp; 1\\end{matrix}\\right] =\\left[ \\begin{matrix} x &amp; y &amp; z &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} a&amp;b&amp;c&amp;p \\ d&amp;e&amp;f&amp;q \\ g&amp;h&amp;i&amp;r \\ l&amp;m&amp;n&amp;s \\end{matrix} \\right] $平移变换$ \\left[ \\begin{matrix} x &amp; y &amp; z &amp; 1\\end{matrix}\\right] · \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ T_x&amp;T_y&amp;T_z&amp;1 \\end{matrix} \\right] = \\left[ \\begin{matrix} x+T_x &amp; y+T_y &amp; z+T_z &amp; 1\\end{matrix}\\right] $比例变换局部比例变换：$ \\left[ \\begin{matrix} x &amp; y &amp; z &amp; 1\\end{matrix}\\right] ·\\left[ \\begin{matrix} a&amp;0&amp;0&amp;0 \\ 0&amp;e&amp;0&amp;0 \\ 0&amp;0&amp;i&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] = \\left[ \\begin{matrix} ax&amp;ey&amp;iz &amp; 1\\end{matrix}\\right] $整体比例变换：$ \\left[ \\begin{matrix} x &amp; y &amp; z &amp; 1\\end{matrix}\\right] ·\\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;s \\end{matrix} \\right] = \\left[ \\begin{matrix} \\frac{x}{s}&amp;\\frac{y}{s}&amp;\\frac{z}{s} &amp; 1\\end{matrix}\\right] $旋转变换右手定则：右手大拇指指向旋转轴的正向，其余四指指向旋转角的正向绕 z 轴旋转：$ \\left[ \\begin{matrix} x &amp; y&amp;z &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} cos\\theta &amp; sin\\theta &amp;0&amp;0 \\ -sin\\theta&amp;cos\\theta &amp; 0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x ·cos\\theta-y ·sin\\theta &amp; x ·sin\\theta + y ·cos\\theta &amp;z&amp;1\\end{matrix}\\right] $绕 x 轴旋转：$ \\left[ \\begin{matrix} x &amp; y&amp;z &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;cos\\theta &amp; sin\\theta &amp;0 \\ 0&amp;-sin\\theta&amp;cos\\theta &amp; 0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x &amp; y·cos\\theta-z ·sin\\theta &amp; y ·sin\\theta + z ·cos\\theta &amp;1\\end{matrix}\\right] $绕 y 轴旋转：$ \\left[ \\begin{matrix} x &amp; y&amp;z &amp; 1 \\end{matrix}\\right]· \\left[ \\begin{matrix} cos\\theta &amp;0&amp; -sin\\theta &amp;0 \\ 0&amp;1&amp;0&amp;0 \\ sin\\theta&amp;0&amp;cos\\theta &amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x·sin\\theta+x·cos\\theta &amp; y &amp; z·cos\\theta-x·sin\\theta &amp; 1 \\end{matrix}\\right] $绕任意轴旋转：对称变换关于坐标平面的对称关于 x0y 平面对称：$T = \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;-1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $关于 y0z 平面对称：$T = \\left[ \\begin{matrix} -1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $关于 z0x 平面对称：$T = \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;-1&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $关于坐标轴的对称关于 x 轴对称：$T = \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;-1&amp;0&amp;0 \\ 0&amp;0&amp;-1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $关于 x 轴对称：$T = \\left[ \\begin{matrix} -1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;-1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $关于 z 轴对称：$T = \\left[ \\begin{matrix} -1&amp;0&amp;0&amp;0 \\ 0&amp;-1&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $三维投影变换解决三维输出到二维投影法分类（区别在于投影中心道投影面之间的距离是有/无限的）：透视投影法（中心投影法），比如建筑透视表示真实看到的物体平行投影法正投影法，比如工程样图斜投影法表示真实大小和形状的物体平行投影特点：物体各个面的精确视图又平行投影而得没有给出三维物体外表的真实性但保持比例正投影 之 三视图：主视图变换矩阵$T = \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $俯视图变换矩阵$T = \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;-1&amp;0 \\ 0&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;-z_0&amp;1 \\end{matrix} \\right] $直接置 y=0，$T = \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $为了使俯视图与主视图都画在一个平面内，就要使H面绕x轴顺时针转90°，$T = \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;cos(-90^ \\circ)&amp;sin(-90^ \\circ)&amp;0 \\ 0&amp;-sin(-90^ \\circ)&amp;cos(-90^ \\circ)&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;-1&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $为了使主视图和俯视图有一定的间距，还要使H面沿z方向平移一段距离 $-z_0 $ ，$T = \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;-z_0 &amp;1 \\end{matrix} \\right] $侧视图变换矩阵$T = \\left[ \\begin{matrix} 0&amp;0&amp;0&amp;0 \\ -1&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ -x_0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $直接置 y=0，$T = \\left[ \\begin{matrix} 0&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $为了使侧视图与主视图也在一个平面内，就要使W面绕z轴正转90°，$T = \\left[ \\begin{matrix} cos(-90^ \\circ)&amp;sin(-90^ \\circ)&amp;0&amp;0 \\ -sin(-90^ \\circ)&amp;cos(-90^ \\circ)&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} 0&amp;1&amp;0&amp;0 \\ -1&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $为使主视图和侧视图有一定的间距，还要使W面沿负x方向平移一段距离$-x_0 $，$T = \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ -x_0&amp;0&amp;0 &amp;1 \\end{matrix} \\right] $主视图： $\\left[ \\begin{matrix} x ‘ &amp; y ‘ &amp;z ‘ &amp; 1 \\end{matrix}\\right] = \\left[ \\begin{matrix} x &amp; 0&amp;z &amp; 1 \\end{matrix}\\right]$俯视图： $\\left[ \\begin{matrix} x ‘ &amp; y ‘ &amp;z ‘ &amp; 1 \\end{matrix}\\right] = \\left[ \\begin{matrix} x &amp; 0&amp;-(y+z_0 ) &amp; 1 \\end{matrix}\\right]$侧视图： $\\left[ \\begin{matrix} x ‘ &amp; y ‘ &amp;z ‘ &amp; 1 \\end{matrix}\\right] = \\left[ \\begin{matrix} -(y+x_0) &amp; 0&amp;z &amp; 1 \\end{matrix}\\right] $三个视图中的y’均为0，表明三个视图均落在xOz面上正投影 之 正轴侧：等轴侧：当投影面与三个坐标轴之间的夹角都相等正二测：当投影面与两个坐标轴之间的夹角相等正三测：当投影面与三个坐标轴之间的夹角都不相等正投影 之 正轴侧变换矩阵：以 V 面为轴测投影面，先将物体绕 Z 轴转 γ 角，接着绕X轴转 -α 角，最后向 V 面投影$T_正 = T_Z ·T_X·T_V = \\left[ \\begin{matrix} cos\\gamma &amp; sin\\gamma &amp; 0&amp;0 \\ -sin\\gamma &amp; cos\\gamma &amp; 0&amp; 0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;cos\\alpha&amp;-sin\\alpha&amp;0 \\ 0&amp;sin\\alpha&amp;cos\\alpha&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] \\ = \\left[ \\begin{matrix} cos\\gamma &amp; 0 &amp; -sin\\gamma sin\\alpha &amp;0 \\ -sin\\gamma &amp; 0&amp;-cos\\gamma sin\\alpha &amp; 0 \\ 0&amp;0&amp;cos\\alpha&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $即 $\\left[ \\begin{matrix} x ‘ &amp; y ‘ &amp;z ‘ &amp; 1 \\end{matrix}\\right] = \\left[ \\begin{matrix} xcos\\gamma-ysin\\gamma &amp; 0&amp; -xsin\\gamma sin\\alpha-ycos\\gamma sin\\alpha + zcos\\alpha &amp; 1 \\end{matrix}\\right] $正等轴测图：取 $\\gamma = 45^\\circ ， \\alpha = -35.26^\\circ $，$T_{\\text{正等轴测}} = \\left[ \\begin{matrix} 0.7071&amp;0&amp;-0.4082&amp;0 \\ -0.7071&amp;0&amp;-0.4082&amp;0 \\ 0&amp;0&amp;0.8165&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $正二测图：取 $\\gamma = 20.7^\\circ ， \\alpha = 19.47^\\circ $，$T_{\\text{正二测}} = \\left[ \\begin{matrix} 0.9354&amp;0&amp;-0.1178&amp;0 \\ -0.7071&amp;0&amp;-0.3118&amp;0 \\ 0&amp;0&amp;0.9428&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $中心投影(透视投影)特点：物体投影视图由计算投影线与观察平面之交点而得生成真实感视图但不保持比例三维变换矩阵，$ T_{3D} = \\left[ \\begin{matrix} a&amp;b&amp;c&amp;p \\ d&amp;e&amp;f&amp;q \\ g&amp;h&amp;i&amp;r \\ l&amp;m&amp;n&amp;s \\end{matrix} \\right] $，其中 p、q、r 能产生透视变换的效果。一点透视：假设 $q \\not=0，p=r=0$$\\left[ \\begin{matrix} x&amp;y&amp;z&amp;1 \\end{matrix} \\right]· \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;q \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x&amp;y&amp;z&amp;qy+1 \\end{matrix} \\right] $齐次化后：$\\left[ \\begin{matrix} x ‘ &amp;y ‘ &amp;z ‘ &amp;1 \\end{matrix} \\right]=\\left[ \\begin{matrix} \\frac{x}{qy+1}&amp;\\frac{y}{qy+1}&amp;\\frac{z}{qy+1}&amp;1 \\end{matrix} \\right] $当y=0时，$\\left[ \\begin{matrix} x ‘ &amp;y ‘ &amp;z ‘ &amp;1 \\end{matrix} \\right]=\\left[ \\begin{matrix}x&amp;0&amp;z&amp;1 \\end{matrix} \\right] $，即处于 y=0 平面内的点变换后无变化当y-&gt;∞时，$\\left[ \\begin{matrix} x ‘ &amp;y ‘ &amp;z ‘ &amp;1 \\end{matrix} \\right]=\\left[ \\begin{matrix}0&amp;\\frac{1}{q}&amp;0&amp;1 \\end{matrix} \\right] $，所有点都集中到y轴的1/q处，这点叫灭点形成灭点的透视变换即为一点透视。同样的分别假设 p、r 其中一个不为 0 ，另外两个为 0 ，都会产生灭点(1/p, 0, 0)、(0, 0, 1/r)。多点透视：根据一点透视的原理予以推广，如果p、q、r三个元素中有两个为非零元素时，将会生成两个灭点，因此得到两点透视；相应的三点透视概念也可得知。如当 $p\\not=0，r\\not=0 $，$\\left[ \\begin{matrix} x&amp;y&amp;z&amp;1 \\end{matrix} \\right]· \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;q \\ 0&amp;0&amp;1&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x&amp;y&amp;z&amp;px+rz+1 \\end{matrix} \\right] $齐次化后：$\\left[ \\begin{matrix} x ‘ &amp;y ‘ &amp;z ‘ &amp;1 \\end{matrix} \\right]=\\left[ \\begin{matrix} \\frac{x}{px+rz+1}&amp;\\frac{y}{px+rz+1}&amp;\\frac{z}{px+rz+1}&amp;1 \\end{matrix} \\right] $分别看到两个灭点，(1/p, 0, 0)、(0, 0, 1/r)生成透视投影图的方法：设投影中心：c(0, 0, -d)，现在推空间一点 p(x, y, z) 的透视投影点 p ‘ (x ‘ , y ‘ , z ‘ )$\\large \\triangle ABC \\sim \\triangle A ‘ OC \\Rightarrow \\frac{x ‘ }{x} =\\frac{y ‘ }{y} = \\frac{d}{d+z} \\Rightarrow x ‘ = \\frac{x}{1+z/d}，y ‘ = \\frac{y}{1+z/d}，z ‘ = 0 $矩阵形式是：$\\left[ \\begin{matrix} x&amp;y&amp;z&amp;1 \\end{matrix} \\right]· \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;\\frac{1}{d} \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] =\\left[ \\begin{matrix} x&amp;y&amp;z&amp;\\frac{z}{d}+1 \\end{matrix} \\right] $透视坐标与z值成反比。即z值越大，透视坐标值越小d的取值不同，可以对形成的透视图有放大和缩小的功能。当值较大时，形成的透视图变大；反之缩小。再乘以向投影面投影的变换矩阵，就得到点在画面上的投影$\\left[ \\begin{matrix} x&amp;y&amp;z&amp;1 \\end{matrix} \\right]· \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;1&amp;\\frac{1}{d} \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} 1&amp;0&amp;0&amp;0 \\ 0&amp;1&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;0 \\ 0&amp;0&amp;0&amp;1 \\end{matrix} \\right] $若投影中心在无穷远处，则 1/d -&gt; 0，上式变为平行投影一点透视投影实例：设 l=-0.8, m=-1.6, n=-2, 视距 d=-2.5二点透视投影实例：将物体平移到适当位置l、m、n将物体绕y轴旋转θ角进行透视变换最后向xoy面做正投影，即得二点透视图第5章 曲线曲面描述物体的三维模型：线框模型：顶点和棱边曲面模型：只描述物体表面和表面的连接关系，不描述物体内部的点属性实体模型：不但有物体的外观而且也有物体内点的描述曲线曲面基础曲线曲面的非参数表示分为显/隐式显式表示，y = f(x)，x -&gt; y 一一对应，故不能表示封闭或多值曲线隐式表示，f(x, y)=0，优点是容易判断点是否在曲线上显/隐式表示存在的问题与坐标轴相关用隐函数表示不直观，作图不方便用显函数表示存在多值性会出现斜率为无穷大的情形曲线曲面的参数表示为了克服非参数表示的问题p(t) = [x(t), y(t)]、p(t) = [x(t), y(t), z(t)]，等价于笛卡尔分量表示是p(t) = x(t)i + y(t)j + z(t)k归一化表示：$t ‘ =\\frac{t-a}{b-a}（a\\le t\\le b） \\Rightarrow p(t)（t \\in [0,1]）$曲面则可表示为双参数：$p(u, v) = p(x(u,v), y(u,v), z(u,v))，(u, v) \\in [0,1]\\times [0,1] $优势：可以满足几何不变性的要求。即形状的数学表示及其所表达的形状不随所取坐标系而改变的性质更大的自由度来控制曲线、曲面的形状，$y = ax^3+bx^2+cx+d \\rightarrow p(t) =\\left[ \\begin{matrix} a_1t^3+b_1t^2+c_1t+d_1 \\ a_2t^3+b_2t^2+c_2t+d_2 \\end{matrix} \\right] $，有8个系数来控制曲线。直接对参数方程进行几何变换：对非参数方程表示的曲线、曲面进行变换，必须对曲线 、曲面上的每个型值点进行几何变换；而对参数表示的曲线、曲面可对其参数方程直接进行几何变换便于处理斜率为无穷大的情形，不会因此而中断计算界定曲线、曲面的范围十分简单：$t \\in [0,1]$易于用向量（矢量）和矩阵运算，简化计算参数曲线的相关概念内容来自微分几何（用微分的方法来研究曲线的局部性质，比如弯曲程度）$\\begin{cases} x=x(t) \\ y=y(t) \\ z=z(t)\\end{cases}，p ‘ (t)=\\frac{dP}{dt}，p ‘ ‘ (t)=\\frac{d^2 P}{dt^2} $位置矢量曲线上任一点的位置矢量可表示为：$p(t) = [x(t), y(t), z(t)] $切矢量选择弧长s作为参数，当 △t→0时，弦长△s→0，但方向不能趋向于0。单位失切量：$T = \\frac{dP}{ds} =\\lim\\limits_{\\Delta x \\rightarrow 0} \\frac{\\Delta P}{\\Delta s}= \\frac{dP}{dt}·\\frac{dt}{ds} = \\frac{P ‘ (t)}{|P ‘ (t)|}$曲率切向量再求导几何意义：曲线的单位切向量对弧长的转动率，刻画某一点曲线的弯曲程度曲率 $ K = |T ‘ |= \\lim\\limits_{\\Delta x \\rightarrow 0} |\\frac{\\Delta T}{\\Delta s}|= \\lim\\limits_{\\Delta x \\rightarrow 0} |\\frac{T(s+\\Delta s) - T(s)}{\\Delta s}| = \\lim\\limits_{\\Delta x \\rightarrow 0} |\\frac{\\Delta \\theta}{\\Delta s}| $，越大曲线越弯曲率半径 $\\rho = \\frac{1}{K} $ ，越小圆弧越陡越大圆弧越平缓法矢量法矢量是与切矢量垂直的向量挠率空间曲线不但要弯曲，而且还要扭曲，即要离开它的密切平面。为了能刻画这一扭曲程度，等价于去研究密切平面的法矢量（即曲线的副法矢量）关于弧长的变化率。挠率 τ 的绝对值等于副法线方向(或密切平面)对于弧长的转动率：$ |\\tau| = \\lim\\limits_{\\Delta x } |\\frac{\\Delta \\theta}{\\Delta s}|$插值自由曲线、自由曲面一般通过少数分散的点生成，这些点即“型值点”、“样本点”或“控制点”。插值曲线：插值(interpolation)构造出来的曲线线性插值f(x)在两个不同点x1和x2间值，用线形函数y=ax+b近似代替抛物线插值f(x)在三个不同点x1、x2、x3间值，用抛物线 $\\varphi (x) = ax^2+bx+c $ 近似代替拟合拟合曲线：构造一条曲线使之在某种意义下最接近给定的数据点(但未必通过这些点)逼近：通常指用一些性质较好的函数近似表示一些性质不好的函数。插值和拟合都可以视为逼近对于逼近样条，连接控制点序列的折线（控制多边形/特征多边形）通常被显示出来，以提醒设计者控制点的次序光顺指曲线的拐点不能太多（有一、二阶导数等）相对光顺：具有二阶几何连续性($G^2 $)不存在多余拐点和奇异点曲率变化较小连续性曲线段首尾相接，在连接处如何有合乎要求的连续性曲线段 $p_i = p_i(t)，t\\in [t_{i0}, t_{i1}] $参数连续性0阶参数连续性，又称$C^0 $连续性，指曲线的几何位置连接，即前后两曲线相接处的x,y,z值相等1阶参数连续性，又称$C^1 $连续性，即前后两曲线相接处的一阶导数(切线)相等2阶参数连续性，又称$C^2 $连续性，即前后两曲线相接处的一阶导数和二阶导数都相等。$C^2 $连续性交点处的切向量变化率相等，即切线从一个曲线段平滑地变化到另一个曲线段几何连续性经典的参数连续性在图形学不适合，太苛刻。几何连续性只要求曲线段在相交处的参数导数成比例即可0阶几何连续性，又称$G^0 $连续性。与0阶参数连续性的定义相同，满足：$ p_i(t_i1) = p_{(i+1)}(t_{(i+1)0}) $1阶几何连续性，又称$G^1 $连续性。满足$G^0 $连续的前提下，有公共的切矢：$Q ‘ (0) = \\alpha P ‘ (1)，(\\alpha &gt; 0 ) $导数相等指大小方向都相等，公共切矢指方向相等大小不一定等2阶几何连续性，又称$G^2 $连续性。满足$G^1 $连续的前提下，有公共的曲率参数化过三点构造参数表示的插值多项式有无数。常用方法均匀参数化节点在参数轴等距分布累加弦长参数化根据长度的比例关系来确定 t$\\begin{cases} t_0=0 \\ t_i=t_{i-1}+|\\Delta P_{i-1}|,i=1,\\cdots , n\\end{cases}, \\Delta P_i = P_{i+1}-P_i $向心参数化法向心参数化法假设在一段曲线弧上的向心力与曲线切矢从该弧段始端至末端的转角成正比，加上一些简化假设，得到向心参数化法。此法尤其适用于非均匀型值点分布。$\\begin{cases} t_0=0 \\ t_i=t_{i-1}+|\\Delta P_{i-1}|^{\\frac{1}{2}},i=1,\\cdots , n\\end{cases} $参数曲线的代数形式和几何形式代数形式$\\begin{cases} x(t) = a_{3x}t^3 + a_{2x}t^2 + a_{1x} t + a_{0x} \\ y(t) = a_{3y}t^3 + a_{2y}t^2 + a_{1y} t + a_{0y} \\ z(t) = a_{3z}t^3 + a_{2z}t^2 + a_{1z} t + a_{0z}\\end{cases}, t\\in [0,1] $上式的矢量式为 $P(t) = a_3 t^3 +a_2t^2+a_1t+a_0 $，$a_i $是参数曲线的系数，且不是常数是向量，比如 $a_3 $ 对应 $a_{3x}, a_{3y}, a_{3z} $，但改变系数曲线如何变化不清楚，这是代数形式的缺点几何形式利用一条曲线端点的几何性质来刻画一条曲线，比如利用曲线的端点位置、切向量、各阶导数等端点的信息。对三次参数曲线，若用其端点位矢P(0)、P(1)和切矢P’(0)、P’(1)描述。需要这四个量来刻画三次参数曲线Hermit曲线的推导参数曲线的几何形式，对三次参数曲线，若用其端点位矢P(0)、P(1)和切矢P’(0)、P’(1)描述。需要这四个量来刻画三次参数曲线：将位矢P(0)、P(1)和切矢P’(0)、P’(1) 简记为 $P_0、P_1、P_0 ‘ 、P_1 ‘ $，代入三次参数曲线 $P(t) = a_3t^3+a_2t^2+a_1t+a_0，t\\in [0,1] $得 $\\begin{cases} P_0 = a_0 \\ P_1 = a_3+a_2+a_1+a_0 \\ P_0 ‘ = a_1 \\ P_1 ‘ = 3a_3+2a_2+a_1 \\end{cases} \\Rightarrow \\begin{cases} a_0 = P_0 \\ a_1 = P_0 ‘ \\ a_2 = -3P_0 + 3P_1 -2P_0 ‘ -P_1 ‘ \\ a_3=2P_0 -2P_1+P_0 ‘ +P_1 ‘ \\end{cases} $回代入 $P(t) $ 得 $P(t) = (2t^3-3t^2+1)P_0 + (-2t^3+3t^2)P_1 + (t^3-2t^2+t)P_0 ‘ +(t^3-t^2)P_1 ‘ ，t\\in [0,1] $令 $ \\begin{cases} F_0(t) = 2t^3-3t^2+1 \\ F_1(t) = -2t^3+3t^2 \\ G_0(t)=t^3-2t^2+t \\ G_1(t) = t^3-t^2 \\end{cases} \\Rightarrow P(t) = F_0P_0 + F_1P_1 + G_0P_0 ‘ + G_1P_1 ‘ ，t\\in [0,1] $上式即是三次 Hermit 曲线的几何形式，几何系数是 $P_0、P_1、P_0 ‘ 、P_1 ‘ $ ，调和函数是 $F_0、F_1、G_0、G_1 $。Bezier曲线与曲面Bezier曲线的背景插值：曲线通过所有的数据点逼近：曲线逼近这些数据点当用曲线段拟合曲线f(x)时，可以把曲线表示为许多小线段 $\\varphi_i(x) $ 之和，其中 $\\varphi_i(x) $ 称为基（混合）函数：$f(x) = \\sum\\limits_{i=0}^n a_i\\phi_i(x) $。经常会选择多项式作基函数。Bezier博士的想法是：先勾画折线多边形，再用光滑的参数曲线（Bezier曲线）逼近折线多边形（特征多边形）他的方程是： $ \\begin{cases} p(t) = \\sum\\limits_{i=0}^n P_i · f_{i,n}(t)，t\\in [0,1] \\ f_{i,n}(t)= \\begin{cases} 1, i=0 \\ \\frac{(-t)^i}{(i-1)!} \\frac{d^{i-1}}{dt^{i-1}} \\frac{(1-t)^{n-1}-1}{t} 称为Bezier基函数 \\end{cases} \\end{cases} $后来，剑桥大学博士生Forrest证明了Bezier曲线的基函数可以简化成伯恩斯坦基函数 $B_{i,n}(t) = C_n^it^i(1-t)^{n-i} = \\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}，i=0,1,\\cdots ,n $Bezier曲线的定义设空间 n+1 个点的位置矢量 $P_i，i=0,1,\\cdots , n$则Bezier曲线段的参数方程 $p(t) = \\sum\\limits_{i=0}^n P_i · B_{i,n}(t)，t\\in [0,1]$由二项式定理，$\\sum\\limits_{i=0}^n B_{i,n}(t) $ 恰好是二项式 $[t+(1-t)]^n $的展开式（$0^0 = 0! = 1$）一次Bezier曲线对 p(t)，当n=1，有两个控制点 p0、p1，Bezier多项式为一次多项式$\\begin{cases}p(t) = P_0B_{0,1}(t) + P_1B_{1,1}(t) \\ B_{0,1}(t) = 1-t \\ B_{1,1} = t \\end{cases} \\Rightarrow p(t) = (1-t) P_0 + tP_1 $是连接 p0、p1 的直线段二次Bezier曲线对 p(t)，当n=2，有两个控制点 p0、p1、p2，Bezier多项式为二次多项式$\\begin{cases}p(t) = P_0B_{0,2}(t) + P_1B_{1,2}(t)+ P_2B_{2,2}(t) \\ B_{0,2}(t) = (1-t)^2 \\ B_{1,2} = 2t(1-t) \\ B_{2,2}=t^2 \\end{cases} \\Rightarrow p(t) = (1-t)^2 P_0 + 2t(1-t)P_1+t^2P_2 $是一条抛物线，其矩阵形式为 $ p(t) = \\left[ \\begin{matrix} t^2 &amp; t&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} 1&amp;-2&amp;1 \\ -2&amp;2&amp;0 \\ 1&amp;0&amp;0 \\end{matrix} \\right] · \\left[ \\begin{matrix} P_0 \\ P_1 \\ P_2 \\end{matrix} \\right] $三次Bezier曲线对 p(t)，当n=3，有两个控制点 p0、p1、p2、p3，Bezier多项式为三次多项式$\\begin{cases}p(t) = P_0B_{0,3}(t) + P_1B_{1,3}(t)+ P_2B_{2,2}(t) + P_3B_{3,3}(t) \\ B_{0,3}(t)=(1-t)^3 \\ B_{1,3}(t)=3t(1-t)^2 \\ B_{2,3}(t)=3t^2(1-t) \\ B_{3,3}(t)=t^3 \\end{cases} \\Rightarrow \\ p(t) = (1-t)^3 P_0 + 3t(1-t)^2P_1+3t^2(1-t)P_2+t^3P_3 $矩阵形式：$ p(t) = \\left[ \\begin{matrix}t^3 t^2 &amp; t&amp;1 \\end{matrix} \\right] · \\left[ \\begin{matrix} -1&amp;3&amp;-3&amp;1 \\ 3&amp;-6&amp;3&amp;0 \\ -3&amp;3&amp;0&amp;0 \\ 1&amp;0&amp;0&amp;0 \\end{matrix} \\right] · \\left[ \\begin{matrix} P_0 \\ P_1 \\ P_2 \\ P_3 \\end{matrix} \\right] = T·M_{be}·G_{be}$，其中 $M_{be} $ 是三次Bezier曲线系数矩阵，$G_{be} $ 是4个控制点位置矢量。Bernstein基函数的性质$B_{i,n}(t) = C_n^it^i(1-t)^{n-i} = \\frac{n!}{i!(n-i)!}t^i(1-t)^{n-i}，i=0,1,\\cdots ,n $非负性$B_{i,n}(t) = \\begin{cases}=0 &amp; t=0,1 \\ &gt;0 &amp; t\\in(0,1),i=1,\\cdots ,n-1 \\end{cases}$权性$\\sum\\limits_{i=0}^n B_{i,n}(t) = 1， t\\in(0,1) $端点性质$B_{i,n}(0) = \\begin{cases}i &amp;(i=0) \\ 0&amp; otherwise \\end{cases} \\ B_{i,n}(1) = \\begin{cases}i &amp;(i=n) \\ 0&amp; otherwise \\end{cases} $对称性保持n次Bezier曲线控制多边形的顶点位置不变，而把次序颠倒过来，则此时曲线仍不变，只不过曲线的走向相反而已递推性$B_{i,n}(t) = (1-t)B_{i,n-1}(t) + tB_{i-1,n-1}(t)， i=0,\\cdots, n$导函数$ B ‘ {i,n}(t) = n[B_{i-1,n-1}(t) - B_{i,n-1}(t)]，i=0,\\cdots, n $最大值$B_{i,n}(t) $ 在 $t =\\frac{i}{n} $ 处取最大值积分$\\int_0^1 B_{i,n}(t)dt = \\frac{1}{n+1}$降阶公式一个n次Bernstein基函数能表示成两个n-1次基函数的线性和，$B_{i,n}(u) = (1-u)B_{i,n-1}(u)+uB_{i-1,n-1}(u) $升阶公式$ B_{i,n}(u) = (1-\\frac{i}{n+1}) B_{i,n+1}(t) + \\frac{i+1}{n+1} B_{i+1, n+1}(t) $Bezier曲线的性质端点性质顶点 $p_0$ 和 $p_n$ 分别位于实际曲线段的起点和终点上$p(0) = \\sum\\limits_{i=0}^n P_i ·B_{i,n}(0) = P_0 \\ p(1) = \\sum\\limits_{i=1}^n P_i · B_{i,n}(1) = P_1 $一阶导数Bernstein基函数的一阶导数 $ B’ {i,n}(t) = n[B{i-1,n-1}(t) - B_{i,n-1}(t)]，i=0, \\cdots , n \\ p ‘ (t) = n \\sum\\limits_{i=1}^n (p_i-p_{i-1}) B_{i-1,n-1}(t) $$ p ‘ (0) =n(p_1-p_0) \\ p ‘ (1)=n(p_n-p_{n-1}) $，这说明Bezier曲线的起点和终点处的切线方向和特征多边形的第一条边及最后一条边的走向一致。几何不变形指某些几何特性不随坐标变换而变化的特性。Bezier曲线的形状仅与控制多边形各顶点的相对位置有关，而与坐标系的的选择无关变差缩减性若Bezier曲线的特征多边形是一个平面图形，则平面内任意直线与p(t)的交点个数不多于该直线与其特征多边形的交点个数此性质反映了Bezier曲线比其特征多边形的波动还小，也就是说Bezier曲线比特征多边形的折线更光顺Bezier曲线的生成根据定义直接生成：给出 $C_n^i $ 的递归计算式：$C_n^i = \\frac{n!}{i!(n-i)!} = \\frac{n-i+1}{i}C_n^{i-1}，n \\ge i $将 $p(t) = \\sum\\limits_{i=0}^n P_i · B_{i,n}(t)，t\\in [0,1] $ 表示成分量坐标形式： $\\begin{cases} x(t) = \\sum\\limits_{i=0}^n x_i · B_{i,n}(t) \\ y(t) = \\sum\\limits_{i=0}^n y_i · B_{i,n}(t) \\ z(t) = \\sum\\limits_{i=0}^n z_i · B_{i,n}(t) \\end{cases}，t\\in[0,1]$de Casteljau算法（Bezier曲线的递推算法）：每次取每条线段上等比例t的点P连线，n次后得到的单一连线的比例t处是Bezier曲线上一点，不断的变化 t ( 0-&gt;1 )，即可得到Bezier曲线二次Bezier曲线举例：三次Bezier曲线举例：公式：$P_i^k = \\begin{cases} P_i &amp; k=0 \\ (1-t)P_i^{k-1}+tP_{i+1}^{k-1} &amp; k=1,\\cdots ,n，i=0,\\cdots ,n-k \\end{cases}$，$P_i $为控制点，$k $ 为第k级递推时Bezier曲线的拼接几何设计中，一条Bezier曲线往往难以描述复杂的曲线形状。这是由于增加特征多边形的顶点数，会引起Bezier曲线次数的提高，而高次多项式又会带来计算上的困难。所以采用分段设计，然后将各段曲线相互连接起来，并在接合处保持一定的连续条件拼接：给两条Bezier曲线P(t)和Q(t)，相应控制点为Pi(i =0,1,…,n)和Qi(i=0,1,…,m)要使它们达到 $G^0 $ 连续，保证：$P_n= Q_0 $要使它们达到 $G^1 $ 连续，保证$P_{n-1}，P_n = Q_0，Q_1 $三点共线Bezier曲线的升阶和降阶升阶：保证曲线的形状和定向保持不变，增加顶点个数。比如将找一个三次多项式逼近一个二次多项式，但伯恩斯坦基函数不是简单的多项式函数。降阶，则是反之。Bezier升阶：定义原控制顶点为 $P_0,P_1,\\cdots ,P_n $，升阶增加一个顶点后仍定义为 $ P_0^,P_1^,\\cdots ,P_{n+1}^* $要求曲线形状和定向不变，则 $\\sum\\limits_{i=0}^n C_n^i P_i t^i (1-t)^{n-i} = \\sum\\limits_{i=0}^{n+1} C_{n+1}^i P_i^* t^i (1-t)^{n+1-i} $对上式左乘 $(t+(1-t)) $ 得： $\\sum\\limits_{i=0}^n C_n^i P_i(t^i (1-t)^{n+1-i}+t^{i+1}(1-t)^{n-i}) = \\sum\\limits_{i=0}^{n+1} C_{n+1}^i P_i^* t^i (1-t)^{n+1-i} $比较等式两边 $t^i(1-t)^{n+1-t} $ 项的系数，得到： $P_i^* C_{n+1}^i = P_i C_n^i +P_{i-1} C_n^{i-1} $化简得：$P_i^* = \\frac{i}{n+1}P_{i-1} + (1-\\frac{i}{n+1})P_i， (i=0,\\cdots ,n+1) $ 其中 $P_{-1} = P_{n+1} = (0,0) $此式说明新的控制顶点 $P_i^* $ 是以参数值 $\\frac{i}{n+1} $按分段线性插值从原始特征多边形得到的升阶后的新特征多边形在原始特征多边形的凸包内特征多边形更靠近曲线Bezier降阶：$\\begin{cases} P_i^\\frac{nP_i-iP_{i-1}^}{n-i} &amp; i=0,1,\\cdots, n-1 \\ P_{i-1}^* = \\frac{nP_i-(n-i)P_i^*}{i} &amp; i=n,n-1,\\cdots ,1 \\end{cases} $Bezier升降阶的重要性：它是CAD系统之间数据传递与交换的需要它是系统中分段(片)线性逼近的需要，通过逐次降阶，把曲面化为直线平面，便于求交和曲面绘制它是外形信息压缩的需要。降阶处理以后可以减少存储的信息量Bezier曲面基于Bezier曲线拓展给出基于Bezier曲面的定义定义：设 $P_{i,j} （i=0,1,\\cdots ,m，j=0,1,\\cdots ,n）$ 为 $(n+1)\\times (m+1) $ 个空间点，则 $m\\times n $ Bezier曲面为：$P(u,v) = \\sum\\limits_{i=0}^m\\sum\\limits_{j=0}^n P_{ij}·B_{i,m}(u)·B_{j,n}(v) ， u,v\\in[0,1] $$ B_{i,m}(u) = C_m^i u^i (1-u)^{m-i} \\ B_{j,n}(v) = C_n^j v^j (1-v)^{n-j} $矩阵表示式：$P(u,v) = \\left[ \\begin{matrix} B_{0,m}(u) &amp; B_{1,m}(u)&amp; \\cdots &amp; B_{m,m}(u) \\end{matrix} \\right] · \\left[ \\begin{matrix} P_{00}&amp;P_{01}&amp;\\cdots&amp;P_{0n} \\ P_{10}&amp;P_{11}&amp;\\cdots&amp;P_{1n} \\ \\cdots&amp;\\cdots&amp;\\cdots&amp;\\cdots \\ P_{m0}&amp;P_{m1}&amp;\\cdots&amp;P_{mn}\\end{matrix} \\right]· \\left[ \\begin{matrix}B_{0,n}(v) \\ B_{1,n}(v) \\ \\cdots \\ B_{n,n}(v) \\ \\end{matrix} \\right]$ ​特征网格：依次用线段连接点列中相邻两点所形成的空间网格角点位置：控制网络的四个点边界线：Bezier曲面的四条边界线是Bezier曲线性质：Bezier曲面特征网格的四个角点正好是Bezier曲面的四个角点，即 $P(0, 0) = P_{00} ， \\cdots $Bezier曲面特征网格最外一圈顶点定义Bezier曲面的四条边界几何不变性对称性凸包性Bezier曲面片的拼接：设两张 $m\\times n$ 次Bezier曲面片：$P(u,v) = \\sum\\limits_{i=0}^m\\sum\\limits_{j=0}^n P_{ij}·B_{i,m}(u)·B_{j,n}(v) ， u,v\\in[0,1] \\ Q(u,v) = \\sum\\limits_{i=0}^m\\sum\\limits_{j=0}^n Q_{ij}·B_{i,m}(u)·B_{j,n}(v) ， u,v\\in[0,1] $要求两曲面片达到 $G^0$ 连续，则它们有公共的边界，则 $P (1, v) = Q (0, v)\\Rightarrow P_{ni}=Q_{0i}，i=0,\\cdots , m $要求沿该公共边界达到 $G^1$ 连续，则两曲面片在该边界上有公共的切平面，因此曲面的法向应跨界连续，$Q_u(0,v)\\times Q_v(0,v) = \\alpha(v) P_u(1,v)\\times P_v(1,v) $递推(de Casteljau)算法（曲面的求值）：一条曲线可表示成两条低一次曲线的组合，则将一张曲面表示成低一次的四张曲面的线性组合$ P_{i,j}^{k,l} = \\begin{cases} P_{ij} &amp; k=l=0 \\ (1-u)P_{ij}^{k-1,0}+uP_{i+1,j}^{k-1,0} &amp; k=1,\\cdots ,m， l=0 \\ (1-v)P_{0,j}^{m,l-1} + vP_{0,j+1}^{m,l-1} &amp; k=m， l=1,\\cdots ,n \\end{cases} $按上式，以 u 为参数值对控制网格 u 方向的 n+1 个多边形执行递推算法，m级递推后，得到 n+1 个顶点 $P_{0j}^{m0} $ 构成的多边形，再以 v 参数值拿这 n+1 个顶点当作新控制顶点来算，得到 $P_{00}^{mn}$ 为曲面上一点B样条曲线与曲面B样条产生的背景Bezier曲线的不足：一旦确定了特征多边形的顶点数，即确定了曲线的阶次Bezier曲线/面的拼接比较复杂Bezier曲线/面不能作局部修改Bernstein多项式在[0, 1] 上都有支撑，故每个控制项都对 $t \\in [0,1] $有影响。样条(Spline)：分段连续多项式整条曲线用一个完整的表达形式，但内在的量是一段一段的比如5个点，用Bezier曲线构造的多项式应是四次多项式，用样条构造四段曲线，每一段都是三次，且段间 $C^2$ 连续。既克服了波动现象，曲线又是低次的。既有统一的表达时，又有统一的算法B样条的递推定义和性质Ｂ样条曲线的数学表达式为：$ P(u) = \\sum\\limits_{i=0}^n P_i B_{i,k}(u)，u\\in[u_{k-1}, u_{n+1}] ，P_i $ 是控制多边形的顶点。对比Bezier曲线：$ P(u) = \\sum\\limits_{i=0}^n P_i B_{i,n}(u)，u\\in[0,1] $ ，有两点不一样：一是伯因斯坦基函数的下标参数$ B_{i,k}(u) $ 称为 k 阶(k-1次)的B样条基函数，k 是刻画次数的。对于Bezier曲线，阶数等于次数，B样条而言，阶数等于次数加一二是 u 的取值范围B样条基函数是一个非递减的参数u的序列（称为节点向量）所决定的k阶分段多项式de Boor-Cos递推定义：公认的最容易理解原理：由0次构造1次，1次构造2次，依次类推。$\\large \\begin{cases} B_{i,1}(u) = \\begin{cases} 1&amp;u_i\\lt u \\lt u_{i+1} \\ 0&amp;otherwise \\end{cases} \\ B_{i,k}(u) = \\frac{u-u_i}{u_{i+k-1}-u_i}B_{i,k-1}(u) + \\frac{u_{i+k}-u}{u_{i+k}-u_{i+1}} B_{i+1,k-1}(u) \\end{cases} ，约定 \\frac{0}{0}=0 $若确定第i个k阶B样条 $B_{i,k}(u) $，需要用到 $u_i,u_{i+1},…,u_{i+k} $ 共k+1个节点，称区间 $ [u_i,u_{i+k}]$ 为$B_{i,k}(u) $的支撑区间$ B_{i,1}(u) $ 是0次多项式，推出1次的 $B_{i,2}(u) $ 是一个分段函数de Boor-Cos递推公式：$d_j^i = \\begin{cases}d_j, &amp; l=0 \\ (1-\\alpha_j^l )d_{j-1}^{l-1}+\\alpha_j^l d_j^{l-1}, &amp; l=1,\\cdots ,阶数-1 \\end{cases}， \\alpha j^l = \\frac{u-u_j}{u{j+阶数-l}-t_j } $B样条基函数定义区间及节点向量ezie &amp; cr曲线的定义区间 [0, 1]K阶B样条对应节点向量数：$B_{i,1} $涉及 $[u_i, u_{i+1}]$ 一个区间，即涉及 1 个区间 2 个节点；$B_{i,2} $ 由 $B_{i,1} $ 和 $B_{i+1,1} $ 组成，即涉及 2 个区间 3 个节点；…$B_{i,k} $ 涉及 k 个区间 k+1 个节点。B样条函数定义区间——$u\\in[u_{k-1}, u_{n+1}] $：即在 $[u_{k-1}, u_{n+1}] $ 产生拼接。首先，区间要合法，区间里必要有足够的基函数与定点配对。B样条基函数严重依赖于节点向量的分布。上图中区间 $[u_3,u_5]（从u_{k-1}到u_{n+1}） $是第一个开始有意义的区间，故此上面的曲线被分成两段 $u_3u_4 ， u_4u_5 $，即考虑拼接 $P_0P_1P_2P_3 $ （刚好在$u_3u_4 $区间有定义）和 $P_1P_2P_3P_4 $（刚好在$u_4u_5 $区间有定义），两端有三个定点相同，拼接效果良好节点向量：$u_i $ 是节点值， $U = (u_0,u_1,\\cdots ,u_{n+k}) $ 构成了k阶(k-1次)的B样条函数的节点向量B样条基函数的主要性质局部支承性$B_{i,k}(u)\\begin{cases} \\ge 0 &amp; u\\in [u_i, u_{i+k}] \\ =0 &amp; otherwise \\end{cases} $ 而Bezier在整个区间非0反过来，对每一个区间 $(u_i, u_{i+k})$ ，至多只有 k 个基函数在其上非零权性$\\sum\\limits_{i=0}^n B_{i,k}(u) = 1，u \\in [u_{k-1}, u_{n+1}] $连续性$B_{i,k}(u) $ 在 r 重节点处的连续阶不低于 k-1-r分段参数多项式$B_{i,k}(u) $ 在每个长度非零的区间 $[u_i, u_{i+1})$ 上都是次数不高于 k-1 的多项式，它在整个参数轴上是分段多项式B样条函数的主要性质局部性k阶B样条曲线上的一点至多与k个控制顶点有关，与其它控制顶点无关移动曲线的第i个控制顶点$P_i$ ，至多影响到定义在区间上那部分曲线的形状，对曲线其余部分不发生影响变差缩减性设平面内 n+1 个控制顶点构成B样条曲线 P(t) 的特征多边形。在该平面内的任意一条直线与 P(t) 的交点个数不多于该直线和特征多边形的交点个数几何不变性B样条曲线的形状和位置与坐标系的选择无关凸包性B样条曲线落在Pi构成的凸包之中。其凸包区域小于或等于同一组控制顶点定义的Bezier曲线凸包区域凸包就是包含右边这6个顶点的最小凸多边形。凸多边形是把多边形的每条边延长，其它边都在它的同一侧该性质导致顺序k+1个顶点重合时，由这些顶点定义的k次B样条曲线段退化到这一个重合点；顺序k+1个顶点共线时，由这些顶点定义的k次B样条曲线形状是？B样条曲线类型的划分均匀B样条曲线（uniform B-splinecurve）当节点沿参数轴均匀等距分布，即 $u_{i+1} - u_i = 常数 \\gt 0 $ 时，表示均匀B样条函数{0, 1, 2, 3, 4, 5, 6}{0, 0.2, 0.4, 0.6, 0.6, 0.8, 1}均匀B样条的基函数呈周期性。即给定n和k，所有的基函数有相同形状。每个后续基函数仅仅是前面基函数在新位置上的重复：$B_{i,k}(u) = B_{i+1,k}(u+\\Delta u) = B_{i+2,u}(u+2\\Delta u) $其中 $\\Delta u $ 是相邻节点值的间距，等价地，可以写为： $B_{i,k}(u) = B_{0,k}(u-k\\Delta u) $均匀周期性B样条基函数的计算举例：以均匀二次（三阶）B样条曲线为例假定有四个控制点，取参数值 n=3，k=3，则 n+m=6，$u = (0,1,2,3,4,5,6) $根据de Boor-Cox递推公式$ P(u) = \\sum\\limits_{i=0}^n P_iB_{i,k}(u) $，$ \\begin{cases} B_{i,1}(u) = \\begin{cases} 1&amp;u_i\\lt u \\lt u_{i+1} \\ 0&amp;otherwise \\end{cases} \\ B_{i,k}(u) = \\frac{u-u_i}{u_{i+k-1}-u_i}B_{i,k-1}(u) + \\frac{u_{i+k}-u}{u_{i+k}-u_{i+1}} B_{i+1,k-1}(u) \\end{cases} ， 约定 \\frac{0}{0}=0 $算得：$ B_{0,1}(u) = \\begin{cases} 1&amp;0\\le u \\lt 1 \\ 0&amp;otherwise \\end{cases}，u=(0,1,2,3,4,5,6) \\ B_{0,2}(u) = uB_{0,1}(u) + (2-u)B_{1,1}(u) = \\begin{cases} u &amp; 0\\le u \\lt 1 \\ 2-u &amp; 1\\le u \\lt 2 \\end{cases} \\ B_{0,3}(u) = \\frac{u}{2} B_{0,2}(u) + \\frac{3-u}{2} B_{1,2}(u-1) = \\begin{cases} \\frac{1}{2}u^2 &amp; 0\\le u \\lt 1 \\ \\frac{1}{2}u(2-u) + \\frac{1}{2}(u-1)(3-u) &amp; 1\\le u\\lt 2 \\ \\frac{1}{2}(3-u)^2 &amp; 2\\le u \\lt 3 \\end{cases} \\ B_{1,3}(u) = \\begin{cases} \\frac{1}{2}(u-1)^2 &amp; 1\\le u \\lt 2 \\ \\frac{1}{2} (u-1)(3-u) + \\frac{1}{2}(u-2)(4-u) &amp; 2\\le u \\lt 3 \\ \\frac{1}{2}(4-u)^2 &amp; 3\\le u \\lt 4 \\end{cases} \\ B_{3,3}(u) = \\begin{cases} \\frac{1}{2}(u-3)^2 &amp; 3\\le u \\lt 4 \\ \\frac{1}{2} (u-3)(5-u) + \\frac{1}{2}(u-4)(6-u) &amp; 4\\le u \\lt 5 \\ \\frac{1}{2}(6-u)^2 &amp; 5\\le u \\lt 6 \\end{cases} $准均匀 B 样条曲线（Quasi-uniform B-splinecurve）：与均匀B样条曲线的差别在于两端节点具有重复度k，这样的节点矢量定义了准均匀的B样条基均匀：u = (0,1,2,3,4,5,6)准均匀：u = (0,0,0,1,2,3,4,5,5,5)均匀B样条曲线没有保留Bezier曲线端点的几何性质，采用准均匀的B样条曲线解决了这个问题分段Bezier曲线（Piecewise Bezier Curve）：节点矢量中两端节点具有重复度k，所有内节点重复度为k-1，这样的节点矢量定义了分段的Bernstein基B样条曲线用分段Bezier曲线表示后，各曲线段就具有了相对的独立性另外，Bezier曲线一整套简单有效的算法都可以原封不动地采用缺点是增加了定义曲线的数据，控制顶点数及节点数非均匀B样条曲线（non-uniform B-splinecurve）：当节点沿参数轴的分布不等距，即 $u_{i+1}-u_i \\not= 常数 $ 时，表示非均匀B样条函数B样条曲面给定参数轴 u 和 v 的节点矢量：$\\begin{cases} U=[u_0,u_1, \\cdots, u_{m+p}] \\ V=[v_0,v_1, \\cdots, v_{n+q}] \\end{cases} $则 $p\\times q $ 阶B样条曲面定义为： $ P(u, v) = \\sum\\limits_{i=0}^m \\sum\\limits_{j=0}^n P_{i,j} N_{i,p}(u) N_{j,q}(v) $B样条曲面的特征网络： $P_{i , j}$ 构成的一张控制网格$N_{i,p}(u)，N_{j,v) - C$ 是B样条基，分别由节点矢量U和V按deBoor-Cox递推公式决定第6章 真实感图形学真实感图形学的三部曲：建模：建立三维场景消隐：消隐解决物体深度的显示及确认物体内的相互关系渲染：消隐后，在可见面上进行敏感光泽的处理，然后绘制学习本章之前，先完全记住以下单词：incident light，入射光diffuse，扩散，漫反射specular，缩写spec，镜面的refracted，折射的transparent，透明的Distribution，分布Intensity，光强颜色模型颜色颜色是人的视觉系统对可见光的感知结果，感知到的颜色由光波的波长决定。人眼对于颜色的观察和处理是一种生理和心理现象，其机理还没有完全搞清楚。视觉系统能感觉的波长范围为380～780nm。颜色模型颜色模型（颜色空间），是表示颜色的一种数学方法，人们用它来标定颜色。通常用三个参数表示。几乎所有的颜色模型都从RGB颜色模型导出。目前现有颜色模型还没有一个完全符合人的视觉感知特性、颜色本身的物理特性或发光物体和光反射物体的特性。RGB颜色工业模型如图所示，单位立方体中的三个角对应红色(R)、绿色(G)、蓝色(B)三基色，而其余三个角分别对应于三基色的补色——青色(C)、黄色(Y)、品红色(M)从RGB单位立方体的原点即黑色(0,0,0)到白色顶点(1,1,1)的主对角线被称为灰度线，线上所有的点具有相等的分量，产生灰度色调。其他颜色工业模型主要用于彩色电视信号传输标准，主要有YIQ、 YUV、 YCbCr彩色模型。三种彩色模型中，Y分量均代表黑白亮度分量，其余分量用于显示彩色信息。只需利用Y分量进行图像显示，彩色图像就转为灰度图像。颜色视觉模型以上彩色模型是从色度学或硬件实现的角度提出的但用色调(Hue)、饱和度(Saturation，也称彩度)、亮度(Illumination)三要素来描述彩色空间能更好地与人的视觉特性相匹配。颜色的三个基本属性（也称人眼视觉三要素）色调(Hue)：由物体反射光线中占优势的波长决定的，是彩色互相区分的基本特性。饱和度(Saturation)或彩度：彩色的深浅程度，它取决于彩色中白色的含量。饱和度越高，彩色越深，白色光越少。亮度(Illumination)：光波作用于感受器所发生的效应，它取决于物体的反射系数。反射系数越大，物体亮度越大。HSI彩色模型是截面为三角形或圆形的锥体模型。H，色调，颜色的外观，用角度表示：如赤橙黄绿青蓝紫S，饱和度，分为低(0%～20%)，不管色调如何而产生灰色中(40%～60%)，产生柔和的色泽(pastel)高(80%～100%)，产生鲜艳的颜色(vivid color)I，光照，颜色的量度，取值范围从0%(黑)～100%(最亮)其他颜色视觉模型HSV彩色模型（Hue，Saturation，Value）HSL采用亮度L(lightness)、HSV采用明度V(value)作为坐标。简单光照模型光照明模型：illumination model，模拟物体表面的光照明物理现象的数学模型。简单光照明模型只考虑光源对物体的直接光照光照模型的发展1967年，Wylie等人第一次在显示物体时加进光照效果，认为光强与距离成反比。1970年，Bouknight提出第一个光反射模型：Lambert漫反射＋环境光（第一个可用的光照模型）。1971年，Gouraud提出漫反射模型加插值的思想（漫反射的意思是光强主要取决于入射光的强度和入射光与法线的夹角）。1975年，Phong提出图形学中第一个最有影响的光照明模型 。在漫反射模型的基础上加进了高光项。背景物理知识反射定律：入射角等于反射角，而且反射光线、入射光线与法向量在同一平面上。折射定律：折射线在入射线与法线构成的平面上，折射角与入射角满足：$ \\frac{\\eta_1}{\\eta_2} = \\frac{sin \\varphi}{sin \\theta} $，参数是折射率和折射角能量守恒： $ I_i = I_d+I_s+I_t+I_v $，入射光强=漫反射光强+镜面反射光强+折射光强+吸收光强漫反射光：光线射到物体表面上后（比如泥塑物体的表面，没有一点镜面效果），光线会沿着不同的方向等量的散射出去的现象。漫反射光均匀向各方向传播，与视点无关，它是由表面的粗糙不平引起的。镜面反射光：一束光照射到一面镜子上或不绣钢的表面，光线会沿着反射光方向全部反射出去，这种叫镜面反射光。折射光：比如水晶、玻璃等，光线会穿过去一直往前走。吸收光：比如冬天晒太阳会感觉到温暖，这是因为吸收了太阳光。Phong光照模型Phong光照模型 = 环境光+漫反射光+镜面反射光单一光源照射下Phong光照模型：$I = I_aK_a+I_pK_dcos\\theta+I_pK_scos^n\\alpha $单一光源照射下Phong光照模型常用形式：$I = I_aK_a+I_pK_d(L·N)+ I_pK_s(R·V)^n $$I $ 是景物表面在被照射点处的光亮度，L是已知光源方向，V是视线的方向，R是反射光方向可计算出来，N是物体表面的法向可计算环境光，$I_{\\text{ambient}} = I_aK_a$，$I_a $环境光强度，$K_a$环境光反射系数邻近各物体所产生的光的多次反射最终达到平衡时的一种光。可近似认为同一环境下的环境光，其光强分布是均匀的。漫反射光，$I_{\\text{diffuse}}=I_pK_d(L·N) ，cos\\theta=L·N $，$I_p$点光源光强，$K_a$物体表面漫反射率光照射到比较粗糙的物体表面，物体表面某点的明暗程度不随观测者的位置变化，这种等同地向各个方向散射的现象称为光的漫反射。漫反射光强近似服从Lambert定律镜面反射光，$I_{\\text{spec}} = I_pK_s(R·V)^n ，cos\\alpha=R·V$，$I_p$点光源光强，$K_s$物体表面镜面反射率，$n$镜面高光指数，取值1-2000，反映光滑程度光照射到相当光滑的物体表面，产生镜面反射光，其特点是在光滑表面会产生高光区域。结合RGB颜色模型后，$\\begin{cases} I_r = I_{ar}K_{ar} +I_{pr}K_{dr}(L·N)+I_{pr}K_{sr}(R·V)^n \\ I_g = I_{ag}K_{ag} +I_{pg}K_{dg}(L·N)+I_{pg}K_{sg}(R·V)^n \\ I_b = I_{ab}K_{ab} +I_{pb}K_{db}(L·N)+I_{pb}K_{sb}(R·V)^n \\end{cases} $Phong模型扫描线算法：其中$(r,g,b) = k_a(r_{pa},g_{pa},b_{pa}) + \\sum [ k_d(r_{pd},g_{pd},b_{pd})cos\\theta+k_s(r_{ps},g_{ps},b_{ps})cos^n\\alpha]$12345678910111213for 屏幕上每一条扫描线y do begin 将数组Color初始化成为y扫描线的背景颜色值 for y扫描线上的每一可见区间段s中的每个点(x,y) do begin 设(x,y)对应的空间可见点为P 求出P点处的单位法向量N、P点的单位入射光向量L、单位视线向量V 求出L在P点的单位镜面反射向量R (r,g,b) = 代码块外的那个公式 置Color(x,y) = (r,g,b) end 显示Color endPhong示例：Phong总结：它是真实感图形学中提出的第一个有影响的光照明模型，生成图象的真实度已经达到可以接受的程度。其模拟光从物体表面到观察者眼睛的反射。尽管这种方法符合一些基本的物理法则，但它更多的是基于对现象的观察，所以被看成是一种经验式的方法。实际应用中，这个经验模型还有以下问题显示出的物体像塑料，无质感变化没有考虑物体间相互反射光镜面反射颜色与材质无关镜面反射入射角大，会产生失真现象增量式光照模型光暗处理的必要性：三维物体通常用多边形（三角形）来近似模拟。由于每一个多边形的法向一致，因而多边形内部的象素颜色相同，而且在不同法向的多边形邻接处，光强突变，使具有不同光强的两个相邻区域之间的光强不连续性(马赫带效应)。明暗处理思想：每一个多边形的顶点处计算出光照强度或参数，然后在各个多边形内部进行均匀插值方法Gouraud明暗处理（双线性光强插值算法）Phong明暗处理（双线性法向插值算法）Gouraud明暗处理双线性光强插值算法：计算多边形顶点的平均法向。与某个顶点相邻的所有多边形的法向平均值近似作为该顶点的近似法向量，顶点A相邻的多边形有k个，它的法向量计算为：$N_\\alpha = \\frac{1}{k} (N_1+N_2+\\cdots +N_k)$用Phong光照模型计算顶点的光强Phong光照模型出现前，采用如下光照模型计算：$I = I_aK_a+I_pK_d\\frac{(L·N_\\alpha)}{r+k} $插值计算离散边上个点的光强$I_A = uI_1 +(1-u)I_2，u=\\frac{AV_2}{V_1V_2} \\ I_B = vI_1+(1-v)I_3，v=\\frac{BV_3}{V_1V_3} $插值计算多边形内域中各点的光强$I_p = tI_A + (1-t)I_B，t=\\frac{PB}{AB} $求任一点的光强需要进行两次插值计算扫描线增量思想的优化：离散边上个点的光强$I_{A,j+1} = I_{A,j} + \\Delta I_A \\ I_{B,j+1} = I_{B,j} + \\Delta I_B \\ \\Delta I_A = \\frac{I_1-I_2}{y_1-y_2} \\ \\Delta I_B = \\frac{I_1-I_3}{y_1-y_3} $扫描线内部$I_{i+1, p} = I_{i,p} + \\Delta I_p \\ \\Delta I_p = \\frac{I_B-I_A}{x_B-x_A} $Phong明暗处理Gouraud明暗处理的不足不能有镜面反射光（高光）双线性插值是把能量往四周均匀，平均的结果就是光斑被扩大了，本来没光斑的地方插值后反而出现了光斑。Phong明暗处理以计算量、时间为代价，引入镜面反射，解决高光问题算法：计算每个多边形顶点处的平均单位法矢量（与Gouraud明暗处理方法的第一步相同）用双线性插值方法求得多边形内部各点的法矢量$N_A $ 由 $N_1$ 和 $N_2 $ 线性插值而来$N_B $ 由 $N_1$ 和 $N_3 $ 线性插值而来$N_P $ 由 $N_A$ 和 $N_B $ 线性插值而来按光照模型确定多边形内部各点的光强两种增量式光照模型比较Phong方法Gouraud方法产生的效果高光明显效果并不明显高光多位于多边形内部多边形内部无高光明暗变化缺乏层次感光强度变化均匀，与实际效果更接近计算量大计算量小增量式光照模型的不足物体边缘轮廓是折线段而非光滑曲线等间距扫描线会产生不均匀效果插值结果取决于插值方向局部光照模型简单光照模型是一个比较粗糙的经验模型，不足之处在于镜面反射项与物体表面的材质无关局部光照模型仅处理光源直接照射物体表面，不处理物体间反射的影响相对于简单光照模型的优点基于入射光能量导出的光辐射模型反映表面的粗糙度对反射光强的影响高光颜色与材料的物理性质有关改进入射角很大时的失真现象考虑了物体材质的影响，可以模拟磨光的金属光泽理论基础光的电磁理论光波是电磁波的一种，自然光照射到物体表面的反射光，其反射率系数 $\\rho$ 可由 Fresnel 公式计算：$\\large \\rho = \\frac{1}{2}(\\frac{tg^2(\\theta - \\psi)}{tg^2(\\theta+\\psi)} + \\frac{sin^2(\\theta - \\psi)}{sin^2(\\theta + \\psi)}) $$\\theta $ 是入射角， $\\psi $ 是折射角， $\\eta_1，\\eta_2 $是发生反射的物体表面两侧折射率，其中 $sin\\psi = \\frac{\\eta_1}{\\eta_2} sin\\theta $反射率 $\\rho $ 与折射率有关，是波长的函数 $\\rho (\\theta, \\lambda) $微平面理论将粗糙物体表面看成是由无数个微小的理想镜面组成，这些镜面朝向各异，随机分布，所以可用分布函数去描述综合各种原因后，物体的反射率可以这样计算：$DG\\rho(\\theta, \\lambda) $D 为微平面法向的分布函数G 为由于微平面的相互遮挡或屏蔽而使光产生的衰减因子Gauss分布函数模拟法向分布（Torrance和Sparrow两人用Gauss高斯分布来模拟，也可用Berkmann分布）$D = ke^{-(a/m)^2} $k 为常系数a 为微平面的法向与平均法向的夹角，即 $(N·H) $m 为微平面斜率的均方根，表示表面的粗糙程度，$m =\\sqrt{\\frac{m_1^2+m_2^2+\\cdots +m_n^2}{n}} $衰减因子 G 也可反映物体表面的粗糙程度$G =min(1, G_m, G_s) $下图分别是无遮挡、反射光被遮挡、入射光被遮挡的情况局部光照明模型$I_r$ 反射光光强$E_i$ 单位时间内单位面积上的入射光能量$R_{bd} $ 物体表面对入射自然光的反射率系数，$R_{bd} = \\frac{I_r}{E_i} $又由于入射光能量 $E_i $ 可表示为 $E_i = I_i cos\\theta · d\\omega = I_i (N·L) d\\omega $故，反射光光强：$I_r = R_{bd} I_i (N·L) d\\omega $反射率系数可表示为漫反射率和镜面反射率的代数和：$R_{bd} = K_d R_d + K_s R_s \\ K_d+K_s =1 \\ R_d = R_d(\\lambda) \\ R_s = \\frac{DG\\rho(\\theta, \\lambda)}{\\pi (N·L)(N·V)} $所以局部光照模型表示为：$ \\Large I_r = I_a K_a + I_i (N·L) d \\omega (K_dR_d + K_sR_s) $光透射模型为什么考虑光透射模型：简单和局部光照模型没有考虑光的透射现象其适用于场景中有透明或者半透明的物体的光照处理早期用颜色调和法进行光透射模拟颜色调和法：$ I = t\\times I_b +(1-t) \\times I_a $不考虑透明体对光的折射以及透明物体本身的厚度，光通过物体表面是不会改变方向的，可以模拟平面玻璃。Whitted 光透射模型提出了第一个整体光照模型，并给出了一般光线跟踪算法的范例，综合考虑了光的反射、折射、透射和阴影等。被认为是计算机图形领域的一个里程碑。即在简单光照明模型的基础上，加上透射光项、镜面反射光项$\\large I = I_a · K_a + I_p·K_d·(L·N)+I_p·K_s·(R·V)^n + I_t ‘ ·K_t ‘ +I_s ‘ · K_s ‘ $整体光照模型整体光照模型的诞生：简单和局部光照模型不能很好地模拟光的折射、反射和阴影等，也不能用来表示物体间的相互光照影响。整体光照模型有光线跟踪、辐射度两种方法光线跟踪效果图如下光线跟踪基本过程：如图，点光源 L，透明体 $O_1, O_2$ ，不透明体 $O_3$首先，视线 E 从视点出发，过视屏一个像素点，到达球体 $O_1 $ 交于点 $P_1$交点：从 $P_1$ 向光源 $L $ 作一条阴影测试线 $S_1 $ ，发现期间没有遮挡的物体，用局部光照模型计算光源对 $P_1$ 在其视线 E 方向上的光强作为局部光强在交点产生衍生的光线：反射光线 $R_1$ 方向，没有再与其他物体相交，设该方向的光强为 0，结束 $R_1$ 的跟踪折射光线 $T_1$ 方向，与 $O_1$ 交于点 $P_2 $，由于点在物体内部，假设它的局部光强为 0反射光线 $R_2 $，可递归跟踪下去计算光强看折射光线 $T_2$，与 $O_3$ 交于点 $P_3$，作阴影测试线 $S_3 $，无遮挡，计算该点局部光强。并且该点还产生了 $R_3$ 可以继续跟踪下去…光线跟踪的停止：该光线未碰到任何物体该光线碰到了背景光线在经过许多次反射和折射以后，就会产生衰减，光线对于视点的光强贡献很小光线反射或折射次数即跟踪深度大于一定值光线跟踪伪码：123456789101112131415161718RayTracing(start, direction, weight, ret_color){ if(weight &lt; MinWeight) ret_color = BLACK; else { 计算光线与所有物体的交点中离start最近的点; if(无交点) ret_color = BLACK; else { I_local = 在交点处用局部光照模型计算出的光强; 计算反射方向R; RayTracing(最近的交点, R, weight*W_r, I_r); 计算折射方向T; RayTracing(最近的交点, T, weight*W_t, I_t); ret_color = I_local + K_r * I_r + K_t * I_t; } }}光线跟踪的加速（光线跟踪进行大量的求交运算，效率低）：提高求交速度：针对性的几何算法、…减少求交次数：包围盒、空间索引、八叉树…包围盒求交测试层次包围盒求交测试减少光线条数：颜色插值、自适应控制、…采用广义光线和采用并行算法等纹理映射和阴影处理纹理映射纹理映射的作用：表面用纹理来代替，不用构造模型和材质细节，节省时间和资源可用一个粗糙多边形和纹理来代替详细的几何构造模型，节省时间和资源让用户做其他更重要的东西纹理分类：颜色纹理：颜色或明暗度变化体现出来的表面细节，如刨光木材表面上的木纹。几何纹理：由不规则的细小凹凸体现出来的表面细节，如桔子皮表面的皱纹。纹理定义：图象纹理：将二维纹理图案映射到三维物体表面，绘制物体表面上一点时，采用相应的纹理图案中相应点的颜色值函数纹理：用数学函数定义简单的二维纹理图案，如方格地毯；或用数学函数定义随机高度场，生成表面粗糙纹理即几何纹理纹理映射（Texture Mapping）：通过将数字化的纹理图像覆盖或投射到物体表面，而为物体表面增加表面细节的过程寻找一种从纹理空间(u,v)到三维曲面(s, t)之间的映射关系，将点(u,v)对应的彩色参数值映射到相应的三维曲面(s, t)上，使三维曲面表面得到彩色图案两种方法在绘制一个三角形时，为每个顶点指定纹理坐标，三角形内部点的纹理坐标由纹理三角形的对应点确定。即指定：$\\begin{cases} (x_0,y_0,z_0) \\rightarrow (u_0,v_0) \\ (x_1,y_1,z_1) \\rightarrow (u_1,v_1) \\ (x_2,y_2,z_2) \\rightarrow (u_2,v_2)\\end{cases} $指定映射关系，如 $\\begin{cases} u=a_0x+a_1y+a_2z+a_3 \\ v=b_0x+b_1y+b_2z+b_3 \\end{cases}$扰动函数 $ P(u,v) $通过对景物表面各采样点的位置作微小扰动来改变表面的微观几何形状。几何纹理使用一个称为扰动函数的数学函数进行定义。设景物表面的参数方程 $ Q=Q(u,v) $ ，表面任一点的法线 $N = N(u,v) = \\frac{Q_u(u,v) \\times Q_v(u,v)}{|Q_u(u,v) \\times Q_v(u,v)|} $则扰动后的表面为 $Q ‘ = Q(u,v) + P(u,v)·N $阴影处理阴影的定义：阴影是由于观察方向与光源方向不重合而造成的阴影使人感到画面上景物的远近深浅，从而极大地增强画面的真实感阴影的概念：本影：不被任何光源所照到的区域Umbra。半影：被部分光源所照到的区域Penumbra自身阴影：由于物体自身的遮挡而使光线照射不到它上面的某些面投射阴影：由于物体遮挡光线，使场景中位于它后面的物体或区域受不到光照射而形成的。阴影算法——阴影体法（Shadow Volume）：由一个点光源和一个三角形可以生成一个无限大的阴影体。落在这个阴影体中的物体，就处于阴影中。在对光线进行跟踪的过程中，若射线穿过了阴影体的一个正面（朝向视点的面），则计数器加1。若射线穿过了阴影体的一个背面（背向视点的面），则计数器减1。最终计数器大于0，则说明这个像素处于阴影中，否则处于阴影之外。阴影算法——阴影图法（Shadow Mapping）：思想是使用Z缓冲器算法，从投射阴影的光源位置对整个场景进行绘制。对于Z缓冲器的每一个象素，它的z深度值包括了这个像素到距离光源最近点的物体的距离。一般将Z缓冲器中的整个内容称为阴影图（Shadow Map），有时候也称为阴影深度图。从视点的角度来进行，对场景进行二次绘制。在对每个图元进行绘制的时候，将它们的位置与阴影图进行比较，如果绘制点距离光源比阴影图中的数值还要远，那么这个点就在阴影中，否则就不在阴影中。绘制技术基于图像的绘制技术IBRIBR，Image-Based Redering传统图像绘制与IBR比较传统图像绘制基于图像的绘制技术建模复杂、困难建模简单计算和显示开销大，绘制速度慢显示速度快难以达到真实感效果真实感强IBR的发展方向：与传统集合绘制方式有效结合算法固化提高图像生成速度，达到实时绘制分层绘制提高Morphing中特征提取的效率和质量图像拼接中的快速配准IBR的绘制过程：IBR绘制中的重要方法：几何和图像混合建模(Hybrid Geometry- and Image-based Approach [DTM96])特点可以通过拍摄的几张照片合成逼真的新视图，简单快捷只能适用于普通建筑物等外形规整的景物过程a. 拍摄相片，交互指定建筑物边缘b. 生成建筑物粗模型c. 利用基于模型的立体视觉算法精化模型d. 利用基于视点的纹理映射合成新视图视图插值和变形(View Interpolation[CW93] / View Morphing[SD96])特点简单方便，只要求几幅参考图像漫游范围受限，只能在几幅参考图像的视点连线之间作有限运动常用于加速图形学中的绘制速度视图插值方法(View Interpolation)：要求新视点位于两参考图象视点所决定的直线(基线， baseline)上。由参考图线性插值产生新视图。一般情况下不能产生正确的透视投影结果，而只生成近似的中间视图。视图变换方法(View Morphing)：利用参考图像上像素点重投影生成新视图利用投影知识决定的变形位置全视函数(Plenoptic Function-based)$\\mu = Plenoptic(\\theta , \\phi ,\\lambda,V_x,V_y,V_z,t) $基于光场的显示(Light Field Rendering[LH96] and Lumigraph [GGSC96])基于“自由空间中沿一条光线传递的辐射能不变” 的假设，把全视函数简化为描述离开或进入一封闭自由空间(如空立方体)的完全光流分布由于只考虑视流信息，因此不必对反射属性作假设，不需要立体对应关系数据量大，采样困难图象拼接(mosaic)全景图(Panorama)在一个视点拍摄的几幅图像，通过整合拼接成一个视点周围的场景视图，投影在圆柱面或者球面上成为全景图。只需在一个视点拍摄的几张照片，数据量小，采样方便。视点不能移动，但是可以转动观察方向，通过放大缩小（zoomin/zoom out)进行近似的前后运动同心拼接(Concentric Mosaic)通过沿一系列同心圆切线方向拍摄的狭缝图像拼合成同心拼接特点：只需在一个圆上拍摄的一系列图像，采样方便视点可以在采样圆内做平面移动，生成场景真实感强数据量较光场等全视函数方法为小移动范围受限，基于狭缝图象的绘制：有场景畸变现象基于狭缝图象段的绘制将同心拼接中使用的狭缝图象进一步分为狭缝图象段测定不同距离上对应狭缝图象段的伸缩比例利用狭缝图象段的伸缩进行正确的绘制立体视觉(Stereo Vision)基于点的建模与绘制Point based Rendering随着模型多边形复杂度的剧增，点模型的优势越发明显。点模型的数字几何处理流程：点的获取3D扫描仪（深度照相机生成的深度图和激光三维扫描仪等设备得到的大量空间三维点位置）点模型的另一个来源是现有模型 ，大部分几何模型如多边形网格模型、隐式曲面等都能方便地转化为点模型点的处理配准机器配准：标签法自动配准：特征提取法去噪移动最小二乘（MLS）曲面逼近原始点集模型基于三维Meanshift过程的各向异性点模型去噪算法MLS曲面重建方法点模型的非局部去噪方法基于采样保真性的点模型去噪算法修补基于上下文的点模型修复点的建模目标：从原始点云中构造出一个连续的表面模型涉及的技术较多，曲面重建、曲面简化、几何属性分析、特征提取、重采样点模型的后期处理则是对点模型作进一步的造型处理：编辑、变形、布尔运算曲面重建技术指根据离散扫描点数据重建三维模型的过程常用方法：RBF(Radial Basis Function)曲面重建方法MLS(Moving Least-Square)曲面曲面简化技术利用三维扫描仪获得的点模型通常具有很高的复杂度，为了使大规模数据模型符合几何处理和绘制，必须对数据模型进行简化点模型编辑技术对点模型的颜色、纹理等外观属性以及法向量的处理。例如下图是点模型的画刷着色效果图。几何造型技术实体几何造型(CSG：Constructive Solid Geometry)一种基于简单实体的布尔运算构造复杂模型的技术，即通过对多个简单的点模型进行布尔运算后生成复杂的点模型。自由变形这种变形技术首先生成一个置换函数 d： $R^3\\rightarrow R^3 $，然后对表面上的每个点 $P_i$ ，实施变换 $P_i \\rightarrow d(P_i ) $点模型动画(MFM：Mesh Free Method)力学分析的新方法，近年来研究者将无网格方法和点模型相结合，提出了基于点的动画。例如： 模型形变模型渐变(Morphing)技术点模型自身的特点决定了在模型渐变中，它比基于网格模型的渐变有明显的优势，但由于点模型没有提供表面的解析表达式和参数化信息，从另一方面又增加了它渐变的难度。基于物理的渐变需要建立相关物理模型，中间过渡点模型根据能量方程求解，这种渐变在一定程度上模拟了真实的物理现象基于几何的渐变通过对源和目标模型进行几何变换来获得中间过渡模型，其计算量没有基于物理的渐变大点模型的绘制，如Qsplat技术由斯坦福大学开发的具有代表性的点绘制技术。它利用树状层次包围球数据结构，树中每个结点包含球的位置和半径、每点处的法向量、法锥面的宽度、颜色值。在进行绘制时，层次树按深度优先方法递归遍历。对每个中间结点，首先判断该球是否完全在屏幕外或者是完全背向的，以进行可见性选择。如果该结点至少有一部分子结点是可见的，则将该结点在屏幕上的投影大小同一个阈值进行比较。如果大于阈值，则继续向下递归；如果小于阈值或者已经到达叶结点，则按该结点的球位置及半径确定的屏幕上的位置和大小绘制一个小区域。基于点的建模与绘制的发展趋势：基于点的自然场景建模基于点模型的动画点模型的简化、压缩和传输基于GPU的大规模点模型绘制","link":"/CS/Computer-Graphics-Study-Notes/"},{"title":"计算机网络-学习笔记","text":"两个设备如何通信？第1章 引言网络硬件PANPersonal Area Network 个域网蓝牙LANLocal Area Network 局域网WiFi、路由AP、以太网MANMetropolitan Area Network 城域网卫星、基于有线电视得城域网WANWide Area Network 广域网VPNIntenet互联网网络软件协议层次结构特点每一层都将数据和控制信息传递给它的下一层，传递到最底层后，再往上传，第一层下面是物理介质每一对相邻层次之间的是接口面向连接与无连接服务面向连接服务：按电话系统建模无连接服务：按照邮政系统建模服务原语原语：一个服务由一组原语正式说明，用户进程通过这些原语来访问该服务。原子性参考模型OSI模型TCP/IP模型本书模型常用术语层次栈/分级栈：网络组织的一种形式，每一层都建立在其下一层的基础上，层的个数、每一层的名字、每一层的内容和功能各个网络都不尽相同。每一层的目的是向上一层提供特定的服务，而把服务实现的细节对上层屏蔽。协议：通信双方就如何进行通信的一种约定。对等体：不同机器上构成相应层次的实体。网络体系结构：层和协议的集合。网络体系结果的规范必须包含足够的信息，以便实现者为每一层编写的程序或设计的硬件能遵守有关协议。协议栈：一个特定的系统所使用的一组协议，即每一层一个协议。服务：某一层向其上一层提供的一组原语。统计复用：许多网络设计根据主机的短期需求变化动态共享网络带宽，而不是给每个主机分配可能用也可能不会用的固定比例带宽。拥塞：太多的计算机要发送太多的流量，而网络没有能力传递所有的数据包。存储-转发交换：中间节点只能在收到报文的全部内容后再将该报文发送给下一个节点。直通式交换：报文还未全部接受完毕之前就向下一个节点传输。请求-应答服务：发送方传输一个包含了每个请求的数据报，接收方以一个包含了请求结果的应答数据报作为反馈。ISP：互联网服务提供商，即向广大用户综合提供互联网接入业务、信息业务和增值业务的电信运营商。P2P：对等计算机网络，是一种在对等者（Peer）之间分配任务和工作负载的分布式应用架构，是对等计算模型在应用层形成的一种组网或网络形式。router：路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。Cable：有线电视电缆FTTH：光纤到户是一种光纤通信的传输方法。是直接把光纤接到用户的家中（用户所需的地方）。DSL：数字用户线路，是以电话线为传输介质的传输技术组合。第2章 物理层主要功能：提供透明的比特流传输注意封装好的数据以“0、1”比特流形式传输物理层上的传输不关心比特流里携带的信息，只关心其正确搬运物理层四大特性机械特性：指明接口所有接线器的形状、尺寸、引脚数和排列等，如RJ45电气特性：指明在接口电缆的各条线上出现的电压范围功能特性：指明某条线上出现的某一电平的电压表示何种意义规程特性：指明对于不同功能的各种可能事件的出现顺序规程的概念类似协议概念物理层上数据的传输：信号信号：数据的电气或电磁表现模拟信号：对应时域的信号取值是连续的数字信号：对应时域的信号取值是离散的码元：不同离散值的基本波形物理带宽：传输过程中振幅不会明显衰减的频率范围（单位Hz），物理特性，通常取决于介质材料的构成、厚度、长度数字带宽：单位时间内流经的信息总量。尼奎斯特定理和香农定理描述了物理带宽和数字带宽的关系。数据通信的理论基础调制解调调制：将模拟信号转换成数字比特解调：将数字比特转换为模拟信号理论基础傅里叶变换任何行为周期为T的函数$g(t)$可表示为正余弦函数组合的无穷级数$g(t) = \\frac{1}{2}c + \\sum_{n=1}^{\\infty}a_nsin(2 \\pi n ft) + \\sum_{n=1}^{\\infty}b_ncos(2 \\pi nft)$尼奎斯特定理在无噪声信道中，当物理带宽为$B$ Hz，信号离散度等级为$V$级，则该信道最大数据速率 （数字带宽）$ = 2B \\ log_2V \\ \\ bps$，计算后还要乘每秒采样数。任意一个信号的通过一个物理带宽为B的低通滤波器只要进行每秒2B次的采样就可完全重构出被滤掉的信号信道一定，物理带宽确定时，要提高数字带宽只有增加离散等级香农定理在有噪声信道中，如果物理带宽为$B$ Hz，信噪比为S/N，则该信道最大数据速率 （数字带宽）$ = B \\ log_2(1+\\frac{S}{N}) \\ \\ bps$$分贝值=10log_{10}\\frac{S}{N} \\ \\ db$信道一定，物理带宽确定时，要提高数字带宽只有增加信噪比引导性传输介质物理层的功能是搬运比特，承载比特的就是传输介质传输介质按是否有形分为引导性（有线）和非引导性（无线）两种同轴线缆优点：比非屏蔽双绞线有更好屏蔽特性和更大的带宽，而且有很好的抗噪性典型：中心导体（铜芯） - 绝缘材料 - 网状导体 - 外部绝缘层分类：基带同轴电缆（50Ω，用于数字传输，屏蔽层为铜）、宽带同轴电缆（75Ω，用于模拟传输，屏蔽层为铝），还分为粗缆和细缆双绞线两根具有绝缘层的铜导线按一定密度，逆时针绞在一起两根平行的线构成一个很好的天线，当两根线在一起后，不同电线产生的干扰波会相互抵消，从而能显著降低电线的辐射。对外部噪声有更好的免疫力，因为噪声对两根电线的干扰是相同的，而它们的电压却不会改变。典型——5类线/猫5非屏蔽双绞线（UnshieldedTwisted Pair，缩写UTP）提供10M、100M的数字带宽使用了其中的2对线（12、36）分别用于收、发1000M以太网中，用到了全部的4对线最大传输距离100米，广泛用于局域网中优点：成本低、尺寸小、易于安装缺点：易受干扰、传输距离和性能受到绞距影响568B标准排线：白橙-橙-白绿-蓝-白蓝-绿-白棕-棕直通线和交叉线：连接两台相同设备用交叉线（线顺不同），但现在设备都可以自适应，故标准排线即可。屏蔽双绞线（Shielded Twisted Pair，STP），在双绞线和外层绝缘封套之间有一个金属屏蔽层（多了2层）。优点：抗EMI/RFI干扰缺点：成本高、安装不易链路全双工链路：双向可同时使用半双工链路：可以双向使用，一次只能用一个方向单工链路：只允许一个方向上传输电力线特点：非常方便，但是传输数据较为困难，因为分发电能和分发数据信号是两项完全不同的工作，需要考虑到电噪声等影响。光纤光纤——光导纤维，极细的玻璃纤维构成，把光封闭在其中并沿轴向进行传播横截面：极细的玻璃芯 - 玻璃覆盖层 - 塑料封套，玻璃覆盖层的折射率比玻璃芯低以保证光都被限制在玻璃芯内优点：重量轻、损耗低、不受电磁辐射干扰、传输带宽和通信容量非常大缺点：昂贵、易断裂多模光纤玻璃芯直径$50\\mu m$光源：LED许多不同光束以不同角度来回反射着向前传播，每一束光有不同模式（入射角度大于临界值的光束会在内部反射，多个角度所以叫做“多模”）。常用规格：$62.5/125 \\mu m$单模光纤玻璃芯直径$10\\mu m$光源：激光光纤直径减少到几个光波波长时，光只按直线传播而不会反射。$100Gbps$常用规格：$8.3/125 \\mu m$光源光传输系统组成：光源、传输介质、探测器光源：LED（距离较短）和激光（成本较高）光通过玻璃的衰减现今光纤通信最常用的三个波段集中在：0.85、1.30、1.55微米三种拼接方式（光纤断了续接）连接器（10%~20%光损失，但使重配工作较易）机械手段拼接：两端切口放入特殊的套管，夹紧（10%光损失）熔合：两端切口熔合为一个新的连接与铜线的比较细、轻安装费用低不受电源浪涌、电磁干扰或电源故障等影响，不易化学腐蚀难被搭线窃听（光纤不漏光）光传输基本是单向光纤接口成本原高于电子接口无线传输无线电传输光通信复用技术★多个用户共享同一根信道，是在干线上的技术，主要解决干线起点如何复用，干线终点如何分离的问题频分多路复用FDM分割频段利用基带传输的优势使多个用户共享一个信道一个信道多个不同频段，实现信道的复用正交FDM（Orthogonal FDM，简称OFDM）一种更好地利用带宽的FDM，没有了保护带，并且子带之间相互重叠，同样的干线承载更多的用户被广泛用于802.11、有线电视网波分多路复用WDMWDM，Wavelength Division Multiplexing波长$\\lambda$，$c=\\lambda f$按照波长分成若干份，承载不同用户的光信号DWDM（Dense WDM），密集波分多路复用。WDM在相邻波长间隔非常接近，子信道数目非常大时，WDM变成了DWDM。时分多路复用TDM分割时间，Time Division Multiplexing每个用户周期性获得整个带宽非常短的一个时间要求时间上必须同步，各用户需要的带宽不均衡，而TDW用户时间片的使用却是一样的，将造成信道的浪费，不高效STDM（TDMStatistic），统计时分多路复用动态分配信道，按需分配实现技术复杂，通常只在高速远程通信中使用，如ATM，用户使用情况较为平均的情况下不适合使用*码分多路复用CDMACode Division Multiple Access，扩展频谱技术，1942年海蒂拉玛受钢琴启发发明。高通开发用于3GCDMA允许每个站利用整个频段发送信号，没有时间限制可以将TDM看作许多人按顺序交谈，将FDM看作不用人按不同语调交谈，CDMA则是每对交谈者使用不用的语言CDMA关键在于能够提取出需要的信号，同时拒绝所有其他的信号并把这些信号当作噪声调制技术★基带传输定义：基带传输是按照数字信号原有的波形（以脉冲形式）在信道上直接传输，它要求信道具有较宽的通频带。基带传输不需要调制、解调，设备花费少，适用于较小范围的数据传输。 信号需要编码。信号的传输占据传输介质从0到最大值之间的全部频率是有线传输介质普遍采用的传输方法，比如以太网数据比特直接转换为信号的一些方案，不经过调制。线路编码（Line codes），发送一个样本可传输一或多个比特不归零NRZ：高电平表示”1”，低电平表示“0”。（没有电压跳变。随时间累计，接收方可能无法分辨出连续几个“1”或“0”）不归零逆转NRZI：在比特时间中间做电压跳变表示“1“，无跳变表示”0”。（解决了连续1问题，但连续0问题仍存在），USB里采用这种编码曼彻斯特编码：在比特时间中间，电压从高跳变到低表示“1“，反之从低跳变到高表示”0“。（解决了连续0和连续1的问题，在10Base以太网中使用，但因为在比特时间中跳变故编码效率只有50%）双极编码：两级电压的交替出现表示“1“，不出现表示”0”。（实现了信号的平衡）4B/5B：4比特数据被映射为1个5比特模式（抛开连续0的组合，解决连续0问题），相比曼彻斯特编码效率提高80%差分曼彻斯特编码：在每个时钟周期的中间必有一次电平跳变（这个跳变做同步之用）。 在每个时钟周期的起始处：跳变则说明该比特是0，不跳变则说明该比特是1。时钟恢复：将数据、时钟信号异或混合在一起通带传输定义：通带传输是一种采用调制、解调技术的传输形式。在发送端，采用调制手段，对数字信号进行某种变换，将代表数据的二进制“1”和“0”，变换成具有一定频带范围的模拟信号，以适应在模拟信道上传输。在接收端，通过解调手段进行相反变换，把模拟的调制信号复原为“1”或“0”。调节载波信号的幅值、相位或频率来运载比特的调制方案。信号占据了以载波信号频率为中心的一段频带信号星座图——表示某种调制方式中信号的呈现模式（调制的级别）QAM-16（正交调幅调制Quadrature Amplitude Modulation），16表示调制方式中有$2^4=16$种不同振幅和相位的信号组合模式，意味着一个符号可传输4个比特QPSK（正交相移键控）中，使用了4个相位角度，每次采样（码元、样本）可表达的级别有4个，每个码元可传输2 bitsQAM-64中，允许64个不同的信号组合，即64个信号级别，每个码元可传输6 bits下图中，一个点的相位是以它为起点到原点的线与x正轴之间的角度；一个点的振幅则是该点到原点的距离码元：承载信息量的基本信号单位。数字通信中常用时间间隔相同的符号来表示一个二进制数字，该符号即称为（二进制）码元。在使用时间域的波形表示数字信号时，不同离散值的基本波形，也即是码元。波特率B（码率）：1s能发送码元的个数。（每秒钟信号变化的次数）比特率C：位传输率、数据传输速率、数字带宽波特率与比特率关系：$C = B\\times log_2n$，n为信号呈现的个数，一般为2的倍数格子架编码调制TCM（Trellis Coded Modulation）提高数字带宽，要提高信号级别，即星座图上的星点，密密分布下容易导致出错率的提升。为了降低高速调制错误，在每个样本中采用一些额外的位用作纠错，剩下的位采用来传输数据。比如，在V.32调制标准中，波特率2400，使用QAM-32，即每个码元传输5个比特，其中1个比特用来做奇偶校验，4个比特用来传输数据，则数据传输率只有$2400\\times4=9600bps=9.6kbps$公共电话交换网络PSTN★PSTN低速传输原因：最后一英里PSTN发展全连通网-&gt;中心交换网-&gt;层次交换网人工交换-&gt;全自动交换电话系统结构电话系统由主要三部分构成：本地回路(Local loops)：模拟线路，连接端局和千家万户，通常用三类双绞线承担干线、中继线(Trunks)：数字光纤，连接交换局交换局(Switching offices)：语音接驳干线的场所，包括端局本地回路——调制解调器、ADSL和光纤调制解调器：将计算机产生的数字比特流转变为载波输出（模拟信号-&gt;数字信号）56k（64k）的调制解调器：V.90标准电话线路频率为4kHz，采样率$=2\\times 4000=8000 sample/sec$，每个码元传输8bit，其中1个比特控制错误，故传输数据速率$=8000 \\times 7=56000kbps$，若算上控制错误的比特，毛速率为$64kbps$连接调制解调器的本地回路带宽，被限制为4k，因为电话占频为4k；xDSL取消了电话系统里的滤波器后，可使用本地回路的全部（1.1兆）物理带宽ADSL：“Asymmetric Digital Subscriber Lines(DSL)” ，非平衡数字用户线路1999年颁布的标准G.dmt中，允许下行带宽（8Mbps，目前为24Mbps）上行带宽（1Mbps），课本$P_{116}$1.1M的频宽，分为256根信道，每根4k。第1根用于简单的老式电话服务（POTS），再空闲5根， 剩下250根用于上下行控制和数据传输光纤由于本地回路通常用3类UTP来承载信号，3类UTP的物理特性限制了带宽的增长上限，故用户对带宽的需求导致了光纤的替换。FttH，Fiber to the Home，光纤到户采用的光纤传输网络通常是无源的，这带来了更多的可靠性和安全性——光进铜退，最后一英里革命DSLAM：数字用户线路接入复用器NID：网络接口设备PON：无源光网络中继线（干线）和多路复用★干线是用来连接交换局，通常用光纤，要用到复用技术。端局里特殊的设备——编解码器（codec）：$模拟信号 \\rightleftharpoons 数字信号$，其中用到的技术为PCM。脉冲编码调制，PCM，Pulse Code Modulation模拟信号数字化的技术。构成了现代PSTN的核心。采样、量化、编码、传输每125微秒发送一个语音样值，该采样率足以捕捉4kHz电话信道带宽上的信息时分多路复用TDMT1载波（北美和日本），24路每帧248=192个比特，加上控制用的 帧码，则每125微秒产生193个比特，即*数据传输率为$193bits / 0.000125 s = 1.544Mbps$**一通电话带宽为$64kb$，那么100G光缆可同时用于163万通电话E1载波（中国），32路语音的复用每125微秒传递328=256个比特，即*数据传输率为$256bits / 0.000125 s = 2.048Mbps$**TDM允许更高级别的复用，比如4条T1流复用为1条T2流，7条T2流复用为1条T3流（每一步复用有少量开销用于同步控制、成帧）SONET/SDH，光介质上进行同步数据传输的标准SONET（同步光网络），美国ANSIS制定；SDH（同步数字序列），国际标准组织ITU制定。每隔125微秒发送810字节数据块，SONET是同步系统故不管是否有用该帧都被发送出去，总的传输速率为51.84Mbps9行，90列，有效载荷为87列，共$87 \\times 9 \\times 8bit \\times 8000sample/sec = 50.112Mbps$每帧前三列，保留用作传输系统管理信息其中前三列的前三行包括section开销前三列的后六行包含line开销，其中前两个字节包含了指向信息首地址的指针源端正在构造SONET空帧时来了一个有效载荷数据，它可直接半途插入到当前构造的帧中，比如下图，SPE就从第1个帧的半途开始，横跨了两个帧。对应于STS-n的光纤载波称为OC-n，其复用也是按比特进行的如果一个载波（比如OC-3）没有被复用，而是仅承载了来自单个源的数据，则在线路名称后面加一个字母c（表示级联），因此OC-3表示由三条独立的OC-1载波构成的一条155.52Mbps载波，而OC-3c则表示来自于单个源的155.52Mbps数据流。交换局电路交换传统的电话系统，要求通话之前建立一条端到端的通路（物理），即”建立连接“，之后话音沿通道按顺序送达。数据传输完后拆除连接提前分配数据包交换（分组交换）IP电话数据业务。允许包存储在交换局的内存里；每个包携带目的地址、信息（便于独立寻径）；乱序送达按需分配，更好的容错能力和抗毁性移动电话系统常用术语按钮电话系统：push-to-talk system，使用一个被安置在高大建筑物顶上的大型发射器，并且只有一个信道用于发送和接收。为了通话用户必须按一下按钮以便打开发送功能并关闭接收功能。改进型移动电话系统：IMST，较按钮电话系统有两个频率，一个用于发送一个用于接收。高级移动电话系统：AMPS全球移动通信系统：GSM1G：模拟语音高级移动电话系统AMPS2G：数字语音GSM——Global System for Mobile Communications3G：数字语音和数据有线电视频谱分配第3章 数据链路层DLLDLL概述相比物理层关注单个比特的传输，数据链路层更关注完整信息块（帧）的可靠有效的通信。DLL功能向网络层提供一个定义良好的服务接口无确认的无连接服务，广告。事先不需建立逻辑连接，事后也不用释放，若由于线路噪声造成了某一帧的丢失，数据链路层并不试图去检测这样的丢帧情况，更不会去试图恢复。有确认的无连接服务，WiFi。发送方需要知道帧是否已经正确到达目的地有确认的有连接服务保证数据传输的有效、可靠处理传输错误：差错检测和控制流量控制（基于速率/反馈），接收方反馈给发送方，使其调节数据流，确保慢速的接收方不会被快速的发送方淹没成帧——使接收方很容易发现一个新帧的开始★帧PDU数据处理单元Protocol Data Unit帧 = 帧头(控制) + 载荷 + 帧尾(校验)成帧：将原始的位流分散到离散的帧中字节计数法——Byte count每帧开始使以一个计数字段表示该帧的总字符数。简单，但很少被使用缺点：一旦出错，无法同步字节填充的标志字节法——Byte stuffing以某些特殊字符作帧的开始/结束标志，同时增加转义环节以免该字符无法表达。缺点：容易造成帧界混淆（故增加转义字节）、依赖8位字符比特填充的标志比特法——Bit stuffing用特殊的位模式01111110作为帧标志，即一个帧的开始（前一个帧的结束）且为了处理帧内容中出现一个和帧标志相同的位串01111110。发送方一般在5个1后插入1个0，变为01111101。接收方自动删除第5个1后的0。优点：可传输任意比特数的帧、传输速率更高物理层编码违例法在物理层的线路编码方法里头，有一些冗余信号是不会出现在传输数据里的，以其作帧界比如，在4B/5B编码中，4B被映射成5B传输，32个模式，只用到16个，剩下的可以用作帧界比如，曼彻斯特编码，高电位跳变到低电位表示”1”，相反表”0”。所以有两个跳变（高-&gt;高，低-&gt;低），两个冗余的跳变是没有使用的，也可拿作帧界。好处是使用冗余信号，不会混淆也不需要填充，故传输速率高差错处理概述概念处理错误的手段纠错码：恢复出正确的来（前项纠错技术）。需要纠错，需要更多的冗余位，所以在有线网较少采用主要用于无线网检错：仅检出错误，不恢复，通常伴随着重传。局域网中主要采用错误的类型单个错误：分散在各块中突发错误：集中在某个块中突发错误比单个错误更难处理，通常利用单个处理的方法来应对突发错误码字：包含数据位和校验位的n位单元。海明距离、海明码海明距离：两个码字(codeword)的海明距离，是两个码字之间不同位的数，即异或结果中1的个数全部码字的海明距离：全部码字中任意两个码字之间海明距离的最小值。海明距离的意义在于：如果海明距离为d，则一个码字需要发生d个1位错误才能变成另外一个码字海明距离=2d+1的编码，能纠正d位差错。比如，一个系统有4个合法码字：0000000000, 0000011111, 1111100000 和 1111111111。海明距离5，d=2，所以可以纠正两位错误发送了0000011111，若接收到0000000111，它离0000011111的海明距离最近（为2），故恢复成功；发送了0000000000，若接收到0000000111，纠正后就是0000011111，错误了3位所以无法纠错海明距离越大，纠错能力越强，同时合法码字就减少了，传输效率降低海明码：在数字逻辑，略Internet(互联网)校验和校验和通常是按照N位码字，来进行模2加运算。发方将运算结果附加在数据报文的尾部作为校验位比如4位字的Internet校验和，就将信息每隔4位相加起来，高于4位的溢出被放回低序位相加，最终和为全0或全1则正确。常用：16位互联网补码校验和特点比奇偶校验更好的检错性能能检出高至N位的突发错误检错随机错误率$1-2^N$易受系统错误干扰，比如，增加的”0”循环冗余校验码CRCCRC工作原理任何一个k位的帧，可以看做一个k-1次的多项式。如1011001，看做$x^6+x^4+x^3+x^0$（6阶7项多项式）约定一个生成多项式（Generator Polynomial）：$G(x)$，阶数为$r$，项数为 $r+1$。现在有一个要计算CRC的m位帧的多项式$M(x)$，$m \\gt r$，即$M(x)$比$G(x)$长在 $M(x) $ 后附上 r 个0，成为 $x^rM(x) $。$x^r M(x)/G(x) = Q(x)+R(x)$，其中$Q(x)$为商、$R(x)$为余数，则$x^rM(x)-R(x)$一定能被$G(x)$整除。接收方，将收到的码字，除生成多项式，余数为0则无误。一个著名的CRC标准：CRC32，用于以太网计算循环冗余校验$G(x)=x^{32}+x^{26}+x^{23}+x^{22}+x^{16} +x^{12}+x^{11} \\+x^{10}+x^{8} +x^{7}+x^{5}+x^{4}+x^{3}+x^{1}+0$基本数据链路协议1~3网络接口卡NIC（Network InterFace Cards），能以帧到达的速度来处理帧单工：数据的传输是单向的假设物理层、数据链路层、网络层，在工程中可能有不同的存在形式，在此作为三个独立进程机器A希望向B发送的一个可靠的、面向连接的长数据流假设机器不会崩溃从网络拿到的数据是纯数据三个层的数据传输传送接口：$网络层 \\xrightarrow{\\text{from_network_layer}} 数据链路层 \\xrightarrow{\\text{to_physical_layer}} 物理层$$网络层 \\xleftarrow{\\text{to_network_layer}} 数据链路层 \\xleftarrow{\\text{from_physical_layer}} 物理层$Wait_for_event函数，等待帧到达事件frame_arrival、校验和出错事件cksum_err、定时器超时事件timeout定时器，重传定时器、捎带确认定时器protocol.h文件1234567891011121314151617181920212223242526#define MAX_PKT 1024 /*数据包最大大小*/typedef enum {false, true} boolean; /*布尔类型枚举变量*/typedef unsigned int seq_nr; /*seq(序列号)、ack(确认号), nr(number缩写)*/typedef struct {unsigned char data[MAX_PKT];} packet; /* packet结构体定义*/typedef enum {data, ack, nak} frame_kind; /*帧类型定义*/typedef struct{ /* 帧结构体定理 */ frame_kind kind; seq_nr seq; seq_nr ack; packet info;} frame; void wait_for_event(event_type *event);/*阻塞等待某事件*/void from_network_layer(packet *p);void to_network_layer(packet *p);void from_physical_layer(frame *f);void to_physical_layer(frame *s);void start_timer(seq_nr k);void stop_timer(seq_nr k);void start_ack_timer(void);void stop_ack_timer(void);void enable_network_layer(void);void disable_network_layer(void);#define inc(k) if(k &lt; MAX_SEQ) k = k + 1; else k = 0; /* 序列号、确认号自增 */无限制的单工协议——乌托邦式假设数据单向传输收发双方的网络层都处于就绪状态（随时待命）帧处理时间忽略不计可用缓存空间无穷大数据通道不损坏、不丢帧（完美通道）Sender不断从网络层拿数据，组帧，传输给物理层Receiver不断从物理层收帧，处理，提取载荷packet，传输给网络层12345678910111213141516171819202122typedef enum {frame_arrival} event_type;#include \"protocol.h\"void sender1(void){ frame s; packet buffer; while(true) { from_network_layer(&amp;buffer); s.info = buffer; to_physical_layer(&amp;s); }}void receiver1(void){ frame r; event_type event; while(true) { wait_for_event(&amp;event); from_physical_layer(&amp;r); to_network_layer(&amp;r.info); }}其他的协议是逐步取消乌托邦中的假设形成的。单工停-等协议取消了乌托邦中允许无限量接受的假设 -&gt; 接收方可能被大量数据淹没解决若接收方有能力处理的话回反馈给发送方一个哑帧发送方收到哑帧，发下一帧数据。此时数据流向为双向（半双工）。12345678910111213141516171819202122232425typedef enum{frame_arrival} event_type;#include \"protocol.h\"void sender2(void){ frame s; packet buffer; event_type event; while(true) { from_network_layer(&amp;buffer); s.info = buffer; to_physical_layer(&amp;s); wait_for_event(&amp;event); // 等待哑帧，阻塞循环 }}void receiver2(void){ frame r, s; event_type event; while(true) { wait_for_event(&amp;event); from_physical_layer(&amp;r); to_network_layer(&amp;r.info); to_physical_layer(&amp;s); // 发送哑帧后进入下一循环 }}有噪声信道的单工协议取消了完美信道的假设，信道可能有错误、有噪声 -&gt; 接收方可能发现接收的帧不能通过校验。解决肯定确认重传（PAR：Positive Acknowledgement with Retransmissioin）自动重传请求（ARQ：Automatic Repeat ReQuest）接收方接收的帧通过校验后才向发送方发送确认只有发送方收到确认后才会发送下一帧倘若发送帧丢失或确认帧丢失，则发送方发送前启动的定时器会引发重传。定时器时间设置不恰当会发送多于的重传帧，区别新帧与重传帧的方法——给每帧一个独一无二序列号，同时该序号可用作重排、重组。12345678910111213141516171819202122232425262728293031323334353637383940414243444546#define MAX_SEQ 1typedef enum{frame_arrival,cksum_err,timeout} event_type;#include \"protocol.h\"void sender3(void){ seq_nr next_frame_to_send; frame s; packet buffer; event_type event; next_frame_to_send = 0; from_network_layer(&amp;buffer); // 准备下一个包 while(true) { s.info = buffer; s.seq = next_frame_to_send; // 下一帧序列号 to_physical_layer(&amp;s); start_timer(s.seq); // 启动定时器 wait_for_event(&amp;event); // 等待确认帧 if(event == frame_arrival) { from_physical_layer(&amp;s); // 读入确认帧 if(s.ack == next_frame_to_send) {// 确认号与序列号匹配 stop_timer(s.ack); // 拆除定时器 from_network_layer(&amp;buffer); // 准备下一个包 inc(next_frame_to_send); // 序列号自增 } } }}void receiver3(void){ seq_nr frame_expected; // 确认号 frame r, s; event_type event; frame_expected = 0; while(true) { wait_for_event(&amp;event); if(event == frame_arrival) { from_physical_layer(&amp;r); if(r.seq == frame_expected) {//序列号=确认号 to_network_layer(&amp;r.info); inc(frame_expected); // 确认号自增 } s.ack = 1-frame_expected; // 模2加 to_physical_layer(&amp;s); // 回发确认帧 } }}提高传输效率：全双工、捎带确认（不单独发确认帧，搭”顺风车”过去）、批发数据 （管道化技术）滑动窗口协议之前3个模拟协议，为单工协议，信道利用率特别低，可在等待对方确认的时候继续发数据，这叫批量发送（管道化技术，一次性若干个数据，即一个窗口的数据）接下来要介绍的3个协议，协议4对应着w=1的滑窗协议，协议5~6分别对应着批量传输数据出错后采用的两种策略。滑动窗口发送窗口：已经发送，未被确认接受窗口：期望接收1位滑动窗口协议w=1的滑窗协议，引出滑动窗口的基本概念。基本工作原理设置滑动窗口最大值：MAX_SEQ = 1通信双方初始值：seq=0, ack=1(期望接收seq=0)特点序列号seq和确认号ack，01交替滑动窗口长度w=1，收到确认才移动窗口保证按序将接收到的正确帧只一次上交网络层123456789101112131415161718192021222324252627282930313233343536373839#define MAX_SEQ 1typedef enum {frame_arrival, cksum_err, timeout} event_type;#include \"protocol.h\"void protocol4(void) // 双工的函数，即处理发送又处理接收{ // 声明 seq_nr next_frame_to_send; seq_nr frame_expected; frame r, s; packet buffer; event_type event; // 初始化 next_frame_to_send = 0; frame_expected = 0; from_network_layer(&amp;buffer); do { // 新发/重发一个包 s.info = buffer; s.seq = next_frame_to_send; s.ack = 1 - frame_expected;// 接收信道的捎带确认号 to_physical_layer(&amp;s); start_timer(s.seq); wait_for_event(&amp;event); if(event == frame_arrival) { from_physical_layer(&amp;r); if(r.seq == frame_expected) { // 接收包带的序列号 to_network_layer(&amp;r.info); inc(frame_expected); // 更新接收窗口 } if(r.ack == next_frame_to_send) { // 捎带确认号，跟发包没关系，可能是上一次的确认号 stop_timer(r.ack); from_network_layer(&amp;buffer); inc(next_frame_to_send);// 更新发送窗口 } } }while(true);}协议4的异常异常一：对重复帧的差错控制异常二：同步开始发送过程的差错控制协议4的信道利用率如何假设了忽略接收方处理到达帧的时间。事实上在低速信道，来回时间RTT（Round Trip TIme）可能会非常大-&gt;想到提高信道利用率要批量发送-&gt;即增大W如何找到合适的W值信道容量：一帧从发出到目的期间，信道上能够容纳的帧数量带宽-延迟积：$B \\times D $窗口值：$W = 2\\times B\\times D +1$，这是信道利用率100%情况，实际上$W \\le 2\\times B D +1$2倍带宽-延迟积，是指发送帧和接收确认帧的时间+1，是指接收窗口要留多一个帧位接收该发送帧。异常处理：批量发送了一些帧，但中间某个帧出错了重传出错帧后的所有帧——Go Back n协议缓存出错帧后面的正确帧，重传出错帧——Select Repeat回退N协议——Go Back n基本概念定义序列号seq的取值范围、滑动窗口W发送方连续发送，直至发送窗口满接收窗口为1，对出错帧不确认（-&gt;引发超时）发送方超时重传，从未被确认帧开始工作原理发送方正常发送：对帧编号，待确认帧缓存收到确认：释放确认帧所占缓冲区，滑动发送窗口差错帧超时事件到：回退到超时帧，顺序重传最后被确认帧以后的缓冲区中缓存的帧接收方收到每一个期望的正确帧：上交网络层、回送确认收到出错帧或非期望帧：丢弃，回送对接收的最后正确帧的确认采用累计确认。需要发送方付出更多的缓存代价，适合出错率较少的高速信道。数据链路层采用后退N帧（GBN）协议，发送方已经发送了编号为0~9的帧。当计时器超时时，若发送方只收到0.2.3号帧的确认，则发送方需要重发的帧数是6——因为累计确认！滑动窗口长度W的选择发送窗口：$W \\le \\text{MAX_SEQ}$接收窗口：$W = 1$倘若头铁，W=MAX_SEQ+1，比如三位的MAX_SEQ=7，取W=8，那么在发送方接收到一个ack=7时候，无法知道是对上一个窗口最后一个帧的确认（即对当前窗口全部出错的肯定），或者是当前窗口全部帧的累计确认。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#define MAX_SEQ 7typedef enum {frame_arrival, cksum_err, timeout, network_layer_ready} event_type;#include \"protocol.h\"static boolean between(seq_nr a, seq_nr, seq_nr c){ // 判断 环式a&lt;=b&lt;c成立 return (a&lt;=b &amp;&amp; b&lt;c) || (c&lt;a &amp;&amp; a&lt;=b) || (b&lt;c &amp;&amp; c&lt;a);}static void send_data(seq_nr frame_nr, seq_nr frame_expected, packet buffer[]){ // 构造并传输一个数据帧 frame s; s.info = buffer[frame_nr]; s.seq = frame_nr; s.ack = (frame_expected + MAX_SEQ)%(MAX_SEQ+1); // 上一到达帧，做捎带确认 to_physical_layer(&amp;s); start_timer(frame_nr);}void protocol5(void){ seq_nr next_frame_to_send, ack_expected, frame_expected; next_frame_to_send = ack_expected = frame_expected = 0; frame r; packet buffer[MAX_SEQ + 1]; seq_nr nbuffered, i; nbuffered = 0; event_type event; enable_network_layer(); while(true) { wait_for_event(&amp;event); switch(event) { case network_layer_ready: // 网络层下传，放到发方缓冲区 from_network_layer(&amp;buffer[next_frame_to_send]); nbuffered = nbuffered + 1; send_data(next_frame_to_send, frame_expected, buffer); inc(next_frame_to_send); break; case frame_arrival: from_physical_layer(&amp;r); if(r.seq == frame_expected) { to_network_layer(&amp;r.info); // 接收窗口=1，直接传网络层 inc(frame_expected); } while(between(ack_expected, r.ack, next_frame_to_send)) { // 累计确认处理 nbuffered = nbuffered - 1; // 缓冲区清刷 stop_timer(ack_expected); inc(ack_expected); } // 第三个参数在出错时会起到中止循环的作用 break; case cksum_err: break; // 校验和出错，不确认，让发方自动超时 case timeout: next_frame_to_send = ack_expected; // 直接重传出错帧后的所有 for(i = 1;i &lt;= nbuffered; i++) { send_data(next_frame_to_send, frame_expected, buffer); inc(next_frame_to_send); } } if(nbuffered &lt; MAX_SEQ) enable_network_layer(); else disable_network_layer(); // 缓冲区满，不接收网络层下传包 }}选择性重传协议——Select Repeat工作原理发送方正常发送：对帧编号，待确认帧缓存收到确认：释放确认帧所占缓冲区，滑动发送窗口差错帧超时事件到：重传缓存的最后被确认帧以后的那一帧接收方正常接收：上交网络层、回送确认，滑动接收窗口收到非期望的正确帧：缓存，回送对接收的最后正确帧的确认收到重传帧：将缓存帧排序上交，回送确认，滑动接收窗口超时重传的优化 -&gt; 否定确认NAK机制，收到某帧的错帧，明确的回馈接收方NAK=出错帧序号。与回退N帧协议的比较缓冲区：回退N帧对发送方要求，选择性重传对接收方要求适用网络：回退N帧适用存信道出错率小，选择性重传适用信道出错率高滑动窗口长度W的选择发送窗口：$$\\text{SWnd} \\le 接收窗口大小$$接收窗口：$\\text{RWnd} = (\\text{MAX_SEQ + 1})/2 $如果不能保证新老窗口不重叠，那么重传帧可能被当为下一窗口的新帧1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#define MAX_SEQ 7 // 协议6必要奇数#define NR_BUFS ((MAX_seq + 1)/2)typedef enum {frame_arrival, cksum_err, timeout, network_layer_ready} event_type;#include \"protocol.h\"boolean no_nak = true;seq_nr oldest_frame = MAX_SEQ + 1;static boolean between(seq_nr a, seq_nr, seq_nr c){ // 判断 环式a&lt;=b&lt;c成立 return (a&lt;=b &amp;&amp; b&lt;c) || (c&lt;a &amp;&amp; a&lt;=b) || (b&lt;c &amp;&amp; c&lt;a);}static void send_frame(frame_kind fk, seq_nr frame_nr, seq_nr frame_expected, packet buffer[]){ // 构造并传输一个帧/否定帧 frame s; s.kind = fk; if(fk == data) s.info = buffer[frame_nr % NR_BUFS]; s.seq = frame_nr; s.ack = (frame_expected + MAX_SEQ)%(MAX_SEQ+1); // 上一到达帧，做捎带确认 if(fk == nak) no_nak = false; to_physical_layer(&amp;s); if(fk == data) start_timer(frame_nr % NR_BUFS); stop_ack_timer(); // 不需要单独的确认帧}void protocol6(void){ seq_nr ack_expected, // 发送窗口下界 next_frame_to_send, // 发送窗口上界 + 1 frame_expected, // 接收窗口下界 too_far; // 接收窗口上界 + 1 int i; frame r; packet out_buf[NR_BUFS], in_buf[NR_BUFS]; boolean arrived[NR_BUFS]; seq_nr nbuffered; event_type event; enable_network_layer(); ack_expected = next_frame_to_send = frame_expected = 0; too_far = NR_BUFS; nbuffered = 0; for(i = 0; i &lt; NR_BUFS; i++) arrived[i] = false; while(true) { wait_for_evnet(&amp;event); switch(event) { case network_layer_ready: nbuffered = nubuffered + 1; from_network_layer(&amp;out_buf[next_frame_to_send % NR_BUFS]); send_frame(data, next_frame_to_send, frame_expected, out_buf); inc(next_frame_to_send); break; case frame_arrival: from_physical_layer(&amp;r); if(r.kind == data) { if(r.seq != frame_expected &amp;&amp; no_nak) // 发送否定确认 send_frame(nak, 0, frame_expected， out_buf); else start_ack_timer(); // 收方发送确认帧的计时器 if(between(frame_expected, r.seq, too_far) &amp;&amp; !arrived[r.seq%NR_BUFS]) { // 按序收帧 arrived[r.seq % NR_BUFS] = true; in_buf[r.seq % NR_BUFS] = r.info; while(arrived[frame_expected % NR_BUFS]) { to_network_layer(&amp;in_buf[frame_expected % NR_BUFS]); no_nak = true; arrived[frame_expected % NR_BUFS] = false; inc(frame_expected); inc(too_far); start_ack_timer(); } } } if(r.kind==nak &amp;&amp; between(ack_expected, (r.ack+1)%(MAX_SEQ+1), next_frame_to_send)) // 收到否定确认帧，选择重传该帧 send_frame(data, (r.ack+1)%(MAX_SEQ+1), frame_expected, out_buf); while(between(ack_expected, r.ack, next_frame_to_send)) { // 累计确认处理 nbuffered = nbuffered - 1; // 缓冲区清刷 stop_timer(ack_expected % NR_BUFS); inc(ack_expected); } // 第三个参数在出错时会起到中止循环的作用 break; case cksum_err: if(no_nak) send_frame(nak, 0, frame_expected, out_buf); // 否定确认 break; case timeout: send_frame(data, oldest_frame, frame_expected, out_buf); break; case ack_timeout: send_frame(ack, 0, frame_expected, out_buf); } if(nbuffered &lt; MAX_SEQ) enable_network_layer(); else disable_network_layer(); // 缓冲区满，不接收网络层下传包 }}PPP协议PPP协议是为在同等单元之间传输数据包的简单链路设计的链路层协议。这种链路提供全双工操作，并按照顺序传递数据包。设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其成为各种主机、网桥和路由器之间简单连接的一种共通的解决方案。主要区别：成帧：使用了字节填充的标志字节法采用“无编号模式”来提供无连接无确认的服务使用校验和字段来检错PPP无需支持的功能无需差错纠正/恢复无需流量控制不存在乱序交付无需支持多点链路链路控制协议：LCP，它可用于启动线路、测试线路、协商参数，以及当线路不再需要时温和地关闭线路。网络控制协议：NCP，一种协商网络层选项的方式。协商方式独立于网络层协议。所选择的方法是针对每一种支持的网络层都有一个不同网络控制协议。常用术语ATM：异步传输模式，是一种链路层，它的传输基于固定长度的信息信元。第4章 介质访问控制层数据链路层分为：逻辑链路控制（LLC，Logical Link Control）、介质访问控制（MAC，Media AccessControl）MAC子层概述数据通信的三种方式单播unicast：一对一广播broadcast：一对所有组播multicast：一对一组局域网里采用的传输方式：共享传输介质 -&gt; 降低成本，在共享传输介质上通常采用广播。广播网络面临的问题：同时会有多个站点请求占用广播信道（多路访问信道）故我们要解决的是在多路访问信道上确定下一个使用者、及信道的分配，即介质的多路访问控制（MAC）分配信道（介质访问控制）静态分配：预先分配给各用户。PSTN中的干线用到了复用技术FDM、TDM。问题：资源分配不合理。提前分配会造成资源浪费，效率低。延迟时间增大N倍。适用：用户数量少且较固定的情况、通信量大且流量稳定的情况、不适合突发性业务。动态分配：信道开放临时分配。通过多路访问协议（Multiple Access Protocol），提高信道利用率。多路访问协议随机访问协议：站点/用户争用信道 -&gt; 冲突典型的随机访问协议：ALOHA协议、CSMA协议、CSMA/CDX协议（以太网采用）受控访问协议：站点明确地被分配、占用始信道 -&gt; 不会产生冲突ALOHA协议ALOHA协议是上世纪70年代诞生于夏威夷大学的一个随机访问协议，为解决夏威夷群岛和檀香山之间无线通信而提出。夏威夷打招呼的方式即ALOHA。无线信道是典型的广播/共享信道。ALOHA协议的两个版本纯ALOHA协议分隙ALOHA协议，隙是时隙、时槽的意思纯ALOHA工作原理任何一个工作站都可以在帧生成后立即发送，并通过信号的反馈检测信道以判断是否发送成功。冲突则随机等待后重发。即任性，想发就发。性能分析吞吐率S：发送时间T内（一个帧时内）发送成功的平均帧数（$0&lt;S&lt;1$），S越大信道利用率越高运载负载G：一个帧时T内所有通信站总共发送的帧平均值（包括原发和重发的帧），$G \\ge S$。无冲突时，$G=S$，有冲突时，$G &gt; S$，冲突频繁时，$G &gt; 1$。$P_0$：$P_0$是一帧发送成功（未冲突）的概率$S = G \\times P_0 $冲突危险期：时间长度2t（要保证在该帧发送之前t内没有帧发送，并且该帧开始发送后t内没有帧发送）在冲突危险期内，生成帧均值为$2G$。生成k帧的概率服从泊松分布：$\\text{Pr[k]} = \\frac{G^k e^{-G}}{k !}$。例如生成0帧的概率是$\\text{Pr[0]} = e^{-G}$在2t时间内，发送成功的概率应为，2t内都不才产生新帧的概率：$P_0 = Pr[0] \\times Pr[0] = e^{-2G}$纯ALOHA协议的性能将$P_0 = e^{-2G} $代入$S = G\\times P_0$，得$S = G \\times e^{-2G}$求导求吞吐率S的极大值：$S’ = e^{-2G} - 2G \\times e^{-2G} = 0$，故当 $G = 0.5 $时， $S \\approx 0.184$即，纯ALOHA信道的利用率最高为18.4%。因为ALOHA协议的利用率极低，所以改进为分隙ALOHA协议。分隙ALOHA协议（Slotted ALOHA）工作原理把时间分成时隙（时间片），时隙 = 帧时T（较纯ALOHA降低一半）发送帧必须在时隙的起点，所以冲突值发生在时隙的起点冲突危险期缩短为T，一旦某个站占用某个时隙并发送成功，则在该时隙内不会出现冲突性能分析$P_0 = P[0] = e^{-G}$，$S = G\\times e^{-G}$在G=1时取得最大吞吐率：$S_{max} = \\frac{1}{e} \\approx 0.368$即，分隙ALOHA信道的利用率最高为36.8%。CSMA协议载波侦听多路访问协议（CSMA，Carrier Sense Multiple Access），改进的ALOHA协议。特点：先听后发。非持续式CSMA概念：经过侦听，若介质空闲，则发送帧；若介质忙碌，则随机等待再侦听。缺点：随机等待时间内介质上没有数据传送，这段时间被浪费。持续式CSMA分为：1-持续CSMA、P-持续CSMA概念：经过侦听，若介质空闲，则发送帧；若介质忙碌，则持续侦听直至空闲；若发送帧发生冲突，则随机等待后再侦听P-持续CSMA侦听得到介质空闲，则以P的概率发送，以1-P的概率延迟一个时间发送1-持续CSMA是P-持续的特例，此时P=1，即侦听到介质空闲就发送，而不会延迟等待后再发送。CSMA仍然会冲突的原因同时侦听同时传送。传播延迟。信号在介质传播速度是光速的65%（每微秒200米），在信号未到达接收方的时候，接收方监听信道发现空闲，随后发帧，两帧碰撞冲突。冲突窗口冲突危险期。一个工作站能够检测到冲突的时间最大值冲突窗口定义为上限：来回时间（RTT，Round Trip Time），2个帧时。信号在信道传播速度：V = 200m/us网卡处理帧的时间：网卡延时$\\text{t}_{\\text{PHY}}$最远的两个工作站相距：S计算得到：$冲突窗口 = 2t + 2t_{\\text{PHY}}$，其中$ t = \\frac{S}{V}$倘若最远两个工作站间还有中继器，则$冲突窗口 = 2（t + t_{\\text{PHY}} + N \\times t_{\\text{中继器}} ）$，其中$ t = \\frac{S}{V}$如果冲突发生在最远两个工作站的正中间，那么此时检测到冲突的时间等于最远两个工作站之间的传播延迟。CSMA/CD带冲突检测的载波侦听多路访问协议——CSMA with Collision Detection，也是1-持续的CSMA。半双工以太网中使用。工作原理先听后发、边发边听经侦听，若介质空闲，则发送；若介质忙碌，持续侦听至空闲；发送之后，持续侦听是否碰撞冲突，若不冲突则发送成功，若冲突则随机等待后再重复侦听。发送站感知冲突后，中断发送，之后发送一个非常简短的拥塞信号（Jam信号，是一个强化信号，广播出去通知各工作组该地方发生了碰撞）。各协议性能比较冲突检测和处理冲突检测的方法：比较发出和收到的两个信号的能量与脉冲宽度变化冲突检测的要求时隙宽度 = 冲突窗口(最大冲突检测时间) -&gt; 保证在一个时隙内能够检测到最远距离的冲突。发送有效帧的时间 &gt;= 冲突窗口 -&gt; 防止因为在发生冲突时，已完成短帧发送而无法知道实际上已发送失败。以太网概述以太网位于OSI参考模型的下两层——物理层、数据链路层。两种以太网经典以太网：3M-10Mbps，不太常用交换式以太网：10M、100M、1G，广泛使用IEEE以太网命名规则10Base2：10——10Mbps、Base——线路编码这种基带传输方式、2——传输距离（百米）10Base-TX：T——传输介质，铜制非屏蔽双绞线10Base-F：F——传输介质，光缆三种以太网线缆参数对比名称电缆最大区间长度节点数/段优点接口拓扑10Base5粗缆500m100用于主干AUI总线拓扑10Base2细缆200m(185m)30廉价BNC总线拓扑10Base-T双绞线100m1024易于维护RJ-45星型/拓展星型10Base-T相比于10Base5、10Base2，优点安装成本大大降低即插即用组网灵活星型结构，故障隔离适用于大批量制造具有开放式标准的互操作能力缺点：多用户共享10Mbps信道的上行信道IEEE802.3协议描述了运行在各种介质上1兆到10兆速度的1-持续CSMA/CD协议的局域网标准。IEEE802.3与Ethernet在帧格式、涵盖参考模型的层数等方面有区别。DIX以太网是一种事实上的以太网标准。二进制指数回退算法在CSMA/CD中，发送冲突后随机等待时长的算法，比如二进制指数回退算法。冲突检测到后，时间被分成离散的时隙，时隙长度等于信号在介质上来回传输时间($51.2 \\mu s$)，一般地，i次冲突后，等待的时间将从$\\begin{cases} (0 \\thicksim 2^i-1) \\times 2\\tau &amp; 0 &lt; i \\le 10 \\ (0 \\thicksim 1023) \\times 2\\tau &amp; 10 &lt; i \\le 16 \\ 放弃发送 &amp; 16 &lt; i \\end{cases} $中随机选择。经典以太网、快速以太网10Base经典以太网，越来越不能满足人们对速度的需求提高负载的方法提速到100M全双工交换式网络，改集线器Hub为交换机Switch快速以太网（100M以太网——IEEE802.3u）要求：跟10M以太网兼容基本思想：保留原有的帧格式、接口和过程规则比特时间：100ns -&gt; 10ns电缆最大长度：2500m - &gt; 250m编码方式10M以太网：曼彻斯特编码快速以太网：4B/5B（4bits数据被编码成5bits信号，易实现、电压平衡、效率80%）千兆以太网（G比特以太网，GE）：IEEE802.3z兼容10/100M以太网（同时期的两个技术FDDI、ATM不兼容）主要工作在全双工模式，若半双工，则需要CSMA/CD技术，可能带来传输距离过短的问题 -&gt; 可使用帧串、帧扩充等方法解决以太网为什么延用至今简单性和灵活性易于维护支持TCP/IP，互联容易善于借鉴：4B/5B，8B/10B小结以太网是多路访问协议的实现：CSMA/CD二进制指数回退算法，降低了再次冲突的可能性以太网类型：经典以太网、交换式以太网以太网信道利用率以太网帧以太网位于OSI参考模型的下两层， IEEE802.3位于OSI参考模型的下一层半，二者有些许差别，以太网处理的PDU是帧，DIX以太帧和IEEE802.3帧有小小差别。IEEE802.3帧结构前导码+帧起始字段：8个Bytes，前7个Bytes都是10101010，最后一个字节10101011（最后一位是1表明帧的开始）。前导码的作用——表明一个帧的开始而在DIX以太网帧中，帧起始字段最后一位是0目的地址：6个Bytes（MAC地址，前24位为OUI表示某公司，后24位表序号）源地址：6个Bytes（MAC地址，全球唯一，表示方法是’-‘、’:’、’.’配合16进制）长度字段：表明帧长度（不包括前导码、但包括帧头帧尾），帧长度最小64字节最大1518字节而在DIX以太网帧中，该字段是类型字段，表明上层网络层是什么协议如何区分是长度字段还是类型字段：判断大小，$\\begin{cases} 长度字段 &amp; 大小&lt;1536(\\text{0x600}) \\ 类型字段 &amp; 大小 &gt; 1536(\\text{0x600})\\end{cases} $数据字段：搭载了LLC的数据，长度最小是46字节，实际内容小于46则要填充到46，如此加上帧头帧尾的18字节再能保证整个帧至少64字节。校验字段：4个Bytes，CRC循环冗余校验，除了前导码+帧起始字段都被校验。有效帧长度至少64Bytes ★CDMA/CD的要求：最短帧发送时间 &gt;= 冲突窗口 $2\\tau$以太网(802.3)规定，在10Mbps局域网中时隙$2\\tau = 51.2 \\mu s$最短帧长度：$10Mbps \\times 2 \\tau /8 = 64\\text{Bytes}$或$(51200/100ns) /8 = 64\\text{Bytes}$为了更加容易区分有效帧和垃圾数据，以太网要求有效帧必须至少64字节二层交换的基本原理不同建筑、单位，有着许多LAN，想要将它们连接起来，可用网桥/交换机。网桥与交换机网桥工作在数据链路层，通过检查MAC地址做出转发帧的举措。不会检查网络层（二层交换不关系三层协议），所以IPv4、IPv6、AppleTalk、ATM、IPX、OSI分组可以穿越网桥。交换器网桥的现代名称，二者不做严格的区分，交换机等同于网桥。二层交换使用网桥/交换机将LAN连接起来。网桥可将不同类型的网络，如802.11、802.3连在一起。从802.X到802.Y的网桥不用的帧格式 -&gt; 重新封装不用的数据传输速率 -&gt; 缓存不同的最大帧长度 -&gt; 切割802.3帧最长1526字节，802.11帧最长2346不同的安全策略不同的服务质量要求透明的网桥（Transparent Bridges）通过透明网桥将多个LAN连接起来，硬件和软件不需做任何变化。透明网桥工作在混杂模式（Promiscuous Mode），它接收所有的帧。当一个帧到达网桥时，他必须做出丢弃（Discard）或转发（Forward）的决策。决策是通过在网桥内部的地址表（Hash Table）中查找目的MAC地址而作出的。MAC地址表的逆向学习当一个帧到达网桥/交换机的时候，若不在表中，则将大量广播该表（向除发送端口外的所有其他端口转发）。同时做逆向学习（Backward Learning），即从到达帧的源地址认识源地址对应的主机在帧发送端口上，将这对信息写入MAC地址表。MAC地址表的变化。因为拓扑是变化的，网桥需要适应这种变化。规则：往表中加入记录的同时，打上时间戳到达帧的源地址在表中已有记录，更新时间戳周期性扫描表，删除超时记录网桥工作原理网桥接收到一个帧，则在MAC地址表中查找该端口。执行下述三个操作（专用的VLSL芯片可在几微秒内完成操作）：若目的端口与源端口相同，则丢弃该帧若目的端口与源端口不同，则转发该帧若目的端口位置（MAC地址查找不到），则广播该帧上述三个操作也叫：过滤、泛洪/扩散、转发，是二层交换的基本原理。不同部分可以同时通信互不影响 -&gt; 网桥/交换机分割了冲突域，提高了性能生成树协议在网络中经常采用冗余结构，来获取可靠性（比如在两个节点建两条信道，其中一条信道损坏时也可保证通信）。但是环结构（回路），可能会造成一些问题多帧传送：有帧的副本到达。广播风暴：局域网内发送的广播帧在两个Switch来回泛洪。MAC地址库不稳定：同样帧从同一个交换机的不同端口到达，导致交换机的逆向学习结果不稳定。于是Radiation Perlman提出的生成树算法——既无“环路”又提高可靠性STP，Spanning Tree Protocol，IEEE802.1D每一个网络有一个根网桥；每一个网桥有一个根端口；每一个网段有一个指定端口；剩下的非指定端口不被使用生成树算法，可在有物理回路的网络中，生成逻辑无回路的生成树，但并不能保证其中的路径最优。非指定端口虽不参与数据帧的转发，但它会侦听树的工作报文。当树上某些端口失效后，非指定端口将重新启用，形成新的生成树。虚拟局域网经典LAN：物理LAN，地理位置靠近的工作站构成。VLAN：一组逻辑上的设备或用户，不考虑地理位置。VLAN的实现：基于MAC地址基于三层协议基于端口（大多数）：在交换机内部有一张VLAN成员配置表VLAN成员跨越不同交换机（帧标记法）：帧在通过Trunk干线起点时打上标签，干线终点拆除标签（把这个帧涂上它所在VLAN的颜色）总结VLAN是一组逻辑上的用户一个VLAN特性等同于一个物理LAN一个VLAN就是一个广播帧VLAN，可使用二层交换机实现广播域的分割帧标记法可以让帧穿过交换机的干线二层设备二层（数据链路层）的设备：网卡、网桥、交换机网卡网卡，NIC，Network Interface Card功能Logical Link Control：网卡提供和上层通信Naming：提供一个独特的MAC地址标识符（MAC地址烧在网卡的ROM）Framing：封装过程的一部分，为传输比特流打包Media Access Control：为访问共享介质提供访问策略Signaling：创建信号和与介质的接口网卡本身还是第一层设备，故，还有第一层的功能（内建转发器等）分类适用PC/Notebook的分类： 标准以太网卡 / pcmcia网卡用于以太网/令牌环的分类：Ethernet NIC / TOKEN Ring NIC以太网卡分为Tx、Rx网桥网桥，用来连接不同的LAN端通过过滤部分交通流量（基于MAC地址，将LAN端分流），减少冲突，改善网络性能交换机一种多端口的网桥。交换机具有比网桥更高的交换速度，支持新的功能如VLAN交换机常被替换集线器用作以太网星型拓扑的中心，以改善现有网络的性能交换机中地址表的维护除了直接读取数据帧中的源地址信息去更新CAM。还有动态更新：利用时戳（每增加/引用/找到一条记录，为它打上新的时间标记），再周期性扫描时戳，过期删除交换机会利用微分段技术来创建无冲突域：LAN被交换机分割开的网段在一个大的冲突域中产生无冲突域。交换机内虚拟的线路，就像一些拨接开关一样，端口之间的交换会建立线路，故交换机的内部，帧交换非常的快。交换机在交换帧时的三种方式存储转发：交换机把整个帧接收下来，计算校验和并检查该帧无错再做策略。（延迟大、出错率小）直通交换（贯穿）：在接收时即读入目的端口转发出去。（延迟小、出错率高）无分片交换：交换时，读满64字节后才转发，不会转发碎片帧，而冲突碎片往往是小于64字节的非法短帧runt。（延迟不大、出错率不高）交换机和集线器的比较功能网桥（二层设备）中继器（一层设备）再生信号√√连接采用不用MAC协议的网段√×隔离冲突域√×根据帧头的物理地址转发帧√×丢弃损坏帧√×无线局域网无线传输信号的性质决定了无线信道接收与发送信号时，无法采用CSMA/CD通过电压变化检测冲突的方法（Near/Far现象），同时无线网络中存在隐蔽站与暴露站的问题，因此设计了CSMA/CA来完成无线局域网下的冲突检测和避免，进行介质访问控制。CSMA/CA利用ACK信号来避免冲突的发生，也就是说，只有当客户端收到网络上返回的ACK信号后才确认送出的数据已经正确到达目的地址。CSMA/CA原理：带冲突避免的载波侦听多路访问协议。首先检测信道是否有使用，如果检测出信道空闲，则等待一段随机时间后，才送出数据。接收端如果正确收到此帧，则经过一段时间间隔后，向发送端发送确认帧ACK。发送端收到ACK帧，确定数据正确传输，在经历一段时间间隔后，会出现一段空闲时间。隐藏站问题：假设有3无线通信站ABC如下所示：A —&gt; (B &lt;— C)其中B在C的无线电波范围内，但A不在C的无线电波范围内。此时C正在向B传送数据，而A也试图向B传送数据。此时，A不能够监听到B正在忙，而错误的认为此时可以向B传送数据了。如果A向B传送数据，则将导致错误。此即隐藏站问题。其中C是A的隐藏站。暴露站问题：假设有3无线通信站ABC如下所示：&lt;—–(A B) —&gt; C其中B在A的无线电波范围内，但C不在A的无线电波范围内。此时A正在传送数据（向除B以外的某通信站），而B希望给C发送数据，但是错误地认为该传送过程将会失败（因为B会监听到一次传输，所以它会错误地认为此时不能向C发送数据）。此即暴露站问题。其中A是B的暴露站。物理层：repeater中继器、hub数据链路层：Bridge、switch网络层：Router传输层：Transport gateway应用层：Application gateway第5章 网络层概述网络层主要功能：将源端产生的数据包（或数据分组）送至目的机过程中其中涉及：信息的封装、目的机识别、找源端到目的机的路由。可能会遭遇的问题：地址不够用、丢包、拥塞网络层内容分三大块：被路由协议——IP协议IP地址（用来定位目的机）IP分组（用来解决信息的封装）IPV6（新一代IP协议）路由选择协议，用来找到源机和目的机之间的最优的路径距离适量路由选择协议，实例RIP链路状态路由协议，实例OSPF其他：ARP、ICMP、CIDR、NAT源和目的间的网络分成两大类：数据报网络：无连接的服务，携带目的机地址，一路查路由表。抗毁性：感知拥塞虚电路网络：面向连接的服务，不携带目的机地址，携带路径的标号，沿途路由器有带路径标号的路由表。IP地址Internet Protocol，互联网协议，TCP/IP协议栈的核心之一，其提供一种尽力而为的把数据从源送达到接收方的方法。IP为路由提供路由所需要的信息，所以它也被称作被路由的协议，其主要包括两方面内容：IP地址（用来标识收发数据主机）IP分组或IP数据报（信息封装的格式）IP地址32位，有二进制表示、点分十进制表示。IP地址有层次结构，比如130.1.1.1属于130.1.1.0，130.1.1.0属于130.1.0.0。IP地址有两层结构，网络部分和主机部分，IP地址分为5大类：A类地址——大型前1×8位是网络部分，后3×8位是主机部分第一字节的最高位固定为0，故第一字节取值范围为 $0 \\sim 127 $全世界的A类地址总共只有128个每一个A类网络可容纳 $2^{24}-2 $ 个主机B类地址——中型前2×8位是网络部分，后2×8位是主机部分第一字节的最高位固定为10，故第一字节取值范围为 $128 \\sim 191 $全世界的B类地址总共只有 $2^{14} $ 个每一个B类网络可容纳 $2^{16}-2 $ 个主机C类地址——小型前3×8位是网络部分，后1×8位是主机部分第一字节的最高位固定为110，故第一字节取值范围为 $192 \\sim 223 $全世界的C类地址总共只有 $2^{21} $ 个每一个C类网络可容纳 254 个主机区分ABC——看第一字节值的D类：用作组播E类：用作一些科研特殊的保留地址（不分配给特定主机）：网络地址：主机部分全0的地址广播地址：主机部分全1的地址0.0.0.0：指该主机、该网络，路由表中默认路由的目的地址255.255.255.255：泛洪广播地址，为防广播风暴，又退化成本地广播地址127.0.0.0：环回地址(Lookback Network)，如127.0.0.1表示本机169.254.0.0：非正常地址，不能与外部正常通信IP地址的分配——ICANN机构：子网规划IP分组如何送达子网：路由器使用子网掩码来决定分组往哪个子网转发主路由器（边界路由器）：负责和外部联系子网掩码：了解内部网络结构的机制点分十进制：如255.255.255.224/网络位数+子网位数：如/27目的网络地址 = 目的IP地址 &amp; 子网掩码举例：131.108.2.2目的IP地址 &amp; 255.255.255.0子网掩码 = 131.108.2.0子网络地址ABC类IP地址的子网掩码分别是：/8、/16、/24子网位由主机位借位而来，剩下的主机位中全0为网络地址、全1为广播地址，不能标识主机。子网位借位原则：从主机域的高位开始、借位剩下的主机部分至少为两位（网络地址和广播地址）子网让两层IP地址结构变成了三层：网络、子网、主机。IP寻址IP寻址根据目的IP地址找到目的网络的过程（大网络-&gt;中网络-&gt;小网络-&gt;目的机所在网络）在中间网络，IP寻址，执行者：路由器，一个路由器称为 1 hop。步骤打开分组-&gt;提取目的IP地址定网络，查路由（将目的IP地址与子网掩码按位与运算）重新封装，转发MAC寻址在最后一个网络进行主机的对应，执行者：交换机。解封装：比特流 -&gt; 帧 -&gt; 分组 -&gt; 数据段 -&gt; 数据流 -&gt; 信息IP分组字段：协议版本：4位，IPv4为0100，IPv6为0110报头长度：4位，表示IP分组的头部有多长，数据范围为0101~1111，单位是 4 Byte，即最小 20 Byte，最大 60 Byte区分服务（ds，Differentiated Service）：8位，表示分组的重要程度优先级等，可提供一定的服务质量保证、拥塞控制总长度：16位，表示包括头部和数据的数据报总长度，单位是 1 Byte，最大为 65535 Byte分组标识号：16位，标识当前的数据分组的序列号（由发送者来分配，接收方可通过该号码来进行重组）标志位：3位，决定分组是否要进行分片分段偏移量：13位，分片后接收方可通过分片偏移进行重组为什么要分片？分组穿越的网络 MTU (载重力)不同。生存时间（TTL）：8位，单位 hop，每经过一个路由器，重新封装时把TTL生存时间减1，当TTL=0时，分组被丢弃，向源发回一个超时消息。该字段可防止分组在网络中无限循环。用户协议：8位，指明它的上层传输层采用的协议，UDP (17)、TCP (6)报头校验和：16位，头部计算来的互联网校验和源IP地址目的IP地址数据报选项：可选、可变长的选项，长度不等，该字段允许主机支持不同的选项，比如安全、源路由、时戳等填充：将数据报选项字段填充到32位的整数倍IPv6IPv4 的先天不足：地址危机端到端业务模式QoS和性能问题配置复杂移动性支持不够路由表的膨胀安全问题IPv4地址不够用，使用私人地址，端 -&gt; 端 变为 端 -&gt; 转换器 -&gt; 端IPv6 的目标：支持几十亿台主机缩减路由表的规模简化协议，让路由器可以更快地处理分组提供比IPv4好的安全性更加关注服务类型 （尤其是实时数据）允许通过指定范围来支持组播传输允许主机在不改变地址的情况下能够漫游（移动性支持）允许协议具有扩展性允许新老协议共存多年IPv6 地址表示——冒分十进制每16位以4位十六进制表示地址前缀长度用 “/xx” 的形式放到地址后例如，2001:0410:0000:0001:0000:0000:0000:45ff简化规则1，省略前导零，变为 2001:410:0:1:0:0:0:45ff简化规则2，忽略全零，变为双冒号，变为 2001:410:0:1::45ff注意：一个IPv6地址最多一个双冒号IPv6地址 分类：单播地址：链路本地地址（FE80::/64 + EUI-64）：FE80:: + MAC地址一分为二中间拼上 “11111111 11111110”可聚合全球单播地址，可用来标识主机的接口，等于64位网络位+64位主机位3位，固定的001，表示只用到了全球IPv6地址的八分之一13位，TLA顶级聚类地址，分给各大地区的网络中心8位，保留位24位，NLA次级聚类16位，SLA站点级聚类IPv6的快速配置：IPv6主机启动时，首先生成链路本地地址，有该地址主机可和本地其他节点通信最主要是和默认网关(内部子网路由器)的通信，获得全球IPv6地址的前缀前缀 + InterfaceID -&gt; 全球单播地址InterfaceID的三种生成方式：手动配、EUI-64（有安全隐患）、DHCPv6IPv6 子网规划：根据路由器数量及其支持网络，来构建寻址的分层结构，不需要精打细算IPv6分组IPv6分组由基本头部、拓展头部、载荷三部分构成，Next Header描述了三者间的关系。IPv6分组字段：基本头部协议版本，4位区分服务，8位，数据分组的服务类型，这些分组有不同的实时传输要求，表明该分组它的重要程度、优先级等字段流标签，20位，为源端和接收端提供了一种建立伪连接的方式，即源端和接收方把一组具有同样需求并希望得到网络同等对待的数据分组打上同样一个标签或者标记有效载荷长度，16位，指明了搭载数据的长度Next Header，8位，指明了紧跟的拓展头类型，最后一个拓展头或无拓展头则表示”用户协议”，6表示TCP，17表示UDP跳数限制（HP），8位，同 IPv4 中TTL源IPv6地址，128位目的IPv6地址，128位删除了分段功能，所以IPv6源端必须一开始就知道全部路径网络的最小MTU，以便分成合适大小的数据报文发送（PMTU算法）删除了校验和字段，数据链路层、传输层有自己的校验和扩展头部，可以有0…6个，用于那些省略的IPv4字段偶尔使用数据IPv6过渡技术IPv6 过程过程：三类基本过渡技术 (RFC-1933)：双协议栈 (Dual Stack)：服务器必须支持双栈，主机端优先用IPv6隧道 (Tunnel)：IPv4分组可以作为无结构无意义的数据被封装在IPv6数据报中，或者反之。翻译/转换技术：从IPv4转换到IPv6，或反过来，不仅发生在网络层，还有传输层和应用层。路由路由器收到IP分组后：解封装到L3，提取目的IP地址目的IP地址与子网掩码进行与运算，查路由表重封装，转发TTL -= 1置换源和目的MAC地址重算校验和分片(可选)路由表表头：目的网络/子网掩码、路径代价、下一跳、转出接口路由信息的三种：直连路由：学习感知直连路由静态路由：人工配置默认/缺省路由，找不到路可以从这转发，能避免错丢包、缩减路由表规模、减少路由器负担优点缺点在小型网络中容易实施仅适用于简单网络或特殊用途（比如默认路由）非常安全，不会发送通告随着网络增大，配置复杂性显著增长总是通过同一路径到达同一目的网络需要人工更新和维护不需要CPU、RAM、带宽等开销动态路由：由路由选择协议动态生成、更新、维护优点缺点适用于有多个路由器的网络可能会使实施更加复杂通常不受网络规模的限制有安全隐患自动更新和维护路由信息需要CPU、RAM、带宽等开销来维护路径优劣的量度：路径长度：由网络管理员定义每条网络链路的代价(cost)，从源到宿的代价总和为路径长度，hop (跳数)可靠性：链路数据传输的可靠性（误码率）延迟：数据包从源到宿需要花费的传输时间带宽：链路的最大传输能力以及网络流量负载：网络资源（例如路由器的CPU）的使用率通信代价：占用通信线路的费用最优化原理：如果一个路由器 J 处在路由器I到路由器K的最优路径上，那么，从路由器J到路由器K的最优路径也在同样的这条路径上。汇聚树（Sink Tree）：从所有的源到一个给定的目的地的最优路径形成的一棵树，树根是目的地。汇聚树不唯一。路由算法的目的，为所有的路由器发现和使用汇聚树。路由选择协议：距离矢量路由选择（Distance Vector，DV）链路状态路由选择（Link State，LS）距离矢量路由选择算法DV是分布式Bellman-Ford路由算法，常被用于小型网络，RIP是一个典型的DV工作原理：维护：每个路由器维护两个向量，$D_i、S_i$交换：在邻居路由器之间交换路由信息（矢量）更新：每个路由器根据收到的矢量信息更新自己的路由表D-V 算法的特点：优点简单缺点交换的信息太大路由信息传播慢，可能导致路径信息不一致收敛慢度量计数到无穷、路径环不适合大型的网络路由选择信息协议RIPRIP：Routing information protocol，路由选择信息协议。版本：RIPv1：有类的路由选择协议RIPv2：无类的路由选择协议，支持CIDR、VLSM等RIPng：支持IPv6尽管在现代网络中极少使用 RIP，但是作为了解基本网络路由的基础则十分有用。特点：RIP 是一种典型的D-V 路由选择协议RIP 采用了跳数（hop）作为量度（metric），不能真正反映网络的状况当量度超过15 跳，目的被认为不可达以防无穷计数，路由环默认地，每30秒钟交换一次矢量/向量信息（全部路由表）可能的问题：路由环路无穷计数“好事传千里，坏事传得慢”解决办法：定义最大跳数、加快收敛收敛慢收敛：网络查找最佳路径的过程收敛的加快：水平分割、毒性逆转、抑制定时器、触发更新因为站得不够高看得不够远，每个路由只从近邻拿信息，无法判断正确与否，可能学习、传播过时信息。全网不断传播错误、过时信息，无法稳定、收敛链路状态路由选择算法为解决DV站得不够高看得不够远的问题。算法思想：发现：向邻居发Hello包，等待回复了解它们的全球唯一名字设置：到它的每个邻居的成本度量链路带宽的反比延迟：发送ECHO包，等待回复，通过测量往返时间RTT，获得合理的延迟估计值构造：Link State Packet，一个分组，包含发送方标识、序列号（防序列号回转问题，用32bits表示）、年龄（解决路由器崩溃和序列号损坏，每过1s，age-1，age=0则丢弃LSP）、邻居列表、到邻居的成本/度量。基于事件/时钟去触发构造。发送：这个分组给所有其他的路由器逆向路径转发：新的分组到达，若该分组是新的，被从除了来线路外的其他线路转发/泛洪出去；重复分组丢弃，过时分组拒绝。保留区：到达的分组不先处理，而是每时钟时间处理一次，期间保留区的相同分组就会被丢弃计算：dijkstra到每个路由器的最短路径，最短路树LS路由算法特点：优点缺电每个路由器的认识一致每个路由器需要较大的存储空间收敛快计算负担很大适合在大型网络里使用开放的最短路径优先(OSPF)OSPF，Open Shortest Path First。内部网关协议（IGP）中应用最广、性能最优的一个协议。特点：可在大型网络中使用无路由自环OSPF支持VLSM、CIDR等使用带宽作为度量值（$10^8 \\div BW$），比如10M网络代价是 $10^8 / (10 \\times 10^6) = 10 $收敛速度快通过分区实现高效的网络管理所有区域都要连到骨干区域（区域0）上术语：RouterID：32位，自治系统内路由的位置标识协议号：89TTL=1，只被传递一跳LSP：Link State PacketOSPF分组类型：OSPF数据包类型描述Type 1－Hello与邻居建立和维护毗邻关系。Type 2－数据库描述包（DD）描述一个OSPF路由器的链路状态数据库内容（概况）Type 3－链路状态请求（LSR）请求相邻路由器发送其链路状态数据库中的具体条目（请求详情）Type 4－链路状态更新（LSU）向邻居路由器发送链路状态通告（发送详情）、事件触发Type 5－链路状态确认（LSAck）确认收到了邻居路由器的LSU全网进行同步，同步次数为 n*(n-1)/2找到一台特别的路由器（Designated Router，指定路由器）进行同步，同步次数为 n-1DR的选举：登记：本网段内的OSPF路由器登记候选人：本网段内的priority&gt;0的OSPF路由器所有的priority&gt;0的OSPF路由器都认为自己是DR取大：选priority值最大的，若priority值相等，选Router ID最大的DR的特点：选举制：DR是路由器选出来的，而非人工指定终身制：一旦当选，除非路由器故障，否则不会更换世袭制：DR选出的同时，也选出BDR，DR故障后，由BDR接替DR成为新的DROSPF维护路由信息的措施：触发更新，LSU通告Hello分组发送的时间间隔：缺省10秒Hello分组的失效间隔：缺省40秒即使没有拓扑变化，LSA在条目过期（缺省30分钟）后，发送LSU，通告链路存活为什么说OSPF克服了路由自环：每一条LSA都标记了生成者（用生成该LSA的路由器的RouterID标记），其他路由器只负责传输，不会对该信息改变或错误理解路由计算的算法是SPF，计算的结果是一棵树，路由是树上的叶子节点，从根节点到叶子节点是单向不可回复的路径。区域之间通过规定骨干区域避免无类域间路由CIDRIP 面临的两大问题：分类造成了数百万个地址浪费A类地址网络：16 M 个地址（太大）C类地址网络：256个地址（太小）B类地址网络：65,536个地址（够用）路由表膨胀CIDR技术的提出：Classless Inter Domain Routing缓解了B类地址的枯竭缩减了路由表的规模CIDR基本思想：分配地址方法：按需分配比如用户需要2000个IP地址，C类不足，B类太大，则分配一个块地址x.x.x.x/21如果路由表中有多个表项匹配 (这些表项有不同的子网掩码) ，使用子网掩码最长（子网最小）的那个表项路由聚合（子网规划的相反行为）如 $\\begin{cases} 200.199.48.0/24 \\ 200.199.49.0/24 \\200.199.50.0/24 \\200.199.51.0/24 \\ \\end{cases} $ ，聚合成 200.199.48.0/22聚合结果——超网（SuperNet）聚合的前提：子网构成地址空间连续、下一跳相同聚合的另一个好处：隔离了路由翻动（RTA下某条具体路由的Down/Up状态，不会影响到上游路由器RTZ汇总后的路由状态）网络地址翻译NATIPv4 总地址池已枯竭，私人地址（不可路由的地址）的提出，NAT技术为私人地址而服务。ClassAddress RangeCIDR PrefixA10.0.0.0 - 10.255.255.25510.0.0.0/8B172.16.0.0 - 172.31.255.255172.16.0.0/12C192.168.0.0 – 192.168.255.255192.168.0.0/16NAT思想：内网使用私人地址，当内网需与外网通信，私人地址转换为合法的global的IP地址NAT转换器（NAT Box），维护地址转换表NAT优点：节省了公有IP地址提供了内部网访问外网的灵活性有一定的保密性NAT缺点：违背了IP的结构模型——每个IP地址唯一地标识了一台机器将互联网改变成了“面向连接”的网络，NAT转换器维护着连接的状态，一旦它崩溃，连接也没有了违背了最基本的协议分层原则，IP是网络层，Port是传输层，跨层工作了如果传输层不是采用TCP或UDP，而是采用了其它的协议，NAT将不再工作有些应用会在payload中插入IP地址，然后接收方会提取出该IP地址并使用，但是NAT转换器对此一无所知，导致该类应用不再有效NAT让一个IP地址可以承载61,440 （65536-4096）个私人地址（超载，PAT）互联网控制消息协议ICMPICMP（IP的姊妹协议）的诞生：IP提供的是境内传送的服务，分组可能会遭遇拥塞、丢弃找不到目的机等问题有时我们也想知道到某个目标机的路是否通达，以及延时是多少等ICMP消息封装在IP分组中ICMP作用：向源报告差错测试网络：ping、tracertICMP应用——Ping：源站点发出ICMP回声请求报文目的站点接收后必须回复ICMP回声应答报文源站点接收到应答报文后决定可达不可达应用测试TCP/IP是否正常工作ping 127.0.0.1网络设备是否正确ping 本机IP地址检查对外连接的路由器ping 默认网关IP检查与某台设备的畅通情况ping IP检查DNS设置ping 域名执行DNS反向查询ping –a IPICMP应用——tracert：通过ICMP超时报文得到途径的路由器列表源机向源机逐步发送 TTL = 1,2,…,n 的报文，得到各层超时报文ICMP应用——PMTU：求从源到目标中间穿过网络的最小MTU发数据包，分段标记DF=1，根据反馈尝试各种长度的报文，直到到达目的机ICMP消息仅送给源机，规定ICMP消息不生成自己的差错报告（拥塞而发出的ICMP源抑制消息，该消息可能同样拥塞发出ICMP源抑制消息，以此类推）地址解析协议ARP封装的任务：添加寻址所需的信息，比如IP地址、MAC地址用 Address Resolution Protocol 解决只知道IP地址不知道MAC地址的问题ARP思想：将IP地址映射到MAC地址向周围广播：”我是128.1.2.7，谁知道128.1.2.15的MAC地址”128.1.2.15收到询问自己的ARP请求，才回复远程主机的MAC地址解析（跨LAN进行ARP）：源将目的MAC地址填上默认网关的MAC默认网关解封装后重封装时将源、目的MAC分别变为默认网关MAC、目的机MACARP的优化——ARP表：动态建立、更新、维护ARP表机器上线/配置改变时，向周围广播免费ARP（srcIP=trgtIP），告知周边的MAC地址，不期望收到应答，若意外收到应答则表明自己的IP冲突收到源的ARP请求非目标机虽不应答，但默默记下源的MAC地址到自己的ARP表定时删除超时ARP信息静态配置ARP可以解决动态更新的病毒隐患拥塞控制拥塞（Congestion）：子网或其一部分出现太多分组，网络性能急剧下降拥塞控制的两类措施：开环试图用良好的设计来解决问题，本质是从一开始就保证问题不会发生很难精准估计需求闭环：建立在反馈环路的概念上，分三个步骤：监视系统，检测何时何地发生了拥塞把这些信息传递到能够采取行动的地方调整系统的运行，以改正问题拥塞量度——如何得知拥塞：因为缺乏缓存空间而丢弃的分组百分比平均队列长度超时和重传的分组数平均分组延迟分组延迟的标准方差（standard deviation）拥塞处理：检测到拥塞的路由器发送一个警告分组给流量源，但是这个分组可能无法到达每个分组可以保留一位或一个域，当拥塞度量超过阈值的时候，路由器填充该位或域，以此警告它的邻居。主机或路由器周期性地向外显式探询拥塞（负载 &gt; 资源）的解决：增加资源在某些点之间使用更多的通道增加带宽（增加通路）把流量分散到多条路径启用空闲或备份的路由器降低负载拒绝为某些用户提供服务给某些用户的服务降低等级让用户更有预见性地安排他们的需求数据报子网中的拥塞控制：路由器监视它的输出线路和其它资源的使用情况，用 实变量 u 关联，u 介于 0.0~1.0u 超出了阈值，对应的线路就进入到警告“warning”状态每个新到达的分组都将被检查，看它的输出线路是否处于“警告状态”，警告位：在分组头部中设置一个特殊的位，分组被传回源后源调整发送速度抑制分组：路由器给源机发回一个抑制分组，并在抑制分组中指明原分组的目标地址；当源机收到抑制分组后，它会以某种百分比减少它发向该目标的流量；这段时间过后恢复原速逐跳抑制分组：让抑制分组路径的每个路由器都采取相应的措施；代价是上游路由器的缓存空间负载脱落：分组超载后的丢弃随机丢弃丢弃新到达的(葡萄酒策略，适合文件传输类)丢弃早到达的分组(牛奶策略，适合多媒体类)丢弃不太重要的（less important）分组，需要发送方在它们的分组中标明优先级随机早期检测RED：在情况恶化之前RED，Random Early Detection路由器检测维护队列的平均长度为了确定何时开始丢弃数据包，路由器需要维护一个运行队列长度的平均值。当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随机丢弃一小部分数据包，随机选择丢弃的数据包使发送方发现丢包的可能性更大；因为在数据报网络中，路由器不能分辩出那个源引起了网络的最大麻烦，因此随机选择丢弃的数据包或许是最佳选择。流量整形用户产生的流量忽大忽小，流量整形就是调节数据传输的平均速率和突发数据流，以减少突发而带来的拥塞、缓存溢出、丢包等问题。算法：漏桶，Leaky Bucket令牌桶，Token Bucket其他：资源预留、准入控制、分组调度等漏桶：每个主机连接到网络的接口中都有一个漏桶，即一个优先长度的内部队列当桶中有分组的时候，输出速率是恒定的，当桶空的时候，输出速率是0当一个分组到达满的桶的时候，分组将被丢弃（满则溢）每个时钟周期tick，仅允许一个分组或固定数量的分组发送出去令牌桶：改进了漏桶中桶满溢出的问题，桶满丢令牌而不丢分组允许有上限的数据输出突发令牌桶拥有令牌（tokens），且以每△T秒产生一个令牌的速度往桶中输入令牌一个分组要发送的时候，它必要从桶中取出和获取到一个令牌令牌桶算法允许累积令牌，但最多可以累积 n（令牌桶的容量）个令牌最大突发时间的计算：设突发时间：S 秒已知，令牌桶容量 B 字节，令牌到达速率 R 字节/秒，最大输出速率 M 字节/秒得到 B+ RS = MS，即 S = B/(M-R)第6章 传输层传输层概述传输层：整个协议栈(TCP/IP)的核心任务：提供可靠、高效、性价比高的数据传输传输实体：是任务完成的硬件或软件可以存在操作系统的内核可以以一个链接库的形式绑定到网络应用中可以以一个独立的用户进程运行可以实现在网卡上传输层用网络层的接口，为上层应用层提供服务，也分面向连接/无连接两种传输层、网络层分层原因：网络层运行在由承运商操作的路由器上，用户无法真正控制到网络层，只能眼睁睁看着丢包、延迟把另一层放在网络层之上，可让用户能够控制道服务质量传输层原语独立于网络层原语，而网络层原语会因网络的不同而不同两层的作用范围不同网络层负责把数据从源机送达目的机，hostToHost传输层负责把数据送到具体的应用进程，endToEnd传输层、数据链路层对比：功能相似流控制、差错控制、数据(报文/帧)排序传输环境不同一个是通信子网，一个是物理信道数据段：TPDU（Transport Protocol Data Unit），传输层协议数据单元。是从传输实体发到对端传输实体的信息TPDUs 被封装在分组（packet）中，由网络层交换分组被封装在帧（frames）中，由数据链路层交换传输层两大协议：用户数据报协议，UDP，User Datagram Protocol传输控制协议，TCP，Transport Control Protocol用户数据报协议UDPUDP 是一个无连接的（connectionless）的传输层协议。UDP传输数据段，无须建立连接，不提供数据的可靠传输。与IP数据分组类似，但不可用IP分组替代UDP，因为UDP有使用源端口、目的端口。UDP数据段头——头部+数据：头部第1字段，源端口，16bits头部第2字段，目的端口，16bits头部第3字段，长度字段，表示包括头部和数据共多少字节，16bits头部第4字段，校验和，可选(不选择填0)，16bits端口Port：16位，0~65535&lt; 1023，知名端口，用于公共应用（保留，全局分配，用于标准服务器），IANA分配1024-49151，非特权用户端口，注册端口，比如BT使用6881-6887$\\ge$ 49152，动态端口，私人端口自由端口 free port本地分配、动态随机端口校验和的计算：IP伪头部、UDP头部、数据按16位列好，按列反码求和，结果取反其中用到的IP伪头部：接收方计算结果为全1，则传输无错。CRC校验和纠错能力较弱。校验和计算中使用了IP地址，这破坏了分层原则UDP特点：提供端点标识，端到端的数据传输不提供差错控制和可靠传输，但简洁高效通信模型端到端，端点即套接字(Socket)，Socket包括(IP, Port)通信五元组：(源IP, 源Port, 目的IP, 目的Port, TCP/UDP协议)已分配的知名端口号：TCP数据段TCP协议：是为在不可靠的互联网上提供可靠的端到端的字节流而设计TCP必须动态适应不同拓扑、带宽、延迟、分组大小、其他网络参数，在出错时要求足够健壮支持TCP的机器都有一个TCP 实体，或者是用户进程或者是操作系统内核，都可以管理TCP流和跟IP层的接口发方：封装。TCP实体接收本地进程的用户数据流，将其分割成不超过64kB的分片（实践中，通常分割成1460字节，以通过以太网传输）收方：解封装当包含TCP数据段的报文到达某台机器的时候，被提交给传输实体，传输实体将其重构出原始的字节流TCP连接上每个字节都有一个32位序列号收发方不以字节而是以数据段的形式交换数据TCP数据段大小的确定——限制其的两个因素：IP分组的载荷限制TCP数据段必须适合IP的65515的载荷限制，65515=65535-IP头的20下层网络的MTU比如以太网载荷大小，1500字节TCP数据段（TPDU）格式：head，20字节的头部（去掉可选项Options，变长的数据字段/域（可是0个或更多字节Data头部第1字段，源端口，16bits头部第2字段，目的端口，16bits头部第3字段，序列号，表示一个字节的编号，32bitsISNs(initial sequence numbers)：初始序列号，是随机产生的SYN：携带了ISNs 和SYN 控制位的数据段头部第4字段，确认号，表示期望对方发来的字节的编号，32bitsTCP的可靠传输保证，采用肯定确认机制和累计确认技术。如确认号是500，表示收到了发方发送的499、498…等字节。下次我就可以发500序列号的字节过去了。头部第5字段，TCP段头长度，单位是4字节，4bits下一字段是保留字段，现在逐步启用做拥塞控制头部第6、7、8、9、10、11字段，控制比特，URG、ACK、PSH、RST、SYN、FIN，各1bitURG：当紧急指针使用的时候，URG 被置为1，表明有紧急数据，必须先处理。ACK：等于1表示确认号有效，启用了捎带确认，等于0表示确认号无效PSH：表示这是带有PUSH标志的数据，接收方收到这样的数据，应该立刻送到上层，而不需要缓存它RST：被用来重置一个已经混乱的连接。如果在连接建立阶段，就直接拒绝建立连接SYN：用在连接建立过程中。与ACK配合使用可以表示连接请求(SYN=1,ACK=0)或连接接收(SYN=1,ACK=1)FIN：被用来释放连接，表示发送方已经没有数据要传输，但可继续接收数据头部第12字段，窗口尺寸，告诉对方可以发送的数据字节数，即从确认字节号开始，连续发送的字节总数，16bits为避免接收方被大量涌入的数据所淹没，TCP实体进行了流量控制，用可变长的滑动窗口来完成，这个窗口尺寸的大小取决于接收方头部第13字段，校验和，16bits头部第14字段，紧急指针，与URG控制位配合使用，16bits紧急指针是一个对于当前序列号的字节偏移量，标明紧急数据从哪里开始。Options，选项域，提供了一种增加基本头没有包含内容的方法TCP三次握手建立连接TCP，提供面向连接的服务，其连接通过三次握手来建立。TCP连接的建立：Host1发送连接请求，控制位SYN=1, ACK=0。SEQ=x，x是随机产生的初始序列号Host2接收后，回答，控制位SYN=1, ACK=1。SEQ=y，y是初始序列号，ACK Number=x+1，表示对x之前的字节都确认收到Host1接收应答，回发最后的确认，控制位SYN=0, ACK=1。SEQ=x+1，ACk Number=y+1，表示对y之前的字节确认收到三次握手也称为同步，在这个过程中双方交换了初始序列号x、y，用来跟踪后续交换的每一个字节TCP双方没有主从之分，是全双工的DoS攻击：利用三次握手，SYN泛洪，导致DoS攻击。控制一些主机向Server发送很多第一次握手信息，SYN里伪造并不存在的源IP地址服务器会这些信息回发第二次握手信息，并且等待第三次握手信息，第二次握手信息无法到达发送者，第三次握手信息等待不来，这让服务器挂起很多资源等待，资源耗尽而瘫痪，无法提供正常服务TCP连接释放TCP连接释放：任何一方没数据要发送时，都可发送一个FIN置位的TCP数据段当FIN被确认时，该方式的连接被关闭当双向连接都关闭后，连接释放TCP连接的释放是对称，要求两方的释放请求都被确认，而一次只能确认一个，这有一些问题，解决方案是把释放连接的决定权交给请求者：一方发送 连接释放请求DR（Disconnect Request），并期待对方的确认ACKDR到达接收端，它回发ACK，并且也发送一个DRACK到达发送端，连接释放；同时回发确认ACK，当这个ACK到达接收端，反方向的连接也释放。采用定时器：避免DR、ACK丢失而引发的问题，在任何时候发出DR的同时，都启动一个定时器如果一方发送了FIN置位的DR数据段出去，若在定时器超时都没收到应答，释放连接另一方最终也会注意到连接的对方已不在，即定时器超时后连接释放杀死半开放连接：半开放连接：最初的DR及其重传都丢失了的话，发送者因超时放弃继续发送且释放连接，但另一端却不知道这些情况仍处于活跃的状态。杀死方式：在一定时间内没有TPDUs到达则单方面自动释放；同时利用定时器，超时时自动发一个哑TPDU（dummy TPDU），避免被对方释放。TCP传输策略TCP传输策略：类似LLC，TCP链路传输，采用了基本的肯定确认重传机制。使用Window Size字段进行流量控制：TCP是以数据段的形式传输数据的，一个数据段包含很多个字节，相当于批量传输。为避免大量数据淹没接收方，采用流量控制技术。下图中，Sender先发送了一个2k的数据，Receiver接收到时缓存窗口还是空的，回复确认接收到2k数据并且告诉对方窗口大小还剩2k；然后对方收到后就满打满算发了2k过来，此时Receiver窗口已满，回复的信息中win=0，告诉对方不要再发过来；待Receiver的应用读取了缓冲中的数据后，又空出2k的缓存，此时Receiver发送一条win=2048的信息告诉对方更新可发送大小；然后对方发了1k的数据过来….当窗口数为0时，发送者不能正常发送数据段，除非：Urgent紧急数据。比如用户想杀掉远端机器上的进程时发送者可发送一个字节的数据段，以便让接受者再次发送(期待接收的字节号或ACK, WIN)，以免死锁优化接收端，不要急着回复确认接收端推迟500ms发送确认分组和窗口更新，以便可免费搭载在处理后的回显分组内（free ride便车）优化发送端——Nagle’s Algorithm当数据以一次一字节的速度到达的时候，只发送第一个字节，然后将后续的字节缓存起来，直到发出的字节得到确认；将缓存起来的字节在一个数据段中发出，再继续缓存，直到发出的数据得到确认。Nagle算法在很多TCP上实现，但是有些时候最好禁用，比如：当一个X-Windows应用在互联网运行的时候，鼠标的移动事件必须发送给远程计算机，把这些移动事件收集起来一批一批发送出去，使得鼠标的移动极不连贯傻瓜窗口综合征：silly window syndrome problem当有大块数据被传递给发送端TCP实体，但接收端的交互式应用每次只读取一个字节的时候，往返发送的有效信息大小与代价相差甚远。解决方案——Clark解决方案阻止接收方发送只有1个字节的窗口更新，相反，它必须等待一段时间，当有了一定数量的空间之后再告诉发送方接收方可以可以维护一个内部缓冲，且阻塞上层应用的READ 请求，直到它有大块的数据提供发送方和接收方的优化：发送方，Nagle’s Algorithm。尽量不发送数据含量小的数据段；缓存应用层数据到一定量才发送接收方，Clark’s Solution。不请求对方发送短数据段(Window Size)；延迟窗口变更信息，使接收缓冲区足够大TCP拥塞控制虽然网络层也管理拥塞，但大多数管理任务由TCP完成。因为针对拥塞的真正解决方案是减慢数据率，所以TCP拥塞控制遵循分组守恒原则，即老分组离开后新分组才注入网络。拥塞检测：Congestion Detection所有的互联网TCP算法都假定超时是由于拥塞引起的，并通过监视超时的情况来判断是否出现问题拥塞控制：Congestion Control当一个连接建立的时候，双方选择一个合适的窗口大小，接收方根据自己的缓冲区大小来指定窗口的大小若发送者遵循这窗口大小的限制，则接收端不会出现缓冲区溢出的问题，但可能由于网络内部的拥塞而发生问题拥塞的两种情形：接收方容量不足，比如快速的网络向小容量接收方传输数据网络容量瓶颈，比如慢速的网络向大容量的接收方传输数据拥塞控制：针对拥塞的两种情形，单独解决问题发送者维护两个窗口：接受者窗口，反映了目前接受者的处理能力（容易获取）拥塞窗口cwnd，反映了目前网络容量（难以获取）发送数据大小 = 上述两个窗口的较小值慢启动算法Slow Start：获取拥塞窗口大小。指数的增长：连接建立时，发送者用当前使用的最大数据段长度MaxSeqL初始化拥塞窗口，然后发送一个最大的数据段，若在定时器超时前得到确认，则将拥塞窗口翻倍，发送两个数据段，直到超时。线性的增长：采用阈值参数，初始为64K，拥塞窗口增长到阈值时，就停止指数增长，按照线性增长，即每次成功的传输让拥塞窗口增加一个最大的数据段长度。当超时发生时，阈值降为当前拥塞窗口的一半，同时将拥塞窗口重设为一个最大的数据段的长度，重新开启新一次的慢启动。下图，一开始阈值Threshold=32k，当指数增长到阈值时改为线性增长，在第14次发送时超时，阈值设为拥塞窗口的一半20k，且发送窗口重置为一个数据段大小，重新开启新一次的慢启动。线性增长，可将窗口尝试粒度变小，以获得更准确的拥塞窗口值TCP慢启动算法就是这样不断超时、不断重启，尝试出的拥塞窗口值也随之网络状况变化而变化，达到拥塞控制的目的快速恢复：重新慢启动时，拥塞窗口值可以不重置为一个数据段大小，而是设置为阈值大小，从这里开始直接线性增长任何时候，若TCP传输实体接收到一个ICMP抑制分组，则这个事件被当作超时对待。TCP定时器等TCP采用肯定确认重传技术，保证每一个字节的可靠传输。重传定时器：retransmission timer为了解决数据段丢失的问题，每发一个数据段都会启动一个重传定时器其时间设置需要良好的考量，设置过长则等待过长，设置过短引发频繁超时重传持续定时器：persistence timer用来避免以下死锁deadlock发生接收方发送了一个窗口数为零的确认（窗口更新），告诉发送方等待。稍后，接收方空出了缓冲，发送更新窗口的数据段，但是该分组丢失啦！现在，收发双方都在等待对方发送数据段过来，但永远等不到，死锁产生。发送方在收到win=0时，启动一个持续定时器，如果定时器超时没有收到更新窗口，则发送一个探测数据段，引发对方重新发出更新窗口。保活定时器：keep-alive timer用来检查连接是否存活，当一个连接空闲的时间超过保活定时器的时间，该连接将被杀掉。在关闭时刻处于TIMED WAIT状态中使用的定时器：运行两倍的最大分组生存时间，以确保连接关闭之后，该连接上的所有分组都完全消失。第7章 应用层DNS工作原理：应用程序以域名作为参数调用解析器解析器发送UDP分组给本地DNS服务器如果待查询域名在该DNS服务器的管辖范围内或存在缓存则返回资源记录给解析器反之则本地DNS服务器向根域名服务器发送一条查询此域的迭代查询请求。根域名服务器会返回所查询域的IP地址或者本地DNS服务器下一步应该向之查询的域名服务器地址。本地域名服务器向正确的域名服务器查询到IP后返回给解析器。同时缓存查询过的域名服务器地址。","link":"/CS/Computer-Network-Study-Notes/"},{"title":"JVM-学习笔记","text":"Java Virtual Machine，So Fascinating.学习参考资料：《深入理解 Java 虚拟机第 3 版》宋红康 JVM 教程一些工具：IDEA Plugin：jclasslib Bytecode viewer内存与垃圾回收JVM 与 Java 体系结构前言The Java Virtual Machine is the cornerstone of the Java platform. It is the component of the technology responsible for its hardware- and operating system-independence, the small size of its compiled code, and its ability to protect users from malicious programs.The Java Virtual Machine is an abstract computing machine. Like a real computing machine, it has an instruction set and manipulates various memory areas at run time. It is reasonably common to implement a programming language using a virtual machine. For the sake of security, the Java Virtual Machine imposes strong syntactic and structural constraints on the code in a class file. However, any language with functionality that can be expressed in terms of a valid class file can be hosted by the Java Virtual Machine. Attracted by a generally available, machine-independent platform, implementors of other languages can turn to the Java Virtual Machine as a delivery vehicle for their languages.JVM 的整体结构Java 代码执行流程JVM 的架构模型Java 编译器输入的指令流基本上是一种基于栈的指令集架构。基于栈式架构的特点：设计和实现更简单，适用于资源受限的系统避开了寄存器的分配难题：使用零地址指令方式分配指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现。不需要硬件支持，可移植性更好，更好实现跨平台123456789101112int i = 2;int j = 3;int k = i + j;// 字节码iconst_2istore_1iconst_3istore_2iload_1iload_2iaddistore_0基于寄存器架构的特点：典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机。指令集架构则完全依赖硬件，可移植性差性能优秀和执行更高效花费更少的指令去完成一项操作在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主。123// 2+3mov eax, 2add eax, 3反编译操作：javap -v test.classJVM 的生命周期虚拟机启动JVM 启动通过引导类加载器 bootstarp class loader 创建一个初始类 initial class 来完成的，这个类由虚拟机的具体实现指定虚拟机执行一个运行中的 JVM 有一个清晰的任务：执行 Java 程序执行一个所谓的 Java 程序，真真正正在执行的是一个叫做 JVM 的进程打印 JVM 进程：jps虚拟机退出程序正常执行结束程序运行过程中遇异常/错误而异常中止某线程调用 Runtime 或 System 的 exit/halt 方法，并且 Java 安全管理器也允许这次 exit/halt 操作除此之外，JNI (Java Native Interface) 规范描述了用 JNI Invocation API 来加载/卸载 JVM 时，JVM 的退出情况JVM 的发展历程Sun Classic VM第一款商用 JVM只提供解释器，解释器和 JIT 编译器（外挂的）无法同时配合Hotspot 内置了此 VMExact VMExact Memory Management 准确式内存管理，也可叫 Non-Conservative/Accurate Memory Management。虚拟机可知内存中某个位置的数据具体是什么类似（变量/引用）具备现代高性能 VM 的雏形：热点探测、编译器和解释器混合工作模式、只在 Solaris 平台短暂使用，最终被 Hotspot 替换HotSpot VM绝对的市场地位Oracle JDK / OpenJDK 默认虚拟机热点代码探测技术通过计数器找到最具编译价值代码，触发即时编译或栈上替换通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡JRocket（EBA 公司，该公司 08 年被 Oracle 收购）专注于服务器端应用不太关注程序启动速度，因此不包含解释器实现，全部代码靠即时编译器编译后执行JRocket JVM 是目前世界上最快的 JVM。70% 性能提升和 50% 硬件减少MissionControl 服务套件，以极低的开销来监控/管理/分析生产环境中的应用程序的工具IBM 的 J9市场定位于 HotSpot 接近有影响力的三大商用虚拟机之一，号称世界上最快的 Java 虚拟机（在 IBM 机上）17 年开源了 J9，为 OpenJ9，给 Eclipse 基金会KVM 和 CDC/CLDC HotspotOracle 在 Java ME 产品线上的两个虚拟机 CDC/CLDC HotSpot Implemention VM运行塞班系统上的 Java 手机游戏TaobaoJVM基于 OpenJDK 开发的定制版本 AlibabaJDK创新的 GCIH (GC invisible heap) 技术实现了 off-heap，即将生命周期较长的 Java 对象从 heap 中移 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的GCIH 中的对象还能在多个 JVM 进程中共享使用 crc32 志林实现 JVM intrinsic 降低 JNI 调用开销PMU hardware 的 Java profiling tool 和诊断协助功能针对大数据场景的 ZenGC硬件严重依赖 intel CPU，损失了兼容性，但提高了性能Dalvik VMGoogle 开发，没有遵循 JVM 规范，应用于 Android，并在 Android 2.2 中提供了 JIT，发展迅猛基于寄存器架构执行的是编译以后的 dex (Dalvik Executable) 文件，效率高dex 文件可通过 Class 文件转化而来，通过 Java 语法编写应用程序，可直接使用大部分 Java APIAndroid 5.0 使用支持提前编译（Ahead Of Time Compilation，AOT）的 ART VM 替换 Dalvik VMGraal VM18 年，Oracle Labs 公开，号称 “Run Programs Faster Anywhere”跨语言全栈虚拟机，可作为任何语言的运行平台使用，包括 C++、Python、R、Ruby、JavaScript 等支持不同语言中混用对方的接口和对象，支持这些语言使用已经编写好的本地库文件工作原理是将这些语言的源代码或源代码编译后的中间格式，通过解释器转换为能被 Graal VM 接受的中间表示。提供了 Truffle 工具集快速构建面向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。其他：Azul VM、Liquid VM、Apache Harmony、Microsoft JVM类加载子系统类加载器子系统：加载字节码文件，使得其中的变量/方法等信息有组织地加载到内存作用：负责从文件系统/网络中加载 Class 文件，只负责加载，至于是否可运行，由 Execution Engine 决定三个阶段：加载阶段引导类加载器 BootStrap ClassLoader扩展类加载器 Extension ClassLoader系统类加载器 Application ClassLoader链接阶段验证 verify准备 prepare解析 resolve初始化阶段加载的类信息存放于一块称为方法区的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中的常量池部分的映射）ClassLoader 角色class file 存在于本地硬盘行，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 中来。根据这个模板实例化出 n 个一模一样的实例class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区在 .class 文件 -&gt; JVM -&gt; 元数据模板 过程中，ClassLoader 扮演快递员的角色类的加载过程Loading通过一个类的全限定名获取定义此类的二进制字节流本地系统网络，比如 Web Appletzip 包（jar、war 格式的基础）运行时计算生成，如动态代理由其他文件生成，如 JSP从专有数据库中提取 .class 文件，少见从加密文件中获取，典型地防 Class 文件被反编译的 措施将这个字节流所代表的静态存储结构转换为方法区的运行时数据结构在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口Linking验证 Verify目的在于确保 Class 文件的字节流中包含信息符合当前 VM 要求，保证被加载类的正确性，不会危害虚拟机自身安全文件格式验证/元数据验证/字节码验证/符号引用验证准备 Prepare为变量分配内存并且设置该类变量的默认初始值，即零值。initial 阶段才会给 static 变量设置值不包含用 final 修饰的 static，final 在编译的时候就会分配了，准备阶段会显式初始化这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中解析 Resolve将常量池内的符号引用转换为直接引用的过程事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行符号引用就是一组符号用来描述所引用的目标。符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄解析动作主要是针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。Initial执行类构造器方法 &lt;clinit&gt;() class init 的过程此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。如果没有静态变量和静态代码块的话就不生成 &lt;clinit&gt;()构造器方法中指令按语句在源文件中出现的顺序执行&lt;clinit&gt;() 不同于类的构造器关联：构造器是虚拟机视角下的 &lt;init&gt;()若该类具有父类，JVM 会保证子类的 &lt;clinit&gt;() 执行前，父类的 &lt;clinit&gt;() 已经执行完毕* 虚拟机必须保证一个类的 `&lt;clinit&gt;()` 方法是并发安全的 &lt;img src=&quot;image-20210127180042340.png&quot; style=&quot;zoom:67%;&quot; /&gt;类加载器的分类分类：JVM 支持两种类型的 ClassLoader引导类加载器 BootStrap ClassLoader自定义类加载器 User-Defined ClassLoader定义：所有派生于抽象类 ClassLoader 的类加载器都为自定义类加载器，并不是字面上的指开发人员自定义的 ClassLoader常见 ClassLoader 只有 3 个下图中的四者是包含关系，不是上下层/继承关系BootStrap Class Loader 是 C/C++ 代码写的，其他是 Java123456789101112// 获取系统类加载器 sun.misc.Launcher$AppClassLoaderClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();// 获取其上层：扩展类加载器ClassLoader extClassLoader = systemClassLoader.getParent();// 获取其上层，nullClassLoader bootstrapClassLoader = extClassLoader.getParent();// 对于用户自定义类来说，默认使用系统类加载器进行记载Test.class.getClassLoader(); // sun.misc.Launcher$AppClassLoader// 系统核心类库的类加载器是引导类加载器加载的String.class.getClassLoader(); // null虚拟机自带的加载器：BootStrap ClassLoaderC/C++ 实现，嵌套于 JVM用来加载 Java 核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容）没有父加载器加载扩展类和应用程序类加载器并制定为他们的父类加载器安全考虑，Bootstrap ClassLoader 只加载报名为 java、javax、sun 等开头的类Extension ClassLoaderJava 编写，由 sun.misc.Launcher$ExtClassLoader 实现派生于 ClassLoader 类父类加载器为 BootStrap ClassLoader从 java.ext.dirs 系统属性所制定的目录中加载类库，或从 JDK 的安装目录的 jre/lib/ext 子目录下加载类库。若用户的 jar 放在此目录下，也会由其加载1234567// 获取 BootStrapClassLoader 能够加载的 api 的路径URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs();for (URL element: urls) { System.out.println(element.toExternalForm());}// 获取 ExtClassLoader 能够加载的类路径 System.getProperty(\"java.ext.dirs\");用户自定义类加载器：why?隔离加载类修改类加载的方式拓展加载源防止源码泄露步骤继承 java.lang.ClassLoaderJDK1.2 之前要重写 loadClass() 方法，之后不建议重写 loadClass() 方法，而是建议把自定义的类加载逻辑写在 findClass() 方法中12345678910111213141516public class CustomClassLoader extends ClassLoader { @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException { try { byte[] result = getClassFromCustomPath(name); // ... } catch (FileNotFoundException e) { e.printStackTrace(); } } private byte[] getClassFromCustomPath(String name) { // 从自定义路径中加载指定类 // 可以包含加密和解密的过程 }}若没有太过复杂的需求，可直接继承 URLClassLoader，这样可避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁关于 ClassLoader：获取 ClassLoader 的途径：获取当前类的 ClassLoader：clazz.getClassLoader()获取当前线程上下文的 ClassLoader：Thread.currentThread().getContextClassLoader()获取系统的 ClassLoader：ClassLoader.getSystemClassLoader()获取调用者的 ClassLoader：DriverManger.getCallerClassLoader()双亲委派机制JVM 对 class 文件采用的是按需加载的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，JVM 虚拟机采用的是双亲委派模式，即把请求交由父类处理。工作原理：如果一个类加载器收到了类加载请求，它并不会自己先加载，而是将请求委托给父类的加载器去执行如果父类加载器还存在其父类加载器，则进一步向上，请求最终到达顶层的 BootStrap ClassLoader如果父类加载器可以完成类加载，则返回，或者子加载器才会尝试自己去加载 好处：避免类的重复加载保护程序安全，防止核心 API 被随意篡改java.lang.SecurityException: Prohibited package name: java.lang沙箱安全机制：自定义一个 String 类，加载时会使用引导类加载器，加载过程中会先加载 JDK 的文件 rt.jar 下的 java\\lang\\String.class 此时自定义 String.class 的 main 方式就会找不到JVM 视角中两个 class 对象为同一个类的条件：全限定类名相同加载这个类的 ClassLoader 实例对象相同对类加载器的引用：JVM 必须知道一个类型是 BootStrap ClassLoader 加载还是自定义 ClassLoader 加载的。如果一个类型是由用户类加载器加载，JVM 会讲这个类加载器的一个引用作为类型信息的一部分保存在方法区中当解析一个类型到另一个类型的引用时，JVM 需要保证这两个类型的类加载器是相同的。类的主动使用（除了以下，其他都是被动使用，不会导致类的初始化）：创建类的实例访问某个类或接口的静态变量，或者对该静态变量赋值调用类的静态方法反射初始化一个类的子类JVM 启动时被标明为启动类的类JDK7 开始提供的动态语言支持：java.lang.invoke.MethodHandle 实例的解析结果RET_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类没有初始化运行时数据区概述与线程运行时数据区：红色部分（堆、堆外内存 (永久代或元空间、代码缓存)）：JVM 定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁灰色部分（程序计数器、栈、本地栈）：则是与线程一一对应，随线程开始/结束而创建/销毁更细致的： 线程：Java 线程与 OS 线程一一对应JVM 系统线程：虚拟机线程：JVM 到达安全点才会出现。执行类型包含 “stop-the-world” 的垃圾收集，线程栈收集，线程挂起，以及偏向锁撤销周期任务线程：这种线程是时间周期时间的体现（比如中断），他们一般用于周期性操作的调度执行GC 线程：对在 JVM 里不同种类的垃圾收集行为提供了支持编译线程：在运行时会将字节码编译成本地代码信号调度线程：接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理程序计数器PC 寄存器用来存储指向下一条指令的地址，由 Execution Engine 读取下一条指令。它是一块很小的内存，几乎可以忽略不计，也是运行速度最快的内存JVM 规范中，每个线程都有它自己的 PC Register，是线程私有的，生命周期与线程的生命周期保持一致任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；若是在执行 native 方法，则是未指定值 undefined它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖它字节码解释器工作时就是通过改变这个计数器的值来选取下一条需执行的字节码指令是唯一一个在 JVM 规范中没有规定任何 OOM 情况的区域Stack Area 和 PC Registers 都没有 GC 虚拟机栈 ★Java Virtual Machine Stack：起因：跨平台性设计，JVM 指令根据栈来设计。每个线程创建时都会创建一个虚拟栈，其内部保存一个个的栈帧 Stack Frame，对应一次次的 Java Method Invoke生命周期与线程一致作用：保存方法的局部变量（8 种基本数据类型、对象的引用地址）、部分结果，并参与方法的调用和返回JVM 直接对 Java 栈的操作：方法执行，伴随着压栈执行结束后的弹栈不存在垃圾回收栈中可能的异常：JVM 规范允许 Java 栈的大小是动态的或者是固定不变的若采用固定大小的 JVM 栈，那每个 Thread 的 JVM Stack 容量在创建时独立选定。若线程请求分配的栈容量超过 JVM 设置，则抛 StackOverflowError 异常若采用动态扩展，在扩展时发现不足了则抛 OutOfMemoryError-Xss256k、-Xss1024k 可以设置栈大小栈帧的内部结构：局部变量表 LV, Local Variables操作数栈 OS, Operand Stack动态链接 DL, Dynami Linking，指向运行时常量池的方法引用方法返回地址 RA, Return Address，方法退出的定义一些附加信息局部变量表：也称为局部变量数组、本地变量表定义为一个数字数组，主要存储方法 参数和定义在方法体内的局部变量，数据类型包括各类基本数据类型、Object Reference、returnAddress是线程的私有数据，不存在数据安全问题容量大小是编译器确定下来的，保存在方法的 Code 属性的 maximum local variables 数据项中。方法运行期间是不会改变局部变量表大小的。最基本的存储单元：Slot（变量槽）参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1 的索引结束32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64 位的类型（long/double）占用两个 slot如果当前帧由构造方法或实例方法创建，那 this 变量会存放在 index=0 的 slot 处，其他参数按按照参数表顺序排列[this, param, localVariable]Slot 重复利用：栈帧中的局部变量表中的槽位是可重用的，如果一个局部变量过了其作用域，那么在作用域后新声明的局部变量就可能复用过期局部变量的槽位1234567void test() { { int a = 2; System.out.println(2); } int b = 3;}局部变量和静态变量对比静态变量有 2 次初始化机会，prepare 和 initial局部变量表则不存在系统初始化过程，意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。int i; System.out.println(i); // CE操作数栈：方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即 push/pop。比如：执行 复制/交换/求和 等操作保存计算过程中的中间结果，同时作为计算过程中变量的临时存储空间如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中栈顶缓存技术 Top-of-Stack Cashing：栈式结构的 JVM 所使用的零地址指令更加紧凑，完成一项操作伴随着很多的入栈和出栈操作，即意味着更多的指令分派 instruction dispatch 次数和内存读写次数。HotSpot JVM 考虑将栈顶元素全部缓存到物理 CPU 的寄存器而不是内存中，以此降低对内存的读写次数，提高执行引擎的执行效率动态链接（指向运行时常量池的方法引用）：帧数据区：方法返回地址、动态链接、附加信息每个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用，包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接 Dynamic Linking。比如 invokedynamic 指令在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用 Symbolic Reference 保存在 class 文件的常量池中。比如：描述一个方法调用其他方法时，就是通过常量池中指向方法的符号引用来表示的。动态链接作用：将这些符号引用转换为调用方法的直接引用使用体现：bytecode 里面的 #1、#2 之类的常量池作用：提供一些符号和变量，便于指令的识别方法的调用（解析与分派）：JVM 中，符号引用转换为调用方法的直接引用与方法的绑定机制相关静态链接：被调用的目标方法在编译期可知，且运行期保持不变时，将调用方法的符号引用转换为直接引用的过程 invokespecial、invokestatic动态链接：被调用方法在编译器无法确定，只能再运行时将调用方法的符号引用转换为直接引用 invokevirtual、invokeinterface推广一下 =&gt; 早期绑定 Early Binding、晚期绑定 Late Binding绑定是一个字段、方法或类在符号引用被替换为直接引用的过程，仅发生一次非虚方法（静态方法/私有方法/final方法/构造器/父类方法）与虚方法普通调用指令：invokespecial（非虚方法）：调用静态方法，解析阶段确定唯一方法版本invokestatic（非虚方法）：调用方法、私有及其父类方法，解析阶段确定唯一方法版本invokevirtual：调用所有虚方法invokeinterface：调用接口方法动态调用指令invokedynamic：动态解析出需要调用的方法，然后执行Java7 增加的指令，是 Java 为实现【动态类型语言】支持而做的一种改进（本质是对 JVM 规范的修改，最直接受益者是运行在 JVM 的动态语言的编译器），但在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 等工具，直到 Java8 中 Lambda 的出现。动态语言和静态语言：区别在于对类型的检查是编译期还是运行期静态类型语言是判断变量的类型信息，动态类型语言则是判断变量值的类型信息方法重写的本质（动态分派）：（调用之前，方法的对象/类在栈顶）找到操作数栈的栈顶元素所执行的对象的实际类型，记作 C先在类型 C 中找到与常量中描述符合、简单名称符合的方法，并进行访问权限校验（通过则返回这方法的直接引用，不通过则返回 java.lang.IllegalAccessError 异常）若没有找到符合的方法，则按照继承关系从下往上对 C 的各个父类依次执行操作 3最终没找到合适方法，则抛出 java.lang.AbstractMethodError 异常虚方法表 virtual method table：OOP 中，动态分派的使用是很频繁的，为了提高性能，JVM 在类的方法区建立了一个虚方法表，使用索引代替查找，表中存放各个方法的实际入口虚方法表会在类加载的 Linking 阶段被创建并开始初始化，类的变量初始值准备完成后，JVM 会把该类的方法表也初始化完毕 方法返回地址：方法开始执行后，仅两种方式退出该方法正常完成出口：执行引擎遇到任一个方法返回的字节码指令，将返回值传递给上层方法调用者ireturn (boolean、byte、char、short、int)lreturnfreturndreturnareturnreturn (void、构造器、类和接口初始化)异常完成出口（没有返回值给上层调用者）：方法执行过程中遇到了异常，异常没有在方法内处理，导致方法退出方法执行过程中抛出异常时的异常处理，存储在一个异常处理表中，方便在发生异常时找到处理异常的代码，如下，PC: 4-&gt;8 范围发生的异常可以跳 PC=11123Exception table: from to target type 4 8 11 Class java/io/IOException本质上，方法的退出即当前栈帧出栈的过程。此时需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈的操作数栈、设置 PC 等一些附加信息：栈帧中还允许携带与 JVM 实现相关的一些附加信息。例如对程序调试提供支持的信息本地方法接口Native Method：一个 Java 调用非 Java 代码接口。很多 PL 都有这一机制，比如 C++ 中的 extern &quot;C&quot; 告知 C++ Compiler 去调 C 的函数。融合不同的编程语言为 Java 所用，初衷是融合 C/C++ 程序可与除 abstarct 外的关键字共用why: 有些功能用 Java 实现不容易或效率不高now: 目前使用的越来越少，除非是与硬件有关的应用本地方法栈Native Method Stack:线程私有虚拟机栈管理 Java 方法调用，本地方法栈管理本地方法调用某个线程调用一个本地方法时，它进入一个全新且不受 VM 限制的世界，和 VM 有同样的权限可通过本地方法接口来访问虚拟机内的运行时数据区甚至可以直接使用本地处理器中的寄存器直接从本地内存的堆中分配任意数量的内存并不是所有 JVM 都支持 Native Method，因为 JVM 规范没明确要求 Native Method Stack 的使用语言、具体实现、数据结构等在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一堆 ★Heap 概述：一个 JVM 实例只存在一个堆内存，JVM 启动时创建并确定空间大小（可人为调节），是 Java 内存管理的核心区域，也是 JVM 管理的最大块内存空间所有线程共享 Java 堆，在此还划分了线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）《Java 虚拟机规范》：堆可处于物理上不连续的空间，但逻辑上是连续的《Java 虚拟机规范》：（几乎）所有的对象实例以及数组都应当在运行时分配在堆上。（栈帧中保存其引用）The heap is the run-time data area from which memory for all class instances and arrays is allocated方法结束后，堆中的对象不会马上被移除，GC 时才会被移除内存细分：现代 GCer 大部分基于分代收集理论设计Java 7 之前，堆内存逻辑上分为：新生区(代)，Young (New) Generation Space，又分为 Eden 区和 Survivor 区存放生命周期较短的瞬时对象，这类对象的创建和消亡都很迅速（IBM 研究表明，新生代中 80% 的对象都是 “朝生夕死”）养老区(代)，Tenure (Old) Generation Space存放生命周期较长的对象（这些对象在某些极端情况还能与 JVM 生命周期一致） 永久区(代)，Permanent (Perm) SpaceJava 8 及之后，堆内存逻辑上分为：新生代，Young (New) Generation Space，又分为 Eden 区和 Survivor 区老年代，Tenure (Old) Generation Space元空代，Meta Space 设置堆空间：-Xms 初始堆内存 （Young + Tenure 代）；Runtime.getRuntime().totalMemory；默认值：内存 / 64。-Xmx 堆区最大内存；Runtime.getRuntime().maxMemory 会输出堆内存减 S0 或 S1 区的内存，因为这两个区只能选一个存，另一个是用来辅助 GC 的 ；默认值：内存 / 4-XX:+PrintGCDetails 打印 GC 详情，或者在命令行 jstat -gc 进程号-XX:NewRatio=2 表示配置新生代和老年代的占比，此时是新生代占 1，老年代占 2（默认就是 2）-XX:SurvivorRatio=8 配置 Eden 和 Survivor 区比例，此时 Survivor 区是 1，Eden 区是 8-XX:-UseAdaptiveSizePolicy：关闭自适应内存分配策略-XX:+UseAdaptiveSizePolicy：打开自适应内存分配策略（默认）对象分配过程（内存分配和内存回收是严谨且相关的）：new 的对象先放伊甸园区，此区有大小限制。当伊甸园的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行 Minor GC，将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区然后将伊甸园中的剩余对象移动到 Survivor 0 区。如果再次触发垃圾回收，此时上次幸存下来的放到 Survivor 0 区的，如果没有回收，就会放到 Survivor 1 区如果再次经历垃圾回收，此时会重新放回 Survivor 0 区，接着再去 Survivor 1 区啥时候能去养老区呢？可以设置次数。默认是15次。 可 -XX: MaxTenuringThreshold&lt;N&gt;进行设置。在养老区，相对悠闲。当养老区内存不足时，触发 Major GC，进行养老区的内 存清理若养老区执行了 Major GC 之后发现依然无法进行对象的保存，就会产生 OOM进度：72 -方法区 ★直接内存执行引擎StringTable垃圾回收垃圾回收概述垃圾回收相关算法垃圾回收相关概念垃圾回收器字节码与类的加载Class 文件结构重要的官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html前置知识Java 前端编译器：javac 是一种能够将 Java 源码编译为字节码的前端编译器。HotSpot VM 并没强制要求前端编译器只能 javac。只要编译结果符合 JVM 规范即可。除了 javac (全量式编译) 之外，还有内置在 Eclipse 中的 ECJ（Eclipse Compiler for Java）编译器，是一种增量式编译器。Ctrl+S 后，ECJ 编译器把未编译部分的源码逐行进行编译，而非每次都全量编译。ECJ 不仅是 Eclipse 的默认内置前端编译器，在 Tomcat 中同样也是使用 ECJ 编译器来编译 jsp 文件。ECJ 基于 GPLv2 开源。默认情况下，Intellij IDEA使用 javac 编译器（可自己设置为 ajc）前端编译器并不会直接涉及编译优化等方面的技术，这些具体优化细节移交给 HotSpot 的 JIT 编译器负责。涉及字节码指令的代码细节举例：12345678910111213141516171819202122232425262728293031323334public class IntegerTest { public static void main(String[] args) { // Integer变量和int变量比较时，只要两个变量的值是相等的（因为包装类Integer和基本数据类型int比较时，java会自动拆包装为int，然后进行比较，实际上就变为两个int变量的比较） Integer x = 5; int y = 5; System.out.println(x == y); // true // 同上 Integer x2 = new Integer(5); int y2 = 5; System.out.println(x2 == y2); // true // 两个非new生成的Integer对象，进行比较时，如果两个变量的值在区间-128到127之间，则比较结果为true，进入 valueOf 代码里有一个 IntegerCache 数组 Integer a1 = 1; Integer b1 = 1; System.out.println(a1 == b1); // true // 同上 Integer a3 = 128; Integer b3 = 128; System.out.println(a3 == b3); // false // 非new生成的Integer变量和new Integer()生成的变量比较时，结果为false // 当变量值在-128~127之间时，非new生成的Integer变量指向的是java常量池中的对象，而new Integer()生成的变量指向堆中新建的对象 Integer a2 = new Integer(1); Integer b2 = 1; System.out.println(a2 == b2); // false // 两个通过new生成的Integer变量永远是不相等的 Integer a4 = new Integer(1); Integer b5 = new Integer(1); System.out.println(a4 == b5); // false }}Class 类的本质：任一个 Class 文件都对应着唯一一个类或接口的定义信息，但反过来说，Class 文件实际并不一定以磁盘文件的形式存在。Class 文件是一组以字节为单位的二进制流Class 文件格式及其总体结构：Class 的结构不像 XML 等描述语言，它没有任何分隔符号，所以在其中的数据项都是严格限定的，字节的含义、长度、先后，都不允许改变。Class 文件格式采用一种类似于 C 语言结构体的方式进行数据存储，这种结构中只有两种数据类型无符号数：基本的数据类型，以 u1、u2、u4、u8 来分别代表指定字节的无符号数可用来描述 数字、索引引用、数量值、UTF-8 字符串值。表：由多个无符号数或者其他表作为数据项构成的复合数据类型所有表都习惯性地以 _info 结尾。用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表。表没有固定长度，所以通常会在其前面加上个数说明123456789101112131415161718ClassFile { u4 magic; // 魔数 u2 minor_version; // 副版本号 u2 major_version; // 主版本号 u2 constant_pool_count; // 常量池计数器 cp_info constant_pool[constant_pool_count-1]; // 常量池表, 首索引 0 没有分配，所以少 1 个字节 u2 access_flags; // 访问标识 u2 this_class; // 类索引 u2 super_class; // 父类索引 u2 interfaces_count; // 接口计数器 u2 interfaces[interfaces_count]; // 接口索引集合 u2 fields_count; // 字段计数器 field_info fields[fields_count]; // 字段表 u2 methods_count; // 方法计数器 method_info methods[methods_count]; // 方法表 u2 attributes_count; // 属性计数器 attribute_info attributes[attributes_count]; // 属性表}魔数每个 Class 文件开头的 4 个字节的无符号整数称为 Magic Number它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。即：魔数是Class文件的标识符。使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。魔数值固定为 0xCAFEBABE。不会改变。如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：Error: A JNI error has occurred, please check your installation and try again Exception in thread &quot;main&quot; java.lang.ClassFormatError: Incompatible magic value 1885430635 in class file TestClass 文件版本紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是4个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 minor_version，而第 7 个和第 8 个字节就是编译的主版本号 major_version。它们共同构成了 class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。向下兼容：高版本兼容低版本。低版本执行高版本则会抛 java.lang.UnsupportedClassVersionError版本号与平台的对应：主版本（十进制）副版本（十进制）编译器版本4531.14601.24701.34801.44901.55001.65101.75201.85301.95401.105501.11常量池 constant_pool概述：常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用。随着 JVM 的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个 Class 文件的基石。在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值（constant_pool_count）。与 Java中语言习惯不一样的是，这个容量计数是从1而不是0开始的。常量池表项中，用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。常量池计数器：u2 类型，2 个字节，constant_pool_count=1 时表示常量池有 0 个常量项（没有常量项）若为 0x16 = 22，表示有 21 个常量项，索引范围是 1-21把第 0 项常量空出来，是为了适配一种情况：某些指向常量池的索引值要表达 “不引用任何一个常量池项目” 的语义。此时这种情况即可用索引值 0 来表示。常量池项类型及其结构细节：常量池主要存放两大类常量字面量（Literal）：文本字符串、final 的变量String str=“atguigu”; final int NUM=10;符号引用（Symbolic References）：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符术语全限定名java/lang/String;简单名称指没有类型和参数修饰的方法或者字段名称，如 add() 方法和 num 字段的简单名称分别是 add 和 num描述符描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。具体如下：标志符含义B基本数据类型 byteC基本数据类型 charD基本数据类型 doubleF基本数据类型 floatI基本数据类型 intJ基本数据类型 longS基本数据类型 shortZ基本数据类型 booleanV代表 void 类型L对象类型，比如：Ljava/lang/Object;[数组类型，代表一维数组。比如：double[][][] is [[[D用描述符描述方法：toString() 方法的描述符 () Ljava/lang/String;；int abc(int[] x, int y) 方法的描述符为 ([II) I常量池里的每个项都符合以下某种类型及其细节（第 1 个字节 tag 作为类型标记，用于确定该项是以下的哪个）一个例子：总结：final 常量直接显示值，没用指向索引byte,short,char,boolean 标志为 3 的 CONSTANT_Integer_info 常量在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息常量池可以理解为 class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用 Class 文件空间最大的数据项目之一常量池中为什么要包含这些内容：Java 代码在进行 Javac 编译的时候，并不像 C/C++ 那样有链接这一步骤，而是在虚拟机加载 Class 文件的时候进行动态链接也就是说，Class 文件不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中访问标志 access_flag2 个字节，用于识别一些类或者接口层次的访问信息，包括：Class 是类还是接口是否定义为 public 类型是否定义为 abstract 类型类的话，是否为 final类的各个访问权限为 ACC_ 开头的常量，位与的运算结构作为 access_flag比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL标志名称标志值含义ACC_PUBLIC0x0001标志为public类型ACC_FINAL0x0010标志被声明为final，只有类可以设置ACC_SUPER0x0020标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）；使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记。ACC_INTERFACE0x0200标志这是一个接口ACC_ABSTRACT0x0400是否为abstract类型，对于接口或者抽象类来说，次标志值为真，其他类型为假ACC_SYNTHETIC0x1000标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）ACC_ANNOTATION0x2000标志这是一个注解ACC_ENUM0x4000标志这是一个枚举补充说明：带有 ACC_INTERFACE 标志的 class 文件表示的是接口而个是类，反之则表示的是类而个是接口如果一个 class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志如果没有设置 ACC_INTERFACE 标志，那么这个 class 文件可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不得同时设置。(注解是 @interface)ACC_SUPER 用于确定类/接口里面的 invokespecial 指令使用的是哪一种执行语义。针对 JVM 指令集的编译器都应当设置这个标志。对于 JavaSE8 及后续版本来说，无论 class 文件中这个标志的实际值是什么，也不管 class 文件的版本号是多少，Java 虚拟机都认为每个 class 文件均设置了 ACC_SUPER 标志。ACC_SUPER 是为了向后兼容由旧 Java 编译器所编译的代码而设计的。目前的 ACC_SUPER 标志在由 JDK1.0.2 之前的编译器所生成的 access flags 中是没有确定含义的，如果设置了该标志，那么 Oracle的Java 虚拟机实现会将其忽略ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_ INTERFACE 标志。(注解是 @interface)ACC_ENUM 标志表明该类或其父类为枚举类型类索引、父类索引、接口索引集合在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：1234u2 this_class; // 类索引u2 super_class; // 父类索引u2 interfaces_count; // 接口计数器u2 interfaces[interfaces_count]; // 接口索引集合类索引 this_class字节无符号整数，指向常量池的索引父类索引 super_class2 字节无符号整数，指向常量池的索引若没有继承类，其默认继承的是 java/lang/Object 类superclass 指向的父类不能是 final接口计数器 interfaces_count接口索引集合 interfaces[]interfaces[] 中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。每个成员 interfaces[i] 必须为 CONSTANT_Class_info 结构，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样字段表集合fields：用于描述接口或类中声明的变量。包括类级变量以及实例级变量，但是不包括 local variables字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。它指向常量池索引集合，它描述了每个字段的完整信息。比如字段的标识符、访问修饰符、static 修饰符、final修饰符等注意：字段表集合中不会列出从父类或者实现的接口中继承而来的字段但可能列出原本 Java 代码不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。在 Java 中字段无法重载，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称但是于字节码来讲，若两个字段的描述符不一，那字段重名合法。字段表：fields 表中的每个成员都必须是一个 fields_info 结构的数据项，用于表示当前类或接口中某个字段的完整描述一个字段的信息包括如下这些信息，各个修饰符都是布尔值作用域（public、private、protected 修饰符）实例变量还是类变量（static 修饰符）可变性（final）并发可见性（volatile 修饰符，是否强制从主内存读写）可否序列化（transient 修饰符）字段数据类型（基本数据类型、对象、数组）字段名称字段表结构u2，access_flags，访问标志u2，name_index，字段名索引u2，descriptor_index，描述符索引u2，attributes_count，属性计数器attribute_info，attributes[attributes_count]，属性表集合一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在attribute_count 中，属性具体内容存放在 attributes 数组中。以常量属性为例（更多的属性下文会统一提及），结构为：12345ConstantValue_attribute{ u2 attribute_name_index； u4 attribute_length； // 对于常量属性而言，attribute_length=2 u2 constantvalue_index；}字段表访问标志：Flag NameValueInterpretationACC_PUBLIC0x0001Declared public; may be accessed from outside its package.ACC_PRIVATE0x0002Declared private; usable only within the defining class.ACC_PROTECTED0x0004Declared protected; may be accessed within subclasses.ACC_STATIC0x0008Declared static.ACC_FINAL0x0010Declared final; never directly assigned to after object construction (JLS §17.5).ACC_VOLATILE0x0040Declared volatile; cannot be cached.ACC_TRANSIENT0x0080Declared transient; not written or read by a persistent object manager.ACC_SYNTHETIC0x1000Declared synthetic; not present in the source code.ACC_ENUM0x4000Declared as an element of an enum.方法表集合methods：指向常量池索引集合，它完整描述了每个方法的签名。在字节码文件中，每一个 method_info 项都对应着一个类或者接口中的方法信息比如方法的访问修饰符（public、private 或 protected），方法的返回值类型以及方法的参数信息等。如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来。methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息比如：类/接口初始化方法和实例初始化方法方法签名一样返回值不一样的方法，java不允许。但 class 文件允许方法表：methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所用的Java虚拟机指令。method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法方法表的结构实际跟字段表是一样的，即u2，access_flags，访问标志u2，name_index，字段名索引u2，descriptor_index，描述符索引u2，attributes_count，属性计数器attribute_info，attributes[attributes_count]，属性表集合方法表访问标志：标志名称标志值含义ACC_PUBLIC0x0001Declared public; may be accessed from outside its package.ACC_PRIVATE0x0002Declared private; accessible only within the defining class.ACC_PROTECTED0x0004Declared protected; may be accessed within subclasses.ACC_STATIC0x0008Declared static.ACC_FINAL0x0010Declared final; must not be overridden (§5.4.5).ACC_SYNCHRONIZED0x0020Declared synchronized; invocation is wrapped by a monitor use.ACC_BRIDGE0x0040A bridge method, generated by the compiler.ACC_VARARGS0x0080Declared with variable number of arguments.ACC_NATIVE0x0100Declared native; implemented in a language other than Java.ACC_ABSTRACT0x0400Declared abstract; no implementation is provided.ACC_STRICT0x0800Declared strictfp; floating-point mode is FP-strict.ACC_SYNTHETIC0x1000Declared synthetic; not present in the source code.属性表集合附加属性：紧随于方法表之后的 Class 字节码结构项，描述类的属性是 class 文件所携带的辅助信息比如该 class 文件的源文件名、以及任何带有 RetentionPolicy.CLASS 或 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 JVM 的验证和运行，以及 Java 程序的调试，一般无须深入了解属性概述：字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息属性表集合的限制没有那么严格，不要求各个属性具有严格的顺序，只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性。属性的通用结构（所有的属性都可以抽象成以下 3 部分，由属性名索引区别具体的属性）：12345attribute_info { u2 attribute_name_index; // 属性名索引 u4 attribute_length; // 属性长度 u1 info[attribute_length]; // 具体信息}JVM 预定义的属性举例（Java 8 定义了 23 种）：属性名存在于解释Code方法表Java 代码编译成的字节码指令ConstantValue字段表final 关键字定义的常量池Deprecated类, 方法, 字段表被声明为 deprecated 的方法和字段Exceptions方法表方法抛出的异常EnclosingMethod类仅当一个类为局部类或者匿名类时次有这个属性，用于标识这个类所在的外围方法InnerClass类内部类列表LineNumberTableCode属性Java源码的行号与字节码指令的对应关系LocalVariableTableCode属性方法的局部变量描述StackMapTableCode属性JDK1.6 中新增的属性，供新的类型检查校验器检查和处理目标方法的局部变量和操作数所需要的类是否匹配Signature类, 方法表, 字段表用于支持泛型情况下的方法签名SourceFile类记录源文件名称SourceDebugExtension类用于存储额外的调试信息Synthetic类, 方法表, 字段表标志方法或字段为编译器自动生成LocalVariableTypeTable类使用特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加RuntimeVisibleAnntations类, 方法表, 字段表为动态注解提供支持Code 属性：存放方法体里面的代码。但并非所有方法表都有 Code 属性（比如接口方法/抽象方法）1234567891011121314151617181920212223242526272829303132333435363738Code_attribute { u2 attribute_name_index; // 属性名索引 u4 attribute_length; // 属性长度 u2 max_stack; // 操作数栈深度的最大值 u2 max_locals; // 局部变量表所需的存储空间 u4 code_length; // 字节码指令的长度 u1 code[code_length]; // 字节码指令，二进制形式，具体有哪些指令，下文再提 u2 exception_table_length;// 异常表长度 { u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; } exception_table[exception_table_length]; // 异常表 u2 attributes_count; // 属性集合计数器 attribute_info attributes[attributes_count]; // 属性集合}// Code 属性类的属性集合，一般是 LineNumberTable、LocalVariableTableLineNumberTable_attribute { u2 attribute_name_index; u4 attribute_length; u2 line_number_table_length; { u2 start_pc; u2 line_number; } line_number_table[line_number_table_length];}LocalVariableTable_attribute { u2 attribute_name_index; u4 attribute_length; u2 local_variable_table_length; { u2 start_pc; u2 length; u2 name_index; u2 descriptor_index; u2 index; } local_variable_table[local_variable_table_length];}一些工具使用javac：javac -g Main.java 会产生 LocalVariableTable 等调试信息12345678910111213141516171819202122232425262728293031323334C:\\Users\\TTTT&gt;javac用法: javac &lt;options&gt; &lt;source files&gt;其中, 可能的选项包括: -g 生成所有调试信息 -g:none 不生成任何调试信息 -g:{lines,vars,source} 只生成某些调试信息 -nowarn 不生成任何警告 -verbose 输出有关编译器正在执行的操作的消息 -deprecation 输出使用已过时的 API 的源位置 -classpath &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -cp &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -sourcepath &lt;路径&gt; 指定查找输入源文件的位置 -bootclasspath &lt;路径&gt; 覆盖引导类文件的位置 -extdirs &lt;目录&gt; 覆盖所安装扩展的位置 -endorseddirs &lt;目录&gt; 覆盖签名的标准路径的位置 -proc:{none,only} 控制是否执行注释处理和/或编译。 -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程 -processorpath &lt;路径&gt; 指定查找注释处理程序的位置 -parameters 生成元数据以用于方法参数的反射 -d &lt;目录&gt; 指定放置生成的类文件的位置 -s &lt;目录&gt; 指定放置生成的源文件的位置 -h &lt;目录&gt; 指定放置生成的本机标头文件的位置 -implicit:{none,class} 指定是否为隐式引用文件生成类文件 -encoding &lt;编码&gt; 指定源文件使用的字符编码 -source &lt;发行版&gt; 提供与指定发行版的源兼容性 -target &lt;发行版&gt; 生成特定 VM 版本的类文件 -profile &lt;配置文件&gt; 请确保使用的 API 在指定的配置文件中可用 -version 版本信息 -help 输出标准选项的提要 -A关键字[=值] 传递给注释处理程序的选项 -X 输出非标准选项的提要 -J&lt;标记&gt; 直接将 &lt;标记&gt; 传递给运行时系统 -Werror 出现警告时终止编译 @&lt;文件名&gt; 从文件读取选项和文件名javap：123456789101112131415161718C:\\Users\\TTTT&gt;javap用法: javap &lt;options&gt; &lt;classes&gt;其中, 可能的选项包括: -help --help -? 输出此用法消息 -version 版本信息 -v -verbose 输出附加信息 -l 输出行号和本地变量表 -public 仅显示公共类和成员 -protected 显示受保护的/公共类和成员 -package 显示程序包/受保护的/公共类和成员 (默认) -p -private 显示所有类和成员 -c 对代码进行反汇编 -s 输出内部类型签名 -sysinfo 显示正在处理的类的系统信息 (路径, 大小, 日期, MD5 散列) -constants 显示最终常量 -classpath &lt;path&gt; 指定查找用户类文件的位置 -cp &lt;path&gt; 指定查找用户类文件的位置 -bootclasspath &lt;path&gt; 覆盖引导类文件的位置字节码指令重要的官方文档：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html类的加载过程类的加载器性能监控与调优","link":"/CS/JVM-Study-Notes/"},{"title":"操作系统-学习笔记","text":"第 1 章 概述操作系统课本概述进程管理内存管理存储管理本章要点：描述计算机系统的基本结构提供操作系统主要组件的详细介绍概述各种类型的计算环境探索几种开源操作系统操作系统目标OS：在计算机用户和计算机硬件之间起中介作用的程序目标：执行用户程序，使解决用户问题更容易使计算机系统使用方便高效地使用计算机硬件计算机系统分为四部件：硬件：提供基本的计算资源CPU、内存、IO设备操作系统：控制和协调各种应用程序和用户之间的硬件使用应用程序：定义如何使用系统资源来解决用户的计算问题文字处理器，编译器，网络浏览器，数据库系统，视频游戏用户人，机器，其他电脑操作系统目标：取决于如何看待用户需要方便、易用和良好的性能。不关心资源的利用但是共享计算机，如大型机或小型计算机，必须让所有用户满意专用系统(如工作站)的用户具有专用资源，但经常使用来自服务器的共享资源掌上电脑资源匮乏，优化了可用性和电池寿命有些计算机很少或没有用户界面，如设备和汽车中的嵌入式计算机操作系统定义：一个资源分配器在要求有效和公平使用资源的冲突中作出决定一个控制程序控制程序的执行，以防止错误和不当使用计算机没有普遍接受的定义内核：“在计算机上始终运行的一个程序”操作系统成长历程：图灵机1936 年末，图灵发表论文解决了一个世纪难题，同时引出了图灵机。它是一种精确的通用计算机模型，能模拟实际计算机的所有计算行为。阿塔纳索夫-贝利计算机（ABC）埃尼阿克计算机（ENIAC）第一台存储程序计算机，使用了冯诺伊曼架构。存储程序计算机（Stored-progeam computer）第一台存储程序计算机（EDSAC）加载用户程序至内存将程序存入rom，出现操作系统最原始的雏型。子程序出现了call、ret指令以及栈的概念，硬件上支持了子程序。子程序库软件上支持了子程序。异常和中断：异常（内部中断）：CPU 自身执行指令时发生的的错误事件。必须具备中断（外部中断）：外部设备向 CPU 发出中断指令。并非必须具备。中断是激活操作系统的手段。共同点：暂停当前指令流的执行，去执行毫无相关的处理程序（另一个指令流，异常/中断处理程序），处理完后返回继续执行当前指令流计算机操作员批处理程序。一次性提交大量计算机指令，集中处理。产生原因：人的操作速度比机器慢太多，非常低效，因此集中处理，减少人的操作，提高效率。机器贵，人便宜，因此提高机器效率至关重要。缺点：计算机利用率提高，人不方便了。监控程序提供效率。操作系统的早期形式。为其它程序提供便利，提高机器效率。批处理系统。作业控制为用户提供方便。JCL，作业控制语言。告诉操作系统如何运行程序。脱机输入输出联机 IO ：指作业的 I/O 是联机。作业从输入机到磁带，由磁带调入主存，以至于结果的输出、打印都是由 CPU 直接控制。脱机 IO：指外设不由 CPU 直接控制，主要是由外围计算机与外设打交道，过程是作业通过外围计算机输入到磁带上，当主机需要输入作业时，就把输入带同到主机上，主机从输入带上把作业调入主存，并予以执行，作业完成后，主机负责把结果记录到输出带上，再由外围计算机把输出带上的信息打印输出。假脱机技术：将低速设备与高速设备通过高速设备中的缓存存储器相联，不独占高速设备，使得高速设备变得可共享的一种速度匹配技术。操作系统的出现命令行 (CLI) 接口命令解释器系统调用计算机系统组织转向操作系统：CPU 转入内核态cache 和 buffer 都是存储区caching 和 buffer 都是管理存储区的技术设备驱动程序：直接控制外部设备的程序！！！！！！！！！！！！计算机系统操作I/O 设备和 CPU 可以并发执行并发 Concurrent，宏观上同时，微观上是交替的并行 parallel，真正的同时每个设备控制器控制一种特定类型的设备每个设备控制器都有一个本地缓存 bufferCPU 在主存和本地缓存间 移动数据I/O 是从设备到控制器的本地缓存设备控制器通过产生中断 interrupt 来告知 CPU 其以完成其操作常见的 Common 中断函数中断 interrupt：中断必须将控制 转移到 合适的中断处理程序。中断向量表 interrupt vector：是一个指针表，包含各种设备的中断处理子程序的地址。对于给定的中断请求，通过中断向量表，可以用唯一设备号来索引，以提供设备的中断处理子程序的地址。陷阱 trap 或异常 exception：错误或用户请求造成的一种软生成中断驱动操作系统的方式：异常、中断、系统调用中断处理：分析中断是否发生的方式轮询 polling矢量中断系统 vectored interrupt systemOS 通过转储寄存器和程序指针 来 保存当前 CPU 的状态独立的代码段 决定 对每种类型的中断 采取的操作中断与子程序的区别？？：中断是随时发生的，时间不确定子程序则时间确定，跟系统设计顺序有关系，起简化、优化作用I/O 结构：I/O 启动之后，控制权仅在 I/O 完成时才返回给用户程序Wait 指令使 CPU 空闲，直到下一次中断等待循环 ( 内存访问争用 )一次最多有一个 I/O 请求未完成，不同时 I/O 处理I/O 启动之后，控制权返回给用户程序，不需等待 I/O 完成系统调用 system call：请求 OS 允许用户等待 I/O 完成设备状态表 Device-status table：包含每个 I/O 设备的条目，如类型、地址、状态OS 索引到 I/O 设备表中，以确定设备状态，并修改表条目为了包含中断存储器结构：主存 —— 唯一的 CPU 可直接访问的大容量存储介质，特点是 随机存取、易失存储辅助存储器 secondary storage —— 提供大的非易失性存储容量的主存储器的扩展硬盘 —— 覆盖有磁性记录材料的硬质金属 rigid metal 或玻璃盘 glass platters硬盘表面逻辑上划分为轨道，轨道又细分为扇区硬盘控制器决定设备和计算机之间的逻辑交互固态硬盘 —— 比硬盘快，非易失性。多种技术、愈加受欢迎存储器层级 —— Speed Cost Volatility：缓存 caching —— 将信息复制到更快的存储系统。主存可以看作是辅助存储器的缓存设备驱动 device driver —— 为每个设备控制器管理I/O的设备驱动程序。在控制器和内核之间提供统一的接口缓存技术 caching：cache 是缓冲区，caching 是缓存技术在计算机 (硬件、操作系统、软件) 的许多层次上执行的重要原理 principle正在使用的信息 临时 从较慢的存储复制到较快的存储查信息时先看 cache 命中与否，不命中则从硬盘中将信息复制到 cache，然后再从 cache 中拿信息缓存空间比存储空间小，这使得 cache 管理是个很重要的设计问题，包括 cache 的大小和替换机制直接内存访问 Direct Memory Access DMA 结构：用于能够以接近内存速度传输信息的高速 I/O 设备设备控制器直接将数据块从缓冲存储器传输到主存储器，不需要 CPU 的干预每个块只生成一个中断，不是每个字节生成一个中断计算机系统体系大多数系统使用单一多用途 general-purpose 处理器，同时也有专用用途处理器多处理器 Multiprocessors 系统在使用和重要性方面不断增长又以 并行 paralled 系统、紧耦合 tightly-coupled 系统 著称特性快速增长的吞吐量 throughput经济可靠性增强 —— 故障弱化 graceful degradation 和 容错 fault tolerance两种类型非对称多处理器 Asymmetric Multiprocessing —— 每个处理器被分配特殊任务对称多处理器 Symmetric Multiprocessing —— 每个处理器执行所有任务分布式系统：独立的计算机、互联、透明性，共同完成一个任务集群 clustered 系统通常通过 存储区域网 Storage-Area Network SAN 进行存储共享提供高可用性服务，失败后也能幸存非对称集群，有一台机器处于 双机热备 hot-standby 模式对称集群，有多个节点运行应用，相互监督有些集群用于高性能计算 (HPC, high-performance computing)应用的编写必须使用 并行化 parallelization使用分布式锁管理 (Distributed Lock Manager, DLM) 去避免操作冲突操作系统结构多道程序设计，Multiprogramming (Batch system)，批处理系统。为效率而生单个用户并不能让 CPU 和 I/O 设备一直处于繁忙状态多道程序设计 Multiprogramming 合理组织任务以使得 CPU 总是处于有工可做状态在内存中存储所有作业的一个子集一个作业通过作业调度 job scheduling 被选中和执行当需要等待时 (如 I/O)，OS 切换到另一个任务分时，Timesharing (multitasking)相应时间理应小于 1 秒每个用户至少有一个程序在内存中执行着 -&gt; 进程提供多任务同时执行的能力 -&gt; CPU 调度OS 为保证合理的相应时间，有时需通过交换 swapping 来得到，交换时进程被换入内存或由内存换出到硬盘 （使用虚拟内存）虚拟内存运行执行的进程并不完全在内存中进程：程序的执行过程作业、进程、任务：都指一个正在运行着的程序操作系统操作中断驱动 (硬件和软件)：硬件被其中一个设备中断软件中断 (异常 exception 或陷阱 trap)软件错误 (例如，除以0)请求操作系统服务其他进程问题包括死循环、进程之间相互修改或操作系统双模式：双模式操作允许操作系统保护自己和其他系统组件用户态 （User Mode）、内核态 （Kernel Mode，Privileged Mode）模式位由硬件提供提供区分内核态和用户态的方式一些特殊的特权指令仅在内核态下可执行系统调用将模式更改为内核，从调用中返回并将其重置为用户越来越多的 cpu 支持多模式操作如 虚拟机管理 VMM 模式用户态转内核态：定时器，防止无限循环/进程占用资源定时器设置为在一段时间后中断计算机。计数器是递减的物理时钟，当计数器为 0 时产生中断时，操作系统设置计数器 (特权指令)在调度进程之前设置定时器，以重新获得超过分配时间的控制或终止程序进程管理资源：相对缺少的东西继承是正在执行的程序。它是系统中的一个工作单元。程序是一个被动的实体，进程是一个主动的实体。进程需要资源去完成任务资源：相对缺少的东西。计算机中是 CPU、内存、IO、文件、初始化数据单线程进程有一个 Program counter，它指定要执行的下一条指令的位置按顺序执行指令，每次执行一个，直到完成多线程进程每个线程有一个程序计数器系统有许多进程，一些用户，一些操作系统在一个或多个 cpu 上并发运行通过在进程/线程之间多路复用cpu实现并发进程进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。线程线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。协程协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。创建和删除用户进程系统进程挂起和恢复进程为进程同步提供机制为进程通信提供机制为死锁处理提供机制内存管理要执行一个程序，所有 (或部分) 指令及数据必须在内存中内存管理决定内存中的内容以其存在时间优化 CPU 利用率和计算机对用户的响应内存管理活动：记录当前正在使用内存的哪些部分以及由谁使用决定将哪些进程 (或其中的一部分) 和数据移入和移出内存据需要分配和释放内存空间存储管理OS 提供了统一的、逻辑的信息存储视图：文件：逻辑存储单元的抽象物理属性每个媒体都又设备驱动 (磁盘设备、磁带设备)多种属性如访问速度、容量、数据转换、访问方法（随机访问、顺序访问）文件系统管理：以目录组织文件对大多数系统的访问进行控制，以确定谁可以访问什么OS 活动创建和删除文件和目录操作文件和目录的原语将文件映射到辅助存储将文件备份到稳定的 (非易失性 non-volatile) 存储介质上大容量管理 Mass-Storage：硬盘通常存储不适合放在主存的数据 / 或需要长期保存的适当的管理尤为重要 -&gt; 整个计算机运行速度取决于磁盘子系统及其算法OS 的活动：空间管理、存储分配、硬盘调度有些存储可以不用速度很快：第三存储 —— 磁带 magnetic tape、光盘 optical但同样需要被 OS、应用 管理种类介于 WORM (write-once, read-many-times) 和 RW (read-write)将数据 “A” 从磁盘迁移到寄存器：硬盘 -&gt; 主存 -&gt; 缓存 -&gt; 寄存器分布式环境状况会更复杂，一个数据可能有多个副本输入输出子系统 I/O Subsystem：操作系统的一个目的是向用户隐藏硬件设备的特性I/O的内存管理，包括缓冲 buffering (在传输数据时临时存储数据)缓存 caching (将部分数据存储在更快的存储器中以提高性能)假脱机 spooling, Simultaneous Peripheral Online Operation, 外围设备同时联机操作 (一个作业的输出与其他作业的输入的重叠)通用设备驱动器接口用于特定硬件设备的驱动程序保护与安全保护 Protection：一些机制：操作系统规定了 “控制进程” 或 “用户” 对资源的访问安全 Security：防御系统内部和外部的攻击攻击定义范围广泛，包括拒绝服务 denial-of-service，蠕虫 worms,，病毒 ruses，身份盗窃 identity theft，盗窃服务 theft of service系统通常首先区分用户，以确定谁可以做什么：用户标识 (用户id、安全id) 包括名称和关联的编号，每个用户一个然后将用户 ID 与所有文件相关联，确定该用户的进程访问控制组标识符 (组ID) 允许定义一组用户并管理控件，然后还可以与每个进程、文件相关联权限升级允许用户更改为具有更多权限的有效 ID计算环境传统计算环境：独立通用机器但是，由于大多数系统与其他系统相互连接(即,互联网)门户 Portals 提供对内部系统的web访问网络计算机 (client) 就像Web终端移动计算机 laptop 通过无线网络相互连接网络变得无处不在——甚至家庭系统也使用防火墙来保护家庭计算机免受网络攻击移动计算环境：手机，平板电脑 tablets分布式：CS：P2P：虚拟化：云计算：实时嵌入式系统 Real-Time Embedded Systems：开源操作系统第 2 章 操作系统结构本章要点：描述操作系统向用户、流程和其他系统提供的服务讨论构建操作系统的各种方法解释操作系统是如何安装和定制的，以及它们是如何引导的操作系统服务OS 为程序和用户提供执行程序和服务的环境：用户界面 —— 几乎所有的操作系统都有一个用户界面(UI)。命令行(CLI)、图形用户界面(GUI)、批处理程序执行 —— 系统必须能够将程序加载到内存中并运行该程序，正常或异常(指示错误)结束执行I/O 操作 —— 正在运行的程序可能需要I/O，这可能涉及文件或I/O设备文件系统操作 manipulation —— 文件系统特别有意义。程序读写文件和目录，创建和删除文件，搜索文件，列出文件信息，权限管理通信 —— 进程可以在同一台计算机上或通过网络在计算机之间交换信息。通信可以通过共享内存或消息传递(操作系统移动的数据包) 进行错误检测 Error detection —— 操作系统需要不断检测到可能的错误：可能发生在 CPU 和内存硬件中，在 I/O 设备中，在用户程序中对于每种类型的错误，OS 应该采取适当的行动来确保正确和一致的计算调试工具可以极大地提高用户和程序员有效使用系统的能力多用户系统通过资源共享提高效率：资源分配 Resource allocation —— 当多个用户或多个作业同时运行时，必须为每个用户或作业分配资源。资源包括 CPU Cycles、主存、文件存储、IO 设备统计 Accouting —— 记录哪些用户使用了多少和什么类型的资源保护与安全 —— 信息所有者对信息使用的控制，并发进程不能相互干扰保护即确保对系统资源的所有访问是受控的安全包括保护外部 IO 设备不受非法访问，并记录所有非法闯入的企图用户操作系统接口CLI 命令行接口有的在内核中实现，有的在系统程序中实现有的实现多种，比如 Linux 中有多种不同的 Shell 可供用户选择主要是捕获 fetches 用户的命令并执行命令有的是内置命令，有的是程序的名字，后者不需修改 shell 的本身特性GUI 图形用户接口通常使用鼠标、键盘、显示器进行交互icons 代表了文件、程序、操作不同鼠标按键造成不同动作，提供信息、选择、执行方法、打开 directory/folder发明于 Xerox PARC现在许多操作系统同时配备 CLI 和 GUIWindows 匹配了 “command” shellMac OS，”Aqua” GUI 和 UNIX 内核的 shellUnix 和 Linux 提供可选的 GUI，如 CDE、KDE、GNOME触屏接口没有鼠标操作和选择基于手势 gestures 的输入用虚拟键盘进行文本键入声控系统调用系统调用 system call，操作系统提供的程序接口。系统调用大多数以高级语言调用。比起直接调用，通过高级语言的 API 进行调用也更常见三种最常见的 APIs：Win32 API for WindowsPOSIX API for POSIX-based systemsJava API for JVM将一个文件内容复制到另一个文件涉及的系统调用Source File -&gt; Destination File获取输入文件名屏幕输入提示 接收输入获取输出文件名屏幕输入提示 接收输入打开输入文件文件不存在则放弃创建输出文件文件存在则放弃循环读入输入文件输出到输出文件直到读完关闭输出文件向屏幕输出完成指令正常终止系统调用实现通常，一个整数对应着某个系统调用，系统调用接口维护一张索引表系统调用接口 调用 在 OS 内核中预设的系统调用，返回系统调用的状态和返回值调用者不需了解系统调用的具体实现方式只需遵守 API 以及了解 OS 会做什么返回什么有了API，大多数 OS 接口对程序员是隐藏细节的：被运行时支持库（编译器内建函数库）所管理系统调用传参 Parameter Passing通常，需要 提供 比所需的系统调用识别符更多 的信息，这些信息的具体类型、数量因 OS、调用而有所不同三种传参方式：最简单：通过寄存器传参。不过有时参数比寄存器多参数存在块、表、内存中，块内存地址通过寄存器传参。Linux 和 Solaris 是这样实现的参数被放在(压入) 堆栈中，在系统调用中被 OS 从堆栈中弹出系统调用类型进程控制类：创建 create 进程、终止 terminate 进程结束 end、放弃 abort加载 load、执行 execute获取进程属性 attributes、设置进程属性等待时间等待事件、标记事件分配、释放内存出错转储内存情况单步调试锁 Locks，用于管理共享数据的访问文件管理类：创建文件、删除文件打开、关机文件读、写、重定位 reposition获得、设置文件属性设备管理类：请求 request 设备、释放 release 设备读、写、重定位 reposition获得、设置设备属性逻辑上的 附加 attach、分离 detach 设备信息维护 maintenance 类：获得 / 设置 时间 / 日期获得 / 设置 系统数据获得 / 设置 进程、文件、设备属性通信：创建 / 创建 通信连接发送 / 接受 信息共享内存模型 -&gt; 创建和获取 gain 对内存的访问权限传输状态信息附加 / 分离 设备例子：MS-DOS单任务系统启动时即调用 Shell执行程序不创建进程单一内存空间程序载入内存，重写内存除了内核程序退出 即 Shell 重载例子：FreeBSDUnix 的变体。多任务用户登录 -&gt; 从用户所选的 shell 进行执行Shell 执行 fork() 系统调用去创建进程执行 exec() 将程序载入进程Shell 等待进程终止或继续执行用户命令进程退出：code=0 无错，code&gt;0 错误代码系统程序系统程序提供了一个便利的环境以便程序开发、执行，系统程序可分为：文件操作 manipulation状态信息：日期、时间、内存、磁盘… （一些系统实现了注册表 registry 将配置信息存储在磁盘中）文件修改程序语言支持程序装入和执行通信：进程、用户、计算机系统之间创建虚拟连接的机制 mechanism后台设备应用程序大多数用户可以看到的 OS，都是由应用和系统程序而不是系统调用决定的。操作系统设计与实现设计和实现操作系统是尚未解决的，但现今的一些方法 approaches 被证实是成功的。不同 OS 的内部结构可能差别很大通过制定目标和规范 specifications 来开始设计用户目标：OS 理应是使用方便、易学、可靠、安全、快速的系统目标：OS 理应是容易设计 / 实现 / 维护、灵活 flexible 、可靠、容错、高效的政策 Policy 与 策略 Mechanism：Policy：做什么。Mechanism：怎么做。例如，定时器结构是一种 CPU 保护的机制，但对特定用户将定时器设置成多长时间是个策略问题因为没有两个设备的配置是完全相同的，每个不同配置的设备都想要最适合自己的操作系统。机制和策略的分开描述，提供了一个灵活的制度，保证了系统能够很容易地被修改，即政策可以随意改变但机制不能改变。OS 实现：早期的 OS 以汇编语言 assembly language 实现随后是系统设计语言比如 Algol, PL/1现在是 C, C++但实际上，如今是混合语言底层是汇编主体是 C系统程序是 C、C++，或者脚本语言例如 PERL、Python、Shell更高级的语言尽管容易实现硬件移植，但是也更慢仿真/模拟 emulation 可让 OS 运行在非原生硬件操作系统结构简单结构如 MS-DOS，编写的目的是在最少的空间内提供最多的功能。未分成模块。虽然 MS-DOS 有一定的结构，但是它的接口和功能级别并没有很好地分离只有设备管理、文件管理，无 CPU 管理不简单结构如 UNIX，由于受到硬件功能的限制，原来的 UNIX 操作系统的结构很有限。UNIX 操作系统由两个可分离的部分组成：系统程序、内核内核：由系统调用接口之下和物理硬件之上的所有内容组成；提供文件系统、CPU调度、内存管理等操作系统功能；这种单一式结构使 UNIX 难以增强分层结构 Layered Approach操作系统分成许多层，每一层都建在较低的层上，底层 ( 第 0 层 ) 为硬件，最高 ( N 层 ) 是用户界面与模块化对比，分层结构每个层只使用较低层的功能 (操作) 和服务微内核缩小操作系统的内核，尽量把非基本功能放到核外。微内核主要功能：使客户程序和运行在用户空间的各种服务之间进行通信。好处 Benefits：容易扩展微内核、容易将操作系统移植到新的体系结构、可靠 (内核模式下运行的代码更少) 、安全缺点 Detriments：用户空间 -&gt; 内核空间 通信的性能开销微内核例子： Mach。 Mac OS X Kernel 部分基于 Mach模块许多现代操作系统实现了 可加载内核模块 loadable kernel modules使用了面向对象 object-oriented 的实现 approach每个核心组件 core component 是分离的 separate每个部分通过已知接口与其他进行通信每个部分需要在内核中加载与分层结构很像但是更灵活杂交系统 hybrid大多数现代操作系统并非一个单纯模型结合了多种方法去解决 address 性能、安全、需求Linux 和 Solaris 内核位于内核地址空间中，所以是单片的 monolithic，结合用于动态加载功能的模块Windows 几乎是单片的，结合微内核以为实现不同子系统特性Mac OS 由 Mach 微内核和 BSD Unix 部件组成的内核，以及 I/O 工具包 kit 和可动态加载的模块（称为内核拓展）。Cocoa 是编程环境iOS，在 Mac OS X 的基础上架构，添加了一些功能 functionality不能原生运行 Mac OS X 应用，但可运行在不同的 CPU 架构上。从上到下分 4 层：Cocoa Touch：提供开发 apps 的 Objective-C APIMedia services：负责图形、音频、图像Core services：负责云计算、数据库Core OS：核心操作系统，基于 Mac OS XAndroid，由 Open Handset Alliance (mostly Google) 开发。与 iOS 类似的结构栈。基于 Linux 内核修改，提供进程、内存、设备驱动管理，增加电源管理运行时环境包括核心库和 Dalvik 虚拟机Apps 以 Java + Android API 开发。Java class 文件被编译成 Java 字节码后能在 Dalvik VM 上执行库包括了 webkit 框架、数据库 SQLite 框架，多媒体 multimedia、小型的 C 库操作系统调试 DebuggingOS 生成包含错误信息的日志文件 log files应用程序的错误运行会产生核心转储 core dump 文件操作系统故障会生成包含内核内存的崩溃转储 crash dump 文件除了崩溃之外，性能调优还可以优化系统性能：有时使用活动的跟踪列表 trace listings ，记录下来进行分析分析 profiling 是对指令指针进行周期性抽样 periodic sampling，以寻找统计趋势DTrace 工具：FreeBSD、Mac OS、Solaris 中可以显示生产系统的实时指令当在提供程序中执行代码时，探测触发，捕获状态数据并将其发送给这些探测的使用者操作系统生成 Generation操作系统被设计成可在任何一类机器上运行必须为每个特定的计算机站点配置系统SYSGEN 程序获取有关硬件系统具体配置的信息用于构建编译特定系统的内核 或 系统调优通用的代码比一个通用的内核更有效系统引导 Boot当加电时，计算机从一个预先定义内存位置启动固件 ROM ( 或 EEPROM ) 用于保存初始引导代码，引导程序，例如 BIOS，可自检，启动 CPU、设备控制器、内存。具体的操作系统是保存在磁盘上的。此时，引导程序从磁盘的固定位置 ( 0 区块，MBR )，读取整块的信息到内存 (硬盘分区表、活动分区)，然后从硬盘中载入 OS 到内存。Booting —— 通过载入内核启动计算机Bootstrap program —— 存在 ROM 中的启动代码能定位内核、将其载入内存、执行之为什么要分成若干个过程？？？？？ 模块化 决策化为步骤第 3 章 进程本章目标：介绍过程的概念 —— 一个正在执行的程序，它是所有计算的基础描述进程的各种特性，包括调度、创建和终止以及通信探讨使用共享内存和消息传递的进程间通信描述客户机-服务器系统中的通信进程概念操作系统执行大量程序：jobs：批处理系统user programs / tasks：分时 Time-shared 系统ps: 课本中将 job、process 、task 混合使用进程：正在执行中的程序 / 一个程序的执行过程 （必须顺序执行）有多个部分程序代码， text section当前活动：包括 程序指针 program counter，进程寄存器栈，存储临时数据：函数参数，返回地址，局部变量数据段 data section：全局变量堆：存储动态申请的内存程序是存储在磁盘上的被动 passive 实体 (可执行文件)，进程是活动 active 的当可执行文件装入内存时，程序变成进程通过GUI鼠标点击、命令行输入其名称等方式启动程序的执行一个程序可以是多个进程考虑多个用户执行同一个程序进程状态：new：进程被创建running：指令被执行waiting：进程等待事件触发 occurready：进程等待处理器分配 assignedterminated：进程完成执行。进程等待 OS 资源回收进程控制块 Process/Task Control Block，PCB：进程状态 —— 运行、等待 …程序计数器 —— 下一步执行指令的位置CPU 寄存器 —— 所有以进程为中心的寄存器的内容CPU 调度信息 —— 优先级 priorities，调度队列指针内存管理信息 —— 分配给进程的内存会计 Accounting 信息 —— CPU 使用，时钟时间经过自启动，时间限制I/O 状态信息 —— I/O 设备分配给进程，打开文件列表CPU 切换进程：线程 Thread：程序：为完成某种功能的有序指令序列在此之前，进程都是单线程的考虑在每个进程中使用多个程序计数器，多个位置可同时被执行存储线程细节，多个程序计数器于 PCB比起操作系统创建更多的进程，一个进程创建多个线程更有利于解决并发处理问题更多的在第 4 章进程调度最大化 CPU 使用 —— 在 CPU 上快速切换进程进行分时进程调度程序从可用进程中选择要在CPU上执行的下一个进程维护进程的调度队列 (进程在各种队列之间迁移)：作业队列 —— 系统中所有进程的集合就绪队列 —— 驻留在主内存中的所有进程的集合，准备好并等待执行设备队列 —— 等待 I/O 设备的一组进程进程调度图示：调度程序 schedulers：调度即选择，选择下一个进程到 CPU 执行短期调度 short-term scheduler （CPU scheduler）选择接下来应执行的进程并分配 CPU 资源有时是系统中唯一的调度程序被执行得十分频繁长期调度 long-term scheduler （Job scheduler）选择应该将哪些进程放入就绪队列调用不频繁控制多道程序的程度 degree of multiprogramming中期调度 medium-term scheduler添加用于降低多道程序设计的程度执行 Swapping —— 从内存中删除进程，将其存储在磁盘上；从磁盘中带回进程以继续执行决定哪些程序临时存储在硬盘进程可被描述成I/O-bound 进程 —— 使用 IO 远多于 CPUCPU-bound 进程 —— 使用 CPU 远多于 IO将进程分类，有利于将进程搭配进行，提高系统效率移动操作系统中的多任务：上下文切换 context switch：当 CPU 切换到另一个进程时，系统保存旧进程的状态，并通过上下文切换转到新进程加载的状态PCB 中表示的过程的上下文上下文切换时间是系统开销切换时系统没有做任何有用的工作OS、PCB 越复杂，上下文切换的开销越大时间取决于硬件支持：一些硬件在每个 CPU 提供多组寄存器，以便多个上下文一次加载进程操作操作：进程创建进程撤销…进程创建：父进程创建子进程，形成了一个进程树第一个进程：操作系统启动时，创建 0 号进程，填入进程控制块通常，通过进程标识符 (pid) 标识和管理进程资源共享选项父子共享所有资源子共享父的部分资源父子进程不共享资源执行期权 execution options父子进程并行执行父等子进程终止地址空间父进程的子副本子进程加载了一个程序UNIX 为例fork() 系统调用，创建新进程，将父进程的内存地址空间复制一份给子进程copy 写时复制，并不真的复制exec() 系统调用，在 fork() 执行后用于替换进程的内存空间为另一新程序进程终止：Process 执行最后一条语句，然后使用 exit() 系统调用请求操作系统删除它。将状态数据从子节点返回给父节点 （通过 wait()）进程资源由操作系统分配父进程可以使用 abort() 系统调用 终止子进程的执行。这样做的原因:子进程已超出分配的资源不再需给子进程分配任务父进程正在退出，如果父进程终止，操作系统不允许子进程继续有些 OS 不允许子进程在父进程终止后存在。若一个进程终止，那其子进程也必须终止。级联终止 cascading termination。所有子女、孙辈等均被终止。终止由操作系统发起。如果没父进程等待 (没有调用wait())，那么子进程就是僵尸进程 zombie如果父进程在未调用 wait 的情况下终止，则子进程为孤儿进程 orphan进程间通信系统中的进程可是独立的，也可是协作的协作进程可以影响或被其他进程影响，包括共享数据进程协作的理由信息共享计算加速 computation speedup模块化 modularity遍历两种 IPC (interprocess communication) 模型消息传递进程通信和同步其操作的机制消息系统——进程之间的通信不依赖于共享变量IPC 工具提供两种操作：发送(消息)接收(消息)消息大小是固定的或可变的消息传递需要建立链接如何建立联系?一个链接可以与两个以上的进程关联吗?每对通信进程之间可以有多少个链接?一个链路的容量是多少?链接所能容纳的消息大小是固定的还是可变的?链接是单向的还是双向的?通讯链路的实现：物理上共享内存硬件总线网络逻辑上直接或间接同步 synchronous 或异步 asynchronous自动或显式缓冲同步 —— 需要等待，是有条件的等待共享内存希望通信的进程之间共享的内存区域通信是由用户进程控制的，而不是由操作系统控制的。提供一种机制，允许用户进程在访问共享内存时同步其操作。第 5 章详细讨论了同步。生产者消费者问题 producer-comsumer：协作流程的范例 —— 生产者进程 生成 消费者进程 使用的信息无边界缓冲区 unbounded-buffer 对缓冲区的大小没有实际的限制有界缓冲区 bounded-buffer 假设有一个固定的缓冲区大小直接通信：进程间必须显式地标识对方 send(P, message) / receive(P, message)通信链接的特性链接是自动建立一个链接关联一对进程的通信，每对进程仅一个连接链接是双向，但通常是单向的间接通信：从邮箱 (也称为端口) 定向和接收消息每个邮箱都有一个唯一的 id进程只有在共享邮箱时才能通信通信链接的特性仅当进程共享公共邮箱时才建立链接一个链接可能关联很多进程。每对进程可能共享许多通信链接链接可是单 / 双向操作创建一个新的邮箱 (端口)通过邮箱收 / 发消息 （原语 primitives：send(A, message) / receive(A, message) ，A 是邮箱）摧毁邮箱多用户共享邮箱的解决仅允许至多两个进程使用链接同一时间仅允许一个进程接收信息系统随意选择接收者，同时发送者会收到回馈谁是接收者同步 synchroniztion：消息传递可以是阻塞的，也可以是非阻塞的阻塞 blocking 又称为同步的 synchronous：分为阻塞式发送、阻塞式接收非阻塞 non-blocking 又称异步的 asynchronous ：分为异步发送、异步接收发送和接收都是阻塞的，称之为会合的 rendezvous缓存 Buffering：零缓冲 —— 发送方必须等待接收方有限容量 Bounded capacity无限容量*IPC系统的例子POSIX：POSIX —— 类 UNIX 厂家遵循的标准进程首先创建共享内存段 lshm_fd = shm_open(name,O CREAT | O RDWR,0666); 或者打开现有的共享内存段设置对象的大小 ftruncate(shm_fd, 4096);现在可向共享内存段中写东西 sprintf(shared memory, &quot;something&quot;);Mach 的通信是基于消息的：每个系统调用都是消息每个任务创建时有两个邮箱：Kernel、Notify消息传输只需要三个系统调用 msg_send()、msg_receive、msg_rpc()用于通信的邮箱，通过 port_allocate 进行发送和接收是灵活的，如若邮箱满了可选择无限等待至多等 n 毫秒立即返回临时缓存消息Windows 的消息传递中心经由 高级本地过程调用 (adavanced local procedure call，LPC) 设备：只有在同一系统的进程间才工作使用端口 (如 mailboxes) 来建立、维护通信信道通信工作如下客户端打开子系统端口对象的句柄客户端发送连接请求服务端创建两个私有连接端口，返回其一的句柄给客户端客户端和服务器通过相应的端口发送消息 / 回调，以及接受回应C-S 系统中的通信Sockets：套接字被定义为用于通信的端点连接基于 IP+Port，以及一对 Socket1024 以下的端口都用于标准服务特殊IP地址127.0.0.1 (环回地址)，指正在运行进程的系统Remote Procedure Calls，RPC：抽象网络系统上进程之间的过程调用 -&gt; 使用端口进行服务区分存根 stubs —— 实际上是客户端用代理的方式在服务端上调用客户端通过代理封包 marshalls 参数，服务端接收信息，解包，执行调用Windows 上的 RPC 被以 Microsoft Interface Definition Language (MIDL) 形式编写编译通过内部数据表示 External Data Representation (XDL) 来解释不同体系的数据表示 （比如大端、小端）远程通信比本地通信有更多的故障场景 （消息是精确地传递一次，实际上不是最多一次）操作系统通常提供了一种 媒介 rendezvous (or matchmaker) 服务来连接客户端和服务端Pipes：充当两个进程通信的管道存在的问题通信是双工 / 单工？若双工，是半双工还是全双工？进程间是否必须存在关系 (如父子进程)pipes 可用于网络通信吗？普通管道 —— 不能从创建它的进程外部访问。通常，父进程创建一个管道并使用它与它创建的子进程通信。适合用在典型的生产者-消费者模型：生产者写到一端 (管道的写端)使用者从另一端读 (管道的读端)。因此，普通管道是单向的需要通信过程之间的父-子关系Windows 称之为匿名管道命名管道 named pipes —— 可以在没有父-子关系的情况下访问。比普通管道更强大沟通是双向的在通信过程之间不需要父子关系几个进程可以使用命名管道进行通信在UNIX和Windows系统上都提供Remote Method Invocation （Java）：Java 运行在 JVM 之上实现了 Serializable 接口的对象可以通过网络传递第 4 章 线程目标：介绍线程的概念 —— 构成多线程计算机系统基础的 CPU 利用率的基本单位讨论 Pthreads、Windows 和 Java 线程库的 api探索几种提供隐式线程的策略检查与多线程编程相关的问题介绍 Windows 和 Linux 中对线程的操作系统支持概述动机 motivation大多数现代应用程序都是多线程的线程在应用程序中运行应用程序的多个任务可以由单独的线程实现更新显示获取数据拼写检查响应网络请求进程创建是重量级的，而线程创建是轻量级的可以简化代码，提高效率吗内核通常是多线程的好处 benefits响应性 responsiveness —— 如果进程的一部分被阻塞，可能允许继续执行，对于用户界面尤其重要资源共享 —— 线程共享进程资源，比共享内存或消息传递更容易经济 economy —— 比进程创建更便宜，线程切换比上下文切换开销更低可伸缩性 scalability —— 流程可以利用多处理器体系结构多核编程多核或多处理器系统给程序员带来压力，挑战包括可并行活动的划分平衡分配数据分割数据依赖测试和调试并行 parallelism 意味着一个系统可以同时执行多个任务并发 concurrency 支持多个正在进行的任务单处理器 / 核心，则是提供并发的调度程序并行性的类型数据并行性 —— 将相同数据的子集分布在多个核上，每个核上执行相同的操作任务并行性 —— 跨内核分配线程，每个线程执行唯一的操作随着线程数量的增长，对线程的体系结构支持也在增长CPUs 有核心，也有硬件线程考虑 Oracle SPARC T4，它有 8 个内核，每个内核有 8 个硬件线程多线程模型用户线程 —— 由用户级线程库完成的管理 （线程库）POSIX PthreadsWindows threadsJava threads若 JVM 运行在 Windows 上，创建线程时 JVM 会调用 Win32 执行线程的创建内核线程 —— 由内核支持多对一 Many-to-One 模型许多用户级线程映射到单个内核线程一个线程阻塞导致所有线程阻塞多个线程不能在 muticore 系统上并行运行，因为一次只能有一个线程在内核中目前很少有系统使用这个模型例子：Solaris 绿色线程、GNU 轻便线程一对一 One-to-One 模型每个用户级线程都映射到内核线程创建用户级线程将创建内核线程并发性比多对一要多每个进程的线程数有时会因为开销而受到限制例子：Windows、Linux、Solaris 9 and later多对多 Many-to-Many 模型允许将多个用户级线程映射到多个内核线程允许操作系统创建足够数量的内核线程Solaris 9 之前的版本带有 ThreadFiber 包的窗口两级 Two-level 模型类似于 Many-to-Many，只是它允许将用户线程绑定到内核线程例子：IRIX、hp - ux、Tru64 UNIX、Solaris 8及更早版本线程库线程库为程序员提供了用于创建和管理线程的 API两种主要的实现方法库完全在用户空间中操作系统支持的内核级库 (即是操作系统)Pthreads一个用于线程创建和同步的POSIX标准 (IEEE 1003.1c) API，可提供用户级或内核级线程。是一种规范 specification，并非实现API 指定线程库的行为，实现取决于线程库的开发常见的 UNIX 操作系统 (Solaris、Linux、Mac OS X)Windows ThreadsJava Threads：Java 线程都被 JVM 管理。通常使用底层 OS 提供的线程模型实现通过继承 Thread 类或实现 Runnable 接口，来创建 Java Threads隐式 implicit 线程随着线程数量的增加，程序正确性越来越难用显式线程实现，由编译器和运行时库 (而不是程序员) 创建和管理线程变得有必要。三种方法探索：线程池池化技术的一种使用现有线程比临时创建新线程响应快允许将应用程序中的线程数绑定到池的大小将要执行的任务与创建任务的机制分开，可以使用不同的策略来运行任务。任务可以定期运行Windows API 支持线程池OpenMP在共享内存环境中提供对并行编程的支持标识并行区域 —— 可以并行运行的代码块OpenMP 采用 fork-join的执行模式。开始的时候只存在一个主线程，当需要进行并行计算的时候，派生出若干个分支线程来执行并行任务。当并行代码执行完成之后，分支线程会合，并把控制流程交给单独的主线程。中央调度 Grand Central Dispatch苹果 Mac OS X、iOS 使用，接管线程管理的大部分细节允许识别代码平行部分，平行块代码形如 ^{ 代码 }块代码放置在调度队列 dispatch queue，队列弹出的同时从线程池中申请一个线程执行该代码两种调度队列串行的 serial，按 FIFO 策略。程序员可以在程序中创建额外的串行队列并发的 concurrent，按 FIFO 顺序进行，但一次可能弹出多个任务。可能有多个分优先级的调度队列12dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);dispatch_async(queue, ^{ printf(\"I am a block.\"); });其他方法包括 Microsoft Threading Building Blocks (TBB)、java.util.concurrent 包线程问题fork() 和 exec() 系统调用的语义：fork() 只复制调用线程还是复制所有线程 ?有些 unix 有两个版本的 forkexec() 通常正常工作 —— 替换正在运行的进程，包括所有线程信号 signal 处理同步和异步在 UNIX 系统中，信号用于通知进程发生了特定的事件同步信号：来自同一个进程异步信号：来自另一个进程信号处理器用于处理信号信号是由特定的事件产生的信号被传递给进程信号由两个信号处理程序之一处理：默认、用户定义每个信号都有内核在处理信号时运行的默认处理程序用户定义的信号处理程序可以覆盖默认值对于单线程，向进程发送信号多线程的信号发送到哪？将信号传递到 应用该信号的线程将信号传递给 进程中的每个线程将信号传递给 进程中的某些线程指定一个特定的线程来接收进程的所有信号这取决于信号生成的类型：同步信号需传递给产生信号的线程，而不是传递给进程中的其他线程。异步信号就不好决定，一些例如 ctrl-C 的异步信号就要被传递给所有线程目标线程 target thread 的撤销在目标线程完成任务时终止线程两种普遍的撤销实现异步：立即撤销目标线程递延 deferred （默认是该实现）：给目标进程发信号，目标进程处理完一些任务后主动撤销。即目标线程到达撤销点 cancellation point 才撤销还有一种是撤销禁用状态，进程收撤销信号时，不理会，当撤销禁用状态被更改时才响应线程本地存储 Thread-Local Storage：TLS 允许线程用于自己的数据副本这与本地变量不同，本地变量仅在单个函数调用期间可见，TLS 是跨函数可见的与 static 数据类似，但 TLS 是因线程而异的调度程序激活：Many-to-Many 和两级模型都需要通信 来维护分配给应用程序的内核线程数量通常在用户和内核线程之间使用一个中间数据结构 —— 轻量级进程 (LWP, lightweight process)它更像一个虚拟处理器，进程可以在其上调度要运行的用户线程每个 LWP 都附加到内核线程调度程序激活提供 upcall —— 一种从内核到线程库中处理程序的通信机制，这种通信允许应用程序维护正确的内核线程数内核提供一个带虚拟进程 (LWP) 的应用，该应用能在虚拟进程上调度用户进程upcall，即发生某些事件时，内核必须通知应用程序，的调用过程当应用程序线程即将阻塞时，向上调用 upcall内核为应用程序分配一个新的虚拟处理器。应用程序保存阻塞线程 blocking thread 的状态并释放它的虚拟处理器然后 upcall 处理程序调度另一个有资格在新的虚拟处理器上运行的线程当阻塞线程等待的事件发生时，向上调用 upcall此事件的 upcall 处理程序还需要一个虚拟处理器来运行线程操作系统样例Windows：实现了 一对一映射，内核级线程每个线程都有线程 id线程的上下文表示处理器状态的寄存器集当线程以用户模式或内核模式运行时，将用户堆栈和内核堆栈分开运行时库和动态链接库 (dll) 使用的私有数据存储区域线程的主要数据结构包括ETHREAD (executive thread block) —— 包含指向线程所属进程和 KTHREAD 的指针，存在内核空间中KTHREAD (kernel thread block) —— 调度和同步信息，内核模式堆栈，指向 TEB 的指针，存在内核空间中TEB (thread environment block) —— 线程id，用户模式堆栈，线程本地存储，存在用户空间中Linux：Linux 将它们称为任务 tasks 而不是线程 threads通过 clone() 系统调用来完成线程创建，其允许子进程共享父进程的地址空间，flag 参数如下第 5 章 进程同步操作系统提供什么样的手段 -&gt; 便于程序员解决同步程序员怎么样去利用操作系统提供的手段 -&gt; 解决同步目标：介绍过程同步的概念。引入临界段问题，该问题的解可用于保证共享数据的一致性提出临界段问题的软硬件解决方案研究几个经典的进程同步问题探讨用于解决进程同步问题的几种工具背景进程可并发执行。可随时中断，部分完成并发访问共享数据可能导致数据不一致性维护数据一致性需要一些机制去确保执行的顺序临界性问题：每个进程有临界代码段：如改变共有变量、更新表、写文件等需要保证同一时刻没有两个进程都在临界区临界性问题即设计一种协议来解决该问题每个进程在进入临界区的入口段 entry section 前申请权限，在退出区 exit section 前，归还权限临界性的问题Solution 的三个要求：互相排斥 Mutual Exclusion —— 同一时刻没有两个进程都在临界区。（互斥也是一种同步）progress —— 没有进程在临界区，任一可立马进入有限等待 bounded waiting —— 进程提出申请后，进程的等待是有限的操作系统的临界区解决：Peterson’s 解决方案一个软件方法。符合三个要求12345678do { flag[i] = true; turn = j; while(flag[j] &amp;&amp; turn==j); critival section flag[i] = false; remainder section} while(true);忙式等待：自身时钟检测非忙式等待：放弃检测，直接睡眠等待唤醒同步硬件许多系统为实现临界段代码提供硬件支持基于 “锁” 的思想单处理器 uniprocessors —— 可以禁用中断当前正在运行的代码将在没有抢占的情况下执行在多处理器系统上效率太低，使用关中断的 OS 无法广泛推广现代机器提供特殊的原子 atomic 硬件指令atomic = non-interruptible提供的指令：test memory、set value、swap原语是不可打断，事务是可打断，但需要复原原语在时间上是原子性的，事务在逻辑上是原子性，事务执行失败需要回退test_and_set 指令：123456bool test_and_set(bool *target){ bool rv = *target; *target = true; return rv;}利用 test_and_set 解决临界区问题：123456do { while(test_and_set(&amp;lock)); critical section lock = false; remainder section} while(true);compare_and_swap 指令：1234567int compare_and_swap(int *value, int expected, int new_value){ int tmp = *value; if(*value == expected) *value = new_valie; return tmp;}利用 compare_and_swap 解决临界区问题：12345678lock &lt;- 0;do { while(compare_and_swap(&amp;lock, 0, 1) != 0); critical section lock = 0; remainder section} while(true);利用 test_and_set 实现有限等待、互斥：12345678910111213141516do { waiting[i] = true; key = true; while(waiting[i] &amp;&amp; key) key = test_and_set(&amp;lock); waiting[i] = false; // critical section j = (i+1)%n; while((j!=i) &amp;&amp; !waiting[j]) // 往后找第一个等待着的进程 j = (j+1)%n; if(j==i) lock = false; else waiting[j] = false; // remainder section} while(true);互斥锁 Mutex Locks先前的解决方案很复杂，通常程序员无法访问操作系统的设计者设计了一种软件工具来解决临界区问题，最简单的即是 互斥锁acquire()、release() 的调用需要保证是原子性的这种解决方案是忙式等待，因此该锁被称为自旋锁 spinlockx1234567891011121314acquire() { while (!available) ; /* busy wait */ available = false;; } release() { available = true; } do { acquire(lock) critical section release(lock) remainder section } while (true);信号量 Semaphores同步工具，为进程同步提供了比互斥锁更复杂的方法Semaphore $S$ —— 一个整型数wait()、signal()，最初称为 P()、V()12345678wait(S) { while (S &lt;= 0); // busy wait S--;}signal(S) { S++;}计数信号量 counting semaphore：整型取值二进制信号量 binary semaphore：取值 0/1，与互斥锁相同信号量 semaphores 使用：1234567// 要求了执行顺序 P1-&gt;P2P1: S1; signal(synch);P2: wait(synch); S2;没有两个进程可同时执行 wait() 和 signal() ，关中断、放入临界区（硬件指令）可以实现非忙式等待的实现：每个信号量都有一个相关的等待队列等待队列中的每个条目都有两个数据项值、指向下一个记录的指针两个操作阻塞 block —— 把进程状态改变并将其放入等待队列唤醒 wakeup —— 等待队列出队，入队就绪队列1234567891011121314151617181920typedef struct { int value; struct process *list;} semaphore;wait(semaphore *S) { S-&gt;value--; if (S-&gt;value &lt; 0) { add this process to S-&gt;list; block(); // scheduler -&gt; dispatch 进行 CPU 切换，阻塞、等待唤醒 } }signal(semaphore *S) { S-&gt;value++; if (S-&gt;value &lt;= 0) { remove a process P from S-&gt;list; wakeup(P); } }死锁 deadlock 和饥饿 starvation：死锁：两个或多个进程无限期地等待一个事件，该事件只能由其中一个进程引起饥饿：无限阻塞。进程可能永远不会从挂起它的信号量队列中删除优先级反转 Priority Inversion：低优先级进程持有高优先级进程所需的锁时的调度问题通过优先级继承协议解决经典的同步问题Bounded-Buffer Problem：1 生产者，1 消费者，1 缓冲区123456789101112131415161718192021222324/*Semaphore full = 0;Semaphore empty = 1;Item buffer[1];*/producer:do { ...... // produce an item wait(empty); buffer[0] = item; signal(full); ......} while (true)；comsumer:do { ...... wait(full); item = buffer[0]; signal(empty); // comsume an item ......} while (true)；1 生产者，1 消费者，k 缓冲区123456789101112131415161718192021222324252627/*Semaphore full = 0;Semaphore empty = k;Item buffer[k];in = out = 0;*/producer:do { ...... // produce an item wait(empty); buffer[in] = item; in = (in+1)%k; signal(full); ......} while (true)；comsumer:do { ...... wait(full); item = buffer[out]; signal(empty); out = (out+1)%k; consume the item; ......} while (true)；m 生产者，n 消费者，k 缓冲区1234567891011121314151617181920212223242526272829303132/*Semaphore full = 0, empty = 1; Semaphore mutex1 = 1, mutex2 = 1;Item buffer[k];int in=0; out=0;*/m producers:do { ...... // produce an item wait(empty); wait(mutex1); buffer[in] = item; in = (in+1)%k; signal(mutex1); signal(full); ......} while (true)；n consumers:do { ...... wait(full); wait(mutex2); item = buffer[out]; out = (out+1)%k; signal(mutex2); signal(empty); // consume the item; ......} while (true)；Readers and Writers Problem：临界区的力度要小，否则并发就小了12345678The writer process:do { ... wait(rw_mutex); // writing signal(rw_mutex); ... } while (true);Dining-Philosophers Problem：围棋捡子问题123while(1) { wait(a)}管程 Monitors一种高级抽象，为进程同步提供方便有效的机制。高级的同步机制，自动实现了互斥抽象数据类型 Abstract data type，内部变量只能由过程中的代码访问一次只能在管程中激活一个进程，但还不足以对某些同步方案建模123456789monitor monitor-name{ // shared variable declarations procedure P1 (…) { …. } procedure Pn (…) {……} Initialization code (…) { … }}管程和信号量的区别第 6 章 CPU 调度目标：介绍 CPU 调度，这是多程序操作系统的基础描述各种 cpu 调度算法讨论为特定系统选择 cpu 调度算法的评价准则研究几种操作系统的调度算法基本概念通过多道程序设计获得的最大 CPU 利用率CPU 调度程序：1 和 4 的调度是非抢占的，2、3 调度是抢占的分派程序 Dispatcher：调度程序模块对短期调度程序选择的进程进行 CPU 控制，包括上下文切换切换成用户模式跳转到用户程序中的适当位置来重新启动该程序分派延时 dispatch latency —— 调度程序停止一个进程并启动另一个进程所需的时间，一种 overhead调度原则 criteriaCPU 利用率 utilization —— 让 CPU 尽可能的忙吞吐量 throughput —— 每个时间单元完成其执行的进程的数量周转时间 turnaround time —— 执行特定流程的时间量，某个作业进入系统的时间和退出时间的差（等待时间+执行时间）等待时间 waiting time —— 进程在就绪队列中等待的时间响应时间 response time —— 从提交请求到生成第一个响应所花费的时间，不是输出 (对于分时环境)调度算法First- Come, First-Served (FCFS) Scheduling：先来先服务护航效果 convoy effect —— 长进程后的短进程考虑一个 cpu 消耗型 和多个 I/O 消耗型进程Shortest-Job-First (SJF) Scheduling：平均等待时间最优难点在于知道下一个 CPU 请求的耗时$t_n $ 为第 n 个 CPU burst 时间$\\tau {n+1} $ 为第 n+1 个 CPU burst 的预测时间$ 0\\le \\alpha \\le 1 $$\\tau{n+1} = \\alpha t_n + (1-\\alpha) \\tau_{n}$抢占式版本短作业优先称为 “最短剩余时间优先 shortest-remaining-time-first”Priority Scheduling：优先级编号 (整数) 与每个进程相关联，CPU 被分配给具有最高优先级的进程分为抢占性、非抢占性可能会饿死，解决方案是 aging —— 随时间增加优先级增大高响应比优先调度算法：$\\large 响应比 = \\frac{周转时间}{执行时间} = 1+ \\frac{等待时间}{执行时间}$同等情况下短作业优先等待事件越长（先来先服务）优先级越高，不会出现饿死Round Robin (RR) 轮转：每个进程获得一小单位 CPU 时间 (时间片 quantum q )，通常为 10-100 毫秒。在此时间过后，进程被抢占并添加到就绪队列的末尾。如果就绪队列中有 n 个进程，时间片为 q，那么每个进程一次最多可获得 q/n CPU时间。利用每个时间片的定时器中断来调度下一个进程q 过大时 -&gt; FIFOq 过小时 -&gt; 上下文切换频繁Multilevel Queue：就绪队列被划分为单独的队列前台队列 foreground (interactive 互动) —— 用 RR 算法后台队列 background (batch 批处理) —— 用 FCFS 算法调度必须在队列之间完成最早的分时系统：CTSS (1961)Multilevel Feedback Queue 多级反馈队列：进程可以在不同队列之间移动：老化可以通过这种方式实现由以下参数定义的多级反馈队列调度程序队列的数量每个队列的调度算法用于确定何时升级 upgrade 一个调度方法用于确定何时降级 demote 一个调度方法用于确定进程在该进程需要服务时将进入哪个队列线程调度多处理器调度实时 CPU 调度 Real-Time操作系统示例算法的评估 Evaluation第 7 章 死锁系统模型资源类型：CPU 周期、内存空间、IO 设备每个资源有类型 type 和 实例 instances每个进程使用进程的方式requestuserelease死锁的特征死锁所拥有的特征（其四大必要条件）：互斥 Mutal exclusion ：同一时间一个资源只有一个进程在使用持有和等待 Hold and wait：一个进程持有一个资源并等待其他进程持有的资源不可抢占 No preemption：一个资源只能由持有它的进程在该进程完成其任务后自动释放。环路等待 Circular wait：持有和等待关系成环（以哲学家就餐问题作例子）。同时也是个充分条件。循环等待未必死锁，死锁必有循环等待资源分配图 Resource-Allocation Graph (RAG)：进程（圆圈）、资源类型（大方块）、资源实例（大方块内的小方块 无死锁 有死锁处理死锁的方法确保系统永远不会进入死锁状态：死锁预防（采取防污染措施，禁止出现污染）：对资源的使用加上诸多限制条件，以防止系统出现死锁现象死锁避免（根据环评结果，决定是否通过项目的审批）：基于进程及系统的一些先验知识，当进程申请资源时，若发现满足该资源的请求可能导致死锁发生，则拒绝该申请死锁检测与恢复（先污染，后治理）：鸵鸟策略，放任污染，当环境无法居住时，地球生命灭绝，开始一个新的轮回死锁预防 (静态策略)破坏死锁产生的四个必要条件中的一个或几个解决互斥：共享资源不需要互斥; 必须持有非共享资源。解决持有等待（不剥夺条件）：必须确保每当进程请求资源时，它不包含任何其他资源。占有不等待。资源静态分配策略：流程在开始执行前请求并分配其所有资源。一个进程的系统调用请求资源先于所有其他系统调用。等待不占有（缺点是低利用率和可能饿死）。当进程不拥有资源时才可申请资源；进程使用完一种资源，才可以申请另一种资源解决不可抢占如果申请资源而未满足，则释放自己已经获得的资源；将从其他进程剥夺的资源分配给其他等待该资源的进程问题：进程只有在能够恢复其旧资源以及它所请求的新资源时才会重新启动。适用于状态可保存及恢复的资源，如 CPU 和 内存解决环路等待：强制所有资源类型的总排序，并要求每个流程以递增的枚举顺序请求资源。死锁避免 (动态策略)要求系统具有一些附加的先验 a priori 信息：最简单和最有用的模型要求每个流程声明它可能需要的每种类型的最大资源数量。死锁避免算法动态检查资源分配状态，以确保不存在循环等待条件。资源分配状态由可用资源和已分配资源的数量以及进程的最大需求来定义。死锁检测和解除第 8 章 内存管理目标：提供记忆体硬体的各种组织方式的详细描述讨论各种内存管理技术，包括分页和分段提供英特尔奔腾的详细描述，它支持纯分割和分页分割背景必须将程序 (从磁盘) 放入内存，并将其放置在进程中才能运行主存和寄存器是 CPU 只能直接访问的存储寄存器访问较主存块缓存位于主存和 CPU 寄存器之间内存的保护需要确保操作的正确性一对 base 寄存器和 limit 寄存器定义逻辑地址空间交换连续内存分配分段分页页表结构实例","link":"/CS/Operating-System-Study-Notes/"},{"title":"信息检索技术-学习笔记","text":"目前的 IR 实质上是融合了 文本及多媒体检索、数据挖掘、机器学习、自然语言处理的综合学科。因此本课内容包括：信息检索的基本知识布尔检索倒排索引向量空间模型文档评分检索评价检索模型简单的自然语言处理语言模型信息检索/知识发现/机器学习/数据挖掘中的经典算法分类聚类内容大部分是从陈教授的 PPT 和参考书作者原书上摘来的。加上我的习惯用语修改，脑图总结知识点 + Markdown 写成流式笔记。内容规整统一，便于学/复习，而已。第一章 引论考核：期末考试 60%考勤 5%实验 35%互联网数据类型众多：内容数据新闻文本半结构化数据（HTML、XML）图像、视频、音频结构化数据（表格、暗网）博客、微博等结构数据网页链接结构社交网络关系使用（日志）数据用户档案数据大数据的 4V 特性：体量 Volume多样性 Variety价值密度 Value速度 Velocity搜索技术：从大规模非结构化数据(通常是文本)的集合(通常保存在计算机上)中找出满足用户信息需求的资料(通常 是文档)的过程作为一门学科，是研究信息的获取(acquisition)、表示(representation)、存储(storage)、组织(organization) 和访问(access)的一门学问。搜索的基本概念：用户需求 (User Need，UN)：用户需要获得的 信息严格地说，UN只存在于用户的内心，但是通常 用文本来描述，如查找与2016奥运会相关的新闻， 有时也称为主题(Topic)UN提交给检索系统时称为查询(Query)，如 2016 奥运会，对同一个UN，不同人不同时候可以构 造出不同的Query ， 比如上述需求也可表示成 2016奥运会新闻，Query在IR系统中往往还有内 部表示文档(Document)：检索的对象可以是文本，也可以是图像、视频、语音等多媒体文档，text retrieval / image retrieval / video retrieval / speech retrieval / multimedia retrieval可以是无格式、半格式、有格式的文档集合(Collection)：所有待检索的文档构成的集合也称为Repository，Corpus，Dataset相关(relevant)、相关度(relevance)、相似度(Similarity)相关取决于用户的判断，是一个主观概念不同用户做出的判断很难保证一致即使是同一用户在不同时期、不同环境下做出的判断也不尽相同信息检索系统的基本组成：用户接口(User Interface)：用户和IR系统的人机接口输入查询(Query)返回排序后的结果文档(Ranked Docs)并对其进 行可视化(Visualization)支持用户进行相关反馈(Feedback)用户的两种任务：retrieval 或者 browsingIR 的两种模式： pull (ad hoc) 或者 push (filtering)Pull: 用户是主动的发起请求，在一个相对稳定的数据集合上进行查询Push: 用户事先定义自己的兴趣，系统在不断到来的流动数据上进行操作，将满足用户兴趣的数据推送给用户，典型就是推荐系统。文本处理(Text Operations)：对查询和文本进行的预处理操作中文分词(Chinese Word Segmentation)词干还原(Stemming)停用词消除(Stopword removal)查询处理(Query operations)：对经过文本处理后的查询进行进一步处理 ， 得到查询的内部表示 (Query Representation)查询扩展(Query Expansion)：利用同义词或者近义词对查询进行扩展查询重构(Query Reconstruction)：利用用户的相关 反馈信息对查询进行修改文本索引(Indexing)：对经过文本处理后的文本进行 进 一 步 处 理 ， 得 到 文 本 的 内 部 表 示 (Text Representation)，通常基于索引项(Term)来表示向量化、概率计算组成倒排表进行存储搜索(Searching)：从文本中查找包含查询中索引项的 文本排序(Ranking)：对搜索出的文本按照某种方式来计算其相关度Logical View：指的是查询或者文本的表示，通常采用一些关键词或者索引项(index term)来表示一段查 询或者文本。IR 的新课题：自然语言理解多媒体检索垂直检索技术移动搜索对社会媒体信息检索用户画像自动问答知识发现-知识图谱行为分析、舆情监控自动对话重要工具：Lemur、Indri：包含各种IR模型的实验平台，C++SMART：向量空间模型工具, C编写Weka：数据挖掘工具，Java编写Lucene：开源检索工具，Java版本受维护，存在各种语言编写的其他版本Nutch：开源爬虫，Java版本Sphinx：开源检索工具，C++Larbin：采集工具，C++Firtex：检索平台，C++，计算所开发更多：http://www.searchtools.com/tools/tools-opensource.html第二章 布尔检索信息检索模型概述检索模型：用于度量相关性是描述信息检索中的文档 、查询 和它们之间关系 (匹配函数) 的数学模型。布尔模型：文档表示一个文档被表示为关键词 (bag of words) 的集合查询表示查询式(Queries)被表示为关键 词的布尔组合，用 “与、或 非” 连接起来相关度计算一个文档当且仅当它能够满足布尔查询式时，才将其检索出来检索策略是二值匹配 (true/false)优点由于查询简单，因此容易理解通过使用复杂的布尔表达式，可方便地控制查询结果相当有效的实现方法经过某种训练的用户可以容易地写出布尔查询式布尔模型可以通过扩展来包含排序的功能缺点弱。不支持部分匹配，完全匹配会导致结果太多或太少非常刚性: “与”意味着全部; “或”意味着任何一个原则上讲，所有被匹配的文档都将被返回不考虑索引词的权重，所有文档都以相同的方式和查询相匹配很难进行自动的相关反馈如果一篇文档被用户确认为相关或者不相关，怎样相应地修改查询式呢？简单的搜索示例查询《莎士比亚全集》这本大部头的书中：哪些剧本包含 Brutus 和 Caesar 但不包含 Calpurnia？简单想法与正确想法一种简单的想法：使用 UNIX 下的 grep，这是一种线性的扫描方式这种想法不合适的原因：对于大规模文档的搜索太慢。处理 NOT Calpurnia 并不容易（一旦包含即可停止判断）不太容易支持其他操作。比如，要求查找 countrymen 附近的 Romans。无法对结果进行排序。用户希望能在多个能满足要求的文档中得到最佳答案。正确的做法是：采用非线性的扫描方式，比如事先给文档建立索引(index)词项-文档 (term-doc) 的关联矩阵：然后只要取出 Brutus、Caesar 以及 Calpurnia 3个词项对应的行向量110100，110111，010000，并对Calpurnia 对应的向量求反 101111，得到的 01 向量就是剧本的对应结果。典型的搜索过程信息检索的基本假设：集合：固定数量的文档目标：找到与用户信息需求相关的含有信息量的文档，帮助用户完成一个任务典型的搜索过程：返回文档的好坏 ★：查准率：返回的能满足用户信息需求的文档占总的返回文档的百分比如返回80篇文档，其中20篇相关，正确率1/4召回率：返回的能满足用户信息需求的文档占总的能满足用户信息需求的文档的百分比如返回80篇文档，其中20篇相关，但是总的应该相关的文档是100篇，召回率1/5查准率和召回率缺一不可！全部返回，正确率低，召回率100%只返回一个非常可靠的结果，正确率100%，召回率低简单模型存在的问题：假设有一个更大的数据集，共有N=100万个文档，每个文档包含大概1000个词汇假设一个词汇需要 6 个字节(将空格和标点计算 在内)，则这些文档共有 6G (100万*1000*6)假设其中共有 500k 个唯一的不重复的词汇上述数据集建立的矩阵 1 只有不到 10 亿个，其他都是 0，矩阵中的 1 十分稀疏所以 —— 大的数据集无法构建矩阵！—— 更好的方法是 只记录 1 的位置倒排索引 Inverted index对于每一个词项，存储所有包含这个词项的文档的一个列表。 一个文档用一个序列号 docID 来表示。倒排索引及其构建倒排索引：通常采用变长表方式磁盘上，顺序存储方式比较好，便于快速读取内存中，采用链表或者可变长数组方式存储空间/易插入之间需要平衡倒排索引构建：排序 （核心步骤）第一关键字是词项的字典序，第二关键字是 docID词典 &amp; 倒排记录表合并在单篇文档中的多次某个词项分割成词典和倒排表加入每个词项出现的文档数目 (doc. frequency, DF)一共有多少的存储开销(doc. freq)指向链表的指针docID布尔查询的处理假设索引已经建好，现在利用其来处理查询AND 查询的处理：考虑 Brutus AND Caesar在词典中定位 Brutus返回对应倒排记录表(对应的docID)在词典中定位Caesar再返回对应倒排记录表合并 (Merge) 两个倒排记录表，即求交集（复杂度 O(x+y)，因为倒排记录表按 docID 排序）布尔检索模型定义：文档表示一个文档被表示为关键词的集合 Bag of Words查询表示查询式 (Queries) 被表示为关键词的布尔组合，用 “ 与、或、非” 连接起来相关度计算一个文档当且仅当它能够满足布尔查询式时，才将其检索出来检索策略是二值匹配 {0,1}形式化表示：定义：用 $q_{\\text{dnf} }$ 表示查询 $q$ 的析取范式，$q_{\\text{cc} }$ 表示 $q_{\\text{dnf} }$ 的任意合取分量文献 $d_i$ 与查询 $q$ 的相似度为$\\large \\begin{align}\\operatorname{sim}\\left(d_{j}, q\\right)=\\left{\\begin{array}{l}1 \\text { if } \\exists \\mathbf{q}{\\mathrm{cc} } |\\left(\\mathbf{q}{\\mathrm{cc} } \\in \\mathbf{q}{\\mathrm{dnf} }\\right) \\wedge\\left(\\forall k{i}, g_{i}\\left(d_{j}\\right)=g_{i}\\left(\\mathbf{q}_{\\mathrm{cc} }\\right)\\right) \\ 0 \\text { otherwise }\\end{array}\\right.\\end{align}$如果 sim(dj,q)=1，则表示文献 dj 与 q 相关，否则为不相关。精确匹配的欠缺：无法体现出检测的文档的差异查询优化：处理查询的最佳顺序 —— 按照文档频率的顺序进行处理，先处理文档频率小的，再处理大的更一般的优化：获得所有词项的文档频率保守地估计出每个 OR 操作后的结果大小按照结果从小到大的顺序执行 AND第三章 词项词典和倒排记录表The term vocabulary &amp; postings lists词项词典的建立文档解析(Parsing a document)涉及三个问题：文档包含哪些格式？pdf/word/excel/html et al.文档中包含的语言？文档使用何种编码方式？上述问题都可以看成是机器学习中的分类问题， 但在实际中往往采用启发式方法来实现。文档中的编码方式：7bit ASCII ？UNICODEUTF-8、UTF-16、UTF-32Email对二进制附件的编码Content-Type: text/html;charset=”gb2312”Content-Transfer-Encoding: base64复杂因素：格式/语言待索引文档集中包含不同语言的文档单独的一个索引应该包含不同语言的文档一个文档或者其附件中包含多种语言或格式例子：一封法语的邮件中包含德语的 pdf文档单位的选择一个文件 ？一封 email ？一封带有 5 个附件的 email ？一组文件 ？词条化 (Tokenization)词条化：将给定的字符序列拆分成一系列子序列的过程，其中每一个子序列称之为一个 “词条” Token。例子：输入 Friends, Romans and Countrymen输出 Friends、Romans、Countrymen每个词条Token都作为候选的索引词条化可能遇到的问题 (英文)：连字符 Co-education空格 人名 San Francisco连字符和空格相互影响 lower-case、lower case英文句号 IEEE 802.3数字 Mar.2011词条化可能遇到的问题 (中文)：Out of Vocabulary 超出词表如人名、地名、机构名、新词Ambiguity 同一句子有多种可能的分词结果南京市长江大桥南京 市长 江大桥南京市 长江大桥兵乓球拍卖完了兵乓 球拍 卖完 了兵乓球 拍卖 完了词条化的策略：针对不同的语言，采取不同策略的词条化方法分词的基本方法：基于词典(规则)的方法按照一定策略将待分析的汉字串与一个 “词典” 中的词条进行匹配，如果匹配成功，那么该汉字串就是一个词。基于统计的方法训练：根据观测到的数据(人工标注好的语料)的统计特征对模型参数进行估计。分词：通过模型计算各种分词出现的概率，将概率最大的分词结果作为最终结果。基于词典(规则)的方法按照扫描方向：正向匹配和逆向匹配按照扫描长度：最大匹配和最小匹配正向最大匹配从左向右取待切分语句的 m 个字符作为匹配字段 (m为词典中最长词条个数)；查找词典并进行匹配；若匹配成功，则将这个匹配字段作为一个词切分出来；若匹配不成功，则将这个匹配字段的最后一个字去掉，剩下的字符串作为新的匹配字段，进行再次匹配，重复以上过程，直到切分出所有词为止。例：南京市长江大桥(m=5)逆向最大匹配双向最大匹配将正向最大匹配法和逆向最大匹配法得到的分词结果进行比较，把所有可能的最大词都分出来。基于统计的方法n-gram：基于假设，第 n 个词的出现只与前面 n-1 个词相关，而与其它任何词都不相关，整句的概率就是各个词出现概率的乘积。一个句子 $S={t_1t_2t_3\\cdots t_N}$句子出现的概率：Y 是分词序列 $\\large Y^*=\\underset{Y}{argmax} P(Y|S) = \\prod\\limits_{i=1}^NP(t_i|t_1\\cdots t_{i-1})$特别地Unigram：$\\begin{align}P_{\\mathrm{uni} }(Y | S)=P\\left(t_{1}\\right) P\\left(t_{2}\\right) P\\left(t_{3}\\right) P\\left(t_{4}\\right) \\cdots P\\left(t_{N}\\right)\\end{align}$Bigram：只考虑前一个词项的出现情况 $\\begin{align}P_{\\mathrm{bi} }(Y | S)=P\\left(t_{1}\\right) P\\left(t_{2} | t_{1}\\right) P\\left(t_{3} | t_{2}\\right) \\ldots P\\left(t_{N} | t_{N-1}\\right)\\end{align}$Trigram：不写了基于 HMM 的中文分词方法给定一个观测序列(句子) $\\begin{align}X=x_{1} x_{2} \\ldots x_{t} \\ldots x_{T}\\end{align} $，其中 $x_t$ 是一个字、词等文字单元假设 X 的状态序列 (如词的开始符、词的结束符等) 为 Y$y_t(i)$ 有 M 个状态$\\begin{align}Y=y_{1}(i) y_{2}(i) \\ldots y_{t}(i) \\ldots y_{T}(i), 1 \\leq i \\leq M\\end{align}$$\\begin{align}Y^{}=\\underset{Y}{\\arg \\max } P(Y | X)=\\underset{Y}{\\arg \\max } \\frac{P(Y, X)}{P(X)} \\propto \\underset{Y}{\\arg \\max } P(X | Y) P(Y)\\end{align*}$独立性假设 $\\Rightarrow P(X | Y)=\\prod_{t=1}^{T}$ $ P\\left(x_{t} | y_{t}\\right)$马尔可夫（一阶）假设$\\large P\\left(y_{t} | y_{t-1} y_{t-2} \\ldots y_{1}\\right)=P\\left(y_{t} | y_{t-1}\\right) \\Rightarrow P(Y)=$ $\\large P \\left(y_{1}\\right) $ $\\large \\prod_{t=2}^{T}$ $ \\large P\\left(y_{t} | y_{t-1}\\right)$符号发射概率 $\\large P(x_t|y_t)$状态转移概率 $\\large P(y_t|y_{t-1})$Y 共有 M 个状态 $\\begin{align}\\sum_{i=1}^{M} P\\left(y_{t}(i) | y_{t-1}\\right)=1\\end{align}$初始状态概率分布 $\\large P \\left(y_1(i)\\right) \\ \\ \\ \\ (i=1\\cdots M)$HMM 包括隐层状态 Y，观测序列 X，状态转移概率 A ， 符号发射概率B，初始状态概率分布 π (马尔科夫三部分)HMM 表示为 $\\mu={A,B,\\pi}$，参数通过训练集来学习获得HMM 可以用有向图模型来表示，因为 states(Y)与 observations(X) 之间存在着明显的依赖关系。中文分词例子：输入观察序列 X：南京市长江大桥状态集合 $Y(i)={\\mathrm{B}, \\mathrm{M}, \\mathrm{E}, \\mathrm{S}} $输出状态序列 Y：BMEBMME又一个 HMM 的例子 (来自 caojiangxia 的博客)：假如我们面对一堆过去的数据，过去的数据当中只有自然生长下的海藻的每天的状态我们也有一些最近的数据，最近的数据中有海藻的状态和每天的天气情况。现在我们给定天气的转移矩阵，天气对海藻状态影响的矩阵。我们希望根据这些数据，去预测过去的天气。海藻的状态只有 4 种： {干、稍干、潮湿、湿润}天气的状态只有 3 种：{晴、阴、雨}天气状态转移矩阵（后面简称为A）：雨阴晴雨0.6250.1250.25阴0.3750.250.375晴0.250.250.5注意：上表表示的是今天的天气分别是雨，阴，晴的情况下，明天的天气是雨，阴，晴的概率分布。天气对海藻干湿的影响(后面简称为B):干稍干潮湿湿润晴0.600.200.150.05阴0.250.250.250.25雨0.050.100.350.50注意：上表表示的是今天的天气分别是雨，阴，晴的情况下，今天的海藻出现干，稍干，潮湿，湿润的概率分布。建立模型我们的任务是根据观察序列去推测状态序列。首先我们根据之前的信息：构建状态集合s，状态转移矩阵A，初始状态概率分布π，观察集合ss，状态对观测的影响矩阵B对于我们这个题目而言，状态集合s为(晴，阴，雨)，观察集合ss为(干，稍干，潮湿，湿润)，请务必注意这个地方！那么我们可以得到五元组模型:(s,ss,π,A,B)，通常我们将模型简写为三元组:λ=(π,A,B)。对于上述三元组，只有π是未知的，这个东西怎么统计出来呢？其实很简单，由于我们包含最近的数据，我们根据最近的天气可以统计出来每种天气出现的概率，那么这个分布就是 π，公式表示为：πi=P(q1=si)当然这仅仅是对于这个任务是这样计算的，别的任务可能会不一样。上述公式表示的就是说第i种情况出现的概率比如说统计后大概长成这个样子：晴雨阴P0.50.050.45求解过程我们现在已知观察序列 $O=o_1,\\cdots ,o_n$，模型 λ=(π,A,B) 。现在我们需要求给定模型与观察序列的情况下求状态序列QQ。有我们需要以下概率最大：P(O|Q,λ)意思也很简单啊，就是我们求这个条件概率，当前模型 λ 来说，希望找到一个状态序列 Q 使得观察序列 O发生的可能性最大。我们假设Q=q1…qn我们把上面的式子打开，有：$P(O | Q, \\lambda)=\\pi_{q_{1} } A_{q_{1} q_{2} } A_{q_{2} q_{3} } \\ldots A_{q_{n-1} q_{n} } B_{q_{1} o_{1} } B_{q_{2} o_{2} } \\ldots B_{q_{n} o_{n} } $对上面的式子我们很简单的可以想到枚举每一种 Q，对每一种都进行计算，之后输出使得 P(O|Q,λ) 最大的那个 Q 就可以了。但是枚举当然是不可能的，这是指数级别的，n 大的话就凉了解释一下上面的公式：$π_{q1}$ 表示最初天气为 q1 成立的概率$A_{ij}$ 表示天气从 i 到 j 转移的概率$B_{ij}$ 表示天气为 i 的情况下海藻状态为 j 的概率，也叫发射概率Viterbi 搜索算法给定模型 μ 和观察序列 $X=x_{1} x_{2} \\ldots x_{t} \\ldots x_{T}$ 的条件下求概率最大的状态序列 $Y=y_{1} y_{2} \\ldots y_{t} \\ldots y_{T}$ ：$Y^*=\\underset{Y}{\\arg \\max } P(Y | X, \\mu)$Viterbi 算法：动态搜索最优状态序列定义：Viterbi 变量 $\\delta_{t}(y(i))$ 是在时间 t 时，模型沿着某 一条路径到达状态 y(i)，并输出观察序列$X=x_{1} x_{2} \\ldots x_{t} \\ldots x_{T}$的最大概率：$$\\Large \\delta_{t}(y(i))=\\max {y{i} y_{2} \\cdots y_{t-1} } P\\left(y_{1} y_{2} \\cdots y_{t-1} y_{t}(i), x_{1} x_{2} \\cdots x_{t-1} x_{t} | \\mu\\right)$$算法描述 (时间复杂度 $O(M^2T)$)：初始化：概率最大的路径变量：$\\psi_{1}(i)=0 $递推计算：结束：$\\large Y=\\underset{1 \\leq i \\leq M}{\\arg \\max }\\left[\\delta_{T}(i)\\right], \\quad P(Y)=\\max\\limits_{1 \\leq i \\leq M} \\delta_{T}(i)$通过回溯得到路径（状态序列）：$\\large y_{t}=\\psi_{t+1}\\left(y_{t+1}\\right), \\quad t=T-1, T-2, \\cdots, 1 $C++ 的代码，写起来很简单，每种语言都可以按照这个方式写。但是为了保证精度，我们一般是取log的，这份代码的结果应该会很差！123456789101112131415161718192021void viterbi(int O[],double PI[],double A[][],double B[][]){//传观察序列和模型 int i,j,back; int path[][]； double dp[][],MX； for(i=1;i&lt;=n;i++){//初始化 dp[1][i]=PI[i]; } for(i=1;i&lt;=m;i++){ for(j=1;j&lt;=n;j++){ MX=-1; for(k=1;k&lt;=n;k++){//枚举前一层 if(MX&lt;dp[i-1][k]*A[k][j]){ MX=dp[i-1][k]*A[k][j];//找到最大的 back=k; } } path[i][j]=back;//用于回溯 dp[i][j]=MX*B[j][O[i]];//计算结果存起来 } }}中文分词例子：输入观察序列 X：南京市长江大桥状态集合 $Y(i)={\\mathrm{B}, \\mathrm{M}, \\mathrm{E}, \\mathrm{S}} $输出状态序列 Y给定 HMM 模型：{A, B, π}又一个例子，前向的 Viterbi 算法 (来自 caojiangxia 的博客)：为了结果看起来比较正常，我们把初始分布π 设的极端一点，同时我们再次召唤之前的表。晴阴雨P100天气状态转移矩阵 A：雨阴晴雨0.6250.1250.25阴0.3750.250.375晴0.250.250.5天气对海藻干湿的影响 B:干稍干潮湿湿润晴0.600.200.150.05阴0.250.250.250.25雨0.050.100.350.50对于我们给定的观测序列：干，潮湿，湿润。我们计算的结果入上图所示。其中红色括号的结果就是表示结果是上一次的第几个节点过来的到此为止，隐马尔可夫模型的这个例子就介绍完了，当然问题有其他变种，一般是在 viterbi 算法上动刀条件随机场模型 (Conditional Random Fields，CRF)对汉字进行标注训练，不仅考虑了词语出现的频率，还考虑了上下文具备较好的学习能力，对歧义词和未登录词的识别都具有良好的效果。$\\Large \\begin{array}{l}Y^{*}=\\underset{Y}{\\arg \\max } P(Y | X ; \\lambda)=\\frac{1}{Z(X)} \\exp \\left[\\sum_{j} \\lambda_{j} F_{j}(Y, X)\\right] \\Z(X)=\\sum_{Y} \\exp \\left[\\sum_{j} \\lambda_{j} F_{j}(Y, X)\\right] \\F_{j}(Y, X)=\\sum_{t=1}^{T} f_{j}\\left(y_{t-1}, y_{t}, X, t\\right)\\end{array} $$F_j()$：第 j 个特征函数，可以表示状态特征函数，或者状态转移函数$λ_j$：第 j 个特征特征函数的权重Z(X)：归一化因子例子：$\\Large \\begin{aligned}P\\left(y_{t} | x_{t}, \\lambda\\right)=&amp; \\lambda_{1} f_{1}\\left(x_{t}, y_{t}\\right)+\\lambda_{3} f_{3}\\left(x_{t-1}, x_{t}, y_{t}\\right)+\\lambda_{4} f_{4}\\left(x_{t}, x_{t+1}, y_{t}\\right) \\&amp;+\\lambda_{2} \\max {y{t-1} \\in{B, M, E, S} }\\left{f_{2}\\left(y_{t-1}^{\\prime}, y_{t}\\right) P\\left(y_{t-1}^{\\prime} | x_{t-1}, \\lambda\\right)\\right}\\end{aligned} $停用词 (Stop Words)停用词表将词项按照文档集频率(collection frequency)，从高到底排列选取与文档意义不大，高频出现的词，比如，a, an, the, to, and, be …停用词使用的趋势现代搜索引擎发展的趋势使用少量的停用词表现代IR系统更加关注利用语言的统计特性来处理常见词问题停用词的消除：优点：停用词消除可以减少 term 的个数缺点：有时消除的停用词对检索是有意义的。“的士”、“to be or not to be”消除方法查表法基于文档频率词项归一化 (Normalization)归一化：将文档和查询中的词条 “归一化” 成一致的形式例如：希望 USA 和 U.S.A. 之间也能形成匹配归一化的结果：在 IR 系统的词项词典中，形成多个近似词项的一个等价类隐式的建立等价类例如将 USA 和 U.S.A. 映射为 USA例如将 anti-discrimination 和 antidiscrimination 映射为 antidiscrimination不同语言之间的区别：重音符号e.g.：法语中résumé vs. resume变音符号e.g.：德语中Tuebingen vs. Tübingen. (其实它们应该 是等价的)最重要的标准最重要的问题不是规范或者语言学的问题，而是用户将会如何根据这些词来构造查询？即使在一些语言中，有的词有了标准的读音， 但是用户有自己的读音/拼写方式e.g.：Tuebingen, Tübingen, Tubingen其他中文中日期的表示7月30日 vs. 英文中7/30日语中使用的假名汉字 vs. 中文中的汉字词条化和归一化二者都依赖于不同的语言种类，因此，在整个索引建立过程中要综合考虑大小写转换：一般策略将所有字母转换为小写绝大多数情况下，用户在构造查询时都忽略首字母的大写一些专有名词除外e.g.：General MotorsFed vs. fedSAIL vs. sailGoogle 的例子输入查询词 C.A.T. ，首页是关于猫的网站， 而不是卡特彼勒公司 (Caterpillar Inc.) (2005年的时候)词项归一化的策略：建立同义词扩展表。例如：查询 windows，检索了 Windows, windows, window扩展词表和 soundex 算法：如何处理同义词和同音词？e.g.：手工建立同义词词表car = automobile, color = colour①为每个查询维护一张包含多个词的查询扩展词表例如：查询automobile的同时，也查询car②在建立索引时就对词进行扩展例如：对于包含automobile的文档，同时也使用car来索 引如何处理拼写错误？其中的一种处理方法，就是根据发音相同来进行词项扩展后续章节中有讨论词干还原 (Stemming)词干还原：通常指很粗略的去除单词两端词缀的启发式过程。e.g., automate(s), automatic, automation -&gt; automat词干还原能够提高召回率，但是会降低准确率e.g.: operative ⇒ oper词干还原对于芬兰语，西班牙语，德语，法语都有明显的作用，其中对芬兰语的提高达到 30% (以MAP 平均准确率来计算)。中文叠词还原，可视为 “词干还原”Porter 算法：英文处理中最常用的词干还原算法，经过实践证明是高效性的算法。算法包括 5 个按照顺序执行的词项约简步骤每个步骤都是按照一定顺序执行的每个步骤中包含了选择不同的规则的约定比如，从规则组中选择作用时词缀最长的那条规则典型规则：sses-&gt;ss、ies-&gt;i、ational-&gt;ate、caresses-&gt;caress、ponies-&gt;poini、national-&gt;nate要考虑规则的 “权重”(前面的字母数&gt;1) EMENT 的处理replacement → replaccement → cement词形归并 (Lemmatization)词性归并：利用词汇表和词形分析来减少屈折变化的形式，将其转变为基本形式。e.g.am, are, is -&gt; becar, cars, car’s, cars’ -&gt; carthe boy’s cars are different colors -&gt; the boy car be differentcolor词形归并可以减少词项词典中的词项数量词干还原与词性归并对比：代表意义不同。前者：通常指很粗略的去除单词两端词缀的启发式过程。后者：通常指利用词汇表和词形分析来去除屈折词缀，从而返回词的原形或词典中的词的过程。假如给定词条 saw，词干还原过程可能仅返回 s，而词形归并过程将返回 see 或者 saw，具体返回哪个词取决于当前上下文中saw是动词还是名词。两个过程的区别还在于词干还原在一般情况下会将多个派生相关词合并在一起，而词形归并通常只将同一词元的不同屈折形式进行合并。语言的特殊性：词干还原和词形归并，都体现了不同语言之间的差异性，包括不同语言之间的差异特殊专业语言与一般语言的差异词干还原或者词形归并往往通过在索引过程中增加插件程序的方式来实现商业软件开源软件实现倒排记录表快速合并算法：带跳表的倒排记录表前面的倒排记录表合并复杂度是 O(x+y)，考虑做的更好 —— 基于跳表跳表指针能够跳过那些不可能出现在检索结果中的记录项。两个主要问题：如何利用跳表指针进行快速合并 ？在什么位置设置跳表指针 ？模拟查询处理过程：假定进行遍历一直发现共同记录 8，将 8 放入结果表中之后，继续移动二个表的指针。假定第一个表指针移到 41，第二个表的指针移到 11。由于11 &lt; 41，因此，上面的指针不需要继续移动，只需移动下面的指针，跳到31 (当然如31&gt;41那么就要倒回来)这样就跳过了 17,21设置跳表指针的位置：设置较多的指针 -&gt; 较短的步长 -&gt; 更多的跳跃机会代价：更多的指针比较次数和更多的存储空间设置较少的指针 -&gt; 较长的步长 -&gt; 较少的连续跳跃代价：较少的指针比较次数和较少的存储空间放置跳表指针的一个简单的启发式策略是：如果倒排表的长度是L，那么在每个 $\\sqrt{L}$ 处均匀放置跳表指针该策略没有考虑到查询词项的分布其他：如果索引相对固定的话，建立有效的跳表指针比较容易，如果索引需要经常的更新，建立跳表指针就相对困难。硬件参数对索引构建有一定的影响CPU速度磁盘访问速度注意：跳表指针只对 AND 类型的查询有用，对 OR 类型 的查询不起作用。包含位置信息的倒排记录表以及短语查询短语查询(Phrase Query)：用户希望将类似 “stanford university” 的查询中的二个词看成是一个整体。类似 “I want to university at stanford” 这样的文档是不会被匹配的。大部分的搜索引擎都支持双引号的短语查询，这种语法很容易理解并被用户成功使用。有很多查询在输入时没有加双引号，其实都是隐式的短语查询(如人名)。要支持短语查询，只记录 &lt;term: docs&gt; 这样的条目是不能满足用户需要的。第一种方法：二元词索引 (Biword indexes)将文档中每个连续词对看成一个短语例如，文本 “Friends, Romans, Countrymen” 将生成如下的二元连续词对friends romansromans countrymen其中的每一个二元词对都将作为词典中的词项经过上述的处理，此时可以处理二个词构成的短语查询扩展的二元词索引：名词和名词短语构成的查询具有相当特殊的地位。首先对文本进行词条化，然后进行词性标注把每个词项分为名词(N)、虚词(X)，冠词和介词和其他词。将形式为N*XN非词项序列看成一个扩展的二元词每个这样的扩展的二元词对应一个词项例如：catcher in the ryeN X X N利用这样的扩展二元词索引处理查询将查询拆分成 N 和 X将查询划分成扩展的二元词最后在索引中进行查找第二种方法：位置信息索引(Positional indexes)在这种索引中，对每个词项，采取以下方式存储倒排表记录对于短语查询，仍然采用合并算法，查找符合的文档不只是简单的判断二个词是否出现在同 一文档中，还需要检查它们出现的位置情况短语查询的处理：短语查询：“to be or not to be”对每个词项，抽出其对应的倒排记录表: to, be, or, not.合并&lt;docID:位置 &gt;表，考虑 “to be or not to be”.查找表中，看看是否某个 be 前面的一个位置上正好出现 to邻近查询 (Proximity queries)：Employ me/3 place，表示从左边或右边相距在 k=3 个词之内显然，位置索引能够用于邻近搜索，而二元词 搜索则不能位置信息索引的讨论：采用位置索引会大大增加倒排记录表的存储空间，即使采用后面讨论的压缩方法也无济于事。由于用户期望能够进行短语查询和邻近查询， 所以还是得采取这种索引方式。经验法则(English- like)：位置索引大概是非位置索引大小的 2~4 倍位置索引的大小大约是原始文档的 30%~50%混合索引机制：二元词索引和位置索引二种策略可以进行有效 的合并对 于 高 频 查 询 词 可 以 采 用 二 元 词 索 引 ， 例 如 “Michael Jackson”，Williams 等人(2004)评估了更复杂的混合索引机制 (引入后续词索引方法)。对于一个典型的 web 短语混合查询，其完成时间大概是只使用位置索引的1/4比只使用位置索引增加26%的空间第四章 索引建立与压缩Index Construction &amp; Index Compression索引构建Index：索引Indexer：构建索引的程序、索引器怎样建立一个索引？对于给定的计算机内存，可以采用怎样的索引构建策略?硬件基础与语料库了解两个部分：硬件方面存储能力IR 系统的服务器通常 “数GB” 甚至 “数百GB” 的内存其可用磁盘空间大小一般比内存大小高几个 (2- 3) 数量级 (TB级别)。容错控制代价非常昂贵：使用许多台常规服务器要比使用一台容错服务器便宜得多计算IO的能力：访问内存数据比访问磁盘数据快得多。磁盘寻道：磁头移到数据所在的磁道需要一段 时间，寻道期间并不进行数据的传输。因此：从磁盘到内存传输一个大数据块要比传输很多小的数据块快的多。磁盘读写操作是基于块的：从磁盘读取一个字节和读取一个数据块所耗费的时间可能一样多语料库莎士比亚全集，不够大，所以拿 “Reuters-RCV1文档集” 举例，一个不是真正够大，但是是公开且合理的文档集将使用路透社的 RCV1 文档集作为“可扩展的索引构建算法 ”的样例该文档集由一年的路透社新闻组成(1995-1996)文档ID需 32bit=4Byte词条ID需 32bit (总共约1亿词条)存储所有的“词条ID-文档ID”需要约100,000,000 * (32+32) =6,400,000,000bits =800,000,000Bytes = 0.8GB ，需要对 0.8GB 的 ID 对进行排序！！！而实际语料库要比 RCV1 更大，所以不能在内存中进行索引构建，因为不能扩展因此需要在硬盘中存储中间结果。索引构建算法不能在磁盘中进行排序，磁盘寻道太慢了，需要一个外部排序算法。基于块的排序索引构建算法BSBI : Blocked sort-based Indexing基本思想：对每一个块都生成倒排记录，并排序，写入硬盘然后将这些块合并成一个长的排好序的倒排记录。操作：每条数据 &lt;词项，文档，频数&gt; 占用12字节 (4+4+4)这些数据是在分析文档时生成，需要对 100M 条这样 12 字节的数据进行排序定义一个块 ~10M 大小的数据可以很容易地加载数个这样的块数据到内存中开始加载 10 个这样的块数据100M 数据的排序 → 排序 10 块 10M 的数据在硬盘上直接排序 → 在内存中排序 (10M)带来的问题：需要合并 10 个排序后的结果如何合并排序结果：n-路合并会更加高效内存中维护为 10 个块准备的读缓冲区一个为最终合并索引准备的写缓冲区这样就不会因为硬盘寻道而浪费大量的时间基于 BSBI 排序的算法存在的问题：假设：能够将词典存入内存中。需要该词典(动态增长)去查找任一词项和词项 ID 之间的对应关系。事实上，可以采用&lt;词项，文档ID&gt;对来代替&lt;词项ID，文档ID&gt;对。每个词项的平均字节数=7.5但是中间文件会变的非常的大。所以这是一个可拓展的，但效率非常低的索引构建算法。内存式单遍扫描索引构建算法SPIMI : Single-pass in-memory indexing核心思想1：为每个块单独生成一个词典，不需要维护全局的 &lt;词项，词项ID&gt; 映射表。核心思想2：不进行排序。有新的 &lt;词项，文档ID&gt; 对时，直接在倒排记录表中增加一项。根据这两点思想，可以为每个块生成一个完整的倒排索引。然后将这些单独的索引合并为一个大的索引。压缩技术将会使 SPIMI 算法更加高效压缩词项压缩倒排记录表分布式索引构建 ★Distributed indexing理解集群的宕机概率。分布式索引构建概念：用集群中的主控节点来指挥索引构建工作。假设主控节点是 “安全” 的。将索引构建过程分解成一组并行的任务。主控计算机从集群中选取一台空闲的机器并将任务分配给它。并行任务：采用两组不同的并行任务Parsers 分析器Inverters 倒排器首先，将输入文档集分割成 n 个数据片，每个数据片就是一个文档子集 (与BSBI/SPIMI算法中的数据块相对应)文档集分割：基于文档的分割基于词项的分割分析器 Parsers：主节点将一个数据片分配给一台空闲的分析服务器分析器依次读取文档并生成 &lt;词项,文档&gt; 对分析器将这些 &lt;词项,文档&gt; 按照词项分成 j 个段每一段是按照词项首字母划分的一个区间(例如：a-f, g-p, q-z)-这里 j=3然后可以进行索引的倒排倒排器 Inverters：对于一个词项分区，倒排器收集所有的 &lt;词项, 文档&gt; 对 (也就是“倒排记录”)排序，并写入最终的倒排记录表索引构建后的另一个阶段：索引构建只是其中的一个阶段另一个阶段是：将基于词项划分的索引表转换成基于文档划分的索引表基于词项划分的：一台机器处理所有词项的一个子区间基于文档划分的：一台机器处理所有文档的一个子区间在本课程的Web搜索部分会讲到，大部分搜索引擎都是采用基于文档划分的索引表优点：更好的负载平衡等等MapReduce：MapReduce (Dean and Ghemawat 2004) 是一个稳定的并且概念简单的分布式计算架构不需要自己再对分布式部分书写代码Google索引系统 (ca.2002) 由各个不同的阶段组成，每个阶段都是 MapReduce 的一个应用刚刚所讲的索引构建算法是 MapReduce 的一个应用使用 MapReduce 的索引构建架构：一个简单的例子 —— Map阶段 ：To be, or notto be: that isthe questionthe head is not more native to the heartbrevity is the soul of wit一个简单的例子 —— Reduce 阶段 ：动态索引迄今为止，我们都假设文档集是静态的但文档集通常不是静态的文档会不断的加入进来文档也会被删除或者修改这就意味着词典和倒排记录表需要修改对于已在词典中的词项更新倒排记录新的词项加入到词典中方法1: —— 最简单的索引更新方法：周期性索引重构建立新索引的同时，旧索引继续工作条件更新次数不是很多能够接受对新文档检索的一定延迟（重构之前新文档检索不到）有足够的资源进行重构方法2：维护一个大的主索引新文档信息存储在一个小的辅助索引中 (位于内存)检索可以同时遍历两个索引并将结果合并删除文档的删除记录在一个无效位向量 (invalidation bit vector) 中在返回结果前利用它过滤掉已删除文档定期地，将辅助索引合并到主索引中文档更新通过先删除后插入方式实现主索引与辅助索引存在的问题：频繁的合并 — 带来很大的开销合并过程效率很低如果每个词项的倒排记录表都单独成一个文件，那么合并主索引和辅助索引将会很高效合并将是一个简单的添加操作但需要非常多的倒排文件 — 对文件系统来说是低效的以后课程中都假设：索引是一个大的文件现实中：往往在上述两种极端机制中取一个折中方案(例如，对非常大的索引记录表进行切分；并对那些长度为1的索引记录表进行合并)对数合并：维护一系列的索引 $I_0,I_1,I_2, \\cdots$，每个都是前一个的两倍大小 $n\\times 2^0,n\\times 2^1,n\\times 2^2，\\cdots $。n 是辅助索引 $Z_0$ 的大小辅助索引 $Z_0$ 存在内存将较大的那些 ($I_0,I_1,\\cdots$) 存在磁盘当 $Z_0$ 达到上限 n 时，将它写入磁盘的 $I_0$ 中 (此时 $I_0=n\\times 2^0$)当 $Z_0$ 再次达到上限 n 时，它会和 $I_0$ 合并，生成 $Z_1$ ($n\\times 2^1$)此时，如果 $I_1 $ 不存在，存储到 $I_1$ 中如果 $I_1$ 已经存在，则 $Z_1$ 与 $I_1$ 合并成 $Z_2$ ($n\\times 2^2$)此时，如果 $I_2$ 不存在，存储到 $I_2$ 中以此类推拥有多个索引产生的问题：全局统计信息很难得到例如：对于拼写校正算法，得到几个校正的备选词后，选择哪个呈现给用户？可以返回具有最高选中次数的那些对于多个索引和无效位向量，怎样维护那些拥有最高次数的结果？一个可能的方法：除了主索引的排序结果，忽略其它所有的索引事实上，采用对数合并方法，信息检索系统的各个方面，包括索引维护，查询处理，分布等等，都要复杂的多搜索引擎中的动态索引：现在所有的大型搜索引擎都采用动态索引它们的索引经常增加和改变新的产品、博客，新的Web网页但是它们也会周期性地从头开始重新构建一个全新的索引查询处理将会转到新索引上去，同时将旧的索引删除总结基于排序的索引构建算法它是一种最原始的在内存中进行倒排的方法基于块的排序索引算法 BSBI合并排序操作对于基于磁盘的排序来说很高效(避免寻道)内存式单遍扫描索引构建算法 SPIMI没有全局的词典对每个块都生成单独的词典不对倒排记录进行排序有新的倒排记录出现时，直接在倒排记录表中增加一项采用 MapReduce 的分布式索引构建算法动态索引构建算法：多个索引，对数合并搜索引擎：周期性索引重构索引压缩压缩必要性：节省磁盘空间省钱提高内存的利用率提高速度加快数据从磁盘到内存的传输速度读取压缩数据+解压缩 比直接 读取未压缩的数据 快前提：解压缩算法要很快目前所用的解压缩算法在现代硬件上运行相当快压缩倒排记录表的必要性：词典压缩的足够小以便能够放入内存中当词典足够小时，也可以在内存中存储一部分倒排 记录表倒排记录文件减少所需的磁盘空间减少从磁盘读取倒排记录文件所需的时间大的搜索引擎在内存中存储了很大一部分倒排记录表，压缩可以在内存中存储的更多词项统计量有损压缩 Lossy 与无损压缩 Lossless：无损：压缩后所有原始信息都被保留在 IR 系统中常采用无损压缩有损：丢掉一些信息一些预处理步骤可以看成是有损压缩：大小写转换，停用词剔除，词干还原，数字去除第 7 章：那些削减的倒排记录项都不太可能在 查询结果的前 k 个列表中出现。对于前k个返回结果来说，这几乎是无损的选择有损还是无损与需求相关Heap 定律：词汇量与文档集大小的关系：文档集越大，词汇量越大Heap 定律：$M = kT^b$M 是词项数目，T 是文档集中词条个数$30 \\le k \\le 100, b\\approx 0.5$词汇量大小 M 和文档集大小 T 在对数空间中，存在着斜率为 1/2 的线性关系（一个经验发现 empirical law）Zipf 定律：词项在文档中的分布情况。在自然语言中 ，只有很少一些非常高频的词项，而其它绝大部分都是很生僻的词项Zipf 定律：排名第 i 多的词项的 文档集频率 与 1/i 成正比$\\large c f_{i} \\propto \\frac{1}{i}=\\frac{K}{i} $K 是一个归一化常数$c f_{i}$ 是文档集频率：词项 $t_i $ 在文档集中出现的次数如果最高频的词项(the)出现了cf1次那么第 2 高频的词项(of)出现了cf1/2次第 3 高频的词项(and)出现了cf1/3次词典压缩必要性：搜索从词典开始，需要将词典放入内存中，和其他应用程序共享内存资源手机或者嵌入式设备通常只有很小的内存即使词典不存入内存中，也希望它能比较小，以便搜索能快速启动词典的存储：定长数组存储 词项 20B, 文档频率 4B, 指向倒排记录表的指针 4B词项的定长存储浪费空间书面英文中单词的平均长度约为 4.5 个字符较短的词项支配了词条的数目但是并不是典型的平均值，即较短的词项占绝大多数压缩词项列表 —— 将词典看成一个字符串指向下一词项的指针同时也标识着当前词项的结束按块存储每 k 个词项分成一块，只保留第一个指针，额外存储词项长度 (1Byte) 来划分词项前端编码：按照词典顺序排列的连续词项之间往往具有公共前缀处理块内 k 个词项的最后 k-1 个搜索次数比较：假设每个词项被查询的概率相同未压缩词典的搜索如下按块存储方式下的搜索如下（这个图没有体现二分查找的部分过程）倒排记录表压缩压缩方案：定制位数压缩：按照文档数目定制 文档ID 字段，要多少位给多少位按 GAP 压缩：按文档 ID 的间距 (GAP) 存储词项的倒排索引表如 33, 47, 154, 159, 202, ... 压缩成 33, 14, 107, 5, 43, ...期望：绝大多数间距存储空间都远小于 20 bit可变长度编码（可变字节码 VB, Variable Byte）：目标是：对于 arachonocentric 这样低频的词使用 20bit/间距项对于 the 这样高频的词使用 1bit/间距项如果词项平均间距为 G，想用 logG bit/词距项关键问题：需要利用整数个字节来对每个间距编码。需要实现一个可变长度编码，这样对一些小数字可使用短码例子如下：最后一个字节的首位标记为一个数的最后一个字节缺点：很小的间距上仍然浪费空间，那种情况半字节更可取总结：现在可以为布尔查询创建一个索引，即高效又非常节省空间只有文档集总大小的 4%，在文档集中只有文本总大小的 10-15%但是，忽略了索引的位置信息。因此，在实际中，索引所节省的空间并没有这 么多第五章 Web搜索Web搜索基础Web 与文档集的不同对搜索结果的经验性评价：页面质量良莠不齐仅仅相关是不够的质量也很关键内容: 可信, 多样, 不重复, 容易维护页面可读性: 显示得又快又好无打扰: 无弹出广告等正确率和召回率 Precision vs.Recall在互联网上, 召回率不再那么重要但匹配结果比较少的时候召回率很重要什么比较重要？头版头条的正确率 (反例：百度前几条都是广告)全面 – 要能处理模糊的查询词用户的认可：用户的认知可能非学术的，但是是有意义的Web 文档集的特点：分散：没有特别的设计，分散的内容创作、链接, 民主化的发布内容多样：包含真理、谎言、矛盾和大量猜测 …异构：非结构化的(text, html, …)、半结构化的 (XML, 有注释的照片), 结构化的 (数据库) …重复：规模比之前的文本集大得多，但是其中有很多重复的记录增长：最开始每几个月就翻一倍，现在涨速下降但总量依然在扩大动态：内容可能是动态生成的Web 搜索基本流程图：近似重复检测近似重复文档：完全复制 Duplication通过指纹 fingerprints (如 Hash) 来检测近似重复 Near-Duplication （大多数情况，比如内容一样日期不同）通过编辑距离计算语法上的相似性通过阈值来检测近似重复，但是这种方法是不可传递的 (AB 近似，BC 近似，推不了 AC 近似)相似性计算 N-Grams 的概念：搭叠 Shingles (N 元词 N-Grams)给定正整数 N 和文档 d 的一个词项序列，N-Shingles 即文档 d 的所有 N 个连续词项构成的序列山东大学在青岛 的 3-Grams山东大东大学大学在学在青在青岛如果直观上看，两个文档的 shingle 集合几乎一样，它们满足近似重复Jaccard 系数：在两个文档的 Shingle 集合上衡量重复度$\\huge \\operatorname{Jaccard}\\left(C_{i}, C_{j}\\right)=\\frac{\\left|C_{i} \\cap C_{j}\\right|}{\\left|C_{i} \\cup C_{j}\\right|}$需要注意：计算所有文档之间搭叠的精确交集是非常费时而且难以处理的抽样 Sample：使用一种聪明的方式从 Shingles 中选出一个 子集 (素描 sketch) 来近似计算Sketch, 文档的素描：比如对于文档 D，其 $\\large \\text{sketch}_D[i]$ 如下用 f 函数 把所有搭叠 shingles 映射到 $\\large {0,\\cdots, 2^m}$ 得到 $\\large f(s)$也可以看作是为每个搭叠计算一个 m 位的 Hash Code$\\Large \\pi_i$ ：对 $\\large {0,\\cdots, 2^m}$ 的随机置换函数，即对集合的对象进行随机排序用 $\\Large \\pi_i$ 对所有搭叠的哈希 $\\large f(s)$ 进行随机置换得到 $\\large \\pi_i(f(s))$ ，从而形成一个新的随机序列对上一步的随机置换序列选择 $\\Large \\text{MIN} {\\pi_i(f(s))}$为每篇文档生成素描向量 sketch vector(大小约为 200)相同向量个数 $\\ge t $ （一般 80%）判定为近似测试 if Doc1.Sketch[i]==Doc2.Sketch[i]本质上是对 shingle 集合进行洗牌 + 抽样定理 19-1：A=B 发生的概率 = 交集大小 / 并集大小小结：Shingle 算法的核心思想是将 文件相似性问题 转换为 集合相似性 问题数量较大时，抽样 Sketch，以降低时空复杂度Shingle 抽样有三种方法，Min-Wise、Modm、MinsMins 技术先将 shingle 和整数集进行映射，然后从中选择最小 s 个元素组成取样集合。此外，还可以使用 shingle 的 hash 值代表 shingle 进行相似性计算，能够节省一定计算开销。Web采集采集器采集器必须具有的功能：礼貌性: Web服务器有显式或隐式的策略控制采集器的访问只爬允许爬的内容、尊重 robots.txt鲁棒性: 能从采集器陷阱中跳出，能处理Web服务器的其他恶 意行为分布式: 可以在多台机器上分布式运行可扩展性: 添加更多机器后采集率应该提高性能和效率: 充分利用不同的系统资源，包括处理器、存储器和网络带宽优先抓取“有用的网页”新鲜度: 对原来抓取的网页进行更新功能可扩展性：支持多方面的功能扩展，例如处理新的数据格式、新的抓取协议等采集器结构图：采集器分布式：在分布式系统环境下不同节点的不同进程中运行多个采集线程地理位置分布的采集系统把要采集的主机分配到每个节点通过 Hash 函数或其他针对性的策略节点间通信通过滤检测的 URL 需要发送到每个节点上进行查重处理连接服务器Web → Web 图：可以将整个静态 Web 看成是静态 HTML 网页通过超链接互相连接而成的有向图，每个网页是图的顶点，而每个超链接则代表一个有向边。这样网页和超链接抽象成的图即 Web 图Web 特性 → Web 图特性：可能不是强连通图入度：入链接 in-link 数出度：出链接 out-link 数无标度网络站点大小 Site Size (以页面数量计算) 服从 Power-Law 分布跨越不同的规划a 在 1.6-1.9 间节点的度服从 Power-Law 分布出度，a = 2.45入度，a = 2.1网页数量 $\\approx \\frac{1}{i^a} $连接服务器：支持 Web 图上的快速查询哪些URL指向给定的URL给定的URL指向哪些URL在内存中存储了映射表，URL 到出链, URL 到入链邻接表应用采集控制Web 图分析连通性 Connectivity, 采集优化链接分析 Link analysis链接分析索引锚文本：在 HTML 中，锚同时可以附带一个文本在索引文档 D 时，同时也索引指向文档 D 的锚文本比如搜索 IBM 可以得到 IBM 的官网，搜索 Big Blue 也可以得到 IBM 的官网，后者是因为太多人使用这一绰号而加大了权重根据页面的权威性确定页面的锚文本比如 cnn.com 和 yahoo.com 的内容是权威PageRank链接分析之 PageRank：对 Web 图中的每个节点赋一个 0-1 间的分值PageRank 是一种排序，但是是与查询词无关的排序，仅仅是按对页面的评分来排序。Google 使用了 PageRank，但是还使用其他复杂的特征，以及使用基于机器学习的排序PageRank 对爬虫的爬取策略很有用第一代版本使用链接的数目作为流行程度的最简单度量两个基本的改进建议（链接流行度）无向流行度：赋予每个页面一个分数：即出链数 + 入链数 (3+2=5)有向流行度：页面分数 = 入链数 (3)缺点：可以作弊PageRank 打分：随机游走：从一个随机页面开始，等概率地选择喵链接进入。（访问越频繁的网页越重要）随机跳转 Teleporting：解决 Dead End 问题。遇到 Dead End 时，随机跳转到 N 个网页之一；非 Dead End 时，以 α (较小10-20%) 的概率做随机跳转，1-α 的概率做随机游走随机跳转的结果：不会困在一个地方将有一个比率表示所有网页在长期的情况下被访问的概率PageRank 值：PageRank： $\\Large \\pi(v)$随机游走+随机跳转，冲浪者会以一个稳定的概率 $\\Large \\pi(v)$ 访问每个节点 v，其中 $\\Large \\pi(v)$ 依赖于：Web 图结构α 值将采用 马尔科夫链 理论来说明离散时间随机过程 discrete-time stochastic processMarkov 链, 马尔科夫链：一个 Markov 链有 N 个状态，一个 N×N 的转移概率矩阵 PN：对应 N 个 Web 网页$\\forall i, \\sum_{j=1}^{N} P_{i j}=1 $：P 中每一行的元素之和为 1，即从该页面跳转到所有出链的概率和为 1随机矩阵 Stochastic Matrix：满足上述性质的非负矩阵重要性质：最大特征值=1，有一个主左特征向量 Principal Left Eigenvector马尔科夫链中，下一个状态的分布仅仅依赖于当前的状态，而和如何到达当前状态无关概率向量：马尔科夫链的状态概率分布可以看成一个概率向量 (probability vector)，其中的每个元素都在[0,1]之间， 并且所有的元素之和为 1 (一行)如果一个 N 维的概率向量的每个分量对应马尔科夫链中的一个状态，那么该向量就可以被看成是在状态上的一个概率分布。(一行)邻接矩阵 A 转为转移概率矩阵 P (随机游走+随机跳转)：$A=\\left[\\begin{array}{lll}0 &amp; 1 &amp; 0 \\1 &amp; 0 &amp; 1 \\0 &amp; 1 &amp; 0\\end{array}\\right]$归一化：$\\left[\\begin{array}{ccc}0 &amp; 1 &amp; 0 \\\\frac{1}{2} &amp; 0 &amp; \\frac{1}{2} \\0 &amp; 1 &amp; 0\\end{array}\\right]$加上随机游走： $(1-\\alpha) · \\left[\\begin{array}{ccc}0 &amp; 1 &amp; 0 \\\\frac{1}{2} &amp; 0 &amp; \\frac{1}{2} \\0 &amp; 1 &amp; 0\\end{array}\\right]$加上随机跳转：$\\large (1-\\alpha) · \\left[\\begin{array}{ccc}0 &amp; 1 &amp; 0 \\\\frac{1}{2} &amp; 0 &amp; \\frac{1}{2} \\0 &amp; 1 &amp; 0\\end{array}\\right] + \\frac{\\alpha}{N} \\overset{\\alpha=0.5}{=} \\left[\\begin{array}{ccc}0 &amp; \\frac{1}{2} &amp; 0 \\\\frac{1}{4} &amp; 0 &amp; \\frac{1}{4} \\0 &amp; \\frac{1}{2} &amp; 0\\end{array}\\right]+\\frac{0.5}{3}=\\left[\\begin{array}{ccc}\\frac{1}{6} &amp; \\frac{2}{3} &amp; \\frac{1}{6} \\\\frac{5}{12} &amp; \\frac{1}{6} &amp; \\frac{5}{12} \\\\frac{1}{6} &amp; \\frac{2}{3} &amp; \\frac{1}{6}\\end{array}\\right] $概率向量的变化：在当前这一步的概率向量是 $\\overrightarrow{\\mathrm{x} }=\\left(x_{1}, \\ldots, x_{N}\\right) $下一步的概率向量是 $\\overrightarrow{\\mathrm{x} } P$ ，下下步 $\\overrightarrow{\\mathrm{x} } P^2$，…稳态概率：当 k 很大，$\\overrightarrow{\\mathrm{\\pi} } = \\overrightarrow{\\mathrm{x} } P^k $，这就是最终访问频率的稳态概率 。是起点无关的，该向量中的值 $\\pi_i$ 即是节点 i 的稳态概率 这个例子中 $\\pi_1 = \\frac{1}{4}，\\pi_2 = \\frac{3}{4} $幂迭代 Power Iteration，计算 α 的一种方法：给 $\\overrightarrow{\\mathrm{x} }$ 乘上 P 的 k 次方，k 不断增加，直到乘积稳定 (比如 $\\overrightarrow{\\mathrm{x} }P^{k-1}$ 与 $\\overrightarrow{\\mathrm{x} }P^{k}$ 相差不大)HITS超链导向的主题搜索：Hyperlink-Induced Topic Search对于每个网页给出两部分得分hub 值，导航authority 值，权威针对某一主题的好 Hub 页会指向很多关于这个主题的 Authority 页面关于某一主题的好 Authority 页面会被很多针对这一主题的好Hub页指向循环定义Circular definition - 导致可以迭代求解页面的Hub值和Authority值步骤：确定基本集 Base Set根集合：给一个查询词 (比如 browser)，使用一个文本索引，取出所有包含 browser 的页面在根集合中添加满足下面任一要求的页面指向根集合中的某个页面被根集合中的一个页面指向的页面精选出 Hub 页和 Authority 页对于基本集中的每一个页面 x 计算 Hub 分 h(x) 和 Authority 分 a(x)初始化：所有的 x，h(x)=a(x)=1关键：迭代更新 h(x), a(x)迭代之后输出具有最高 h 的页面作为 Top Hub 页最高 a 的页面作为 Top Authority 页迭代更新对所有 x 重复如下步骤：$\\large \\begin{aligned}&amp;h(x) \\leftarrow \\sum_{x \\mapsto y} a(y)\\&amp;a(x) \\leftarrow \\sum_{y \\rightarrow x} h(y)\\end{aligned} $， 先重新计算所有网页的 hub 值，接着根据更新后的 hub 值又来计算所有网页的 authority 值接着又根据更新的 authority 值去重计算 hub 值，如此反复迭代避免 h、a 过大，每次迭代后按一定比列缩小。( 缩放不影响，因为值关系相对分数 )问题：应该迭代多少次宣称：迭代一些次数后分数会收敛。实际上，适当的缩放, h() 和 a() 会陷入一个稳定状态!只需要 h() 和 a() 的相对顺序，而不需要它们的值实践中发现, 大概 5 次迭代后就会稳定第六章 向量模型及检索系统向量模型排序式检索引入：前面介绍了 布尔查询 —— 文档要么匹配要么不匹配对专家来说合适，但对大多数用户不方便专家对自身需求和文档集性质十分了解大部分用户不能撰写布尔查询或者他们认为需要大量训练才能撰写合适的布尔查询大部分用户不愿意逐条浏览 1000 多条结果，特别是对于 Web 搜索布尔查询本身的缺点“盛宴 or 饥荒”，查询结果不是太多就是太少Query1 “standard user dlink 650” → 200,000 个匹配结果Query2 “standard user dlink 650 no card found” → 0 个匹配结果需要花费很多精力去构造一个合适的 query排序检索模型：系统不是简单地返回所有满足 query 描述的文档集合而是，根据文档与query 的相关性，排序，返回文档集合中的文档序列自由文本查询：用户 query 是自然语言的一或多个词语，而不是由查询语言构造的表达式总体上，排序检索模型中有布尔查询和自由文本查询两种方式但是实际中排序检索模型总是与自由文本查询联系在一起，反之亦然给出的不是集合，而是有序的序列查询结果数目多不是问题，只要取 Top K 即可为用户减轻负担→ 排序算法很重要排序的前提是指标，或者说评分：希望根据，查询对查询者的有用性大小，来排序如何根据一个 query 对文档进行排序为每个 查询-文档 对，进行评分，记为 [0, 1] 之间的小数评分值用来衡量，文档与 query 的匹配比如，单个词为例该词不在文档，则文档评 0 分出现频率越高，文档评分越高方案选取：Jaccard 系数举例：Query: ides of marchDocument 1: caesar died in marchDocument 2: the long marchJaccard(q, doc1) = 1/6Jaccard(q, doc2) = 1/5缺点、存在的问题：没有考虑词频罕见词比高频词信息量更大，更有区分度词项频率词项-文档 二值关联矩阵：每个文档用一个二值向量表示 $\\in {0,1}^{|V|}$词项-文档 词频关联矩阵：考虑词项在文档中出现的频率每个文档是一个词频向量：矩阵中的一列词袋模型 Bag of words：词袋：不考虑词在文档中的顺序一种倒退 (主动丢失位置信息)，位置索引可很容易区分这两个文档后面课程会考虑如何恢复位置信息Term Frequency 词项频率：$\\Large tf_{t,d}$：词项 t 在文档 d 中出现的次数raw tf 的缺点：相关性不会正比于词项频率举例：某词项在 A 文档出现 10 次，tf=10，在 B 文档出现 1 次，tf=1，A 比 B 更相关。但是相关度不会差 10 倍对数词频：$\\Large w_{t, d}$ ：词项 t 在文档 d 中的对数频率权重$\\Large w_{t, d}=\\left{\\begin{array}{cl}1+\\log {10} t f{t, d} &amp; \\text{if}\\ \\ t f_{t, d}&gt;0 \\0 &amp; \\text { otherwise }\\end{array}\\right.$$\\large t f_{t, d} \\rightarrow w_{t, d}: \\begin{cases} 0 \\rightarrow 0,\\1 \\rightarrow 1,\\2 \\rightarrow 1.3,\\10 \\rightarrow 2,\\1000 \\rightarrow 4 \\end{cases}$文档-词项的匹配得分是所有同时出现在查询 q 和文档 d 中的词项的词频的对数之和$\\Large \\text {Score}(q, d)=\\sum\\limits_{t \\in q \\cap d}\\left(1+\\log t f_{t, d}\\right)$评分为 0，表示文档和 query 中无公共词项tf-idf 权重计算文档词频 → 文档集词频：进行权重和评分计算罕见词项：蕴含的信息更多包含该词项的文档很可能相关 (因为这是罕见词)，所以权重高常见词：包含该词的文档比不包含该词的文档相关度要高但不是非常强的指示词文档频率，Document Frequency，df：$\\large df_t$：文档集合中包含 t 的文档数目$\\large df_t$ 与词项 t 包含的信息量成反比$\\large df_t \\le N$ (N 是文档的总数)使用文档频率 df 这个因子来实现：对罕见词项赋予高权重对常见词项赋予低权重逆文档频率，Inverse Document Frequency，idf：$\\large idf_t = log_{10} \\frac{N}{df_t} $反映词项 t 的信息量的指标，其中取 log 起到抑制增长的作用例子：N=1000000idf 对排序的影响：对于含有两个以上查询词的 query，idf 才会影响排序结果例子：query=”arachnocentric line”，idf 提高 arachnocentric 的相对权重，降低 line 的相对权重文档集频率，Collection Frequency，cf：$\\large cf_t$：词项 t 在整个文档集合中出现的次数df （和 idf）比 cf（和icf）更适合权重计算词频-逆文档频率 tf-idf：针对单个词的，又名 tf·idf、tf×idf，中间的符号表示连接 (而不是运算)值：$\\Large w_{t, d}=\\left(1+\\log\\ tf_{t, d}\\right) \\times \\log {10}\\left(N / d f{t}\\right)$随着词项在单个文档中出现次数 (tf) 增加而增大随着词项在文档集中数目 (df) 增加而减小Query 的最终文档排序：$\\Large \\text {Score}(q, d)=\\sum\\limits_{t \\in q \\cap d} tf \\times idf_{t, d}$向量空间模型二值矩阵 → 词频矩阵 → tf-idf 矩阵：每篇文档表示成一个基于 tf-idf 权重的实值向量 $\\large \\in R^{|V|}$文档表示成向量：每篇文档表示成一个基于 tf-idf 权重的实值向量 $\\vec{d} \\in R^{|V|}$ （可看作是上图矩阵中的一列）于是，有一个 |V| 维实向量空间空间的每一维都对应一个词项文档是空间中的点或者向量维度非常高：特别是互联网搜索引擎，空间可能达到千万维或更高向量空间非常稀疏：对每个文档向量来说大部分都是 0Queries 表示成向量（同样可看作是一列）：关键思路 1：对于查询做同样的处理，即将查询表示成同一高维空间的向量 $\\vec{q}$关键思路 2：在向量空间内根据 query 与文档的向量间的距离来排序向量空间下，基于什么排序：两点之间距离 —— 两个向量终点间距离欧式距离，不是一种好的选择对向量长度很敏感 $\\Large D_{E u c}(\\vec{q}, \\vec{d})=\\sqrt{\\sum\\limits_{i=1}^{|V|}\\left(q_{i}-d_{i}\\right)^{2} } $举例：在欧式空间中，q 与文档 $d_2$ 的欧式距离很大，但是 q 与 $d_2$ 的分布很相近举例：将一篇文档 d 的内容复制一份追加在自身末尾，构建一个新文档 d’语义上看，文档 d 和 d′ 的内容是相同的，但是这两个文档的欧氏距离却是非常大夹角代替距离：可通过计算文档与 query 的夹角给文档排序举例：将一篇文档 d 的内容复制一份追加在自身末尾，构建一个新文档 d’这两个文档的向量间夹角为 0，表示最大相似度 1余弦 Cosine 相似度：下面两个观点是等价的按 query 与文档夹角递增给文档排序按余弦 cosine(query, document) 递减给文档排序这是因为在 [0°, 180°] 区间上，cosine 是单调递减函数只考虑相对顺序引入：文档长度归一化文档 x 的 $L_2$ 范数为：$\\Large |\\vec{x}|{2}=\\sqrt{\\sum{i} x_{i}^{2} }$ （就是向量长度，别看了）可用 $L_2$ 范数对文档长度进行归一化 —— 文档向量除以它的 $L_ 2$ 范数归一化后，前一页中的文档 d 和 d′ （前面的那个例子）就可以用同一个向量表示了如此，长文档和短文档之间的长度差异就不会影响相关性了不带归一化的 Cosine$\\huge \\cos (\\vec{q}, \\vec{d})=\\frac{\\vec{q} · \\vec{d} }{|\\vec{q}||\\vec{d}|}=\\frac{\\vec{q} }{|\\vec{q}|} · \\frac{\\vec{d} }{|\\vec{d}|}=\\frac{\\sum_{i=1}^{|V|} q_{i} d_{i} }{\\sqrt{\\sum_{i=1}^{|V|} q_{i}^{2} } \\sqrt{\\sum_{i=1}^{|V|} d_{i}^{2} }} $$q_i$ 是词项 i 在 query 中的 tf-idf 权值$d_i$ 是词项 i 在文档中的 tf-idf 权值$cos(\\vec{q},\\vec{d})$，q 与 d 的余弦相关性 = 向量 q 与 d 夹角的余弦值带归一化的 Cosine$\\vec{q}$ 归一化成 $\\vec{q}’$$\\huge \\cos \\left(\\vec{q} ‘ , \\vec{d}’ \\right)=\\vec{q}’ \\bullet \\vec{d}’ =\\sum_{i=1}^{|V|} q_{i}^{\\prime} d_{i}^{\\prime}$余弦相似度计算举例：下面三部小说为例SaS: Sense and Sensibility(理智与情感)PaP: Pride and Prejudice(傲慢与偏见)WH: Wuthering Heights?(呼啸山庄)为简化计算，仅考虑 tf，不考虑 idf $\\large \\begin{array}{l}\\quad 0.789=\\frac{3.06}{\\sqrt{3.06^{2}+2^{2}+1.3^{2}+0^{2} }} \\\\cos (\\mathrm{SaS}, \\mathrm{PaP}) \\approx 0.789 * 0.832+0.515 * 0.555+0.335 * 0.0+0.0 * 0.0 \\approx 0.94 \\\\cos (\\mathrm{SaS}, \\mathrm{WH}) \\approx 0.79 \\\\cos (\\mathrm{PaP}, \\mathrm{WH}) \\approx 0.69 \\\\cos (\\mathrm{SaS}, \\mathrm{PaP})&gt;\\cos (\\mathrm{SAS}, \\mathrm{WH})&gt;\\cos (\\mathrm{PaP}, \\mathrm{WH})\\end{array}$计算 Cosine 的伪码：N 文档总数Length[N] 数组中存放的是每个文档向量的长度(即归一化因子)Scores[N] 数组放的是每篇文档的得分tf-idf 权重机制的变形：向量空间模型小结：将 query 看作带 tf-idf 权重的向量将每个文档也看作带 tf-idf 权重的向量计算 query 向量与每个文档向量间的余弦相似度根据相似度大小将文档排序将 Top K 个结果返回给用户检索系统结果排序的重要性不排序问题的严重性用户只希望看到一些而不是成千上万的结果很难构造只产生一些结果的查询，即使是专家也很难→ 排序能够将成千上万条结果缩减至几条结果，因此非常重要实际上，大部分用户只看 1 到 3 条结果结果显示顺序对行为的影响：摘要阅读 Viewing Abstracts：用户更可能阅读前几页的结果的摘要结果排序的实现tf 存储、idf 存储：tf 和 position 存在倒排索引idf 存到词典精确 top K 检索及其加速：目标：从文档集的所有文档中找出 K 个离查询最近的文档一般步骤：评分 -&gt; 排序 -&gt; 选前 K 个加速方案 1. 加快余弦相似度计算 —— 无权重查询一般来说没有高效的加速方法，但如果查询很短，普通的索引可以支持这种快速计算特例 —— 不考虑查询词项的权重查询的多个词项无权重。相当于假设查询的每个词项都出现 1 次例如 query = “jealous gossip”，归一化的两个非零向量都是 $\\large \\vec{v}(q)=\\frac{1}{\\sqrt{1+1} }=0.707 $排序只需要相对得分→ 不需要对查询向量归一化→ 只需要计算非归一化 $\\vec{V}(q)$ 和归一化 $\\vec{v}(d)$ ，计算两者乘积加速方案 2. 不排序而选 Top K —— 堆排序法 N 中选 K加速方案 3. 不计算所有 N 篇文档的评分 —— 提前终止计算静态质量：与查询无关的另一种反映结果好坏程度的指标前面的倒排记录表都按照 docID 排序docID 按照页面的 PageRank g(d) 排序（度量有多少好页面指向 d 的一种指标）最后得分：PageRank 和余弦相似度线性组合$\\text {net-score}(q, d)=g(d)+\\cos (q, d)$提前终止计算：检索算法按照 $doc_1, doc_2, \\cdots $ ，依次计算，当出现处理的文档 g(doc) &lt; 0.1而目前找到的 Top K 的文档得分中最小的都 &gt; 1.2后续文档的得分 $\\text {net-score}(q, d)=g(d)+\\cos (q, d)$ 不可能超过 1.1，因为 cos&lt;1 且 g&lt;0.1所以已得到 Top K 结果，不需再进行后续计算精确 top K 检索的问题：仍无法避免大量文档参与计算→ 能否尽量减少参与计算文档的数目→ 丢失部分正确性—— 非精确 Top K 检索，尽管非真正 Top K 但结果非常接近目的是得到与查询匹配的结果，让用户满意余弦相似度是刻画用户满意度的一种方法非精确 Top K 检索：一般思路：找一个文档集合 A，有 K &lt; |A|&lt;&lt; N利用 A 中的 Top K 结果作为整个文档集的 Top K 结果给定查询，A 是整个文档集上近似剪枝得到的结果该思路不仅适用于余弦相似度得分策略一 —— 索引去除 Index Elimination引入：显然地，我们只考虑包含至少 1 个查询词项的文档拓展 1. 只考虑 idf 值超过阈值的文档优点：含有低 idf 值的词项的文档很多，这种方法可以去除大量无关文档例子：在查询 catcher in the rye 时，只有 catcher 和 rye 的倒排记录表才会被遍历显然，in 和 the 的作用很小 (idf很小)拓展 2. 只考虑包含多个查询词项的文档对于多词项查询，只考虑那些包含较多查询词项的文档可以在倒排记录表遍历过程中实现比如，至少含有超过 3/4 的查询词项策略二 —— 胜者表 Champion List预处理：对于词典中每个词项 t，选出 $\\large tf_t$ 最高的 r 篇文档，构造成 t 的胜者表r 的值在索引建立时确定 （可能出现 r&lt;K）给定查询 q ，对 q 的所有词项的胜者表求并集生成集合 A再根据余弦相似度大小从 A 选出 Top K策略三 —— 静态得分希望排序靠前的文档是 相关+权威 的相关性 通过余弦相似度得分判断权威性 文档本身的属性决定，与 query 无关权威度计算每篇文档与查询无关的值 g(d)最终文档排名基于 g(d) 和相关度做线性组合$\\text {net-score}(q, d)=g(d)+\\cos (q, d) $等权重、不同权重皆可线性函数、任何形式的函数基于 net-score 的 Top K 文档检索1、先按照 g(d) 降序排序（优点：高分文档在前期出现，时间受限时可提前结束遍历）2、并行遍历不同查询词项的倒排记录表，做 倒排记录表合并、余弦相似度计算结合全局胜者表选好 r 值，预处理：对每个词项 t ，找出 $\\large \\text{g}(d)+\\text{tf-idf}_{td} $ 得分最高的 r 篇文档对所有全局胜者表的并集中文档计算最后得分，取 Top K高端表和低端表 High list、Low list：对每个词项 t，维护两个倒排记录表，分别为高端表和低端表（高端表即可看作胜者表）遍历倒排记录表，先遍历高端表返回 Top K，数量不足时继续遍历低端表补足 K 个（该思路可直接基于词项权重，不需要全局量 g(d)，实际上是相当于整个索引分层）策略四 —— 影响度排序 Impact以前都是对文档采用单一排序方式，能支持并发扫描现在，多个 Term 对应文档的词项不统一（多种顺序）→ 不能并发扫描多个倒排记录表来计算得分词项为单位的得分计算 (term-at-a-term)：在遇到每个词项时，得分累加思路：将词项 t 对应的所有文档 d 按照 $\\large tf_{t,d}$ 降序排序不同文档对不同的 t 有不同的顺序降低用于累加得分的文档数目的思路 1 —— 提前结束对词项 t 的倒排记录表从前往后扫描→ 在扫描了 r 篇固定数目文档时可提前结束→ 在当前 $\\large tf_{t,d}$ 低于某个阈值时可提前结束降低用于累加得分的文档数目的思路 2 —— 词项按 idf 降序query 的词项按照 idf 降序→ 对最终得分贡献大的理应被优先考虑查询处理过程中自适应处理→ 遇到较低 idf 值的查询词项时，根据与前一个查询词项的文档得分的改变值 (即累加得分的增量)，来决定是否停止例如：查询 catcher in the rye ，idf 降序后是 catcher rye in the，依次处理到 in 时，发现分数改变值很小，对排序影响很小，终止策略五 —— 簇剪枝方法 （一种聚类方法）预处理：随机选 $\\sqrt{N}$ 篇文档作为先导者为什么随机 → 速度快、先导者能反映数据分布情况对于其他文档，计算和它最近的先导者追随者：依附在先导者上的文档一个先导者平均有 $\\sqrt{N}$ 的追随者查询处理：给定查询 q，通过与先导者计算余弦相似度，找出和它最近的一个先导者 L候选集合 A：包括 L 及其追随者对 A 中的所有文档计算余弦相似度推广化：引入两个参数 $b_1、b_2$→ 追随者分配给离它最近的 $b_1$ 个先导者 （上述方法 $b_1=1$）→ 找出离查询最近的 $b_2$ 个先导者（上述方法 $b_2=1$）完整的搜索系统层次索引：胜者表的一般化形式最重要, ..., 最不重要可用 静态得分 (查询无关) 或其他得分 衡量倒排记录表按重要性降序，分层，转化为，层次索引查询只用上层索引，返回结果不足 K 时往下层检索查询词项的邻近性：自由文本 查询：用户输入几个词项到搜索框（一般的 Web 检索）令文档 d 中包含所有查询词项的最小窗口大小为 w，其取值为窗口内词的个数例子：某篇文档 = The quality of mercy is not strained查询 = strained mercy在此文档中的最小窗口大小是 4理解为 “滑动窗口” 即可窗口大小来度量位置关系查询分析器：自由文本查询对用户输入的关键词，可能需要基于底层索引结果，对多个查询进行处理如查询 rising interest rates之类时，查询分析器可能做如下操作：1、将输入的查询字符串看成整个短语查询2、如果包含短语 rising interest rates 的文档数目少于10 篇，那么会将原始查询看成 rising interest 和 interest rates 两个查询短语，同样通过向量空间方法来计算3、若结果仍少于 10 个，重新利用向量空间模型求解，认为 3 个查询词项之间互相独立综合评分：已经介绍的评分函数 —— 余弦相似度、静态得分、邻近性如何组合最优？通用方法 —— 机器学习通过机器学习找到较优的组合搜索系统组成：第七章 检索评价有关检索评价IR 系统的目标：较少消耗尽快、全面结果准确IR 中评价指标：效率 Efficiency时间空间响应速度效果 Effectiveness返回的文档中有多少相关文档所有相关文档中返回了多少返回得靠不靠前其他指标覆盖率(Coverage)访问量数据更新速度效果的评价方法：相同的文档集合，相同的查询主题集合，相同的评价指标，不同的检索系统进行比较。The Cranfield Experiments, Cyril W. Cleverdon, 1957–1968 (上百篇文档集合)SMART System, Gerald Salton, 1964-1988 (数千篇文档集合)TREC (Text REtrieval Conference), Donna Harman, 美国标准技术研究所, 1992 – 今 (上亿篇文档)，信息检索的“奥运会”评价的几部分：评价指标：某个或某几个可衡量、可比较的值评价过程：设计上保证公平、合理无序检索结果的评价评价指标分类：对单个查询进行评估的指标—— 在单个查询上检索系统的得分对多个查询进行评估的指标—— 在多个查询上检索系统的得分文档集合的划分：评价指标：召回率 Recall ：返回的相关结果数占实际相关结果总数的比率，也称查全率$\\Large R=\\frac{R R}{R R+N R} \\in [0,1] $正确率 Precision：返回的结果中真正相关结果的比率，也称查准率$\\Large P=\\frac{R R}{R R+R N} \\in [0,1]$两个指标分别度量检索效果的某个方面，忽略任何一个方面都有失偏颇。两个极端情况：– 返回有把握的 1 篇，P=100%，但 R 极低；– 全部文档都返回，R＝1，但 P 极低查准率和召回率的应用领域：拼写校对中文分词文本分类人脸识别……关于查准率和召回率的讨论：“宁可错杀一千，不可放过一人”➔ 偏重召回率，忽视查准率。冤杀太多。判断是否有罪：无证据证明无罪，那判定有罪 ➔ 召回率高，受冤枉无证据证明有罪，那判定无罪 ➔ 召回率低，逍遥法外虽然 Precision 和 Recall 都很重要，但不同应用、不同用户可能对两者的要求不一。因此，实际应用中应该考虑清楚。垃圾邮件过滤：宁愿漏掉一些垃圾邮件，但尽量少将正常邮件判成垃圾邮件有些用户希望返回的结果全一点，他有时间挑选；有些用户希望返回结果准一点，他不需要结果很全就能完成任务P/R 指标的方差：对于一个测试文档集来说，某些信息需求上效果很差，但在其他信息需求上效果很好 （R=0.1，P=0.2 或 P=0.95）实际上，同一系统在不同查询上的结果差异 往往高于 不同系统在同一查询上的结果也就是说，信息需求有难易之分查准率和召回率的问题：召回率难以计算解决方法：Pooling 方法，或者不考虑召回率两个指标分别衡量了系统的某个方面，但是也为比较 带来了难度，究竟哪个系统好？解决方法：将两个指标融成一个指标两个指标都是基于 (无序) 集合进行计算，并没有考虑顺序的作用举例：两个系统，对某个查询，返回的相关文档数目一样都是 10，但是第一个系统是前 10 条结果，后一个系统是最后 10 条结果。显然，第一个系统优。但是根据上面基于集 合的计算，显然两者指标一样。解决方法：引入序的作用关于召回率的计算：缓冲池 (Pooling) 方法：对多个检索系统的 Top N 个结果组成的集合进行人工标注，标注出的相关文档集合作为整个相关文档集合。因为对于大规模语料集合，列举每个查询的所有相关文档是不可能的事情，不可能准确地计算召回率缓冲池做法被验证是可行的 (可以比较不同系统的相对效果)，在 TREC 会议中被广泛采用使用查准率/召回率的问题：需要在大规模的文档集合和查询集合上进行计算需要人工对返回的文档进行评价由于人的主观因素，人工评价往往不可靠评价是二值的无法体现细微的差别文档集合和数据来源不同，结果也不同，有严重的偏差评价结果只适用于某个范围，很难引申到其他的范围一个综合评价准则 —— $F=P$ 和 $R$ 融合：F 值 (F-measure)：召回率 R 和查准率 P 的加权调和平均值为什么？调和平均比较“保守”-调和平均小于算术平均和几何平均-如果采用算术平均计算 F 值，那一个返回全部文档的搜索引擎的 F 值就不低于 50%，这过高做法：不管是 P 还是 R，如有一个偏低，那么结果应该表现出来，即这样的情形下最终的 F 值应该有所惩罚采用 P 和 R 中的最小值可能达到上述目的但是最小值方法不平滑而且不易加权基于调和平均计算出的F值可以看成是平滑的最小值函数$\\huge F=\\begin{cases} F=0, &amp;P=0\\ or\\ R=0 \\ F_{\\beta}=\\frac{1}{\\alpha \\frac{1}{P}+(1-\\alpha) \\frac{1}{R} } \\xlongequal{\\beta^{2}=\\frac{1-\\alpha}{\\alpha} } \\frac{\\left(1+\\beta^{2}\\right) P R}{\\beta^{2} P+R} , &amp;P \\neq 0,\\ R \\neq 0 \\end{cases} $$F_\\beta $ ：表示召回率的重要程度是查准率的 $\\beta\\ge 0$ 倍$\\beta &gt;1$ 更重视召回率，$\\beta &lt;1$ 更重视查准率一般取等权重，$\\large F_{\\beta=1}=\\frac{2 P R}{P+R}(P \\neq 0, R \\neq 0) $精确率 Accuracy：精确率是所有判定中正确的比率，即被正确判定 (相关→相关，不相关→不相关) 的文档占总文档的百分比accuracy = (RR+NN)/(RN + RR + NR + NN)为什么通常使用 P、R、F 而不使用精确率？信息检索当中精确率为什么不可用？由于和查询相关的文档毕竟占文档集的极少数，所以即使什么都不返回也会得到很高的精确率什么都不返回可能对大部分查询来说可以得到 99.99% 以上的精确率信息检索用户希望找到某些文档并且能够容忍结果中有一定的不相关性返回一些即使不好的文档也比不返回任何文档强因此，实际中常常使用 P、R 和 F1，而不使用精确率课堂练习，计算 P、R、$F_1$：P=18/20， R=18/100，F1=(2*18/20*18/100)/(18/20+18/100)=0.3A=(18+1000000000)/(18+2+82+1000000000)有序检索结果的评价评价排序后的结果：P、R、F 值都是基于无序集合的评价方法。→如果搜索引擎输出为有序的检索结果时，需要扩展。对于一个特定检索词的有序检索结果– 系统可能返回任意数量的结果 (=N)– 考虑 Top k 返回的情形 (k=0,1,2,…,N)– 则每个 k 的取值对应一个 R 和 P→ 可以计算得到查准率-召回率曲线查准率-召回率 曲线 (Precision-Recall curve)用户观察过程中，正确率和召回率在不断变化 (vary)：检索结果以排序方式排列，用户不可能马上看到全部文档可以求出在召回率分别为 0%,10%,20%,30%,…, 90%,100% (11点) 上对应的查准率，然后描出曲线位于上面的曲线对应的系统结果更好例子：某个查询 q 的标准答案集合为：$R_{q}=\\left{\\mathrm{d}{3}, \\mathrm{d}{5}, \\mathrm{d}{9}, \\mathrm{d}{25}, \\mathrm{d}{39}, \\mathrm{d}{44}, \\mathrm{d}{56}, \\mathrm{d}{71}, \\mathrm{d}{89}, \\mathrm{d}{123}\\right}, \\quad\\left|R_{q}\\right|=10$某个 IR 系统对 q 的检索结果如下插值查准率：原始的曲线常常呈现锯齿状 (左图) 原理：如果第 (K+1) 篇文档不相关，则召回率不变，但准确率下降，所以曲线会下降。如果第 (K+1) 篇文档相关，则召回率和查准率都上升。需要去掉锯齿，进行平滑，采用插值查准率 (interpolated precision)，记为 Pinterp在召回率为 r 的位置的插值查准率：召回率不小于 r 的位置上的查准率的最大值，即 (见右图)既每个点往右找最大的 P$\\Large P_{\\text {interp } }(r)=\\max\\limits_{r^{\\prime}&gt;r} P\\left(r^{\\prime}\\right)$例子的插值（每个点向右找最大的 P）：解决的问题：把前面的例子改为 $R_{q}=\\left{\\mathrm{d}{3}, \\mathrm{d}{56}, \\mathrm{d}_{129}\\right} $ * 此时不存在 10%, 20%,…,90% 的召回率点，而只存在 33.3%, 66.7%, 100% 三个召回率点 在这种情况下，需要利用存在的召回率点对不存在的召回率点进行插值 (interpolate) * 对于 t%，如果不存在该召回率点，则定义 t% 为从 t% 到 (t+10)% 中最大的正确率值。 * 对于上例， 0%, 10%, 20%, 30% 上正确率为0.33， 40%~60% 对应0.25， 70% 以上对应0.2基于 P-R 曲线的单一指标：引入 —— P-R 的优缺点优点：简单直观既考虑了检索结果的覆盖度，又考虑了检索结果的排序情况缺点：单个查询的直观，两个查询的检索结果优劣难以表示→ 曲线图虽好，但评价标准若能浓缩成一个数字，将绝杀固定检索等级的查准率 —— Precision@k, 前 k 个结果的查准率对大多数的 web 搜索合适，因为用户看重的是在前几页中有多少好结果但这种平均的方式不好，是通常所用指标中最不稳定的11 点平均正确率 (11 point average precision)：对每个信息需求，插值的正确率定义在 0、0.1、0.2、…、0.9、1.0 共十一个召回率水平上对于每个召回率水平，对测试集中多个查询在该点的插值正确率求算术平均。平均查准率 (Average Precision, AP)：对不同召回率点上的正确率进行平均例子：查询 Q 共有 6 个相关结果，某系统排序返回了 5 篇相关文档，其位置分别是第 1，第 2，第 5，第 10，第 20 位未插值的 AP:AP=(1/1+2/2+3/5+4/10+5/20+0)/6，等价于 6 点平均插值的AP：在召回率分别为 0, 0.1, 0.2, …, 1.0 的十一个点上的正确率求平均，等价于 11 点平均AP= (1+1+2/3+2/3+3/5+3/5+4/10+5/20+5/20+5/20+5/20)/11只对返回的相关文档进行计算的 AP：倾向那些快速返回结果的系统，没有考虑召回率，等价于 5 点平均AP=(1/1+2/2+3/5+4/10+5/20)/5如果不考虑召回率的指标Precision@N：在第 N 个位置上的正确率对于搜索引擎，大量统计数据表明，大部分搜索引擎用户只关注前一、两页的结果，因此，P@10, P@20 对大规模搜索引擎来说是很好的评价指标bpref、NDCG，后面介绍====前面都是对单个查询评估的指标，如今是多个查询上检索系统的得分求平均====宏平均 与 微平均：宏平均(Macro Average)：对每个查询求出某个指标，然后对这些指标进行算术平均微平均(Micro Average)：将所有查询视为一个查询，将各种情况的文档总数求和，然后进行指标的计算如：Micro Precision=(对所有查询检出的相关文档总数)/(对所有查询 检出的文档总数)宏平均对所有查询一视同仁，微平均受返回相关文档数目比较大的查询影响 (宏平均保护弱者)课堂练习：两个查询 q1、q2 的标准答案数目分别为 100 个和 50 个，某系统对 q1 检索出 80 个结果，其中正确数目为 40，系统对 q2 检索出 30 个结果，其中正确数目为 24，求 MacroP/MacroR/MicroP/MicroR：$\\begin{array}{l}\\mathrm{P}{1}=40 / 80=0.5, \\mathrm{R}{1}=40 / 100=0.4 \\\\mathrm{P}{2}=24 / 30=0.8, \\mathrm{R}{2}=24 / 50=0.48 \\\\mathrm{MacroP}=\\left(\\mathrm{P}{1}+\\mathrm{P}{2}\\right) / 2=0.65 \\\\text {MacroR}=\\left(\\mathrm{R}{1}+\\mathrm{R}{2}\\right) / 2=0.44 \\\\text {MicroP}=(40+24) /(80+30)=0.58 \\\\text {MicroR}=(40+24) /(100+50)=0.43\\end{array} $平均查准率均值 Mean Average Precision，MAP：返回每个相关文档位置上查准率的平均值，被称为平均查准率 (AP)运用宏平均，对所有查询求宏平均，得到平均查准率均值 (MAP)$\\huge MAP(Q)=\\underbrace{\\frac{1}{|Q|} \\sum\\limits_{j=1}^{|Q|} \\underbrace{\\frac{1}{m_{j} } \\sum\\limits_{k=1}^{m_{j} } \\operatorname{Precision}\\left(R_{j k}\\right)}{\\mathrm{AP} }}{\\text{MAP} }$Q 为查询集合$q_j \\in Q $ 表示第 j 个查询$q_j$ 对应的索引里所有相关文档集合 $\\large {d_1,d_2,\\cdots, d_{m_j}}$$R_{jk}$ 是查询 $q_j$ 返回的列表中第 k 个相关文档 (注意是相关文档，不一定是 1、2、3、4延续下去)$Precision(R_{jk})$ 表示在位置 k 时的查准率（仅考虑 1 到 k 个文档） * 补充：MacroF = F 的平均，MicroF = 用 MicroP、MicroR 来算 FP 和 AP 的区别：面向用户的评价指标：前面的指标都没有考虑用户因素。而相关不相关由用户判定假定用户已知的相关文档集合为 U，检索结果和 U 的交集为 $R_u$覆盖率 (Coverage) ：$C=|R_u|/|U|$，表示系统找到的用户已知的相关文档比例假定检索结果中返回一些用户以前未知的相关文档 $R_k$新颖率 (Novelty Ratio)：$N=|R_k|/(|R_u|+|R_k|)$，表示系统返回的新相关文档的比例近几年新的评价指标 —— GMAP、NDCG、MRRGMAP (Geometric MAP)：TREC2004 Robust 任务引进几何平均值$\\Large G M A P=\\sqrt[n]{\\prod\\limits_{i=1}^{n} A P_{i} }=\\exp \\left(\\frac{1}{n} \\sum\\limits_{i=1}^{n} \\ln A P_{i}\\right) $一般用第一个式子算，n 为查询数目先看一个例子 从 MAP 来看，系统 A 好于系统 B，但是从每个查询来 看，3 个查询中有 2 个 Topic B 比 A 有提高，其中一个提高的幅度达到 300% $GMAP_A = 0.056，GMAP_B=0.086 $ $GMAP_A \\lt GMAP_B $GMAP 和 MAP 各有利弊，可以配合使用如果存在难 Topic 时，GMAP 更能体现细微差别NDCG, Normalized Discounted Cumulative Gain 归一化折损累计增益：每个文档不仅仅只有相关和不相关两种情况，而是有相关度级别，比如 0,1,2,3可以假设，对于返回结果：– 相关度级别越高越好– 相关度级别越高的结果越多越好– 相关度级别越高的结果越靠前越好CG, Cumulative Gain 累计增益检索结果相关性分数的总和只考虑文档相关性级别不考虑文档位置$\\Large CG=\\frac{1}{|Q|} \\sum\\limits_{j=1}^{|Q|} \\sum\\limits_{m=1}^{k} R(j, m) $j, 第 j 个查询R(j, m) 是评价人员给出的文档 $d_m$ 对查询 $q_j $ 的相关性得分m 是返回结果文档的位置，k 是前 k 个位置DCG, Discounted Cumulative Gain 折损累计增益检索结果相关性分数的总和考虑文档相关性级别考虑文档位置：修改结果越靠前越好，越靠后越不好$\\Large D C G=\\frac{1}{|Q|} \\sum\\limits_{j=1}^{|Q|} \\sum\\limits_{m=1}^{k} \\frac{R(j, m)}{\\log {2}(m+1)}=\\frac{1}{|Q|} \\sum\\limits{j=1}^{|Q|}\\left[R(j, 1)+\\sum\\limits_{m=2}^{k} \\frac{R(j, m)}{\\log _{2}(m+1)}\\right]$其中 $\\frac{R(j, m)}{\\log _{2}(m+1)} $ 是 Discount商业常用的一个公式，增加相关性级别的权重：$\\Large D C G=\\frac{1}{|Q|} \\sum\\limits_{j=1}^{|Q|} \\sum\\limits_{m=1}^{k} \\frac{2^{R(j, m)}-1}{\\log _{2}(m+1)}$j, 第 j 个查询R(j, m) 是评价人员给出的文档 $d_m$ 对查询 $q_j $ 的相关性得分，当 $R(j,m)\\in{0,1} $ 时，两个公式等价m 是返回结果文档的位置，k 是前 k 个位置NDCG, Normalized Discounted Cumulative Gain 归一化折损累计增益同一查询，不同系统返回的结果数量不同，而 DCG 是一个累加值，没法量化两个不同的系统，因此要进行归一化。$NDCG=\\frac{DCG}{IDCG} $IDCG 为理想情况下最大 DCG$\\begin{aligned}\\operatorname{NDCG}(Q, k) &amp;=\\operatorname{NDCG} @ k=\\frac{1}{|Q|} \\sum_{j=1}^{|Q|} Z_{j} \\sum_{m=1}^{k} \\frac{R(j, m)}{\\log {2}(m+1)} \\ 或\\operatorname{NDCG}(Q, k) &amp;=\\operatorname{NDCG}(\\widehat{a}) k=\\frac{1}{|Q|} \\sum{j=1}^{|Q|} Z_{j} \\sum_{m=1}^{k} \\frac{2^{R(j, m)}-1}{\\log _{2}(m+1)}\\end{aligned} $j, 第 j 个查询R(j, m) 是评价人员给出的文档 $d_m$ 对查询 $q_j $ 的相关性得分m 是返回结果文档的位置，k 是前 k 个位置$Z_j $ 是归一化因子，保证对整个查询 NDCG 的最大值为 1例子：MRR，Mean Reciprocal Rank：倒数排名 Reciprocal Rank：第一个正确答案的位置倒数积平均倒数排名 MRR：是多个查询结果的平均值$\\large \\mathrm{MRR}=\\frac{1}{Q} \\sum\\limits_{i=1}^{Q} \\frac{1}{r a n k_{i} } $ranki 第 i 个查询的第一个正确答案的位次如果没有正确答案，那么导数排名 = 0关于评价方面的研究：现有评价体系远没有达到完美程度对评价的评价研究指标的相关属性 (公正性、敏感性) 的研究新指标的提出 (新特点、新领域)指标的计算 (比如Pooling方法中如何降低人工代价?)结果摘要结果的呈现 —— 摘要：对与查询相关的检索结果排序后，可以展现一个列表通常情况，这个列表包含文档的标题和一段摘要 (Snippet) 摘要 Snippet：标题通常是从文档的元数据中自动抽取出来的这个描述信息非常重要，用户可以根据它来判断这个文档是不是相关两种基本类型静态：不论输入什么查询，文档的静态摘要都是不变的动态：而动态摘要依赖于查询，它试图解释当前文档返回的原因静态摘要 Summarization：一般系统中静态摘要是文档的一个子集最简单的启发式方法：返回文档的前 50 个左右的单词作为摘要更复杂的方法：从文档中返回一些重要句子组成摘要可以采用简单的 NLP 启发式方法来对每个句子打分将得分较高的句子组成摘要也可以采用机器学习方法，参考第 13 章最复杂的方法：通过复杂的 NLP 方法合成或者生成摘要对大部分 IR 应用来说，最复杂的方法还不够成熟动态摘要：给出一个或者多个 “窗口” 内的结果 (snippet) ，这些窗口包含了查询词项的多次出现如果查询是短语，出现查询短语的 Snippet 优先；如果查询是多个词项，在一个小窗口内出现查询词项的 Snippet 优先最终将所有 Snippet 都显示出来作为摘要动态摘要的生成：基于位置索引来构建动态摘要不太合适，至少效率上很低需要对文档进行缓存通过位置索引会知道查询词项在文档中的出现位置文档的缓存版本可能会过时不缓存非常长的文档，对这些文档只需要缓存其一个短前缀文档小结：信息检索的评价方法不考虑序的检索评价指标 (即基于集合)：P、R、F考虑序的评价指标：P/R曲线、MAP、NDCG检索结果的摘要第八章 相关反馈及查询扩展Relevance Feedback &amp; Query Expansion本章主要内容 —— 两种提高召回率的方法：交互式相关反馈 Interactive relevance feedback：在初始化检索结果的基础上，通过用户交互指定哪些文档相关或不相关，然后改进检索的结果最著名的相关反馈方法：Rocchio 相关反馈查询扩展 Query Expansion：通过在查询中加入同义或者相关词项来提高检索结果相关词项来源：人工编辑的同义词辞典、自动构造的同义词辞典、查询日志等动机引入 / 原理：考虑文档 q: [aircarft]某篇文档 d 包含 “plane” 但是不包含 “aircraft”简单的 IR 系统对于查询 q 不会返回 d，即使他们相关→ 改变这种做法→ 返回不包含查询词项的相关文档关于召回率 Recall：本讲当中会放松召回率的定义，即(在前几页)给用户返回更多的相关文档这可能实际上会降低召回率比如，将 jaguar 扩展为 jaguar(美洲虎；一种汽车品牌) + panthera (豹属)可能会去掉一些相关的文档，但是可能增加前几页返回给用户的相关文档数提高召回率的方法：局部(local)方法: 对用户查询进行局部的即时的分析主要的局部方法: 相关反馈(relevance feedback)第一部分全局(Global)方法: 进行一次性的全局分析(比如分析整个文档集)来产生同/近义词词典 (thesaurus)利用该词典进行查询扩展第二部分相关反馈基础相关反馈的基本思想：用户提交一个 (简短的) 查询搜索引擎返回一系列文档用户将返回文档标记相关与不相关搜索引擎根据标记结果计算得到信息需求的一个新查询表示 （希望该表示好于初始的查询表示）搜索引擎对新查询进行处理，返回新结果新结果可望 (理想上说) 有更高的召回率相关反馈可以循环若干次相关反馈分类：用户相关反馈 / 显式相关反馈 (User Feedback or Explicit Feedback)：用户显式参加交互过程隐式相关反馈 (Implicit Feedback)：系统跟踪用户的行为来推测返回文档的相关性，从而进行反馈伪相关反馈 / 盲相关反馈 (Pseudo Feedback or Blind Feedback)：没有用户参与，系统直接假设返回文档的前 k 篇是相关的，然后进行反馈相关反馈的例子：例 1 类似页面例 2 图像检索例 3 向量空间 查询 “canine” 似犬的例 4 一个实际的例子 相关反馈详细介绍相关反馈中的核心概念 —— 质心：质心是一系列点的中心，前面将文档表示成高维空间中的点因此可用计算文档的质心$\\huge \\vec{\\mu}(C)=\\frac{1}{|C|} \\sum\\limits_{d \\in C} \\vec{d}$其中 C 是一个文档集合，$\\vec{d}$ 是文档 d 的向量表示相关反馈基本理论：基本理论：假定要找一个最优查询向量 q，它与相关文档之间的相似度最大且同时又和不相关文档之间的相似度最小最优的 $\\vec{q} $ 是使下式最大的查询 $\\vec{q}{opt} $ ：$\\huge \\vec{q}{o p t}= \\underset{\\vec{q} }{argmax} \\left[\\operatorname{sim}\\left(\\vec{q}, \\vec{\\mu}\\left(C_{r}\\right)\\right)-\\operatorname{sim}\\left(\\vec{q}, \\vec{\\mu}\\left(C_{n r}\\right)\\right)\\right]$$C_r$ 相关文档集$C_{nr}$ 不相关文档集$\\vec{\\mu}(C_r) $ 质心上述公式的意图是 $\\vec{q}_{o p t}$ 是将 相关文档、不相关文档 区分开的向量当 sim() 函数采用余弦相似度计算时，能够将相关文档与不相关文档区分开的最优查询向量为$\\huge \\vec{q}{o p t}=\\frac{1}{\\left|C{r}\\right|} \\sum\\limits_{\\bar{d}{i} \\in C{r} } \\vec{d}{i}-\\frac{1}{\\left|C{n r}\\right|} \\sum\\limits_{\\vec{d}{j} \\in C{r} } \\vec{d}_{j}$这即是说，最优的查询向量 等于 相关文档和不相关文档两者质心向量的差然而这个发现没有什么意义因为检索本来的就是要找相关文档，而所有的相关文档集事先是未知的Rocchio 算法：加入一些额外的假设，可将上式改写为：$\\Large \\vec{q}{\\text {opt} }=\\mu\\left(D{r}\\right)+\\left[\\mu\\left(D_{r}\\right)-\\mu\\left(D_{n r}\\right)\\right] $最优查询向量为：$\\Large \\begin{aligned}\\vec{q}{o p t} &amp;=\\mu\\left(D{r}\\right)+\\left[\\mu\\left(D_{r}\\right)-\\mu\\left(D_{n r}\\right)\\right] \\&amp;=\\frac{1}{\\left|D_{r}\\right|} \\sum_{\\vec{d}{i} \\in D{r} } \\vec{d}{i}+\\left[\\frac{1}{\\left|D{r}\\right|} \\sum_{\\vec{d}{i} \\in D{r} } \\vec{d}{i}-\\frac{1}{\\left|D{n r}\\right|} \\sum_{\\vec{d}{j} \\in D{n r} } \\vec{d}_{j}\\right]\\end{aligned}$$D_r$ 指已知的部分相关文档即将相关文档的质心移动一个 量（相关文档与不相关文档二者质心的差）Rocchio 的计算：Rocchio 1971 算法 （SMART 系统使用）：假定有一个用户查询，并知道部分相关文档 $D_r$ 和不相关文档 $D_{nr}$ 的信息，最优查询向量为：$\\Large \\vec{q}{m}=\\alpha \\vec{q}{0}+\\beta \\frac{1}{\\left|D_{r}\\right|} \\sum\\limits_{\\vec{d}{i} \\in D{r} } \\vec{d}{i}-\\gamma \\frac{1}{\\left|D{n r}\\right|} \\sum\\limits_{\\vec{d}{j} \\in D{nr} } \\vec{d}{j} $$\\vec{q}{m}$ 修改后的查询$\\vec{q}0$ 原始查询$D_r、D{nr}$ 已知的相关和不相关文档集合$\\alpha、\\beta、\\gamma$ 权重修改后的新查询从 $\\vec{q}_0$ 开始，向着相关文档的质心向量靠近了一段距离，而同时又与不相关文档的质心向量远离了一段距离即新查询向相关文档靠拢而远离非相关文档正反馈与负反馈正反馈价值往往大于负反馈比如可通过设置 $\\beta = 0.75，\\gamma = 0.25$ 来给正反馈更大的权重很多系统甚至只允许正反馈，即 $\\gamma=0$相关反馈中的假设：假设1：用户对于初始查询有充分的认识，知道使用哪些词项来表达不满足假设 1 的情况用户没有足够的知识来建立一个初始查询比如：拼写错误、跨语言、用户词汇与文档集词汇不吻合假设2：相关文档的原型有一种良好的形式相关文档的词项分布相似不相关文档的词项分布 和 相关文档的词项分布 不相似所有文档都紧密聚集在某个 prototype 周围，形成一个簇或者 —— 有多个不同的prototype, 但是它们之间的词汇具有显著的重合率相关文档和不相关文档之间的相似度很低不满足假设 2 的情况相关文档聚成几个不同的簇比如：文档子集使用不同的词汇 (Burma/Myanmar/缅甸)、某个查询的答案本续需要不同类的文档来组成 (Pop stars that worked at Burger King)通用概念需要多个具体概念体现相关反馈策略的评价：使用初始查询 q0，然后计算 “查准率-召回率率” 曲线使用相关反馈后修改的查询 qm，然后计算“查准率-查全率”曲线方法一、在整个文档集合上评价有显著的改善，但是有作弊的嫌疑部分原因是会把已知的相关文档排的很前需要用用户没有看到的文档集合来评价方法二、使用剩余的文档集合来评价 (总的文档集合减去评价过相关性的文档)评价结果往往比初始查询的结果差– 但是这种方法更现实– 可以用来有效地比较不同相关反馈方法之间的相对效果评价结果往往比初始查询的结果差但是这种方法更现实可以用来有效地比较不同相关反馈方法之间的相对效果方法三、使用两个文档集合在第一个文档集合上使用初始查询 q0，并进行相关反馈在第二个文档集合上使用初始查询 q0 和修改过的查询 qm 进行评价从经验上说，一轮相关反馈很有用。两轮相关反馈的效果就不那么明显。评价的误区：评价不同相关反馈方法的效用的时候，必须考虑消耗时间的要素代替相关反馈的方法：用户修改并重新提交查询 （相对于判断文档的相关性，用户可能更喜欢这样）没有证据能表明相关反馈占用了用户的时间就能给用户带来最大的效用相关反馈存在的问题：开销很大生成的新查询往往很长长查询的处理开销很大用户不愿意提供显式的相关反馈很难理解，为什么会返回 (应用相关反馈之后) 某篇特定文档Excite 搜索引擎曾经提供完整的相关反馈功能，但是后来废弃了这一功能隐式相关反馈：通过观察用户对当前检索结果采取的行为来给出对检索结果的相关性判定判定不一定很准确，但是省去了用户的显式参与过程对用户非当前检索行为或非检索相关行为的分析也可以用于提高检索的效果，这些是个性化信息检索(Personalized IR) 的主要研究内容，并非本节的主要内容优点：不需要用户显式参与，减轻用户负担用户行为某种程度上反映用户的兴趣，具有可行性缺点：对行为分析有较高要求准确度不一定能保证某些情况下需要增加额外设备间接相关反馈：可以使用间接的资源进行相关反馈 。 比如 DirectHit 搜索引擎DirectHit 将用户点击频率高的文档排在前面点击多的页面被认为是相关的从用户的点击记录中挖掘信息，进行相关反馈这种方法是全局的，并不依赖特定用户或查询这是点击流挖掘 (clickstream mining) 的典型应用场景现在这是通过机器学习产生排序的一部分用户行为种类：鼠标键盘动作点击链接、加入收藏夹、拷贝粘贴、停留、翻页等等用户眼球动作Eye tracking 可以跟踪用户的眼球动作拉近、拉远、瞟、凝视、往某个方向转伪相关反馈 Pseudo-relevance feedback：伪相关反馈对于真实相关反馈的人工部分进行自动化伪相关反馈算法对于用户查询返回有序的检索结果假定前 k 篇文档是相关的进行相关反馈 (如 Rocchio)平均上效果不错但是对于某些查询而言可能结果很差几次循环之后可能会导致查询漂移 (query drift)优点不用考虑用户的因素，处理简单很多实验也取得了较好效缺点没有通过用户判断，所以准确率难以保证不是所有的查询都会提高效果查询扩展查询扩展，是另一种提高召回率的方法使用 “全局查询扩 展 ” 来指那些 “查询重构 (query reformulation)的全局方法”在全局查询扩展中，查询基于一些全局的资源进行修改，这些资源是与查询无关的主要使用的信息:同义词或近义词词典 (thesaurus)两种同(近)义词词典构建方法：人工构建和自动构建用户反馈的类型：用户对文档提供反馈在相关反馈中更普遍用户对词或短语提供反馈在查询扩展中更普遍查询扩展的类型：基于同义词词典对查询中的每个词项 t, 将词典中与 t 语义相关的词扩充到查询中例子: HOSPITAL → MEDICAL通常会提高召回率可能会显著降低正确率，特别是对那些有歧义的词项INTEREST RATE → INTEREST RATE FASCINATE广泛应用于特定领域 (如科学、工程领域) 的搜索引擎中创建并持续维护人工词典的开销非常大人工词典和基于受控词汇表 (controlled vocabulary) 的标记的效果大体相当基于查询日志挖掘出的查询等价类 (Web 上很普遍，比如上面的 “palm” 例子)同(近)义词词典的构建：构建方法：人工构建的同(近)义词词典 (人工编辑维护的词典，如 PubMed)自动导出的同(近)义词词典 (比如，基于词语的共现统计信息)自动构建通过分析文档集中的词项分布来自动生成同(近)义词词典基本想法：计算词语之间的相似度定义 1: 如果两个词各自的上下文共现词类似，那么它们类似“car”≈“motorcycle”，因为它们都与 “road”、“gas” 及“license”之类的词共现，因此它们类似定义 2: 如果两个词同某些一样的词具有某种给定的语法关系的话，那么它们类似由 “harvest, peel, eat, prepare” apples 和 pears, 因此 apples 和 pears 肯定彼此类似共现关系更加鲁棒，而语法关系更加精确基于共现的词典构造简单的方法：通过词典-文档矩阵 A 计算词项-词项的相似度给定 A，其中 $A_{t,d} = (t,d)$ 词项 t 在文档 d 中的 (归一化) 权重计算 $C=AA^T$，其中元素 $C_{uv}$ 表示词项 u 和词项 v 的相似度对每个 $t_i$，选择 C 中高权重的词项进行扩展 搜索引擎中的查询扩展：搜索引擎进行查询扩展主要依赖的资源： 查询日志(query log)例 1: 提交查询 [herbs] (草药)后，用户常常搜索[herbal remedies] (草本疗法)→ “herbal remedies” 是 “herb”的潜在扩展查询例 2: 用 户 搜 索 [flower pix] 时 常 常 点 击 URL photobucket.com/flower，而用户搜索[flower clipart] 常点击同样的URL→ “flower clipart”和“flower pix” 可能互为扩展查询第九章 概率检索模型向量空间模型回顾概念：文档、查询都表示成向量计算两个向量之间的相似度：余弦相似度内积相似度在向量表示中的词项权重计算方法主要是 —— tf-idf 公式实际考虑 tf、idf 及文档长度 3 个因素优点：简洁直观，可以应用到很多其他领域 (文本分类、 生物信息学)支持部分匹配和近似匹配，结果可以排序检索效果不错缺点：理论上不够：基于直觉的经验性公式索引项之间的独立性假设与实际不符：实际上，term 的出现之间是有关系的，不是完全独立的。如 “王励勤” “乒乓球”的出现不是独立的。基本概率统计知识概率与统计：随机试验和随机事件：随机试验：可在相同条件下重复进行；试验可能结果不止一个，但能确定所有的可能结果；一次试验之前无法确定具体是哪种结果出现。掷一颗骰子，考虑可能出现的点数随机事件：随机试验中可能出现或可能不出现的情况叫 “随机事件”掷一颗骰子，4 点朝上概率和条件概率：概率：直观上来看，事件A的概率是指事件A发生的 可能性，记为P(A)掷一颗骰子，出现6点的概率为多少？条件概率：已知事件 A 发生的条件下，事件 B 发生的概率称为 A 条件下 B 的条件概率，记作 P(B|A)30 颗红球和 40 颗黑球放在一块，请问第一次抽取为红球的情况下第二次抽取黑球的概率？乘法公式、全概率公式、贝叶斯公式：乘法公式：$\\Large \\begin{aligned}&amp;\\mathrm{P}(\\mathrm{AB})=\\mathrm{P}(\\mathrm{A}) \\mathrm{P}(\\mathrm{B} | \\mathrm{A})\\&amp;\\mathrm{P}\\left(\\mathrm{A}{1} \\mathrm{A}{2} \\ldots \\mathrm{A}{n}\\right)=\\mathrm{P}\\left(\\mathrm{A}{1}\\right) \\mathrm{P}\\left(\\mathrm{A}{2} | \\mathrm{A}{1}\\right) \\mathrm{P}\\left(\\mathrm{A}{3} | \\mathrm{A}{1}\\mathrm{A}{2}\\right) \\ldots \\mathrm{P}\\left(\\mathrm{A}{n} | \\mathrm{A}{1} \\ldots \\mathrm{A}{n-1}\\right)\\end{aligned}$全概率公式：$A_1A_2\\cdots A_n$ 是整个样本空间的一个划分$\\Large P(B)=\\sum\\limits_{i=1}^{n} P\\left(A_{i}\\right) P\\left(B | A_{i}\\right)$贝叶斯公式：$A_1A_2\\cdots A_n$ 是整个样本空间的一个划分$\\Large P\\left(A_{j} | B\\right)=\\frac{P\\left(A_{j}\\right) P\\left(B | A_{j}\\right)}{\\sum\\limits_{i=1}^{n} P\\left(A_{i}\\right) P\\left(B | A_{i}\\right)},(j=1, \\ldots, n)$事件的独立性：两事件独立：事件 A、B，若 P(AB)=P(A)P(B)，则称 A、B 独立三事件独立：事件 A B C，若满足 $\\begin{cases}P(AB)=P(A)P(B)\\ P(AC)=P(A)P(C)\\P(BC)=P(B)P(C)\\ P(ABC)=P(A)P(B)P(C)\\end{cases}$ ，则称 A、B、C 独立多事件独立：两两独立、三三独立、四四独立….随机变量：随机变量：若随机试验的各种可能的结果都能用一个变量的取值 (或范围) 来表示，则称这个变量为随机变量，常用 X、Y、Z 来表示(离散型随机变量)：掷一颗骰子，可能出现的点数 X (可能取值 1、2、3、4、5、6)(连续型随机变量)：北京地区的温度 (-15~45)概率排序原理引入：给定查询 → 计算每个文档的相关度检索系统对用户查询的理解，是非确定的 (uncertain)，对返回结果的猜测也是非确定的而概率理论为非确定推理提供了坚实的理论基础概率检索模型可以计算文档和查询相关的可能性概率检索模型：通过概率的方法将查询和文档联系起来定义 3 个随机变量 R、Q、D：相关度 R={0,1}，相关或不相关查询 Q={q1,q2,…}文档 D={d1,d2,…}通过计算 条件概率 P(R=1 | Q=q, D=d) 来度量文档和查询的相关度概率模型包括一系列模型，如最经典的二值独立概率模型 BIM、BM25 模型等(还有贝叶斯网络模型)1998 出现的基于统计语言建模的信息检索模型本质上也是概率模型的一种概率排序原理 PRP, Probability Ranking Principle：利用概率模型来估计，每篇文档和需求的相关概率 P(R=1 | d,q)然后对结果进行排序最简单的 PRP 情况检索没有任何代价因子，或者说不会对不同行为或错误采用不同的权重因子在 返回一篇不相关文档 / 返回一篇相关文档不成功 的情况下，将失去 1 分(在计算精确率时这种基于二值的情形也往往称为 1/0 风险)检索的目标是对于用户任意给定的 k 值，返回可能性最高的前 k 篇文档作为结果输出。即，PRP 希望可以按照 P(R=1|d,q) 值的降序来排列所有文档定理 11-1：在 1/0 损失的情况下，PRP 对于最小化期望损失 (也称为贝叶斯风险) 而言是最优的基于检索代价的概率排序原理：$C_0$ 表示检索到一篇不相关文档发生的代价$C_1$ 表示未检索到一篇相关文档所发生的代价PRP 认为，如果对于一篇特定的文档 d 及所有其他未返回的文档 d′ 都满足$\\LargeC_{0} \\cdot P(R=0 | d)-C_{1} \\cdot P(R=1 | d) \\leq C_{0} \\cdot P\\left(R=0 | d^{\\prime}\\right)-C_{1}P\\left(R=1 | d^{\\prime}\\right) \\ \\Large \\Rightarrow C_{0} \\cdot[1-P(R=1 | d)]-C_{1} \\cdot P(R=1 | d) \\le C_{0}-\\left(C_{0}+C_{1}\\right) P(R=1 | d)$二者相减表示返回文档 d 的代价函数，也即此时前者越低越好，后者越高越好，即 $P(R=1|d)$ 越高越好BIM 模型二值独立概率模型 BIM, Binary Independence Model：不考虑词项频率和文档长度伦敦城市大学和剑桥大小 1970 年代提出，代表系统 OKAPIBayes 公式是理解 BIM 的关键通过 Bayes 公式对条件概率 P(R=1 | q,d) 进行计算 观察到事件 B 已发生的条件下，寻找导致 B 发生的每个原因 $A_i$ 的概率 贝叶斯公式含义比较难理解，但是理解了就很好掌握以下。是一种生成式 (generative) 模型为了对概率函数 P(R | q,d) 进行估计，引入一些简单假设“二值” 等价于 布尔值：文档和查询都表示为词项出现与否的布尔向量即文档 d 表示为向量 $ \\vec{x} =(x_1, \\cdots, x_m) $ ，其中当词项 t 出现在文档 d 时， $x_t=1$由于不考虑词项出现的次数和顺序，许多不同文档可能有相同的向量表示类似地，将查询 q 表示成词项出现向量 $\\vec{q}$“独立性”：指词项在文档中出现是互相独立的，BIM 并不是被词项之间的关联BIM Bayes 公式的使用：后面的公式都是为了对一个文档进行排序而推导，此时只有一个查询 q，q 作为条件概率的条件，”全有就是没有”，适当忽视 q ，可以获得更好的理解在 BIM 模型下，基于词项出现向量的概率 $P(R|\\vec{x},\\vec{q})$ 对概率 $P(R|d, q)$ 建模，利用贝叶斯定理，有 $\\Large \\begin{aligned}&amp;P(R=1 | \\vec{x}, \\vec{q})=\\frac{P(\\vec{x} | R=1, \\vec{q}) P(R=1 | \\vec{q})}{P(\\vec{x} | \\vec{q})}\\&amp;P(R=0 | \\vec{x}, \\vec{q})=\\frac{P(\\vec{x} | R=0, \\vec{q}) P(R=0 | \\vec{q})}{P(\\vec{x} | \\vec{q})}\\end{aligned} $对于上述公式，适当忽视 q，可以把 q 去掉来理解：$\\Large P(R=1 | \\vec{x})=\\frac{P(\\vec{x} | R=1) P(R=1 | \\vec{q})}{P(\\vec{x} )} $ 此时就是一个贝叶斯公式了，“没有就是所有”，再给等式左右分子分母加上 q 作为条件，就得到了上上面的公式。$P(\\vec{x} | R=1, \\vec{q})$ 和 $P(\\vec{x} | R=0, \\vec{q})$ 分别表示当返回一篇相关或不相关文档时生成文档 $\\vec{x}$ 的概率即，R=1 同时查询词项出现向量是 q 的发生情况下，寻找生成文档词项出现向量为 x 的概率$P(R=1 | \\vec{q})$ 和 $P(R=0 | \\vec{q})$ 分别表示对于查询 $\\vec{q}$ 返回一篇相关或不相关文档的先验概率BIM 排序函数的推导：对每个 d 定义优势率函数：优势率 $\\Large O(A)=\\frac{P(A)}{P(\\bar{A})}=\\frac{P(A)}{1-P(A)} $你可以理解我这个事件发生的概率比不发生概率的 “优势”$\\Large O(R | \\vec{x}, \\vec{q})=\\frac{P(R=1 | \\vec{x}, \\vec{q})}{P(R=0 | \\vec{x}, \\vec{q})}=\\frac{\\frac{P(R=1 | \\vec{q}) P(\\vec{x} | R=1, \\vec{q})}{P(\\vec{x} | \\vec{q})} }{\\frac{P(R=0 | \\vec{q}) P(\\vec{x} | R=0, \\vec{q})}{P(\\vec{x} | \\vec{q})} }=\\frac{P(R=1 | \\vec{q}) P(\\vec{x} | R=1, \\vec{q})}{P(R=0 | \\vec{q}) P(\\vec{x} | R=0, \\vec{q})} $其中 $\\frac{P(R=1 | \\vec{q}) }{P(R=0 | \\vec{q})}$ 对于同一个 q 是常量，与文档无关，对排序不起作用。（保留但忽视）$\\ \\Large 有\\ O(R | \\vec{q}) =\\frac{P(R=1 | \\vec{q})}{P(R=0 | \\vec{q})} \\quad 和\\quad \\frac{P(\\vec{x} | R=1, \\vec{q})}{P(\\vec{x} | R=0, \\vec{q})} \\xlongequal{词项间独立性}\\prod_{t=1}^{m} \\frac{P\\left(x_{t} | R=1, \\vec{q}\\right)}{P\\left(x_{t} | R=0, \\vec{q}\\right)} \\ \\Large \\Rightarrow O(R | \\vec{x}, \\vec{q})=O(R | \\vec{q}) \\prod\\limits_{t=1}^{m} \\frac{P\\left(x_{t} | R=1, \\vec{q}\\right)}{P\\left(x_{t} | R=0, \\vec{q}\\right)} \\ \\Large \\xrightarrow{二值：X_t 的取指 {0,1} } O(R | \\vec{x}, \\vec{q})=O(R | \\vec{q}) \\prod\\limits_{t: x_{t}=1} \\frac{P\\left(x_{t}=1 | R=1, \\vec{q}\\right)}{P\\left(x_{t}=1 | R=0, \\vec{q}\\right)} \\prod\\limits_{t: x_{t}=0} \\frac{P\\left(x_{t}=0 | R=1, \\vec{q}\\right)}{P\\left(x_{t}=0 | R=0, \\vec{q}\\right)} $$\\Large \\xrightarrow{\\begin{array}{l}p_{t}=P\\left(x_{t}=1 | R=1, \\vec{q}\\right) \\u_{t}=P\\left(x_{t}=1 | R=0, \\vec{q}\\right)\\end{array} } O(R | \\vec{x}, \\vec{q})=O(R | \\vec{q}) \\prod\\limits_{t: x_{t}=q_{t}=1} \\frac{p_{t} }{u_{t} } \\prod\\limits_{t:x_{t}=0, q_{t}=1} \\frac{1-p_{t} }{1-u_{t} } $$P_t $ 词项出现在一篇相关文档中的概率$u_t$ 词项出现在一篇不相关文档中的概率$q_t=1$ 表示词项在查询中出现 (=0不考虑)$t: x_{t}=q_{t}=1$ 出现在文档和查询中的查询词项的概率$t:x_{t}=0, q_{t}=1$ 出现在查询，但不出现在文档中的查询词项的概率RSV, Retrieval Status Value 检索状态值：从上述公式中可以看出，只有中间红色部分才会考虑到文档，这也是排序函数只需计算的东西$\\Large \\prod\\limits_{t: x_{t}=q_{t}=1} \\frac{p_{t}\\left(1-u_{t}\\right)}{u_{t}\\left(1-p_{t}\\right)}$最终用于排序的是$ \\huge R S V_{d}=\\log \\prod\\limits_{t: x_{t}=q_{t}=1} \\frac{p_{t}\\left(1-u_{t}\\right)}{u_{t}\\left(1-p_{t}\\right)}=\\sum\\limits_{t: x_{t}=q_{t}=1} \\log \\frac{p_{t}\\left(1-u_{t}\\right)}{u_{t}\\left(1-p_{t}\\right)}$设 $C_t $ 是查询词项的优势率比率的对数值$\\Large c_{t}=\\log \\frac{p_{t}\\left(1-u_{t}\\right)}{u_{t}\\left(1-p_{t}\\right)}=\\log \\frac{p_{t} }{1-p_{t} }+\\log \\frac{1-u_{t} }{u_{t} } $$\\large \\rightarrow RSV_d = 1 \\sum\\limits_{t: x_{t}=q_{t}=1} C_t$求 $C_t$ —— 理论上的概率估计方法 求 $C_t$ —— 实际上的概率估计方法ut 的估算：假设相关文档 S 只占所有文档的极小一部分，那么可通过整个文档集的统计数字来计算与不相关文档有关的量。pt的估算：如果知道某些相关文档，那么可以利用这些已知相关文档中的词项出现频率来对 pt 进行估计Croft 和 Harper (1979) 在组合匹配模型 (combination match model)中提出了利用常数来估计 pt 的方法Greiff (1998) 提出了 $p_t = \\frac{1}{3} + \\frac{2}{3} \\frac{df_t}{N} $BIM 模型小结：目的是求排序函数 $O(R | \\vec{x}, \\vec{q}) $首先估计或计算每个 term 分别在相关文档和不相关文档中的出现概率$p_t = P(t|R=1)$ 及 $u_t = P(t|R=0) $然后根据独立性假设，将 $\\frac{P(d|R=1)}{P(d|R=0)} $ 转化为 $p_t$ 和 $u_t$ 的某种组合，将 $p_t$ 和 $u_t$ 代入即可求解 BIM 模型的优缺点优点：建立在数学基础上，理论性较强缺点：需要估计参数原始 BIM 没有考虑 TF、文档长度因素BIM 中同样存在词项独立性假设BM25 模型 ★考虑词项频率和文档长度引入 —— 从 BIM 到 BM25：BIM 模型最初主要为 较短的编目记录 (catalog record) 和长度大致相当的摘要 所设计在这些环境下它用起来也比较合适。但对现在的全文搜索文档集来说， 显然模型应该重视词项频率和文档长度BM25 权重计算机制 (BM25 weighting scheme) 或 Okapi 权重计算机制 (Okapi weighting) (Spärck Jones 等人 2000)基于词项频率、文档长度等因子来建立概率模型不会引入过多的模型参数Okapi BM25 —— 一个非二值模型：考虑词项 $t_i$ 在文档中的 tf-idf 权重，有$\\huge \\operatorname{RSV}(Q, D)=\\sum\\limits_{t_{i} \\in D \\cup Q} W_{i}^{\\mathrm{IDF} } \\frac{\\left(k_{1}+1\\right) t f_{t_{i}, D} }{k_{1}\\left((1-b)+b \\times\\left(L_{D} / L_{a v e}\\right)\\right)+t f_{t_{i}, D} }$$W_{i}^{\\mathrm{IDF} } $ 是词项 $t_i$ 的 IDF 权重$tf_{t_{i}, D} $ 是词项 $t_i$ 在文档 D 中的词项频率$L_D $ 是文档 D 的长度$L_{ave}$ 是整个文档集的平均长度$k_1$ 是用于控制文档中词项频率权重的调节参数$b$ 是用于控制文档长度权重的调节参数本学期实验的 baseline 中 b=0.75, k1=2如果查询比较长，则加入查询的 tf$\\huge \\operatorname{RSV}(Q, D)=\\sum\\limits_{t_{i} \\in D \\cup Q} W_{i}^{\\mathrm{IDF} } \\cdot \\frac{\\left(k_{1}+1\\right) t f_{t, D} }{k_{1}\\left((1-b)+b \\times\\left(L_{D} / L_{a v e}\\right)\\right)+t f_{t i, D} } \\cdot \\frac{\\left(k_{3}+1\\right) t f_{t, Q} }{k_{3}+t f_{t, Q} }$本学期实验用的是这个公式$tf_{t_{i}, Q} $ 是词项 $t_i$ 在文档 Q 中的词项频率$k_3$ 是用于控制查询中词项频率比重的条件参数没有查询长度的归一化 (由于查询对于所有文档都是固定的)理想情况下，上述参数都必须在开发测试集上调到最优一般情况下，实验表明，k1 和 k3 应该设在 1.2 到 2 之间， b 设成 0.75另一个 BM25 写法：$\\Large\\operatorname{RSV}(Q, D)=\\sum\\limits_{t_{i} \\in D \\cup Q} \\ln \\frac{N-d f_{i}+0.5}{d f_{i}+0.5} \\cdot \\frac{\\left(k_{1}+1\\right) t f_{t i, D} }{k_{1}\\left((1-b)+b \\times\\left(L_{D} / L_{a v e}\\right)\\right)+t f_{t i, D} }\\cdot \\frac{\\left(k_{3}+1\\right) t f_{t_{i}, Q} }{k_{3}+t f_{t_{i}, Q} }$$df_i$ 是词项 $t_i$ 的 df第十章 基于语言建模的检索模型语言模型 Language Model概率语言模型及其比较传统概率模型 与 概率语言模型：传统概率模型：需要对文档 d 与查询 q 的相关概率 $P(R=1|q,d)$ 进行显式建模概率语言模型：首先对每篇文档 d 建模得到文档的概率语言模型 $M_d$然后按照模型生成查询 q 的概率 $P(q|M_d)$ 的高低来对文档进行排序建模实际上是建立了文档中词项的 distribution，这个文档有多大的概率生成这个查询 q比如文档中没有某个词，很难生成有这个词的 q语言模型的概念本质上也是基于概率的最简单的语言生成模型 Generative Model：一个简单的有穷自动机及其生成语言中的一些字符串→ 指向的是自动机的初始状态双圈节点对应的是 (可能的) 终止状态如果每个节点都有一个生成不同词项的概率分布，便得到一个语言模型，或者概率语言模型 Probabilistic LM，或者统计语言模型 (Statistical LM)语言模型的概念本质上也是基于概率的有穷自动机 → 语言模型：一个语言模型 LM 是从某词汇表上抽取的字符串到概率的一个映射函数。就是说，对于字母表 Σ 上的语言模型 M 有： $\\large \\sum_{s \\in \\Sigma^{*} } P(s)=1 $最简单的语言模型等价于一个仅仅包含一个节点的概率有穷自动机，只有一个生成不同词项的概率分布，因此有 $\\sum_{t\\in V} P(t)=1 $例子：其中 STOP 自动机结束的标识符$P(\\text { frog said that toad likes frog })\\ =(0.01 \\times 0.03 \\times 0.04 \\times 0.01 \\times 0.02 \\times 0.01)\\times(0.8 \\times 0.8 \\times 0.8 \\times 0.8 \\times 0.8 \\times 0.8 \\times 0.2)\\ \\approx 0.000000000001573 $第一个括号内的是词项发射概率；第二个括号内是生成每个词后继续前进或停止的转移概率上面有一个停止概率，假定停止概率是固定的，因此，它不会影响文档的排序。因此可以不考虑停止概率，但形式上得到的结果将不再是概率，而只是概率的部分项。课程中后续内容将忽略停止概率语言模型的比较：比较两个模型，可计算似然比 (likelihood ratio)即将其中一个模型的数据生成概率除以另外一个模型的数据生成概率例子：P(s|M1) &gt; P(s|M2)说明 s 由 M1 生成的可能性大这里是对概率求积，但是通常在概率应用中，往往采用对数求和的计算方法语言模型的种类对于词项序列如何求解其生成的概率值?根据链式规则将一系列事件的概率分解成多个连续的 事件概率之积，每个概率是每个事件基于其历史事件的条件概率。计算公式如下：$P\\left(t_{1} t_{2} t_{3} t_{4}\\right)=P\\left(t_{1}\\right) P\\left(t_{2} | t_{1}\\right) P\\left(t_{3} | t_{1} t_{2}\\right) P\\left(t_{4} | t_{1} t_{2} t_{3}\\right) $语言模型的种类 n-gram：一元语言模型 (Unigram LM)：也称上下文无关语言模型，是最简单的语言模型，去掉所有条件概率中的条件来独立地估计每个词项的概率。$P_{\\mathrm{uni} }\\left(t_{1} t_{2} t_{3} t_{4}\\right)=P\\left(t_{1}\\right) P\\left(t_{2}\\right) P\\left(t_{3}\\right) P\\left(t_{4}\\right) $词袋模型 Bag of words二元语言模型 (Bigram LM)，即计算条件概率时只考虑前一个词项的出现情况$P_{\\mathrm{bi} }\\left(t_{1} t_{2} t_{3} t_{4}\\right)=P\\left(t_{1}\\right) P\\left(t_{2} | t_{1}\\right) P\\left(t_{3} | t_{2}\\right) P\\left(t_{4} | t_{3}\\right) $三元语言模型 (Trigram LM)…Unigram → Bigram→ … → n-gram，还有其他的本课不讨论词的多项式分布由一元语言模型产生一个文档 d 的概率？词的多项式分布一元语言模型会给有序的词项序列赋予概率当然这些词项按照其他次序出现时的概率也与之相等因此实际上这相当于词项存在一个多项式分布。也可以称之为多项式模型$\\Large P(d)=\\frac{L_{d} !}{t f_{t_{1}, d}! \\ tf_{t_{2}, d}!\\ \\cdots\\ tf_{f_{n}, d} !} P\\left(t_{1}\\right)^{f_{1}, d} P\\left(t_{2}\\right)^{f_{t_{2}, d} } \\cdots P\\left(t_{M}\\right)^{tf_{t_{M},d} }$$L_{d}=\\sum_{1 \\leq i \\leq M} t f_{t_{i}, d} $ 是文档的长度 (即词条的总个数)M 是词典的大小多项式分布的概率公式：$P\\left(X_{1}=x_{1}, \\cdots, X_{k}=x_{k}\\right)=\\left{\\begin{array}{l}\\frac{n !}{x_{1} ! \\ldots x_{k} !} P(1)^{x_{1} } \\cdots P(k |)^{x_{k} } \\text { when } \\sum_{i=1}^{k} x_{i}=n \\0 \\quad \\text { otherwise }\\end{array}\\right. $k 个状态，第 1 个状态发生的概率 P(1)，发生了 $x_1$ 次。总共发生了 $n$ 次语言模型于 IR 的应用查询似然模型 Query Likelihood ModelIR 中使用 LM 的问题：N 个文档，各自有一个语言模型，给定一个查询，求查询与哪个文档相关度最高对比问题：问题：设有 N 个作者，每人有一篇文章，对于不在上述 N 篇文章中的一篇新文档 q，问最有可能是哪 个作者写的？一个解决思路：根据每个作者写的文章，总结出作者的写作风格，然后根据写作风格来判断 q 与谁的风格最近一种可能的思路：把相关度看成是每篇文档对应的语言模型下生成该查询的可能性总体分布 &amp; 抽样 （文档 -&gt; 总体分布 -&gt; 查询）：文档的模型(风格)实际上是某种总体分布文档和查询都是该总体分布下的一个抽样样本实例根据文档，估计文档的模型，即求出该总体分布 (一般假设某种总体分布，然后求出其参数)然后计算该总体分布下抽样出查询的概率查询似然模型 Query Likelihood Model, QLM：每篇文档 d 构建其对应的语言模型 $M_d$将文档按照其与查询相关的似然 $P(d|q)$ 排序$P(d|q) = P(q|d) P(d)/P(q) $$P(q)$ 文档无关，可以忽视$P(d)$ 均匀分布所以最后按照 $P(q|d)$ 进行排序$P(q|d)$ ：在文档 d 对应的语言模型 $M_d$ 下生成 q 的概率问题 —— 已知样本 d，求其模型 $M_d$ 的参数 $P(w|M_d) $ （即这个 LM 下一个个 Term 的分布）因此，IR 中的语言建模方法实际上是在对查询的生成过程进行建模：每篇文档 d 对应一个文档模型 $M_d$然后计算查询被视为每个文档模型的随机抽样样本的概率根据这个概率对文档排序$\\Large P\\left(q | M_{d}\\right)=K_{q} \\prod_{t \\in V} P\\left(t | M_{d}\\right)^{tf_{t, d} } $$\\Large K_q = \\frac{L_{d} !}{t f_{t_{1}, d}! \\ tf_{t_{2}, d}!\\ \\cdots\\ tf_{f_{n}, d} !} $ 是查询 q 的多项式系数，对于特定的查询来说是常数，可以忽略基于语言模型 (LM) 的检索，将查询的生成看成一个随机过程。具体方法：(1) 对每篇文档 $d_i$ 推导出其 LM $M_{d_i}$；(2) 估计查询 q 在每个文档 $d_i$ 的 LM 下的生成概率 $P(q|M_{d_i})$；(3) 按照上述概率对文档进行排序。上述模型的直观意义是用户脑子里有一篇原型文档，按照该文档中的词语用法来生成查询 （DocToQuery）通常，用户对感兴趣的文档中可能出现的词项有一些合理的想法他们会选择那些能够区分其他文档的查询项构成查询。查询生成概率（文档生成查询的概率）的估计：每篇文档 d 构建其对应的语言模型 $M_d $采用最大似然估计 (Maximum Likelihood Estimation, MLE)使得观察样本出现概率 (似然) 最大的估计$\\Large \\hat{P}\\left(q | M_{d}\\right)=\\prod_{t \\in q} \\hat{P}{\\mathrm{mle} }\\left(t | M{d}\\right)=\\prod_{t \\in q} \\frac{t f_{t, d} }{L_{d} } $$L_d$ 是 d 中的词条数目平滑方法：线性插值 LM引入：上面那个式子中，如果 $\\hat{P}{\\mathrm{mle} }\\left(t | M{d}\\right) = 0$，怎么办所以，要对文档 LM 的概率进行平滑 Smoothing即对出现事件的概率结果进行折扣，并对未出现的词的概率赋予一定的值对概率分布进行平滑方法的有很多在事件的观察数目上加某个数字 (1、1/2、或者一个小的α )然后对概率分布重新进行归一化线性插值 LM，linear interpolation LM线性插值 (linear interpolation) LM：在一般的参照概率分布中，文档中未出现的查询项都可能在查询中出现它的概率在某种程度上接近但不可能超过在整个文档集中偶然出现的概率也就是说，如果 $tf_{t,d}=0$，那么有 $\\Large \\hat{P}{\\mathrm{mle} }\\left(t | M{d}\\right) \\le \\frac{cf_t}{T} $$cf_t$ 是 t 在整个文档集的出现次数，T 是所有文档集中词条的个数实际效果较好的简单方法：将基于文档的多项式分布和基于全部文档集估计出的多项式分布相混合，即$\\large \\hat{P}(t | d)=\\lambda \\hat{P}{\\mathrm{mle} }\\left(t | M{d}\\right)+(1-\\lambda) \\hat{P}{\\mathrm{mle} }\\left(t | M{c}\\right) $$0&lt;\\lambda &lt;1$，$M_c$ 是基于全部文档集构造的 LM，C 是英文单词 Corpus线性插值 LM 示例：在语言建模的 IR 模型下，查询 q 的检索排序函数定义如下：$\\Large P(d | q) \\propto P(d) \\prod_{t \\in q}\\left[\\lambda P\\left(t | M_{d}\\right)+(1-\\lambda) P\\left(t | M_{c}\\right)\\right] $例 12-3 假如某文档集中包含如下两篇文档d1: Xyzzy reports a profit but revenue is down (8)d2: Quorus narrows quarter loss but revenue decreases further (8)混合参数 λ = 1/2。假定查询为 revenue down，则有$\\begin{array}{l}P\\left(q | d_{1}\\right)=\\left[\\frac{\\frac{1}{8}+\\frac{2}{16} }{2}\\right] \\times\\left[\\frac{\\frac{1}{8}+\\frac{1}{16} }{2}\\right]=\\frac{1}{8} \\times \\frac{3}{32}=\\frac{3}{256} \\P\\left(q | d_{2}\\right)=\\left[\\frac{\\frac{1}{8}+\\frac{2}{16} }{2}\\right] \\times\\left[\\frac{\\frac{0}{8}+\\frac{1}{16} }{2}\\right]=\\frac{1}{8} \\times \\frac{1}{32}=\\frac{1}{256}\\end{array} $扩展的 LM 方法拓展的 LM 方法分类：查询似然类：文档建模，计算查询的似然比如，基本 QLM 模型、翻译模型等文档似然类：查询建模，计算文档的似然例子，BIM 模型、相关性模型 (Relevance模型) 等模型比较类：文档建模、查询建模，计算两个模型的距离 —— KL 距离模型KL 距离模型：通过计算查询模型 $M_q$ 和文档模型 $M_d$ 的 KL 距离 (Kullback-Leibler divergence) 来对文档 d 的风险进行建模$\\Large R(d ; q)=K L\\left(M_{d} | M_{q}\\right)=\\sum_{t \\in V} P\\left(t | M_{q}\\right) \\log \\frac{P\\left(t | M_{q}\\right)}{P\\left(t | M_{d}\\right)}$KL 距离源自信息论的一个非对称距离度量方法，主要度量的是概率分布 Md 对 Mq 建模的无效程度。Lafferty 和 Zhai(2001) 给出的结果表明基于模型对比的方法比查询似然和文档似然的方法都好。KL 作为排序函数的缺点：查询间的最后得分没有可比性。对于 ad hoc 检索来说没有关系，但是对于一些其他应用 (如话题跟踪) 影响很大。翻译模型：基本的 LM 方法没有考虑表达方式不同的问题，比如一义多词或者查询语言和文档语言间的偏差问题翻译模型可以通过翻译的方法，让不在文档中的词项转变为其近义词项后出现在查询中这种方法也为跨语言 IR 提供了基础假定翻译模型可以通过一个词项间的条件概率分布 T(.|.) 来表示，则基于翻译的查询生成模型定义为：$\\Large P\\left(q | M_{d}\\right)=\\prod_{t \\in q} \\sum_{v \\in V} P\\left(v | M_{d}\\right) T(t | v) $其中，P(v|Md) 是基本的文档语言模型T(t|v) 表示翻译概率。翻译模型往往基于单独的资源来构建(比如传统的 同义词词典或者双语词典)。当然，如果存在一些文本片段很自然地解释或者概括了其他文本，那么也可以基于文档集来构建翻译模型。第十一章 文本分类及朴素贝叶斯分类器文本分类的概念及其与 IR 的关系概念：Text Classification 或者 Text Categorization：给定分类体系 (taxonomy)，将一篇文档分到其中一个或者多个类别中的过程给定文档 d∈X 和一个固定的类别集合 $C= {c_1, c_2, . . . , c_J} $，其中 X 表示文档空间 (document space)，类别 (class) 也通常称为类 (category) 或类标签 (label)。按类别数目：binary vs. multi-class按每篇文档赋予的标签数目：single label vs. multi label分类方法：手工方法Web 发 展 的 初 期 ， Yahoo 使用人工分类方法来组织 Yahoo 目录类似工作还有： ODP, PubMed如果是专家来分类精度会非常高如果问题规模和分类团队规模都很小的时候，能否保持分类结果的一致性但是对人工分类进行规模扩展将十分困难，代价昂贵规则方法Google Alerts 的例子是基于规则分类的存在一些 IDE 开发环境来高效撰写非常复杂的规则 (如 Verity )通常情况下都是布尔表达式组合 (如 Google Alerts)如果规则经过专家长时间的精心调优，精度会非常高建立和维护基于规则的分类系统非常繁琐，开销也大机器学习方法文本分类被定义为一个学习问题，这也是本书中的定义，包括通过有监督的学习，得到分类函数 ϒ然后将其用于对新文档的分类将介绍一系列分类方法: 朴素贝叶斯, Rocchio, kNN, SVM当学习方法基于统计时，这种方法也称为统计文本分类 (statistical text classification)在统计文本分类中，对于每个类别需要一些好的文档样例 (或者称为训练文档)由于需要人来标注 (labeling, 对每篇文档赋予类别标签的过程) 训练文档，所以对人工分类的需求仍然存在基于学习的文本分类：文档空间 X文档都在该空间下表示，通常都是某种高维空间固定的类别集合 $\\mathrm{C}=\\left{c_{1}, c_{2}, \\ldots, c_{J}\\right} $类别往往根据应用的需求来人为定义 (如, 相关类 vs. 不相关类)训练集 D，文档 d 用类别 c 来标记，$&lt;d, c&gt;\\in X \\times C $利用学习算法，可以学习一个分类器 ϒ，将文档映射成类别： ϒ : X → C文档分类的实现对于文档 d∈X，可确定 ϒ(d)∈C，即确定 d 最可能属于的类别 $c_i=ϒ(d)， c_i∈ C$文本分类中的类别、训练集及测试集：无监督 / 有监督 学习：Supervised Learning 监督学习利用一组已知类别的样本调整分类器的参数，使其达到所要求性能的过程，也称为监督训练或有教师学习无监督学习若所给的学习样本不带有类别信息，就是无监督学习搜索引擎中的文本分类应用：语言识别 (类别: English vs. French等)垃圾网页的识别 (垃圾网页 vs. 正常网页)是否包含淫秽内容 (色情 vs. 非色情)领域搜索或垂直搜索 – 搜索对象限制在某个垂直领域 (如健康医疗) (属于该领域 vs. 不属于该领域)静态查询 (如，Google Alerts)情感识别: 影评或产品评论是贬还是褒 (褒评 vs. 贬评)朴素贝叶斯分类器概念朴素贝叶斯分类器 Naive Bayes text classification：是一个概率分类器文档 d 属于类别 c 的概率计算如下：$t_k$ 是 d 中的词条，$n_d$ 是文档的长度 (词条的个数)$P(t_k|c)$ 是词项 $t_k$ 出现在类别 c 中文档的概率，或类别 c 生成词项 $t_k$ 的概率，或度量的是当 c 是正确类别时 $t_k$ 的贡献$P(c)$ 是类别 c 的先验概率如果文档的词项无法提供属于哪个类别的信息，那么直接选择 $P(c)$ 最高的那个类别具有最大后验概率的类别朴素贝叶斯分类的目标是寻找 “最佳” 的类别最佳类别是具有最大后验概率 (maximum a posteriori - MAP)的类别 $c_{map}$ ：$\\Large c_{m a p}=\\underset{c \\in C}{\\arg \\max } \\hat{P}(c | d) \\propto \\underset{c \\in C}{\\arg \\max } \\hat{P}(c) \\prod\\limits_{1 \\leq k \\leq n_{d} } \\hat{P}\\left(t_{k} | c\\right) $由于不知道参数的真实值，所以上述公式中采用了从训练集中得到的估计值 $\\hat{P}$ 来代替 P很多小概率的乘积会导致浮点数下溢出又 log(xy) = log(x) + log(y)，可以通过取对数将原来的乘积计算变成求和计算又 log 是单调函数，因此得分最高的类别不会发生改变因此，实际中常常使用的是 ——分类规则 $\\Large c_{m a p}=\\underset{\\mathrm{c} \\in C}{\\arg \\max }\\left[\\log \\hat{P}(c)+\\sum\\limits_{1 \\leq k \\leq n_{d} } \\log \\hat{P}\\left(t_{k} | c\\right)\\right]$每个条件参数 $\\hat{P}(t_{k} | c )$ 反映 $t_k$ 对 c 的贡献高低的一个权重先验概率 $\\hat{P}(c)$ 是反映类别 c 的相对概率的一个权重因此，所有权重的求和反映的是文档属于类别的可能性选择最具可能性的类别参数估计 1: 极大似然估计 (MLE)如何从训练数据中估计 $\\hat{P}(c)$ 和 $\\hat{P}(t_{k} | c )$ ？先验：$\\large \\hat{P}(c)=\\frac{N_{c} }{N} $$N_c$：训练集中类 c 中的文档数目N：训练集中文档的总数条件概率：$\\Large \\hat{P}\\left(t_{k} | c\\right)=\\frac{T_{c t} }{\\sum\\limits_{t^{\\prime} \\in V} T_{c t^{\\prime} }} $引入了位置独立性假设 (positional independence assumption)，在该假设下，$T_{ct}$ 是 t 在训练集类 c 文档中所有位置的出现次数之和。即不同位置上的概率值采用相同的估计办法。比如，如果词 t 在一篇文档中出现过两次，分别在 k1 和 k2 的位置上，那么假定 $\\hat{P}\\left(t_{k 1} | c\\right)=\\hat{P}\\left(t_{k 2} | c\\right) $存在的问题：零概率问题如果 WTO 在训练集中中没有出现在类别 China 中：$\\Large P(\\mathrm{WTO} | \\text { China })=\\frac{T_{\\text {China, WTO } }}{\\sum_{t^{\\prime} \\in V} T_{\\text {China}, t^{\\prime} }}=\\frac{0}{\\sum_{t^{\\prime} \\in V} T_{\\text {China},t^{\\prime} }}=0 $那么，对于任意包含 WTO 的文档，P(China|d)=0一旦发生零概率，将无法判断类别解决零概率问题：平滑前：$\\Large \\hat{P}\\left(t_{k} | c\\right)=\\frac{T_{c t} }{\\sum\\limits_{t^{\\prime} \\in V} T_{c t^{\\prime} }} $平滑后（对每个量加 1）：$\\Large \\hat{P}(t | c)=\\frac{T_{c t}+1}{\\sum\\limits_{t^{\\prime} \\in V}\\left(T_{c t^{\\prime} }+1\\right)}=\\frac{T_{c t}+1}{\\left(\\sum\\limits_{t^{\\prime} \\in V} T_{c t^{\\prime} }\\right)+B} $B 是不同的词语个数 （这种情况下词汇表大小 $B=|V|$）加 1 平滑可以认为是采用均匀分布作为先验分布 (每个词项在每个类中出现 1 次)，然后根据训练数据进行更新得到的结果训练过程：$\\Large c_{m a p} \\propto \\arg \\max\\limits_{c \\in C} \\hat{P}(c) \\prod\\limits_{1 \\leq k \\leq n_{d} } \\hat{P}\\left(t_{k} | c\\right)=\\underset{c \\in C}{\\arg \\max } \\frac{N_{c} }{N} \\prod\\limits_{1 \\leq k \\leq n_{d} } \\frac{T_{c t_{k} }+1}{\\left(\\sum\\limits_{t^{\\prime} \\in V} T_{c t^{\\prime} }\\right)+B}$测试过程：训练过程已得到估计参数 $\\hat{P}(c)$ 和 $\\hat{P}(t_{k} | c )$根据上面两个值，计算文档 d 的 $\\Large c_{m a p}=\\underset{\\mathrm{c} \\in C}{\\arg \\max }\\left[\\log \\hat{P}(c)+\\sum\\limits_{1 \\leq k \\leq n_{d} } \\log \\hat{P}\\left(t_{k} | c\\right)\\right]$示例：$T_{ct}$ 表示所有 c 类文档中出现的词项的数目和时间复杂度分析：$L_{ave}$：训练文档的平均长度D：训练文档V：词汇表C：类别集合$L_a$：测试文档的平均长度$M_a$：测试文档中不同的词项个数$\\Theta\\left(|D| L_{\\text {ave } }\\right)$：参数计算所需的预处理复杂度，词汇表的抽取、词项计算等$\\Theta\\left( |C| |V| \\right)$：参数估计的时间复杂度，|C||V| 个条件概率、|C| 个先验概率因此：朴素贝叶斯 对于训练集的大小和测试文档的大小 而言是线性的 (相对于测试文档的长度而言)。这是最优的小结：分类目标：找出文档最可能属于的类别。对于 NB 来说，最可能的类是具有 MAP 估计值的结果 $c_{map}$：$\\Large c_{m a p}=\\underset{c \\in C}{\\arg \\max } \\hat{P}(c | d) \\propto \\underset{c \\in C}{\\arg \\max } \\hat{P}(c) \\prod\\limits_{1 \\leq k \\leq n_{d} } \\hat{P}\\left(t_{k} | c\\right) $估计参数：$\\large \\hat{P}(c)=\\frac{N_{c} }{N} $、$\\Large \\hat{P}\\left(t_{k} | c\\right)=\\frac{T_{c t} }{\\sum\\limits_{t^{\\prime} \\in V} T_{c t^{\\prime} }} $零概率问题 -&gt; 平滑：$\\Large \\hat{P}(t | c)=\\frac{T_{c t}+1}{\\sum\\limits_{t^{\\prime} \\in V}\\left(T_{c t^{\\prime} }+1\\right)}=\\frac{T_{c t}+1}{\\left(\\sum\\limits_{t^{\\prime} \\in V} T_{c t^{\\prime} }\\right)+B} $生成模型NB 分类器的生成模型：多项分布（Multinomial NB model）：有多种取值，比如抛骰子伯努利(二项)分布（Bernoulli model）：只有 2 种取值，抛硬币贝叶斯算法：$\\hat{P}(t_{k} | c )$ 的估计策略不同贝努利：类 c 文档中包含 t 的文档数的比率多项式：t 出现的次数占类 c 文档中所有词条数目的比率当对测试文档进行分类时，贝努利模型只考虑词项的出现或不出现(即二值)，并不考虑出现的次数而多项式模型中则要考虑出现次数未出现词项在分类中的使用不同多项式模型：不影响分类效果贝努利模型：计算 P(c|d) 时要以一个因子来参与计算，因为贝努利模型对词项的未出现也要显式建模基于贝努利模型的 NB 示例：参数的计算：$\\hat{P}(c)$ 和 $\\hat{P}(t_{k} | c )$ 的估计理论朴素贝叶斯规则：给定文档的条件下，希望得到最可能的类别 $c_{m a p}=\\underset{c \\in C}{\\arg \\max } P(c | d)$应用贝叶斯定律 $P(A | B)=\\frac{P(B | A) P(A)}{P(B)}$ 得到 $c_{m a p}=\\underset{c \\in C}{\\arg \\max } \\frac{P(d | c) P(c)}{P(d)} $由于分母 P(d) 对所有类目都一样，去掉，$c_{m a p}=\\underset{c \\in C}{\\arg \\max }\\ P(d | c) P(c) $两种模型的文本生成过程：给定类别时文档生成的条件概率计算有所不同多项式模型 $ P(d | c)=P\\left(&lt;t_{1}, \\ldots, t_{k},\\ldots, t_{n d}&gt;| c\\right)$$ &lt;t_{1}, \\ldots, t_{n d}&gt; $ 是在 d 中出现的词项序列 (每个位置都考虑，当 然要去掉那些从词汇表中去掉的词，如停用词)贝努利模型 $P(d | c)=P\\left(&lt;e_{1}, \\ldots, e_{i}, \\ldots, e_{M}&gt;| c\\right) $$\\left\\langle e_{1}, \\ldots, e_{i}, \\ldots, e_{M}\\right\\rangle$ 是一个 M 维的布尔向量，表示每个词项在文档 d 中存在与否两种不同的文档表示方法第一种方法的文档空间 X 是所有词项序列的集合第二种方法的文档空间 X 是 ${0,1}^M$两种生成模型需要估计的参数多项式模型 $ P(d | c)=P\\left(&lt;t_{1}, \\ldots, t_{k}, \\ldots, t_{n d}&gt;| c\\right)$nd 是文档的长度(词条的个数)$\\hat{P}(c) $：|C| 个$\\hat{P} (t| c)$：$M^{nd} • |C|$个 (每个位置)贝努利模型 $P(d | c)=P\\left(&lt;e_{1}, \\ldots, e_{i}, \\ldots, e_{M}&gt;| c\\right) $M是词汇表中所有词项的个数$\\hat{P}(c) $：|C| 个$$\\hat{P} (t| c)$$ ：$2^M •|C| $个不同的参数，每个参数都是 M 个 ei 取值和一个类别取值的组合多项式模型和贝努利模型具有相同数量级的参数个数。要估计这么多参数，必须需要大量的训练样例。但是，训练集的规模总是有限的，于是出现数据稀疏性 (data sparseness) 问题由于参数空间巨大，对这些参数进行可靠估计是不可行的朴素贝叶斯条件独立性假设：为减少参数数目，给出朴素贝叶斯条件独立性假设，即给定类别时，假设特征之间是相互独立的：$\\begin{array}{l}\\text { Multinomianl } P(d | c)=P\\left(&lt;t_{1}, \\ldots, t_{n_{d} }&gt;| c\\right)=\\prod\\limits_{1 \\leq k \\leq n_{d} } P\\left(X_{k}=t_{k} | c\\right) \\\\text { Bernoulli } P(d | c)=P\\left(&lt;e_{1}, \\ldots, e_{M}&gt;| c\\right)=\\prod\\limits_{1 \\leq i \\leq M} P\\left(U_{i}=e_{i} | c\\right)\\end{array} $上面公式中引入了两类随机变量 $X_k$ 和 $U_i$，这样的话两个不同的文本生成模型就更清晰$X_k$ 是文档在位置 k 上的随机变量，$P(X_k=t|c)$ 表示一篇 c 类文档中词项 t 出现在位置 k 上的概率随机变量 $U_i$ 对应词项 $t_i$，当词项在文档中不出现时取 0，出现时取 1。$P(U_i=1|c)$ 表示的是 $t_i$ 出现在 c 类文档中的概率，这时可以是在任意位置上出现任意多次，既只考虑二值 朴素贝叶斯的位置独立性假设：即使是采用条件独立性假设，但假如在文档中每个位置 k 上的概率分布不同的话，那么对于多项式模型来说仍然有太多的参 数需要估计。比如，bean出现在coffee类文档的第1个位置和出现在第2个位置的概率 是不同的词项在文档中的出现位置本身并不包含任何对分类有用的信息故在多项式模型中引入第二个独立性假设 —— 位置独立性假设 (positional independence)即词项在文档中每个位置的出现概率是一样的，也就是对于任意位置 $k_1、k_2$、词项 t 和类别 c，有$\\hat{p}\\left(t_{k 1} | c\\right)=\\hat{p}\\left(t_{k 2} | c\\right) $基于条件独立性和位置独立性假设，我们只需要估计个多项式模型下的参数 $P(t_k|c)$ 或贝努利模型下的参数 $P(e_i|c) $， 其中每个参数对应一个词项和类别的组合两个模型的比较：朴素贝叶斯中的 “朴素”：条件独立性假设声称在给定类别的情况下特征之间相互独立，这对于实际文档中的词项来说几乎不可能成立。多项式模型中还给出了位置独立性假设。而由于贝努利模型中只考虑词项出现或不出现，所以它忽略了所有的位置信息。这种词袋模型忽略了自然语言句子中 词序相关的信息所以 NB 对自然语言的建模做了非常大的简化，从这个意义上讲，如何能保证NB方法的分类效果？朴素贝叶斯方法起作用的原因：即使在条件独立性假设严重不成立的情况下，朴素贝叶斯方法依然能够高效地工作。例如概率 P(c2|d) 被过低估计 (0.01)，而概率 P(c1|d) 被过高估计 (0.99)。然而，分类决策取决于哪个类别得分最高，并不关注得分本身的精确性。尽管概率估计效果很差，但是 NB 会给 $c_1$ 一个很高的分数， 因此最后会将 $d$ 归到正确的类别中分类的目标是预测正确的类别，并不是准确地估计概率准确估计 ⇒ 精确预测，反之并不成立!特征选择引入：也称特征子集选择(Feature Subset Selection)，或 属性选择(Attribute Selection)。指从已有的多个特征中选择特征子集使得学习器的性能最优化。两个功能减少特征数量、降维，使模型泛化能力更强，减少过拟合增强对特征和特征值之间的理解主要方法过滤式 Filter首先对数据集进行特征选择，然后再训练学习器。两者独立互信息，卡方 χ2，信息增益包裹式 Wrapper直接把学习器的性能作为特征子集的评价准则。即特征选择的目的就是为给定的学习器选择最有利其性能的特征子集完全搜索，启发式搜索嵌入式 Embedding前两者特征选择和学习器训练有明显的分别嵌入式特征选择是将特征选择过程与学习器训练融为一体，两者在同一个优化过程中完成，即在学习器训练过程中自动文本分类进行特征选择Lasso，Ridge，深度学习分类特征选择：文本分类中，通常要将文本表示在一个高维空间下，每一维对应一个词项。特征选择是从训练集出现的词项中选出一部分子集的过程。在文本分类过程仅仅使用这个子集作为特征。特征选择有两个主要目的通过减少有效词汇的空间来提高分类器训练和应用的效率。这对于除 NB 之外其他的训练开销较大的分类器来说尤为重要去除噪音特征，提高分类精度噪音特征 (noise feature) 指那些加入后反而会增加新数据上的分类错误率的特征假定某个罕见词项 (如arachnocentric) 对某个类别 (如China) 不提供任何信息， 但训练集中所有的 arachnocentric 恰好都出现在 China 类，那么学习后产生的分类器会将包含 arachnocentric 的测试文档误分到 China 类中去。这种由于训练集的偶然性导出的不正确的泛化结果称为 过学习 (overfitting)特征选择算法：给定类别 c，对词汇表中的每个词项 t，计算 效用指标 A(t,c)，然后从中选择 k 个具有最高值的词项作为最后的特征，其它的词项被忽略。不同的特征选择方法：特征选择方法主要基于其所使用特征效用指标来定义特征效用指标词项频率法 – 选择高频词项互信息 (Mutual information) – 选择具有最高互信息的词项A(t,c) 采用词项 t 和类别 c 的期望互信息 (Expected Mutual Information) 来计算MI 给出的是词项所包含的有关类别的信息量及类别包含的有关词项的信息量定义：$\\Large I(U ; C)=\\sum\\limits_{e_{t} \\in{1, 0}) } \\sum\\limits_{e_c \\in{1,0} } P\\left(U=e_{t}, C=e_{c}\\right) \\log {2} \\frac{P\\left(U=e{t}, C=e_{c}\\right)}{P\\left(U=e_{t}\\right) P\\left(C=e_{c}\\right)}$U 是一个二值随机变量，当文档包含词项 t 时，取值为 et=1， 否则取值为 et=0。C 也是一个二值随机变量，当文档属于类别 c 时，它取值为 ec=1，否则取值为 ec=0。卡方 χ2 (Chi-square) 统计量统计量常常用于检测两个事件的独立性。两个事件 A 和 B 独立，是指两个事件 A、B的概率满足P(AB)=P(A)P(B)或者 P(A|B)=P(A)且P(B|A)=P(B)。在特征选择中，两个事件分别是指词项的出现和类别的出现。度量两者独立性的缺乏程度，χ2越大，独立性越小，相关性越大 (N=A+B+C+D)$\\chi^{2}(t, c)=\\frac{N(A D-C B)^{2} }{(A+C)(B+D)(A+B)(C+D)} $文本分类的评价分类评价：评价必须基于测试数据进行，而且该测试数据是与训练数据完全独立的 (通常两者样本之间无交集)很容易通过训练在训练集上达到很高的性能 (比如记忆所有的测试集合)常用指标：正确率、召回率、F1 值、分类精确率 (classification accuracy) 等当对具有多个分类器的文档集进行处理时，往往需要计算出一个融合了每个分类器指标的综合指标。为实现这个目的，通常有宏平均和微平均两种做法：宏平均 (macro averaging) 是在类别之间求平均值，微平均 (micro averaging) 则是将每篇文档在每个类别上的判定放入一个缓冲池，然后基于这个缓冲池计算效果指标。微平均 vs. 宏平均：对于一个类得到评价指标F1但是希望得到在所有类别上的综合性能宏平均 (Macroaveraging)对类别集合 C 中的每个类都计算一个 F1 值对 C 个结果求平均 Average these C numbers微平均 (Microaveraging)对类别集合 C 中的每个类都计算 TP、FP 和 FN将 C 中的这些数字累加基于累加的 TP、FP、FN 计算 P、R 和 F1二者的使用范围两者的计算结果可能会相差很大。宏平均对每个类别同等对待，而微平均则对每篇文档的判定结果同等对待。由于 F1 值忽略判断正确的负例，所以它的大小主要由判断正确的正例数目所决定，所以在微平均计算中大 类起支配作用上例中，系统的微平均正确率 (0.83) 更接近 c2 类的正确率 (0.9)，而与 c1 类的正确率 (0.5) 相差较大，这是因为 c2 的大小是 c1 的 5 倍因此，微平均实际上是文档集中大类上的一个效果度量指 标。如果要度量小类上的效果，往往需要计算宏平均指标本章要点什么是文本分类？Taxonomies and Classification什么是朴素贝叶斯分类器？朴素贝叶斯分类器的生成模型朴素贝叶斯分类器的性质条件独立性假设 &amp; 位置独立性假设特征选择：互信息、χ2 统计量、词项频率文本分类的评价：宏平均和微平均第十二章 基于向量空间的文本分类基于向量空间的分类方法引入：上一章考虑了词频，本质还是 bag of word 的形式，没有表示成向量空间。向量空间表示：每个文档表示成一个向量，向量的每一维表示一个 term向量可以归一化 (normalize) 成单位长度高维向量空间维度非常高 (term的数量)每个 term 就是一个坐标轴文档表示为空间的向量思路：向量空间模型词项-文档矩阵：二值 -&gt; 频数 -&gt; 权重矩阵 (tf-idf值)相关性=向量距离：欧式距离 -&gt; 夹角 -&gt; 余弦相似度利用向量空间模型进行文本分类的思路主要基于 邻近假设 (contiguity hypothesis)同一类的文档会构成一个邻近区域而不同类的邻近区域之间是互不重叠的核心问题：如何找到 分类面决策边界 (decision boundary) 分类面方案可能有多种，不正确的答案可能导致分类错误Rocchio 方法思路：基于质心 (centroid) 或原型 (prototype) 将整个向量空间划分为多个区域一个类别 c 的质心可以通过类中文档向量的平均向量或者质心向量来计算，即$\\Large \\vec{\\mu} (c) = \\frac{1}{|D_c|} \\sum\\limits_{d\\in D_c} \\vec{v}(d) $其中， $D_c$ 是文档集 D 中属于类别 c 的文档子集：$D_c={d:&lt;d,c&gt;∈D}$这里将 d 归一化的文档向量记为 v(d)算法：计算每个类的中心向量中心向量是所有文档向量的算术平均将每篇测试文档分到离它最近的那个中心向量决策边界：用质心来定义分类边界两类的边界由哪些到两个类质心等距的点集组成 (超屏幕)如图有 |a1|=|a2|、 |b1|=|b2| 和 |c1|=|c2|，那条直线组成了边界分类超平面：二维平面上的一条直线在 M 维空间中可以推广成一个超平面，上面的点满足$\\left{\\vec{x} | \\vec{w}^{T} \\vec{x}=b\\right} $$\\vec{w}$ 称为超平面上的 M 维法向量 (normal vector)b 是一个常数，决定超平面的偏移量维度情况二维 -&gt; 直线：$w_{1} x_{1}+w_{2} x_{2}=b $三维 -&gt; 平面：$w_{1} x_{1}+w_{2} x_{2}+w_{3} x_{3}=b $三维以上 -&gt; 超平面一个超平面将 $R^M$ 分为两个区域 $\\left{\\vec{x} | \\vec{w}^{T} \\vec{x}\\le b\\right} $ 和 $\\left{\\vec{x} | \\vec{w}^{T} \\vec{x}&gt;b\\right} $Rocchio 分类示例：Rocchio 分类方法的缺陷：为了遵循邻近性的要求，Rocchio 分类中的每个类别一定要近似球形， 并且它们之间具有相似的球半径多模态类别 “a” 由两个不同簇 (分别是以 X 为中心的两个小圆) 组成。由于 “O” 更接近 “a” 的中心 A， 因此，Rocchio 分类会将其错分到 “A” 类特点：Rocchio 分类方法类的边界由那些到两个类质心等距的点集组成 (超平面)。Rocchio 分类中的每个类别一定要近似球形，并且它们之间具有相似的球半径。Rocchio 算法的时间复杂度与 NB 方法在训练上具有 相同的时间复杂度kNN (k近邻) 方法引入：将 k 个最近邻 (nearest neighbors) 文档所属的主类别赋给测试文档近邻指的是文档最近，而不是质心最近k=1，分类到离它最近的那篇文档的类别1NN 不鲁棒，一篇文档可能分错类；或者该篇文档本身很反常k&gt;1 情况下的 kNN：将每篇测试文档分到训练集中离它最近的 k 篇文档所属类别中最多的那个类别kNN 的基本依据根据邻近假设，一篇测试文档 d 将和其邻域中的训练文档应该具有相同的类别kNN 是有监督的，标记了 Label，周边文档的类别已知1NN 分类器：1NN 分类器的判别边界是 Voronoi 剖分 (Voronoi tessellation) 形成的多个线段的连接。Voronoi 剖分会将整个平面分成 |D| 个凸多边形，每个多边形都仅包含其对应的文档，而每个凸多边形是在二维空间中通过直线围成的凸区域kNN 思路的改进：改进1：kNN 的概率型版本将属于类别 c 的概率估计为 k 个近邻中属于类别 c 的文档比例P(c|d) = d 的最近的 k 个邻居中属于 c 类的比例将 d 分到具有最高概率 P(c|d) 的类别 c 中改进2：也可以将 k 个近邻基于其余弦相似度进行加权文档 d 属于某个类别 c 的得分计算如下：$\\Large \\operatorname{score}(c, d)=\\sum\\limits_{d^{\\prime} \\in S_{k} } I_{c}\\left(d^{\\prime}\\right) \\cos \\left(\\vec{v}\\left(d^{\\prime}\\right), \\vec{v}(d)\\right) $其中，$S_k$ 表示的是文档 d’ 的 k 个近邻文档组成的集合如果 d’ 属于类别 c 则 $I_c(d’)=1$，否则 $I_c(d’)=0 $最后将得分最高的类别赋予文档 d示例：对于★ 对应的文档，在 1NN 和 3NN 下，分别应该属于哪个类？kNN 算法：对于 k∈N 的一般 kNN 分类来说，考虑 k 个最近邻的区域的方法同前面一样。这里会再次得到一个凸多边形，整个空间也会划分为多个凸多边形，每个凸多边形中的 k 个近邻组成的集合是不变的总结：当训练集非常大的时候，kNN 分类的精度很高如果训练集很小，kNN 可能效果很差。线性分类器定义：指基于特征的简单线性组合就可以对文档进行分类的分类器计算特征值的一个 线性加权和 $\\sum_i w_ix_i$决策规则：$\\sum_i w_ix_i &gt; b$，b 是一个参数考虑二元分类器：从几何上说，二元分类器相当于二维平面上的一条直线、三维空间中的一个平面或者更高维下的超平面，称为分类面分类面：基于训练集来寻找该分类面寻找分类面的方法：Rocchio, Naive Bayes —— 将解释为什么两种方法是二元分类器一维下的线性分类器：一维下的分类器是方程 $w_1d_1=b$ 对应的点点的位置是 $b/w_1$那些满足 $w_1d_1 ≥ b$ 的点 $d_1$ 属于类别 c而那些 $w_1d_1 &lt; b$ 的点 $d_1$ 属于类别 c二维平面下的线性分类器：二维下的分类器是方程 w1d1 + w2d2 = b 对应的直线那些满足 w1d1 + w2d2 ≥ b 的点 (d1, d2) 属于类别 c那些满足 w1d1 + w2d2 &lt; b 的点 (d1, d2) 属于类别 $\\over{c}$三维空间下的线性分类器：三维空间下的分类器是方程 w1d1 + w2d2 + w3d3 = b 对应的平面那些满足 w1d1 + w2d2 + w3d3 ≥ b 的点 (d1, d2 , d3) 属于类别 c那些满足 w1d1 + w2d2 + w3d3 &lt; b 的点 (d1, d2 , d3) 属于类别 $\\over{c}$二元 Rocchio 作为线性分类器：线或面定义为：$\\sum\\limits^M_{i=1}w_id_i = b$对于 Rocchio，置：$\\begin{array}{l}\\vec{w}=\\vec{\\mu}\\left(c_{1}\\right)-\\vec{\\mu}\\left(c_{2}\\right) \\b=0.5 \\times\\left(\\left|\\vec{\\mu}\\left(c_{1}\\right)\\right|^{2}-\\left|\\vec{\\mu}\\left(c_{2}\\right)\\right|^{2}\\right)\\end{array} $朴素贝叶斯是线性分类器：二类朴素贝叶斯，我们计算：$\\large \\log \\frac{P(c | d)}{P(\\bar{c} | d)}=\\log \\frac{P(c)}{P(\\bar{c})}+\\sum\\limits_{t \\in d} \\frac{P(w | c)}{P(w | \\bar{c})} $如果概率 &gt; 1，决定类别 c 。比如 log 概率 &gt; 0所以决策边界是平面：$\\Large \\begin{array}{c}\\alpha+\\sum\\limits_{t \\in V} \\beta_{w} \\times n_{w}=0 \\text { where } \\alpha=\\log \\frac{P(c)}{P(\\bar{c})} \\\\beta_{w}=\\log \\frac{P(w | c)}{P(w | \\bar{c})} \\quad n_{w}=# \\text { of occurrences of } w \\text { in } d\\end{array} $KNN 不是线性分类器：kNN 分类决策取决于 k 个邻居类中的多数类类别之间的分类面是分段线性的 (单个线段是线性的)但是一般来说，很难表示成如下的线性分类器相关讨论：很多常用的文本分类器都是线性分类器：朴素贝叶斯、Rocchio、logistic 回归、线性 SVM 等不同的方法在测试文档分类性能时存在巨大差异 (分类面的选择不同)能否通过更强大的非线性分类器来获得更好的分类性能?一般情况下不能，给定数量的训练集可能足以估计一个线性分类面，但是不足以估计一个更复杂的非线性分类面线性分类器训练困难的原因之一：噪音文档一个带噪音的线性问题在这个假想的网页分类下，仅包含中文的网页用实心圆表示，而中英文混合网页用小方块表示除了 3 篇噪音文档 (用箭头标记) 外，这两个类可以被一个线性类别边界 (用短破折号虚线表示) 分开非线性的分类问题 nonlinear classifiers：如果一个问题是非线性的，即它的类别边界不能通过线性超平面来近似，那么此时使用非线性分类器的分类结果往往会好于使用线性分类器但是如果一个问题是线性的，那么最好用简单的线性分类器多标签分类问题：单标签分类问题，也称 single label problem类别之间互斥。每篇文档属于且仅属于某一个类多标签分类问题，也称 multilabel classification一篇文档可以属于 0 个、1 个或更多个类对于多标签分类问题 (比如 A、 B、 C 三类)，可以组合为多个二类线性分类器 (A vs. BC、B vs. AC、 C vs. AB)第十三章 基于向量空间模型的文本分类二元线性 SVM应该选哪个超平面：对于线性可分的训练集而言，肯定存在无穷多个分类面可以将两类完全正确地分开，但是不同的分类面在测试集的表现完全迥异对于新数据，有些分类器的错误率很高，有一些却很低。如感知机：通常很差；朴素贝叶斯、 Rocchio： 一般；线性 SVM：好分类器的间隔：有些学习方法 (如感知机) 只需找到任一线性分界面即可，而另一些方法 (如NB) 则需按照某个准则找到最优的线性分界面 ——SVM，Support Vector Machines 支持向量机：SVM 是最大间隔分类器的一种，是基于向量空间的机器学习方法，其目标是找到两个类别之间的一个决策边界，使之尽量远离训练集上的任意一点 (当然一些离群点和噪音点可能不包括在内)SVM 定义的准则是寻找一个离数据点最远的决策面。从决策面到最近数据点的距离决定了分类器的间隔 (margin)例子：两点(1, 1)和(2, 3)两点确定直线：x2=2x1-1最优的分类直线：与上述线段 垂直并相交与其中点(1.5, 2)， 既(中垂线)于是，可以求得 SVM 的决策直线方程为 $x_2 = - \\frac{1}{2} x_1 + \\frac{11}{4} $ 函数间隔 Functional Margin：点 $\\vec{x_i}$ 相对于超平面 $&lt;\\vec{w},b&gt;$ 的函数间隔：$y\\left(\\vec{w}^{\\mathrm{T} } \\vec{x}_{i}+b\\right) $函数间隔不是点到平面的距离，不是距离一个数据集的函数间隔是数据集点中最小函数间隔的两倍 (超平面左右各一部分)问题：具体的值没有大小限制，可以通过方法 $\\vec{w}$ 和 b 来获得所需要的任意函数边界例如，如果将 $\\vec{w}$ 和 b 分别替换成 $5\\vec{w}$ 和 5b，那么函数间隔就变成 $y\\left(5\\vec{w}^{\\mathrm{T} } \\vec{x}_{i}+5b\\right) $几何间隔 Geometric Margin是中间空白带的最大宽度，该空白带可以用于将两类支持向量分开，是 r 的最小值 (即支持向量到超平面的距离) 的两倍点 $\\vec{x}$ 到超平面的最短欧式距离 $\\Large r=\\frac{y\\left(\\vec{w}^{T} \\vec{x}+b\\right)}{|\\vec{w}|} $ ，式子的分子是函数间隔离超平面最近的点是支持向量 (support vector)不管参数如何缩放，几何间隔总是一个不变量 (因为分母做了归一化处理)几何间隔是实际的点到直线的距离点 $\\vec{x}$ 到超平面的的几何间隔 r 的分析将超平面上离 $\\vec{x}$ 最近的点标记为 $\\vec{x}’$ ，那么线 $\\vec{x} - \\vec{x}’$ 与法向量 $\\vec{w}$ 平行法向量的单位向量是 $\\frac{\\vec{w} }{|\\vec{w}|} $因此 $\\vec{x} - \\vec{x}’$ 就是 $r\\times \\vec{w} / \\vec{w}$ 平移的结果所以 (y 表示点在上面或者下面) $\\large \\vec{x}’ = \\vec{x} - y\\times r \\times\\frac{\\vec{w} }{|\\vec{w}|}$$\\vec{x}’$ 在超平面上，所以满足 $\\vec{w}^{\\mathrm{T} } \\vec{x}^{\\prime}+b=0 \\ \\vec{w}^{\\mathrm{T} } (\\vec{x} - y\\times r \\times\\frac{\\vec{w} }{|\\vec{w}|})+b=0 $所以 $\\large r=y \\frac{\\vec{w}^{T} \\vec{x}+b}{|\\vec{w}|} $二元线性分类器的形式化定义：$\\vec{w} $ 决定超平面的法向量$\\vec{x_i}$ 数据点 i$y_i$ 数据点 i 的类别 (+1 或 -1，是 Sign 符号函数)分类器 $f\\left(\\vec{x}{i}\\right)=\\operatorname{sign}\\left(\\vec{w}^{\\mathrm{T} } \\vec{x}{i}+b\\right) $线性支持向量机：线性可分的情况假设所有数据离超平面的最小距离是 1，那么对于一个训练集来说 ${(\\vec{x}i, y_i)}$，满足 $\\begin{array}{l}\\vec{w}^{\\mathrm{T} } \\vec{x}{i}+b \\geq 1 \\quad \\text { if } y_{i}=1 \\\\vec{w}^{\\mathrm{T} } \\vec{x}{i}+b \\leq-1 \\text { if } y{i}=-1\\end{array} $对支持向量来说上式是等号每个样本 $\\vec{x}$ 点到超平面的距离是 $\\large r=y \\frac{\\vec{w}^{T} \\vec{x}+b}{|\\vec{w}|} $把支持向量代入，那么间隔 $ρ = \\frac{2}{|\\vec{w}|}$超平面 $\\vec{w}^T \\vec{x_i} + b = 0$约束条件：样本点到超平面的最小距离是 1，即 $\\min\\limits_{i=1, \\ldots, n}\\left|\\vec{w}^{\\mathrm{T} } \\vec{x}_{i}+b\\right|=1$表明：$\\Large \\vec{w}^T (\\vec{x_a} - \\vec{x_b}) = 2 \\ \\Large ρ = ||\\vec{x_a} - \\vec{x_b} ||_2 = \\frac{2}{||\\vec{w}||_2} $支持向量机就是使 ρ 最大化 （间隔最大化）那么该问题变为一个凸优化问题寻找 $\\vec{w}$ 和 b，使得 $ρ = \\frac{2}{||\\vec{w}||}$ 最大化 （或 $\\frac{||\\vec{w}||}{2}$ 最小化），并且所有 ${(\\vec{x_i}, y_i)}$，有$\\vec{w}^{\\mathrm{T} } \\vec{x}{i}+b \\geq 1 \\text { if } y{i}=1 \\ \\vec{w}^{\\mathrm{T} } \\vec{x}{i}+b \\leq-1 \\text { if } y{i}=-1 $更好的描述 -&gt;寻找 $\\vec{w}$ 和 b，使得 $\\Phi(\\vec{w})=\\frac{1}{2} \\vec{w}^{\\mathrm{T} } \\vec{w}$ 最小化，并且所有 ${(\\vec{x_i}, y_i)} $，有 $y_i (\\vec{w}^{\\mathrm{T} } \\vec{x}_{i}+b) \\ge 1 $上述问题实际上是在线性约束条件下的二次函数优化问题。该问题是数学中的基本问题之一，存在很多解决算法。本文通过拉格朗日对偶的方法求解。求解结果对于训练集中的每个约束条件 $y_i (\\vec{w}^{\\mathrm{T} } \\vec{x}_{i}+b) \\ge 1 $ 都对应一个拉格朗日因子 $α_i$那么求得：$\\begin{aligned}&amp;\\vec{w}=\\sum \\alpha_{i} y_{i} \\vec{x}{i}\\&amp;b=y{k}-\\vec{w}^{\\mathrm{T} } \\vec{x}{k} \\text { for any } x{k} \\text { such that } \\alpha_{k} \\neq 0\\end{aligned} $每个非零 $α_i$ 表示对应的 $\\vec{x_i}$最终的分类器：$f(\\vec{x})=\\operatorname{sign}\\left(\\sum \\alpha_{i} y_{i} \\vec{x}_{i}^{\\mathrm{T} } \\vec{x}+b\\right) $总结：线性 SVM 分类器：$f(\\vec{x})=\\operatorname{sign}\\left(\\sum \\alpha_{i} y_{i} \\vec{x}_{i}^{\\mathrm{T} } \\vec{x}+b\\right) $SVM 基本过程基于给定训练数据集，通过二次优化过程寻找最佳的分类超平面对于待分类的新数据点，利用分类函数计算该点到超平面的距离距离的正负 (分类函数的符号) 决定了该数据点类别的归属如果该点在分类器的间隔之内，分类器可以在原来的两个类之外，返回 “类别未知”SVM 用于非线性分类软间隔 (Soft margin) 分类如果训练集不是线性可分，引入松弛变量 (slack variables) $ξ_i$ 来允许决策间隔犯错误非零 $ξ_i$ ，表示允许 $x_i$ 在不满足间隔需求下的惩罚量或代价因子允许错误发生以一定的代价把噪音点移到其属于的类训练的目标依然是最小化错误，并求最大间隔超平面旧形式寻找 $\\vec{w}$ 和 b，使得 $\\Phi(\\vec{w})=\\frac{1}{2} \\vec{w}^{\\mathrm{T} } \\vec{w}$ 最小化，并且所有 ${(\\vec{x_i}, y_i)} $，有 $y_i (\\vec{w}^{\\mathrm{T} } \\vec{x}_{i}+b) \\ge 1 $软间隔分类新形式寻找 $\\vec{w}$ 、b 及 $ξi &gt; 0$ ，使得 $\\Phi(\\vec{w})=\\frac{1}{2} \\vec{w}^{\\mathrm{T} } \\vec{w} + C\\sum ξ_i $ 最小化并且所有 ${(\\vec{x_i}, y_i)} $，有 $y_i (\\vec{w}^{\\mathrm{T} } \\vec{x}{i}+b) \\ge 1 - ξ_i $优化问题就转化为间隔的宽度和允许进入间隔内的数据点数目之间的均衡性问题对于点 xi 来说，通过设置 ξi &gt; 0，间隔的宽度可以小于 1，但是在最小化过程中要付出惩罚代价 Cξi 。 ξi 的和是训练错误的上界。基于软间隔的 SVM 在训练错误和间隔大小之间权衡，并使目标函数最小化C 是正则化 (regularization) 因子，控制过拟合问题：如果 C 变大，会对出现在间隔内的点的惩罚较大，即更尊重数据本 身，当然这时候的代价就是减小几何间隔。当 C 很小时，则很容易通过松弛变量来考虑噪音点，此时可以得到能够对大部分数据点建模的更宽的间隔。非线性 SVM：数据集是线性可分的 (最多包括少数例外点或噪音点)数据集不可能被线性分类器直接分开？解决方法：将数据映射到一个高维空间并在此空间上使用线性分类器将数据分开非线性SVM：特征空间一般思路：将原始的特征空间映射到某个更高维的线性可分的特征空间上去核技巧 (kernel trick)：分类器依赖于数据点之间的内积操作。令 $K\\left(\\vec{x}{i}, \\vec{x}{j}\\right)=\\vec{x}{i}^{\\mathrm{T} } \\vec{x}{j} $通过某个映射函数 Ф 可以将原始空间的点映射到新空间，即 $\\Phi: \\vec{x} \\mapsto \\Phi(\\vec{x})$那么，新空间下的点积计算变为 $K\\left(\\vec{x}{i}, \\vec{x}{j}\\right)=\\Phi\\left(\\vec{x}{i}\\right)^{\\mathrm{T} } \\Phi\\left(\\vec{x}{j}\\right) $核函数 K 实际上是一个对应于新特征空间上的内积函数如果能够证明该点积 (也就是一个实数) 能够通过原始数据点简单高效地计算出来，那么就不必真的要将 $\\vec{x} \\mapsto \\Phi(\\vec{x})$相反，可以直接通过 $K\\left(\\vec{x}{i}, \\vec{x}{j}\\right)=\\Phi\\left(\\vec{x}{i}\\right)^{\\mathrm{T} } \\Phi\\left(\\vec{x}{j}\\right) $ 来计算那么线性分类器→非线性分类器$\\begin{array}{l}f(\\vec{x})=\\operatorname{sign}\\left(\\sum \\alpha_{i} y_{i} \\vec{x}{i}^{\\mathrm{T} } \\vec{x}+b\\right) \\\\Rightarrow f(\\vec{x})=\\operatorname{sign}\\left(\\sum \\alpha{i} y_{i} K\\left(\\vec{x}_{i}^{\\mathrm{T} } \\vec{x}\\right)+b\\right)\\end{array} $二维空间上一个二次核函数的例子：对于二维的向量 $\\vec{u}=\\left(u_{1}, u_{2}\\right) \\quad \\vec{v}=\\left(v_{1}, v_{2}\\right) $考虑 $K(\\vec{u}, \\vec{v})=\\left(1+\\vec{u}^{\\mathrm{T} } \\vec{v}\\right)^{2} $下面证明这是一个核函数，也就是说，对于某个函数 Ф，有 $K(\\vec{u}, \\vec{v})=\\Phi(\\vec{u})^{\\mathrm{T} } \\Phi(\\vec{v}) $考虑：$\\Phi(\\vec{u})=\\left(1 u_{1}^{2} \\sqrt{2} u_{1} u_{2} u_{2}^{2} \\sqrt{2} u_{1} \\sqrt{2} u_{2}\\right) $有：$\\begin{aligned}K(\\vec{u}, \\vec{v}) &amp;=\\left(1+\\vec{u}^{\\mathrm{T} } \\vec{v}\\right)^{2} \\&amp;=1+u_{1}^{2} v_{1}^{2}+2 u_{1} v_{1} u_{2} v_{2}+u_{2}^{2} v_{2}^{2}+2 u_{1} v_{1}+2 u_{2} v_{2} \\&amp;=\\left(1 u_{1}^{2} \\sqrt{2} u_{1} u_{2} u_{2}^{2} \\sqrt{2} u_{1} \\sqrt{2} u_{2}\\right)^{\\mathrm{T} }\\left(1 v_{1}^{2} \\sqrt{2} v_{1} v_{2} v_{2}^{2} \\sqrt{2} v_{1} \\sqrt{2} v_{2}\\right) \\&amp;=\\phi(\\vec{u})^{\\mathrm{T} } \\phi(\\vec{v})\\end{aligned} $小结：非线性 SVM 与 Kernels软间隔分类新形式寻找 $\\vec{w}$ 、b 及 $ξi &gt; 0$ ，使得 $\\Phi(\\vec{w})=\\frac{1}{2} \\vec{w}^{\\mathrm{T} } \\vec{w} + C\\sum ξ_i $ 最小化并且所有 ${(\\vec{x_i}, y_i)} $，有 $y_i (\\vec{w}^{\\mathrm{T} } \\vec{x}{i}+b) \\ge 1 - ξ_i $非线性 SVM通过空间映射将原始空间映射到新空间，为避免显式的映射函数，引入核函数 (定义在原始空间下但是结果是新空间下的内积函数)常用核函数LinearPolynomial (多项式核) $ K(\\vec{x}, \\vec{z})=(1+\\vec{x} \\cdot \\vec{z})^{d} $Radial basis function (径向基核) $K(\\vec{x}, \\vec{z})=e^{-(\\vec{x}-\\vec{z}) /\\left(2 \\sigma^{2}\\right)} $本讲要点回顾：基于向量空间的分类RocchiokNN线性分类器-hyperplaneRocchioNaive BayesSVM（支持向量机）线性 SVM非线性 SVM第十四章 文本聚类聚类介绍Clustering 的定义：(文档) 聚类是将一系列文档按照相似性聚团成子集或者簇 (cluster) 的过程簇内文档之间应该彼此相似簇间文档之间相似度不大聚类是一种最常见的无监督学习 (unsupervised learning) 方法无监督意味着没有已标注好的数据集例子：提出一个算法来寻找该例中的簇结构分类 vs. 聚类：分类：有监督的学习聚类：无监督的学习分类：类别事先人工定义好，并且是学习算法的输入的一部分聚类：簇在没有人工输入的情况下从数据中推理而得但是，很多因素会影响聚类的输出结果：簇的个数、相似度计算方法、文档的表示方式，等等聚类在 IR 中的应用聚类假设：概念：在考虑文档和信息需求之间的相关性时，同一簇中 的文档表现互相类似。聚类在 IR 中的所有应用都直接或间接基于上述聚类假设Van Rijsbergen 的原始定义: “closely associated documents tend to be relevant to the same requests”（彼此密切关联的文档和同一信息需求相关）聚类在 IR 中的应用：应 用聚类对象优 点搜索结果聚类搜索结果提供面向用户的更有效的展 示“分散—集中”界面文档集和文档子集提供另一种用户界面，即不 需要人工输入关键词的搜索 界面文档集聚类文档集提供一种面向探索式浏览的 有效的信息展示方法基于语言建模的 IR 文档集文档集提高正确率和/或召回率基于聚类的检索文档集加快搜索速度文档聚类用于提高召回率：可以实现将文档集中的文档进行聚类当文档 d 和查询匹配时，也返回包含 d 的簇所包含的其它文档希望通过上述做法，在输入查询 “car“ 时，也能够返回包含 “automobile” 的文档由于聚类算法会把包含 “car” 的文档和包含 “automobile” 的文 档聚在一起两种文档都包含诸如 “parts”、 “dealer”、 “mercedes” 和 “road trip” 之类的词语聚类的要求：一般目标：将相关文档放到一个簇中，将不相关文档 放到不同簇中如何对上述目标进行形式化？簇的数目应该合适，以便与聚类的数据集相吻合一开始，假设给定簇的数目为 K后面会介绍确定 K 的半自动方法聚类的其它目标避免非常小和非常大的簇定义的簇对用户来说很容易理解其它 ……扁平聚类 vs. 层次聚类：扁平算法通过一开始将全部或部分文档随机划分为不同的组通过迭代方式不断修正代表算法：K-均值聚类算法层次算法构建具有层次结构的簇自底向上 (Bottom-up) 的算法称为凝聚式 (agglomerative) 算法自顶向下 (Top-down) 的算法称为分裂式 (divisive) 算法硬聚类 vs. 软聚类：硬聚类 (Hard clustering): 每篇文档仅仅属于一个簇很普遍并且相对容易实现软聚类 (Soft clustering): 一篇文档可以属于多个簇对于诸如浏览目录之类的应用来说很有意义比如，将 胶底运动鞋 (sneakers) 放到两个簇中：体育服装 (sports apparel)鞋类 (shoes)只有通过软聚类才能做到这一点本节课关注扁平的硬聚类算法扁平算法：概念：将 N 篇文档划分成 K 个簇给定一个文档集合及聚类结果簇的个数K寻找一个划分将这个文档集合分成K个簇，该结果满足某个最优划分准则全局优化：穷举所有的划分结果，从中选择最优的那个划分结果-&gt; 无法处理高效的启发式方法：K-均值聚类算法K-均值聚类算法引入：或许是最著名的聚类算法算法十分简单，但是在很多情况下效果不错是文档聚类的默认或基准算法聚类中的文档表示：向量空间模型同基于向量空间的分类一样，采用欧氏距离的方法来计算向量之间的相关性.欧氏距离与余弦相似度差不多等价 (如果两个向量都基于长度归一化，那么欧氏距离和余弦相似度是等价的)然而，质心向量通常都没有基于长度进行归一化K-均值聚类算法：K-均值聚类算法中的每个簇都定义为其质心向量划分准则：使得所有文档到其所在簇的质心向量的平方和最小质心向量的定义 $\\vec{\\mu}(\\omega)=\\frac{1}{|\\omega|} \\sum\\limits_{\\vec{x} \\in \\omega} \\vec{x} $其中 ω 代表一个簇通过下列两步来实现目标优化重分配 (reassignment): 将每篇文档分配给离它最近的簇重计算 (recomputation): 重新计算每个簇的质心向量示例：证明 —— K-均值聚类算法一定会收敛：RSS (Residual Sum of Squares，残差平方和) = 所有簇 上的文档向量到 (最近的) 质心向量的距离平方和的总和每次重新分配之后 RSS 会下降这是因为每个向量都被移到离它最近的质心向量所代表的 簇中 (只有找到更近的质心才会重新分配)每次重新计算之后 RSS 也会下降参见下一页幻灯片可能的聚类结果是有穷的因此：一定会收敛到一个固定点当然，这里有一个假设就是假定出现了等值的情况， 算法都采用前后一致的方法来处理(比如，某个向量到 两个质心向量的距离相等)K-均值聚类算法的最优性：收敛并不意味着会达到全局最优的聚类结果!这是 K-均值聚类算法的最大缺点之一如果开始的种子选的不好，那么最终的聚类结果可能会非常糟糕K=2 情况下的最优聚类结果是什么？ 对于任意的种子 di 、dj，是否都会收敛于该聚类结果？对于种子 d2 和 d5，K-均值算法最后收敛为 { {d1, d2, d3}, {d4, d5, d6} }对种子 d2 和 d3，收敛结果为 { {d1, d2, d4, d5}, {d3, d6} }，这是 K=2 时的全局最优值K-均值聚类算法的初始化：种子的随机选择只是 K-均值聚类算法的一种初始化方法之一随机选择不太鲁棒：可能会获得一个次优的聚类结果一些确定初始质心向量的更好办法非随机地采用某些启发式方法来选择种子(比如，过滤掉一 些离群点，或者寻找具有较好文档空间覆盖度的种子集合)采用层级聚类算法寻找好的种子选择 i (比如 i = 10) 次不同的随机种子集合，对每次产生的随机种子集合运行 K-均值聚类算法，最后选择具有最小 RSS 值的聚类结果K-均值聚类算法的时间复杂度：计算两个向量的距离的时间复杂度为 O(M)重分配过程：O(KNM) (需要计算 KN 个文档-质心的距离)重计算过程：O(NM) (在计算质心向量时，需要累加 簇内的文档向量)假定迭代次数的上界是 I整体复杂度: O(IKNM) – 线性但是，上述分析并没有考虑到实际中的最坏情况在一些非正常的情况下，复杂度可能会比线性更糟聚类评价怎样判断聚类结果的好坏?内部准则 (Internal criteria)一个内部准则的例子： K-均值聚类算法的RSS值但是内部准则往往不能评价聚类在应用中的实际效用替代方法：外部准则 (External criteria)按照用户定义的分类结果来评价，即对一个分好类的数据集进行聚类，将聚类结果和事先的类别情况进行比照，得到最后的评价结果外部准则：基于已有标注的标准数据集 (如 Reuters 语料库) 来进行聚类评价目标：聚类结果和给定分类结果一致(当然，聚类中并不知道最后每个簇的标签，而只是关注如何将文档聚到不同的组中)评价指标纯度 (purity)$\\operatorname{purity}(\\Omega, \\mathrm{C})=\\frac{1}{N} \\sum\\limits_{k} \\max\\limits {j}\\left|\\omega{k} \\cap c_{j}\\right| $$Ω= {ω_1, ω_2, . . . , ω_K}$ 是簇的集合$C = {c_1, c_2, \\cdots , c_J}$ 是类别的集合对每个簇 $ωk$：找到一个类别 $c_j$，该类别包含 $ω_k$ 中的元素最多，为 $n{kj}$ 个，也就是说 $ω_k$ 的元素最多分布在 $c_j$ 中将所有 $n_{kj}$ 求和，然后除以所有的文档数目N计算例子：计算纯度 $\\max {\\mathrm{j} }\\left|\\omega{1} \\cap c_{j}\\right|=5 \\quad(\\text {class } \\mathrm{x}, \\text {cluster } 1)\\ \\max {\\mathrm{j} }\\left|\\omega{2} \\cap c_{j}\\right|=4 \\quad(\\text {class o, cluster } 2) \\ \\max {\\mathrm{j} }\\left|\\omega{3} \\cap c_{j}\\right|=3 \\quad(\\mathrm{class}\\ \\diamond, \\text { cluster } 3)$ ，纯度为 $(5+4+3) / 17 \\approx 0.71 $* NMI (Normalized Mutual Information，归一化互信息) * $\\Large \\begin{array}{c} \\operatorname{NMI}(\\Omega, \\mathrm{C})=\\frac{I(\\Omega, \\mathrm{C})}{[H(\\Omega)+H(\\mathrm{C})] / 2} \\\\ I(\\Omega, \\mathrm{C})=\\sum_{k} \\sum_{j} P\\left(\\omega_{k} \\cap c_{j}\\right) \\log \\frac{P\\left(\\omega_{k} \\cap c_{j}\\right)}{P\\left(\\omega_{k}\\right) P\\left(c_{j}\\right)} \\quad H(\\Omega)=\\sum_{k} P\\left(\\omega_{k}\\right) \\log P\\left(\\omega_{k}\\right) \\\\ =\\sum_{k} \\sum_{j} \\frac{\\left|\\omega_{k} \\cap c_{j}\\right|}{N} \\log \\frac{N\\left|\\omega_{k} \\cap c_{j}\\right|}{\\left|\\omega_{k}\\right|\\left|c_{j}\\right|} \\quad\\quad\\quad\\quad\\quad\\quad\\quad=\\sum_{k} \\frac{\\left|\\omega_{k}\\right|}{N} \\log \\frac{\\left|\\omega_{k}\\right|}{N} \\end{array}$ * 其中，P(ωk)、P(cj) 及 P(ωk∩cj) 分别是一篇文档属于 ωk、cj 及 ωk∩cj 的概率。 * RI (Rand Index，兰德指数/准确率) * 定义 $\\Large \\mathrm{RI}=\\frac{\\mathrm{TP}+\\mathrm{TN} }{\\mathrm{TP}+\\mathrm{FP}+\\mathrm{FN}+\\mathrm{TN} } $ * 考虑所有两个文档之间 (文档对) 的关系，可以得到 2x2 的列联表 &lt;img src=&quot;image-20200618120322070.png&quot; style=&quot;zoom:50%;&quot; /&gt; * 将聚类看成是一系列的决策过程，即对文档集上所有N(N−1)/2个文档对进行决策。当且仅当两篇文档相似时，将它们归入同 一簇中。 * TP(True-positive, 真阳性 ): 将 两 篇 相 似 文 档 归 入 一 个 簇 ， 而 TN(True-negative,真阴性)将两篇不相似的文档归入不同的簇。在 此过程中会犯两类错误：FP决策会将两篇不相似的文档归入同 一簇，而FN决策将两篇相似的文档归入不同簇。 * RI计算的是正确决策的比率，就是在8.3节中提到的精确率 * 计算例子：&lt;img src=&quot;image-20200618115736018.png&quot; style=&quot;zoom:50%;&quot; /&gt; 回到上例，三个簇中分别包含 6、6、5 个点，因此处于同一簇的文档对的个数为： $\\mathrm{TP}+\\mathrm{FP}=\\left(\\begin{array}{l} 6 \\\\ 2 \\end{array}\\right)+\\left(\\begin{array}{l} 6 \\\\ 2 \\end{array}\\right)+\\left(\\begin{array}{l} 5 \\\\ 2 \\end{array}\\right)=40 $ 其中， 簇 1 中的 x 对，簇 2 中的 o 对，簇 3 中的 ⋄ 对，以及簇 3 中的 x 对，都是真正例： $\\mathrm{TP}=\\left(\\begin{array}{l} 5 \\\\ 2 \\end{array}\\right)+\\left(\\begin{array}{l} 4 \\\\ 2 \\end{array}\\right)+\\left(\\begin{array}{l} 3 \\\\ 2 \\end{array}\\right)+\\left(\\begin{array}{l} 2 \\\\ 2 \\end{array}\\right)=20 $ 于是，FP = 40 − 20 = 20。类似地，可以计算出FN和TN &lt;img src=&quot;image-20200618145309978.png&quot; style=&quot;zoom:33%;&quot; /&gt; (20 + 72)/(20 + 20 + 24 + 72) ≈ 0.68. * F 值 (F measure) * 可以使用 F 值来度量聚类结果，并通过设置β &gt; 1 以加大对FN 的惩罚，此时实际上也相当于赋 予召回率更大的权重 * $P=\\frac{\\mathrm{TP} }{\\mathrm{TP}+\\mathrm{FP} } \\quad R=\\frac{\\mathrm{TP} }{\\mathrm{TP}+\\mathrm{FN} } \\quad F_{\\beta}=\\frac{\\left(\\beta^{2}+1\\right) P R}{\\beta^{2} P+R} $簇个数确定簇个数确定：在很多应用中，簇个数 K 是事先给定的比如，可能存在对K的外部限制例子：在“分散-集中”应用中，在显示器上(上世纪90年代)很难显示超过10-20个簇如果没有外部的限制会怎样？是否存在正确的簇个数？一种办法：定义一个优化准则给定文档，找到达到最优情况的 K 值能够使用的最优准则有哪些？我们不能使用前面所提到的 RSS 或到质心的平均平方距离等准则，因为它们会导致 K = N 个簇简单的目标函数：基本思路从 1 个簇开始 (K = 1)不断增加簇 (= 不断增大 K)对每个新的簇增加一个惩罚项在惩罚项和 RSS 之间折中选择满足最佳折中条件的 K给定聚类结果，定义文档的代价为其到质心向量 (平方) 距离 (失真率)定义全部失真率 RSS(K) 为所有文档代价的和然后：对每个簇一个惩罚项 λ于是，对于具有 K 个簇的聚类结果，总的聚类惩罚项 为 Kλ定义聚类结果的所有开销为失真率和总聚类惩罚项的和 RSS(K) + Kλ选择使得 (RSS(K) + Kλ) 最小的 K 值当然，还要考虑较好的 λ 值 . . .在曲线中寻找拐点：本图中两个拐点：4 和 9层次聚类层次聚类 hierarchical clustering：扁平聚类优点：概念简单、速度快缺点：算法返回的是一个无结构的扁平簇集合，需要预先定义簇的数目，并且聚类结果具有不确定性层次聚类输出一个具有层次结构的簇集合，因此能够比扁平聚类输出的无结构簇集合提供更丰富的信息。不需要事先指定簇的数目，并且大部分用于IR中的层次聚类算法都是 确定性算法。在获得这些好处的同时，其代价是效率降低。最普遍的层次聚类算法 的时间复杂度至少是文档数目的平方级，而K-均值算法的时间复杂度 是线性的。当效率因素非常重要时，选择扁平聚类算法。而当扁平算法的 问题（如结构信息不足、簇数目需要预先定义、聚类结果非确 定性）需要加以考虑时，则采用层次算法层次聚类的目标：目标：生成类似于前面提到的 Reuters 目录的一个层次结构。这个层次结构是自动创建的，可以通过自顶向下 (分裂式 divisive) 或自底向上 (凝聚 agglomerate) 的方法实现。自底向上的算法：一开始将每篇文档都看成是一个簇，然后不断地对簇进行两两合并，直到所有文档都聚成一类为止而自顶向下的方法：首先将所有文档看成一个簇，然后不断利用某种方法对簇进行分裂直到每篇文档都成为一个簇为止层次凝聚式聚类：在 IR 领域， HAC 方法的使用比自顶向下方法更普遍。最著名的自底向上的方法是层次凝聚式聚类 (hierarchical agglomerative clustering， HAC)一开始每篇文档作为一个独立的簇然后，将其中最相似的两个簇进行合并重复上一步直至仅剩一个簇整个合并的历史构成一个二叉树一个标准的描述层次聚类合并历史的方法是采用树状图 (dendrogram)关键问题：如何定义簇间相似度单连接 (Single-link)：两个最大相似的成员之间的相似度全连接 (Complete-link)：两个最不相似的成员之间的相似度质心法：平均的类间相似度所有的簇间文档对之间相似度的平均值 (不包括同一个簇内 的文档之间的相似度)这等价于两个簇质心之间的相似度组平均(Group-average)：平均的类内和类间相似度所有的簇间文档对之间相似度的平均值 (包括同一个簇内的文档之间的相似度) 单连接/全连接算法：单连接聚类(single-link clustering)两个簇之间的相似度定义为两个最相似 (最近) 的成员之间的相似度这种单连接的合并准则是局部的，即仅仅关注两个簇互相邻近的区域，而不考虑簇中更远的区域和簇的总体结构。全连接聚类(complete-link clustering)两个簇之间的相似度定义为两个最不相似的成员之间的相 似度，这也相当于选择两个簇进行聚类，使得合并结果具有最短直径。全连接聚类准则是非局部的，聚类结果中的整体结构信息 会影响合并的结果。这种聚类实际上相当于优先考虑具有较短直径的紧凑簇，而不是具有长直径的松散簇这种做法可能对离群点较为敏感，比如某个远离中心的文档会显著增加候选簇的直径从而完全改变最后的聚类结果 单连接和全连接聚类方法的缺点：单连接和全连接聚类方法将簇质量的计算过程简化成两个文档的单一相似度计算，其中单连接方法中计算的是两篇最相似的文档之间的相似度而全连接方法中计算的是两篇最不相似的文档之间的相似度仅仅根据两篇文档来计算显然不能完全反映出簇中的文档分布情况，因此，这两种聚类方法 产生的结果簇往往不是非常理想单连接和全连接聚类方法缺点示例：单连接方法的链化(Chaining)现象单连接聚类算法往往产生长的、凌乱的簇结构。对大部分应用来说， 这些簇结构并不是所期望的。全连接法：对离群点非常敏感全连接聚类将 d2 和它的正确邻居分开—-这显然不是我们所需要的出现上述结果的最主要原因是存在离群点 d1这也表明单个离群点的存在会对全连接聚类的结果起负面影响单连接聚类能够较好地处理这种情况组平均凝聚式算法 (GAAC)：GAAC(Group-average Agglomerative Clustering)通过计算所有文 档之间(文档对)的相似度来对簇的质量进行计算，因此可以避 免在单连接和全连接准则中只计算一对文档相似度的缺陷。GAAC也被称为组平均聚类(group-average clustering)或平均连 接聚类(average-link clustering)。GAAC可以计算所有文档之间相似度的平均值SIM-GA，其中 也包括来自同一簇的文档。当然，这种自相似度(dn=dm)在这里并没有使用。计算公式如下：$\\Large \\mathrm{SIM}\\text{-}\\mathrm{GA}\\left(\\omega_{i}, \\omega_{j}\\right)=\\frac{1}{\\left(N_{i}+N_{j}\\right)\\left(N_{i}+N_{j}-1\\right)} \\sum\\limits_{d_{m} \\in \\theta_{q} \\cup \\omega_{j} } \\sum\\limits_{d_{n} \\in c_{i} \\cup \\omega_{j}, d_{n} \\neq d_{m} } \\vec{d}{m} \\cdot \\vec{d}{n}$$\\vec{d}$ 是文档 d 的长度归一化向量，⋅ 是内积运算符，$N_i$和分别 $N_j$ 是 $ω_i $ 和 $w_j$ 中的文档数目质心法 HAC：簇相似度为所有簇间文档对之间相似度的平均值一个原始的粗糙实现方法效率不高 $(O(N^2))$，但是上述定义相当于计算两个簇质心之间的相似度：$\\Large \\begin{aligned}\\text { SIM-CENT }\\left(\\omega_{i}, \\omega_{j}\\right) &amp;=\\vec{\\mu}\\left(\\omega_{i}\\right) \\cdot \\vec{\\mu}\\left(\\omega_{j}\\right) \\&amp;=\\left(\\frac{1}{N_{i} } \\sum_{d_{m} \\in \\omega_{i} } \\vec{d}{m}\\right) \\cdot\\left(\\frac{1}{N{j} } \\sum_{d_{n} \\in \\omega_{j} } \\vec{d}{n}\\right) \\&amp;=\\frac{1}{N{i} N_{j} } \\sum_{d_{m} \\in \\omega_{i} } \\sum_{d_{n} \\in \\omega_{j} } \\vec{d}{m} \\cdot \\vec{d}{n}\\end{aligned} $这也是质心HAC名称的由来注意：这里是内积计算，而非余弦相似度采用质心法进行聚类：每次迭代合并质心距离最近的两个簇第 1 次迭代中，由于 &lt;d5,d6&gt; 具有最高的质心相似度，所以迭代后形成质心为 μ1 的簇 {d5,d6}第2次迭代中，由于&lt;d1,d2&gt;具有最高的质心相似度，所以迭 代后形成质心为μ2的簇{d1,d2}在第 3 次迭代中，最高的质心相似度在 μ1 和 d4 之间，因此产 生以 μ3 为质心的簇 {d4,d5,d6}相似度颠倒现象：与其他三种 HAC 算法相比，质心聚类方法不是单调的，可能会发生相似度的颠倒现象。也就 是说聚类过程中相似度值有可能会下降在相似度颠倒过程中，合并过程中相似度会增加，导致 “颠倒” 的树状图。图中，第一次合并 ($d_1 \\cup d_2$) 的相似度是 4.0，第二次合并的相似度 $((d_1 \\cup d_2)\\cup d_3) \\approx -3.5$到底使用哪一个 HAC 聚类算法？由于存在相似度颠倒，不使用质心法由于组平均 GAAC 不会受限于链化，并且对离群点不敏感，所以大部分情况下，GAAC都是最佳选择然而，GAAC只能基于向量表示来计算对于其他文档表示方法 (或者如果仅仅提供了文档对之间的相似度)时，使用全连接方法有些应用中适合用单链算法 (比如，Web 搜索中的重复性检测，判断一组文档重复并不受那些离它们较远的文档所影响)四种 HAC 算法的比较：方法结合相似度时间复杂度是否最优备注单连接簇间文档的最大相似度$θ(N^2)$yes链化效应全连接簇间文档的最小相似度$θ(N^2 logN)$no对离群点敏感组平均所有文档相似度的平均值$θ(N^2 logN)$no大部分应用中的最佳选择质心法所有簇间相似 度的平均值$θ(N^2 logN)$no相似度颠倒单趟聚类算法 (Single-Pass Clustering)：初始化处理：给定一个相似度阈值 x，任取一个文档， 不失一般性，记该文档为d1，C1 = {d1}，C = {C1}，D = D - {d1}，其中C表示已经生成的聚类集。任取 d’ ∈ D，对所有的 $C_i \\in C$，计算 d‘ 与 Ci 的相似度 Si。找到与 d’ 相似度最大的聚类 Cj，即 $S_j &gt;S_i$，对任何 $i \\not= j$如果 $S_i \\ge x$，则 $C_i = C_i \\cup {d’}$；//合并否则 $ s= |C|＋1，C_s = {d’}，C = C \\cup {C_s}$。 //新增$D = D - {d’}$。如果 $D =\\empty$，则结束计算，输出 C；否则转入步骤2 第十五章 隐性语义索引Latent Semantic Indexing矩阵分解线性代数基础：令 C 为一个 M×N 的词项-文档矩阵， 其中的每个元素都是非负实数矩阵的秩 (rank) 是线性无关的行 (或列) 的数目，因此有 rank(C) ≤ min{M, N}一个非对角线上元素均为零的 r×r 方 阵被称为对角阵 (diagonal matrix)，其秩等于其对角线上非零元素的个数如果上述对角阵上的 r 个元素都是 1，则 称之为 r 维单位矩阵 (identity matrix)， 记为 $I_r$对于 M×M 的方阵 C 及非零向量 x ，有 $\\mathbf{C} \\vec{x}=\\lambda \\vec{x} $满足上式的 λ 被称为矩阵 C 的特征值 (eigenvalues)对于特征值 λ，满足等式 M 维非零向量 x 称为其右特征向量 (right eigenvector)对应最大特征值的特征向量被称为主特征向量 (principal eigenvector)同样，矩阵 C 的左特征向量 (left eigenvectors) 是满足下列等式的 M 维向量 y ：$y^{T} \\mathbf{C}=\\lambda y^{T} $特征方程 (characteristic equation)：$\\left(\\mathbf{C}-\\lambda \\mathbf{I}_{M}\\right) \\vec{x}=0$可以通过求解这个方程来得到矩阵的特征值矩阵分解 (matrix decomposition) ：将方阵分解成多个矩阵因子乘积的方法，并且这几个矩阵因子都可以从方阵的特征向量导出矩阵对角化定理：令 S 为 M×M 的实方阵，并且它有 M 个线性无关的特征向量，那么存在一个特征分解： $\\mathbf{S}=\\mathbf{U} \\mathbf{\\Lambda} \\mathbf{U}^{-1} $其中U 的每一列都是S的特征向量Λ 是按照特征值从大到小排列的对角阵$\\left(\\begin{array}{cccc}\\lambda_{1} \\&amp; \\lambda_{2} \\&amp; &amp; \\ldots \\&amp; &amp; &amp; \\lambda_{M}\\end{array}\\right), \\lambda_{i} \\geqslant \\lambda_{i+1} $如果特征值都不相同，那么该分解是唯一的对称对角化定理：假定 S 是一个 M×M 的实对称方阵，并且它有 M 个线性无关的特征向量，那么存在如下一个 对称对角化分解：$\\mathbf{S}=\\mathbf{Q} \\mathbf{\\Lambda} \\mathbf{Q}^{\\mathrm{T} } $其中，Q 的每一列都是 S 的互相正交且归一化 (单位长度) 的特征向量，Λ 是对角矩阵，其每个对角线上的值都对应 S 的一个特征值另外，由于 Q 是实矩阵，所以有 $\\mathbf{Q}^{\\mathrm{T} }=\\mathbf{Q}^{-1} $词项-文档矩阵及 SVD词项-文档矩阵及 SVD：迄今为止介绍的分解都是基于方阵，然而，我们感兴趣的是 M×N 的词项-文档矩阵 C，如果 排除极端罕见的情况，那么有 M≠N另外，C 基本上也不可能是对称矩阵。因此，先给出对称对角化分解的一个被称为 SVD 的扩展形式，然后将它用于构建 C 的近似矩阵给定矩阵C，U是一个M×M的矩阵，其每一列是矩阵CCT的正交特征 向量，而N×N矩阵V的每一列都是矩阵CTC的正交特征向量。$C^T$ 是 C 的转置矩阵。定理：令 r 是 M×N 矩阵 C 的秩，那么 C 存在如下形式的 SVD：$\\mathbf{C}=\\mathbf{U} \\boldsymbol{\\Sigma} \\mathbf{V}^{\\mathbf{T} }$$CC^T$ 的特征值 λ1, λ2,…, λr 等于 $C^TC$ 的特征值；对于 1≤ i ≤ r，令 $\\sigma_{i}=\\sqrt{\\lambda_{i} }$，并且 $\\lambda_{i} \\geq \\lambda_{i+1} $。 M×N的矩阵 Σ满足 $Σ_{ii}=σ_i$，其中 1≤ i≤ r，而 Σ 中其他元素均为 0其中，$σ_i$ 就是矩阵 C 的奇异值 (singular value)$\\mathbf{C} \\mathbf{C}^{\\mathrm{T} }=\\mathbf{U} \\boldsymbol{\\Sigma} \\mathbf{V}^{\\mathrm{T} } \\mathbf{V} \\boldsymbol{\\Sigma} \\mathbf{U}^{\\mathrm{T} }=\\mathbf{U} \\boldsymbol{\\Sigma} \\boldsymbol{\\Sigma}^{\\mathrm{T} } \\mathbf{U}^{\\mathrm{T} }$左边 $CC^T$ 是一个实对称方阵右边 $UΣΣ^TU^T$ 正好是对称对角化分解形式$CC^T$ 实际上是一个方阵，其每行和每列都对应 M 个词项中的一个矩阵中的第 i 行、第 j 列的元素实际上是第 i 个词 项与第 j 个词项基于文档共现次数的一个重合度 计算指标。其精确的数学含义依赖于构建C所使用的词项权 重方法假定C是词项-文档布尔矩阵，那么 $CC^T$ 的第 i 行、第 j 列的元素是词项 i 和词项 j 共现的文档数目当记录 SVD 分解的数值结果时，由于其他部分都是零，常规做法是将Σ表示成一个r×r的对角方阵，所 有奇异值排列在对角线上。同样，对应于Σ中被去 掉的行，U中的最右M-r列也被去掉。对应于Σ中被 去掉的列，V中的最右N-r列也被去掉。这种SVD的 书写形式有时被称为简化的SVD(reduced SVD)或截 断的SVD(truncated SVD)低秩逼近低秩逼近：给定 M×N 的矩阵 C 及正整数 k，寻找一个秩不高于 k 的 M×N 的矩阵 $C_k$，使得两个矩阵的差 $X = C − C_k$ 的 F−范数 (Frobenius Norm，弗罗宾尼其范数) 最小，即下式最小 $|X|{F}=\\sqrt{\\sum\\limits{i=1}^{M} \\sum\\limits_{j=1}^{N} X_{i j}^{2} } $X 的 F−范数度量了 Ck 和 C 之间的差异程度。目标是找到一个矩阵 Ck，会使得这种差异极小化，同时又要限制 Ck 的秩不高于 k。如果 r 是 C 的秩，那么很显然 Cr=C，此时矩阵差值的 F范数 为 0。当 k 比 r 小得多时，称 Ck 为低秩逼近 (low-rank approximation) 矩阵SVD 可以用于解决矩阵低秩逼近问题，将其应用到词项-文档矩阵的逼近问题上来。要进行三步操作：给定 C，构造 SVD 分解，因此 $C = UΣV^T$；把 Σ 中对角线上 r-k 个最小奇异值置为 0，从而得到 $Σ_k$；计算 $C_k = UΣ_kV^T$ 作为 C 的逼近。由于 $Σ_k$ 最多包含 k 个非零元素，所以 $C_k$ 的秩不高于 k小特征值对于矩阵乘法的影响也小。因此，将这些小特征值替换成 0 将不会对最后的乘积有实质性影响，也就是说该乘积接近 C隐性语义索引回顾一下词项文档矩阵：该矩阵是计算文档和查询的相似度的基础，接下来介绍 能否通过对该矩阵进行转换来获得文档和查询之间的一 个更好的相似度计算方法？隐性语义索引 LSI 简介：将词项-文档矩阵转换成多个矩阵的乘积这里使用的是一个特定的分解方法奇异值分解 (Singular value decomposition, SVD)$C = UΣV^T$ (其中 C 是词项-文档矩阵)利用 SVD 分解的结果来构造一个新的、改进的词项- 文档矩阵 C’通过 C’ 可以得到一个更好的相似度计算方法 (相对 C 而言)为了这种目的使用 SVD 被称为隐性语义索引 (Latent Semantic Indexing, LSI)例子 $C = UΣV^T$，矩阵 C ：词项-文档矩阵(布尔)例子 $C = UΣV^ T$，矩阵 U：每个词项对应一行，每个 min(M, N) 对应一列，M 为词项数目， N 是文档数目这是一个正交矩阵列向量都是单位向量任意两个列向量之间都是正交的。可以想象这些列向量分布代表不同 的“语义”维度，比如政治、体育、经济等主题。矩阵元素 $u_{ij}$ 给出的是词项 i 和第 j 个“语义”维度之间的关系强弱程度例子 $C = UΣV^ T$ ，矩阵 Σ：是一个min(M,N)× min(M,N)的对角方阵 * 对角线上是矩阵C的奇异值 * 奇异值的大小度量的是对应“语义”维度的重要性 * 可以通过忽略较小的值来忽略对应的“语义”维度例子 $C = UΣV^ T$ ，矩阵 $V^T$：每个词项对应一列，每个 min(M,N) 对应一行这也是一个正交矩阵每个行向量都是单位向量任意两个列向量之间都是正交的可以想象每个行向量代表一个“语义”维度矩阵元素 $v_{ij}$ 给出的是文档 i 和第 j 个“语义”维度之间的关系强弱程度LSI 小结：词项-文档矩阵可以分解成3个矩阵的乘积词项矩阵 U-每个词项对应其中的一个行向量文档矩阵 VT-每篇文档对应其中的一个列向量奇异值矩阵 Σ-对角方阵，对角线上的奇异值代表的是每个“语义”维度的重要性空间降维处理为什么在 LSI 中使用 SVD 分解：最关键的性质：每个奇异值对应的是每个“语义”维度的权重将不太重要的权重置为 0，可以保留重要的信息，去掉一些信息“枝节”这些“枝节”可能是噪音-这种情况下，简化的 LSI 噪音更少，是一种更好的表示方法枝节信息可能会使本来应该相似的对象不相似，同样简化的LSI由于其能更好的表达相似度，因而是一种更优的表示方式“细节越少越好”的一个类比鲜红色花朵的图像红黑花朵的图像如果忽略颜色，将更容易看到两者的相似性将空间维度将为 2：实际上，只需将矩阵 Σ 中相应的维度置为 0 即可。此时，相当于矩阵 U 和 $V^T$ 的相应维度被忽略，然后计算 $\\mathrm{C}{2}=\\mathrm{U} \\Sigma{2} \\mathrm{V}^{\\mathrm{T} } $ 为什么新的低维空间更好？ 在原始空间 C 中，d2 和 d3 的相似度是0 在新的空间 C2，d2 和 d3 的相似度为 0.52 ∗ 0.28 + 0.36 ∗ 0.16 + 0.72 ∗ 0.36 + 0.12 ∗ 0.20 + −0.39 ∗ −0.08 ≈ 0.52Boat和ship语义相似。低维空间能反映出这一点。LSI 在 IR 中的应用LSI 在 IR 中使用的原因：LSI 能够发现文档语义上的关联但是在原始向量空间中这些文档相似度不大 (因为它们使用不同的词语)通过 LSI 将它们映射到新的低维向量空间中在新的空间下，两者相似度较高因此，LSI 能解决一词多义和语义关联问题在原始向量空间下，同义词对文档相似度没有任何贡献LSI 所期望的效果：同义词对文档相似度贡献很大LSI 是如何解决一词多义和语义关联问题的：降维迫使忽略大量“细节”将原始空间下不同的词映射到低维空间的同一维中将同义词映射到同一维的“开销”远小于无关词的聚 集SVD选择开销最小的映射方法因此，SVD会将同义词映射到同一维但是，它同时能避免将无关词映射到同一维LSI 与其它方法的比较：如果查询和文档没有公共词项时，前面介绍的相关反馈和查询扩展可以用于提高IR的召回率LSI 会提高召回率但是损害正确率因此，它和相关反馈查询扩展解决的是同一问题同样，它们的缺点也一致LSI 的实现：对词项-文档矩阵进行 SVD 分解计算在新的低维空间下的文档表示将查询 q 映射到 LSI 低维空间中 $\\vec{q}k = \\Sigma_k^{-1} U{k}^{T} \\vec{q}^T $上式来自 $\\mathbf{C}{2}=\\mathbf{U} \\boldsymbol{\\Sigma}{2} \\mathbf{V}^{\\mathrm{T} } \\Rightarrow \\mathbf{\\Sigma}{2}^{-1} \\mathbf{U}^{\\mathrm{T} } \\mathbf{C}=\\mathbf{V}{2}^{\\mathrm{T} } $计算 $q_2$ 和 $V_2$ 中的所有文档表示的相似度像以往一样按照相似度高低输出文档结果最优性：SVD 在下面的意义上说是最优的保留 k 个最大的奇异值并将其它奇异值置为 0，这种 做法得到原始矩阵 C 的最佳逼近最优性：不存在其它同秩的矩阵更加逼近 C","link":"/CS/Information-Retrieval-Study-Notes/"}],"tags":[{"name":"ACM","slug":"ACM","link":"/tags/ACM/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"Language","slug":"Language","link":"/tags/Language/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"LIFE","slug":"LIFE","link":"/tags/LIFE/"},{"name":"Mood","slug":"Mood","link":"/tags/Mood/"},{"name":"ComputerVision","slug":"ComputerVision","link":"/tags/ComputerVision/"},{"name":"Assembly","slug":"Assembly","link":"/tags/Assembly/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"CPP","slug":"CPP","link":"/tags/CPP/"},{"name":"PROGRAMMING","slug":"PROGRAMMING","link":"/tags/PROGRAMMING/"},{"name":"CS","slug":"CS","link":"/tags/CS/"},{"name":"Game","slug":"Game","link":"/tags/Game/"},{"name":"Compilation-Principles","slug":"Compilation-Principles","link":"/tags/Compilation-Principles/"},{"name":"ComputerGraphics","slug":"ComputerGraphics","link":"/tags/ComputerGraphics/"},{"name":"ComputerNetwork","slug":"ComputerNetwork","link":"/tags/ComputerNetwork/"},{"name":"JAVA","slug":"JAVA","link":"/tags/JAVA/"},{"name":"OperatingSystem","slug":"OperatingSystem","link":"/tags/OperatingSystem/"},{"name":"InformationRetrieval","slug":"InformationRetrieval","link":"/tags/InformationRetrieval/"},{"name":"IR","slug":"IR","link":"/tags/IR/"}],"categories":[{"name":"ACM","slug":"ACM","link":"/categories/ACM/"},{"name":"CS","slug":"CS","link":"/categories/CS/"},{"name":"Programing","slug":"Programing","link":"/categories/Programing/"},{"name":"LIFE","slug":"LIFE","link":"/categories/LIFE/"},{"name":"Life","slug":"Life","link":"/categories/Life/"}]}