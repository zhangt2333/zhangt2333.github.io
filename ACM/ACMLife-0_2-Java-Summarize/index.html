<!DOCTYPE html><html lang="zh"><head><meta charset="utf-8"><meta name="generator" content="Hexo 3.9.0"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>ACMLife-0_2-Java总结 - Zhang T&#39;s Blog</title><link rel="icon" href="/images/favicon.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><link rel="stylesheet" href="/css/back-to-top.css"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-212316117-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-212316117-1")</script><link rel="stylesheet" href="/css/progressbar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><link rel="stylesheet" href="/css/style.css"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand is-flex-center"><a class="navbar-item navbar-logo" href="/">TTTT&#39;s Blog</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a> <a class="navbar-item" href="/archives">归档</a> <a class="navbar-item" href="/categories">分类</a> <a class="navbar-item" href="/tags">标签</a> <a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i> </a><a class="navbar-item" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i> </a><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i> </a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main"><div class="card"><div class="card-image"><span class="image is-7by1"><img class="thumbnail" src="/thumbnails/ICPC.png" alt="ACMLife-0_2-Java总结"></span></div><div class="card-content article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>ACMLife-0_2-Java总结</h1><div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto"><div class="level-left"><time class="level-item has-text-grey" datetime="2018-12-31T16:00:02.000Z"><i class="far fa-calendar-alt">&nbsp;</i>2019-01-01</time> <time class="level-item has-text-grey is-hidden-mobile" datetime="2021-11-09T11:31:53.862Z"><i class="far fa-calendar-check">&nbsp;</i>2021-11-09</time><div class="level-item"><i class="far fa-folder-open has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/categories/ACM/">ACM</a></div><span class="level-item has-text-grey"><i class="far fa-clock"></i>&nbsp; 1 小时 读完 (大约 10099 个字) </span><span class="level-item has-text-grey" id="busuanzi_container_page_pv"><i class="far fa-eye"></i> <span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><div class="content"><p>[toc]</p><h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>java作为一门为面向对象而生的语言，与cpp有着巨大的不同（比如万物皆“引用”）。利用java解决算法竞赛题目，在高精度、字符串处理、封装增强复用性等方面较cpp有优势。在ACM中若想用java替代cpp解决题目，理应对继承、多态、垃圾回收、自动打包解包机制，以及面对对象思想有基本的理解。</p><p>首先希望你对 java 基础有一定了解（比如对象判等要用<code>.equals</code>），本章更多的是深究 jdk API 中哪些对于 ACM 有优势。</p><a id="more"></a><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><p>java中的输入输出流多带有一种”管道”的概念。</p><h4 id="标准输入输出"><a href="#标准输入输出" class="headerlink" title="标准输入输出"></a>标准输入输出</h4><p>标准输入输出的最简洁写法主要依靠两个类：Scanner、System。Scanner在java.util包，需要手动导入，System在java.lang包，会自动导入。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 输入 */</span></span><br><span class="line">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="hljs-keyword">int</span> a = sc.nextInt();</span><br><span class="line"><span class="hljs-keyword">int</span> a = sc.nextInt(<span class="hljs-number">2</span>);            <span class="hljs-comment">// 将下一个整数二进制读入</span></span><br><span class="line"><span class="hljs-keyword">long</span> b = sc.nextLong(); </span><br><span class="line"><span class="hljs-keyword">long</span> b = sc.nextLong(<span class="hljs-number">2</span>);          <span class="hljs-comment">// 将下一个整数二进制读入</span></span><br><span class="line"><span class="hljs-keyword">double</span> d = sc.nextDouble();</span><br><span class="line">String s = sc.next();             <span class="hljs-comment">// 读入下一个字符串(自动跳过空白符)</span></span><br><span class="line">String ss = sc.nextLine();        <span class="hljs-comment">// 读入一行字符串</span></span><br><span class="line">BigInteger = sc.nextBigInteger(); <span class="hljs-comment">// 读入高精度整数</span></span><br><span class="line">BigInteger = sc.nextBigInteger(<span class="hljs-number">2</span>);<span class="hljs-comment">// 读入二进制高精度整数</span></span><br><span class="line">BigDecimal = sc.nextBigDecimal(); <span class="hljs-comment">// 读入高精度小数</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 多组读入 */</span></span><br><span class="line"><span class="hljs-keyword">while</span>(sc.hasNext()) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> a = sc.nextInt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 需要注意，倘若输入如下，两个整数+一行：</span></span><br><span class="line"><span class="hljs-comment">1 3</span></span><br><span class="line"><span class="hljs-comment">asdfggh dasd   sd</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-keyword">int</span> a = sc.nextInt(), b = sc.nextInt();</span><br><span class="line">String s = sc.nextLine(); </span><br><span class="line"><span class="hljs-comment">// 上面的读法出错，此时读到的s是第一行末尾的换行符，故正确的用法如下：</span></span><br><span class="line"><span class="hljs-keyword">int</span> a = sc.nextInt(), b = sc.nextInt(); sc.nextLine(); <span class="hljs-comment">// 应先消除第一行末的换行符</span></span><br><span class="line">String s = sc.nextLine(); </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 输出 */</span></span><br><span class="line">System.out.println(<span class="hljs-string">"121212"</span>); <span class="hljs-comment">// 输出末带换行</span></span><br><span class="line">System.out.print(<span class="hljs-string">"213213"</span>);   <span class="hljs-comment">// 输出末不带换行</span></span><br><span class="line">System.out.printf(<span class="hljs-string">"%d"</span>, <span class="hljs-number">123</span>); <span class="hljs-comment">// 格式化输出</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* Scanner 本质上是一个 Iterartor，文档中的解释是"一个可以使用正则表达式来解析基本类型和字符串的简单文本扫描器" */</span></span><br><span class="line">String input = <span class="hljs-string">"1 fish 2 fish red fish blue fish"</span>;</span><br><span class="line">Scanner sc = <span class="hljs-keyword">new</span> Scanner(input).useDelimiter(<span class="hljs-string">"\\s*fish\\s*"</span>);</span><br><span class="line">System.out.println(sc.nextInt()); <span class="hljs-comment">// 输出1</span></span><br><span class="line">System.out.println(sc.nextInt()); <span class="hljs-comment">// 输出2</span></span><br><span class="line">System.out.println(sc.next());    <span class="hljs-comment">// 输出red</span></span><br><span class="line">System.out.println(sc.next());    <span class="hljs-comment">// 输出blue</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 跳过下一个匹配某re模式的信息 */</span></span><br><span class="line">sc.skip(StringOfRegex);</span><br></pre></td></tr></table></figure><h4 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h4><p>格式化输出，大多针对小数的保留几位小数的输出。利用printf像cpp一样格式化输出，二是利用DecimalFormat对象。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* printf 格式化输出 */</span></span><br><span class="line">System.out.printf(<span class="hljs-string">"%d %10.5f\n"</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3.4</span>);</span><br><span class="line"><span class="hljs-comment">/* 借由DecimalFormat */</span></span><br><span class="line">DecimalFormat df = <span class="hljs-keyword">new</span> DecimalFormat(<span class="hljs-string">"0.000"</span>);</span><br><span class="line">System.out.println(<span class="hljs-string">"x = "</span> + df.format(<span class="hljs-number">1.2345</span>));</span><br></pre></td></tr></table></figure><h4 id="快速IO"><a href="#快速IO" class="headerlink" title="快速IO"></a>快速IO</h4><p>快速IO，如同cpp一样，是预先将输入读到缓冲区，模拟读入。</p><ul><li>第一版快速IO</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 代码易懂易记，适合正式比赛 */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span></span><br><span class="line"><span class="hljs-class"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">static</span> BufferedReader in=<span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">    <span class="hljs-keyword">static</span> StringTokenizer tok;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;hasNext();<span class="hljs-keyword">return</span> tok.nextToken();  &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">nextLine</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">try</span>&#123;<span class="hljs-keyword">return</span> in.readLine();&#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;&#125;&#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextLong</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> Long.parseLong(next());&#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">nextInt</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> Integer.parseInt(next());&#125;</span><br><span class="line">    <span class="hljs-keyword">static</span> PrintWriter out=<span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(System.out));</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">while</span>(tok==<span class="hljs-keyword">null</span>||!tok.hasMoreTokens()) <span class="hljs-keyword">try</span>&#123;tok=<span class="hljs-keyword">new</span> StringTokenizer(in.readLine());&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">int</span> a = nextInt();</span><br><span class="line">        String s = nextLine();</span><br><span class="line">        out.println(s);</span><br><span class="line">        </span><br><span class="line">        out.flush(); <span class="hljs-comment">// 末要加上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第二版快速IO</li></ul><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 代码经过压行，略微暴恐，适合平时做题用，效率略高于第一版 */</span></span><br><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span></span></span><br><span class="line"><span class="hljs-class"></span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">      <span class="hljs-comment">/*</span></span><br><span class="line"><span class="hljs-comment">       写代码</span></span><br><span class="line"><span class="hljs-comment">      */</span></span><br><span class="line">      out.flush();</span><br><span class="line">      out.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">static</span> FastReader in = <span class="hljs-keyword">new</span> FastReader();</span><br><span class="line">    <span class="hljs-keyword">static</span> PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(System.out);</span><br><span class="line">    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastReader</span></span></span><br><span class="line"><span class="hljs-class">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">private</span> InputStream mIs;<span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> curChar,numChars;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FastReader</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">this</span>(System.in); &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FastReader</span><span class="hljs-params">(InputStream is)</span> </span>&#123; mIs = is;&#125;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">if</span> (numChars == -<span class="hljs-number">1</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InputMismatchException();<span class="hljs-keyword">if</span> (curChar &gt;= numChars) &#123;curChar = <span class="hljs-number">0</span>;<span class="hljs-keyword">try</span> &#123; numChars = mIs.read(buf);&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InputMismatchException();&#125;<span class="hljs-keyword">if</span> (numChars &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>; &#125;<span class="hljs-keyword">return</span> buf[curChar++];&#125;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">nextLine</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> c = read();<span class="hljs-keyword">while</span> (isSpaceChar(c)) c = read();StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<span class="hljs-keyword">do</span> &#123;res.appendCodePoint(c);c = read();&#125;<span class="hljs-keyword">while</span> (!isEndOfLine(c));<span class="hljs-keyword">return</span> res.toString() ;&#125;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> c = read();<span class="hljs-keyword">while</span> (isSpaceChar(c)) c = read();StringBuilder res = <span class="hljs-keyword">new</span> StringBuilder();<span class="hljs-keyword">do</span> &#123;res.appendCodePoint(c);c = read();&#125;<span class="hljs-keyword">while</span> (!isSpaceChar(c));<span class="hljs-keyword">return</span> res.toString();&#125;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">l</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> c = read();<span class="hljs-keyword">while</span> (isSpaceChar(c)) c = read();<span class="hljs-keyword">int</span> sgn = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) &#123; sgn = -<span class="hljs-number">1</span> ; c = read() ; &#125;<span class="hljs-keyword">long</span> res = <span class="hljs-number">0</span>; <span class="hljs-keyword">do</span>&#123; <span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">'0'</span> || c &gt; <span class="hljs-string">'9'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InputMismatchException();res *= <span class="hljs-number">10</span> ; res += c - <span class="hljs-string">'0'</span> ; c = read();&#125;<span class="hljs-keyword">while</span>(!isSpaceChar(c));<span class="hljs-keyword">return</span> res * sgn;&#125;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">i</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">int</span> c = read() ;<span class="hljs-keyword">while</span> (isSpaceChar(c)) c = read();<span class="hljs-keyword">int</span> sgn = <span class="hljs-number">1</span>;<span class="hljs-keyword">if</span> (c == <span class="hljs-string">'-'</span>) &#123; sgn = -<span class="hljs-number">1</span> ; c = read() ; &#125;<span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<span class="hljs-keyword">do</span>&#123;<span class="hljs-keyword">if</span> (c &lt; <span class="hljs-string">'0'</span> || c &gt; <span class="hljs-string">'9'</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InputMismatchException();res *= <span class="hljs-number">10</span> ; res += c - <span class="hljs-string">'0'</span> ; c = read() ;&#125;<span class="hljs-keyword">while</span>(!isSpaceChar(c));<span class="hljs-keyword">return</span> res * sgn;&#125;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">d</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<span class="hljs-keyword">return</span> Double.parseDouble(next()) ;&#125;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSpaceChar</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> c == <span class="hljs-string">' '</span> || c == <span class="hljs-string">'\n'</span> || c == <span class="hljs-string">'\r'</span> || c == <span class="hljs-string">'\t'</span> || c == -<span class="hljs-number">1</span>; &#125;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEndOfLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> c == <span class="hljs-string">'\n'</span> || c == <span class="hljs-string">'\r'</span> || c == -<span class="hljs-number">1</span>; &#125;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scanIntArr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] arr)</span></span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> li=<span class="hljs-number">0</span>;li&lt;arr.length;++li)&#123; arr[li]=i();&#125;&#125;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scanLongArr</span><span class="hljs-params">(<span class="hljs-keyword">long</span> [] arr)</span></span>&#123;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;++i)&#123;arr[i]=l();&#125;&#125;</span><br><span class="line">        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shuffle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> [] arr)</span></span>&#123; <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=arr.length;i&gt;<span class="hljs-number">0</span>;--i) &#123; <span class="hljs-keyword">int</span> r=(<span class="hljs-keyword">int</span>)(Math.random()*i); <span class="hljs-keyword">int</span> temp=arr[i-<span class="hljs-number">1</span>]; arr[i-<span class="hljs-number">1</span>]=arr[r]; arr[r]=temp; &#125; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="重定向IO"><a href="#重定向IO" class="headerlink" title="重定向IO"></a>重定向IO</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 标准输入输出 */</span></span><br><span class="line"><span class="hljs-keyword">static</span> Scanner sc;</span><br><span class="line"><span class="hljs-keyword">static</span> &#123;</span><br><span class="line">    sc = <span class="hljs-keyword">new</span> Scanner(<span class="hljs-string">"in.txt"</span>);</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        System.setOut(<span class="hljs-keyword">new</span> PrintStream(<span class="hljs-string">"out.txt"</span>));</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        System.exit(<span class="hljs-number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 第一版快速IO+重定向 */</span></span><br><span class="line"><span class="hljs-keyword">static</span> BufferedReader in;</span><br><span class="line"><span class="hljs-keyword">static</span> PrintWriter out;</span><br><span class="line"><span class="hljs-keyword">static</span> &#123;</span><br><span class="line">    <span class="hljs-keyword">try</span> &#123;</span><br><span class="line">        in = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"in.txt"</span>)));</span><br><span class="line">        out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-keyword">new</span> OutputStreamWriter(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"out.txt"</span>)));</span><br><span class="line">    &#125; <span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        System.exit(<span class="hljs-number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><p>基本数据类型的包装类中，包含对进制的处理方法、字符串到整型的转换。这里仅拿Integer作范例，Long、Short、Boolean、Double理应有相应的用法。</p><h4 id="进制相关"><a href="#进制相关" class="headerlink" title="进制相关"></a>进制相关</h4><p>对于进制转换通过10进制为中介，理应可以处理任意进制间的转换。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 进制转换 */</span></span><br><span class="line">Integer.toString(<span class="hljs-number">111</span>, <span class="hljs-number">16</span>);   <span class="hljs-comment">// 111是十进制数，16是目标base进制，最大可支持的radix是"0123456789abcdefghijklmnopqrstuvwxyz"</span></span><br><span class="line">Integer.valueOf(<span class="hljs-string">"FFFF"</span>, <span class="hljs-number">16</span>)  <span class="hljs-comment">// 16-&gt;10</span></span><br><span class="line">Integer.valueOf(<span class="hljs-string">"776"</span>, <span class="hljs-number">8</span>)    <span class="hljs-comment">// 8-&gt;10</span></span><br><span class="line">Integer.valueOf(<span class="hljs-string">"010101"</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 2-&gt;10</span></span><br><span class="line">Integer.toBinaryString(<span class="hljs-number">12</span>);        <span class="hljs-comment">// 将12转成忽略前导零的二进制String，得到1100</span></span><br><span class="line">Integer.toOctalString(<span class="hljs-number">12</span>);         <span class="hljs-comment">// 将12转成忽略前导零的八进制String，得到14</span></span><br><span class="line">Integer.toHexString(<span class="hljs-number">12</span>);           <span class="hljs-comment">// 将12转成忽略前导零的十六进制String，得到c</span></span><br><span class="line">    </span><br><span class="line"><span class="hljs-comment">/* 二进制位处理 */</span></span><br><span class="line">Integer.bitCount(<span class="hljs-number">7</span>);               <span class="hljs-comment">// 7的二进制补码中多少个"1"</span></span><br><span class="line">Integer.highestOneBit(<span class="hljs-number">11</span>);         <span class="hljs-comment">// 11的二进制最左位的幂次 如11=8+2+1, 则返回8</span></span><br><span class="line">Integer.lowestOneBit(<span class="hljs-number">11</span>);          <span class="hljs-comment">// 11的二进制最右位的幂次 如11=8+2+1, 则返回1</span></span><br><span class="line">Integer.numberOfLeadingZeros(<span class="hljs-number">12</span>);  <span class="hljs-comment">// 返回二进制补码中前导零的个数，如12=1100(2),返回32-4=28</span></span><br><span class="line">Integer.numberOfTrailingZeros(<span class="hljs-number">12</span>); <span class="hljs-comment">// 返回二进制补码中末导零的个数，如12=1100(2),返回2</span></span><br><span class="line">Integer.reverse(<span class="hljs-number">12</span>);               <span class="hljs-comment">// 以bit为单位反转12的二进制得到805306368</span></span><br><span class="line">Integer.reverseByte(<span class="hljs-number">12</span>);           <span class="hljs-comment">// 以Byte为单位反转12的二进制得到201326592</span></span><br><span class="line">Integer.rotateLeft(<span class="hljs-number">12</span>, <span class="hljs-number">2</span>)          <span class="hljs-comment">// 将12的二进制循环左移2位，得到110000，注意是循环左移</span></span><br><span class="line">Integer.rotateRight(<span class="hljs-number">12</span>, <span class="hljs-number">2</span>)         <span class="hljs-comment">// 将12的二进制循环右移2位</span></span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> a = Integer.parseInt(<span class="hljs-string">"12345"</span>);         <span class="hljs-comment">// 经常用来将读入String转int</span></span><br><span class="line"><span class="hljs-keyword">long</span> b = Long.parseLong(<span class="hljs-string">"233333333333333"</span>);</span><br></pre></td></tr></table></figure><h3 id="Character"><a href="#Character" class="headerlink" title="Character"></a>Character</h3><p>基本数据类型 char 的包装类，主要使用其对字符的判断方法、以及case转换。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Character.isDigit(<span class="hljs-string">'1'</span>);</span><br><span class="line">Character.isLetter(<span class="hljs-string">'a'</span>);</span><br><span class="line">Character.isLetterOrDigit(<span class="hljs-string">'1'</span>);</span><br><span class="line">Character.isLowerCase(<span class="hljs-string">'a'</span>);</span><br><span class="line">Character.isUpperCase(<span class="hljs-string">'A'</span>);</span><br><span class="line">Character.isWhitespace(<span class="hljs-string">' '</span>);</span><br><span class="line">Character.toUpperCase(<span class="hljs-string">'a'</span>);</span><br><span class="line">Character.toLowerCase(<span class="hljs-string">'A'</span>);</span><br></pre></td></tr></table></figure><h3 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h3><p>数学库</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(<span class="hljs-keyword">double</span> a) </span><br><span class="line">Math.max(a, b) <span class="hljs-comment">// 返回两个值中较大的一个</span></span><br><span class="line">Math.min(a, b) <span class="hljs-comment">// 返回两个值中较小的一个</span></span><br><span class="line">Math.sin(<span class="hljs-keyword">double</span> a) </span><br><span class="line">Math.tan(<span class="hljs-keyword">double</span> a) </span><br><span class="line">Math.sqrt(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">// 返回正确舍入的 double 值的正平方根</span></span><br><span class="line">Math.sinh(<span class="hljs-keyword">double</span> x) <span class="hljs-comment">// 返回 double 值的双曲线正弦</span></span><br><span class="line">Math.tanh(<span class="hljs-keyword">double</span> x)  <span class="hljs-comment">// 返回 double 值的双曲线余弦 </span></span><br><span class="line">Math.toDegrees(<span class="hljs-keyword">double</span> angrad) <span class="hljs-comment">// 将用弧度表示的角转换为近似相等的用角度表示的角 </span></span><br><span class="line">Math.toRadians(<span class="hljs-keyword">double</span> angdeg) <span class="hljs-comment">// 将用角度表示的角转换为近似相等的用弧度表示的角 </span></span><br><span class="line">Math.acos(<span class="hljs-keyword">double</span> a)  <span class="hljs-comment">// 返回一个值的反余弦；返回的角度范围在 0.0 到 pi 之间</span></span><br><span class="line">Math.asin(<span class="hljs-keyword">double</span> a)  <span class="hljs-comment">// 返回一个值的反正弦；返回的角度范围在 -pi/2 到 pi/2 之间</span></span><br><span class="line">Math.atan(<span class="hljs-keyword">double</span> a)  <span class="hljs-comment">// 返回一个值的反正切；返回的角度范围在 -pi/2 到 pi/2 之间</span></span><br><span class="line">Math.atan2(<span class="hljs-keyword">double</span> y, <span class="hljs-keyword">double</span> x) <span class="hljs-comment">// 将矩形坐标 (x, y) 转换成极坐标 (r, theta)，返回所得角 theta </span></span><br><span class="line">Math.cbrt(<span class="hljs-keyword">double</span> a)  <span class="hljs-comment">// 返回 double 值的立方根 </span></span><br><span class="line">Math.ceil(<span class="hljs-keyword">double</span> a)  <span class="hljs-comment">// 返回最小的（最接近负无穷大）double 值，该值大于等于参数，并等于某个整数 </span></span><br><span class="line">Math.copySign(<span class="hljs-keyword">double</span> magnitude, <span class="hljs-keyword">double</span> sign) <span class="hljs-comment">// 返回带有第二个浮点参数符号的第一个浮点参数 </span></span><br><span class="line">Math.copySign(<span class="hljs-keyword">float</span> magnitude, <span class="hljs-keyword">float</span> sign)  <span class="hljs-comment">// 返回带有第二个浮点参数符号的第一个浮点参数 </span></span><br><span class="line">Math.cos(<span class="hljs-keyword">double</span> a)   <span class="hljs-comment">// 返回角的三角余弦 </span></span><br><span class="line">Math.cosh(<span class="hljs-keyword">double</span> x)  <span class="hljs-comment">// 返回 double 值的双曲线余弦 </span></span><br><span class="line">Math.exp(<span class="hljs-keyword">double</span> a)   <span class="hljs-comment">// 返回欧拉数 e 的 double 次幂的值。 </span></span><br><span class="line">Math.expm1(<span class="hljs-keyword">double</span> x) <span class="hljs-comment">// 返回 ex -1 </span></span><br><span class="line">Math.floor(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">// 返回最大的（最接近正无穷大）double 值，该值小于等于参数，并等于某个整数。</span></span><br><span class="line">Math.getExponent(<span class="hljs-keyword">double</span> d)  <span class="hljs-comment">// 返回 double 表示形式中使用的无偏指数。 </span></span><br><span class="line">Math.getExponent(<span class="hljs-keyword">float</span> f)  <span class="hljs-comment">// 返回 float 表示形式中使用的无偏指数。 </span></span><br><span class="line">Math.hypot(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y)  <span class="hljs-comment">// 返回 sqrt(x2 +y2)，没有中间溢出或下溢 </span></span><br><span class="line">Math.log(<span class="hljs-keyword">double</span> a)  <span class="hljs-comment">// 返回 double 值的自然对数（底数是 e）</span></span><br><span class="line">Math.log10(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">// 返回 double 值的底数为 10 的对数。 </span></span><br><span class="line">Math.log1p(<span class="hljs-keyword">double</span> x) <span class="hljs-comment">// 返回参数与 1 之和的自然对数。 </span></span><br><span class="line">Math.nextAfter(<span class="hljs-keyword">double</span> start, <span class="hljs-keyword">double</span> direction) <span class="hljs-comment">// 返回第一个参数和第二个参数之间与第一个参数相邻的浮点数</span></span><br><span class="line">Math.nextUp(<span class="hljs-keyword">double</span> d)  <span class="hljs-comment">// 返回 d 和正无穷大之间与 d 相邻的浮点值</span></span><br><span class="line">Math.pow(<span class="hljs-keyword">double</span> a, <span class="hljs-keyword">double</span> b) <span class="hljs-comment">// 返回第一个参数的第二个参数次幂的值</span></span><br><span class="line">Math.rint(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">// 返回最接近参数并等于某一整数的 double 值</span></span><br><span class="line">Math.round(<span class="hljs-keyword">double</span> a) <span class="hljs-comment">// 返回最接近参数的 long, 四舍五入</span></span><br><span class="line">Math.scalb(<span class="hljs-keyword">double</span> d, <span class="hljs-keyword">int</span> scaleFactor) <span class="hljs-comment">// 返回 d × 2scaleFactor，其舍入方式如同将一个正确舍入的浮点值乘以 double 值集合中的一个值</span></span><br><span class="line">Math.signum(<span class="hljs-keyword">double</span> d) <span class="hljs-comment">// 返回参数的符号函数；如果参数为 0，则返回 0；如果参数大于 0，则返回 1.0；如果参数小于 0，则返回 -1.0</span></span><br></pre></td></tr></table></figure><h3 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h3><p>伪随机数</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* Math库中的简易版 */</span></span><br><span class="line">Math.random()  <span class="hljs-comment">// 返回带正号的 double 值，该值大于等于 0.0 且小于 1.0。 </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 新建随机生成器48位 */</span></span><br><span class="line">Random rand = <span class="hljs-keyword">new</span> Random();             <span class="hljs-comment">// 随机种子</span></span><br><span class="line">Random rand = <span class="hljs-keyword">new</span> Random(aValueOfLong); <span class="hljs-comment">// 填入Long作为种子, 不要填入常数</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 生成随机数 */</span></span><br><span class="line">rand.nextInt();    <span class="hljs-comment">// 在2^32个数中随机生成一个</span></span><br><span class="line">rand.nextInt(<span class="hljs-number">3</span>);   <span class="hljs-comment">// 在[0,3)中生成一个随机数</span></span><br><span class="line">rand.nextInt(<span class="hljs-number">18</span>)-<span class="hljs-number">3</span>;<span class="hljs-comment">// [-3,15)</span></span><br><span class="line">rand.nextLong();   <span class="hljs-comment">// 随机生成一个Long, 由于Random是48位故不会生成所有的Long</span></span><br><span class="line">rand.nextBoolean();</span><br><span class="line">rand.nextDouble(); <span class="hljs-comment">// [0.0,1.0)</span></span><br><span class="line">rand.nextDouble()*<span class="hljs-number">1.5</span>+<span class="hljs-number">1</span>; <span class="hljs-comment">// [1,2.5)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 实现：随机抽出数组中的k个数 */</span></span><br><span class="line"><span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> idx = (<span class="hljs-keyword">int</span>) (Math.random() * n);</span><br><span class="line">    result[i] = numbers[idx];</span><br><span class="line">    numbers[idx] = numbers[n-<span class="hljs-number">1</span>];</span><br><span class="line">    n--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>高精度整数</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">BigInteger bigI1 = <span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"123124"</span>);</span><br><span class="line">BigInteger bigI2 = BigInteger.valueOf(<span class="hljs-number">1234L</span>);</span><br><span class="line"><span class="hljs-keyword">long</span> i1 = bigI1.longValue(); <span class="hljs-comment">// 转long</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 常量 */</span></span><br><span class="line">BigInteger.ONE、BigInteger.ZERO、BigInteger.TEN</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 加add、减substart、乘multiply、除divide、取模mod、取余rem */</span></span><br><span class="line">bigI1 = bigI1.multiply(bigI2);   <span class="hljs-comment">// 时间复杂度有优化 n^1.585 n^1.465</span></span><br><span class="line">System.out.println(bigI1);</span><br><span class="line">bigI1.divide(bigI2);</span><br><span class="line">bigI1.remainder(bigI2);</span><br><span class="line">bigI1.divideAndRemainder(bigI2); <span class="hljs-comment">// 返回包含(bigI1 / bigI2)、(bigI1 % bigI2)的两个BigInteger的数组, 效率</span></span><br><span class="line">bigI1.pow(bigI2); <span class="hljs-comment">// bigI1^bigI2</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 比较 compareTo、equals、max、min  */</span></span><br><span class="line">System.out.println(bigI1.equals(bigI2));    <span class="hljs-comment">// 返回 false</span></span><br><span class="line">System.out.println(bigI1.compareTo(bigI2)); <span class="hljs-comment">// 返回 1、0、-1 分别表示 &gt; = &lt;</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 位操作相关 */</span></span><br><span class="line">BigInteger.valueOf(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">4</span>).bitCount(); <span class="hljs-comment">// 返回3,二进制补码中与符号不同的位的数量</span></span><br><span class="line">BigInteger.valueOf(-<span class="hljs-number">1</span>-<span class="hljs-number">2</span>-<span class="hljs-number">4</span>).bitCount();<span class="hljs-comment">// 返回2</span></span><br><span class="line">BigInteger.valueOf(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">4</span>).bitLength();<span class="hljs-comment">// 返回3,最小二进制补码表示形式的位数，不包括符号位。</span></span><br><span class="line">BigInteger.valueOf(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">4</span>).clearBit(<span class="hljs-number">3</span>);<span class="hljs-comment">// 指定位二进制置零, 右数第3位(下标从0开始算)</span></span><br><span class="line">BigInteger.valueOf(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">4</span>).flipBit(<span class="hljs-number">3</span>); <span class="hljs-comment">// 指定位二进制翻转, 右数第3位(下标从0开始算)</span></span><br><span class="line">BigInteger.valueOf(<span class="hljs-number">1</span>+<span class="hljs-number">2</span>+<span class="hljs-number">4</span>).getLowestSetBit(); <span class="hljs-comment">// 得到右数首个1的位置(下标从0开始算), 若返回-1则数=0</span></span><br><span class="line"><span class="hljs-comment">// 还有 setBig(n)指定位置1、shiftLeft(n)左移、shiftRight(n)右移、testBit(n)第n位是不是1</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 位运算相关and、or、xor */</span></span><br><span class="line">bigI1 = bigI1.and(bigI2);     <span class="hljs-comment">// 位与</span></span><br><span class="line">bigI1 = bigI1.andNot(bigI2);  <span class="hljs-comment">// 位与 bigI1&amp;~bigI2</span></span><br><span class="line">bigI1 = bigI1.or(bigI2);      <span class="hljs-comment">// 位或</span></span><br><span class="line">bigI1 = bigI1.xor(bigI2);     <span class="hljs-comment">// 位异或</span></span><br><span class="line">bigI1 = bigI1.not();          <span class="hljs-comment">// 返回取非, 当且仅当此 BigInteger 为非负时，此方法返回一个负值</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 数学 */</span></span><br><span class="line">bigI1.abs();</span><br><span class="line">bigI1.negate();                  <span class="hljs-comment">// 返回负的bigI1</span></span><br><span class="line">bigI1.gcd(bigI2);</span><br><span class="line">bigI1.isProbablePrime();         <span class="hljs-comment">// 返回bigT1是否可能为素数, 底层是Miller-Rabin判素</span></span><br><span class="line">bigI1.isProbablePrime(certainty);<span class="hljs-comment">// 出错率为(1-(1/2)^certainty), certainty越大时间复杂度越高</span></span><br><span class="line">bigI1.modInverse(m);             <span class="hljs-comment">// 返回m的逆元，可能会抛出异常ArithmeticException，当m&lt;=0或者无逆元（即不是m的相对素数）</span></span><br><span class="line">bigI1.modPow(n,mod);             <span class="hljs-comment">// bigI1^n%MOD, </span></span><br><span class="line">bigI1.nextProbablePrime();       <span class="hljs-comment">// 返回这个数的可能的下一个素数, 出错率小于2^-100</span></span><br><span class="line">BigInteger.probablePrime(<span class="hljs-keyword">int</span> bitLength, Random rnd) <span class="hljs-comment">//  返回有可能是素数的、具有指定长度的正 BigInteger</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 进制转换 */</span></span><br><span class="line"><span class="hljs-keyword">new</span> BigInteger(<span class="hljs-string">"4123"</span>, <span class="hljs-number">5</span>).toString(<span class="hljs-number">30</span>); <span class="hljs-comment">// 5进制转为30进制输出, 进制不超过可用字符26+数位10=36, 超过就变回十进制</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 拓展：多乘优化 */</span></span><br><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MultiplyTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">BigInteger</span>&gt; </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BigInteger b1, b2;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MultiplyTask</span><span class="hljs-params">(BigInteger b1, BigInteger b2)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.b1 = b1;</span><br><span class="line">        <span class="hljs-keyword">this</span>.b2 = b2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> BigInteger <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> b1.multiply(b2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">MultiplyTask mt1 = <span class="hljs-keyword">new</span> MultiplyTask(xh, yh);</span><br><span class="line">mt1.fork();</span><br><span class="line">BigInteger p2 = xl.multiply(yl);  <span class="hljs-comment">// p2 = xl*yl</span></span><br><span class="line">BigInteger p1 = mt1.join();<span class="hljs-comment">//xh.multiply(yh);  // p1 = xh*yh</span></span><br></pre></td></tr></table></figure><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>高精度浮点数</p><p>没写完，留坑！</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">BigDecimal a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"12.2121"</span>);</span><br><span class="line">BigDecimal b = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">12121</span>);</span><br><span class="line">BigDecimal c = BigDecimal.valueOf(<span class="hljs-number">121.12</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 常量 */</span></span><br><span class="line">BigDecimal.ONE、BigDecimal.ZERO、BigDecimal.TEN</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 舍入模式常量 */</span></span><br><span class="line">BigDecimal.ROUND_CEILING     <span class="hljs-comment">// 接近正无穷大的舍入模式</span></span><br><span class="line">BigDecimal.ROUND_FLOOR       <span class="hljs-comment">// 接近负无穷大的舍入模式</span></span><br><span class="line">BigDecimal.ROUND_UP          <span class="hljs-comment">// 舍入远离零的舍入模式</span></span><br><span class="line">BigDecimal.ROUND_DOWN        <span class="hljs-comment">// 接近零的舍入模式</span></span><br><span class="line">BigDecimal.ROUND_HALF_DOWN   <span class="hljs-comment">// 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则上舍入</span></span><br><span class="line">BigDecimal.ROUND_HALF_UP     <span class="hljs-comment">// 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则下舍入</span></span><br><span class="line">BigDecimal.ROUND_HALF_EVEN   <span class="hljs-comment">// 向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向偶数舍入</span></span><br><span class="line">BigDecimal.ROUND_UNNECESSARY <span class="hljs-comment">// 断言请求的操作具有精确的结果，因此不需要舍入</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 加减乘除模余add、subtact、multiply、divide remainder*/</span></span><br><span class="line">BigDecimal addResult = a.add(b);</span><br><span class="line">BigDecimal subResult = b.subtract(c);</span><br><span class="line">BigDecimal mulResult = a.multiply(c);</span><br><span class="line">BigDecimal divResult = b.divide(a, <span class="hljs-number">20</span>, BigDecimal.ROUND_DOWN); <span class="hljs-comment">// 规定精度和舍入规则</span></span><br><span class="line">BigDecimal remResult = a.remainder(c); <span class="hljs-comment">// a%c</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 比较 compareTo、equals、max、min*/</span></span><br><span class="line">System.out.println(a.compareTo(b));<span class="hljs-comment">// 1 0 -1   -&gt;   &gt; = &lt;</span></span><br><span class="line">System.out.println(a.equals(b));   </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 小数点操作 */</span></span><br><span class="line">movePointLeft(<span class="hljs-keyword">int</span> n) </span><br><span class="line">movePointRight(<span class="hljs-keyword">int</span> n)</span><br><span class="line">stripTrailingZeros() <span class="hljs-comment">// 末导零去除</span></span><br><span class="line">    </span><br><span class="line"><span class="hljs-comment">/* 数学 */</span></span><br><span class="line">abs()</span><br><span class="line">negate()<span class="hljs-comment">// 转负数</span></span><br><span class="line">plus()  <span class="hljs-comment">// 转正数</span></span><br><span class="line">pow(n)  <span class="hljs-comment">// 幂次</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 输出  */</span></span><br><span class="line">System.out.println(a.toString());             <span class="hljs-comment">// 科学计数法表示</span></span><br><span class="line">System.out.println(a.toEngineeringString());  <span class="hljs-comment">// 工程计数法表示</span></span><br><span class="line">System.out.println(a.toPlainString());        <span class="hljs-comment">// 10进制小数表示</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 精度处理 */</span></span><br><span class="line">MathContext mc = <span class="hljs-keyword">new</span> MathContext(精度位数n, 舍入模式);</span><br><span class="line">BigDecimal a = <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-string">"12.2121"</span>, mc);</span><br><span class="line">setScale(n)</span><br><span class="line">precision() </span><br><span class="line">scale() </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 如果 BigDecimal 对象用作 SortedMap 中的键或 SortedSet 中的元素，则应特别小心，因为 BigDecimal 的自然排序与 equals 方法不一致。</span></span><br><span class="line">    </span><br><span class="line"><span class="hljs-comment">/* 牛顿法开方 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BigDecimal <span class="hljs-title">sqrt</span><span class="hljs-params">(BigDecimal value, <span class="hljs-keyword">int</span> scale)</span> </span>&#123;</span><br><span class="line">    BigDecimal num2 = BigDecimal.valueOf(<span class="hljs-number">2</span>);</span><br><span class="line">    <span class="hljs-keyword">int</span> precision = <span class="hljs-number">120</span>;</span><br><span class="line">    MathContext mc = <span class="hljs-keyword">new</span> MathContext(precision, RoundingMode.HALF_UP);</span><br><span class="line">    BigDecimal deviation = value;</span><br><span class="line">    <span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-keyword">while</span> (cnt &lt; precision) &#123;</span><br><span class="line">        deviation = (deviation.add(value.divide(deviation, mc))).divide(num2, mc);</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    deviation = deviation.setScale(scale, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">    <span class="hljs-keyword">return</span> deviation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// 牛顿迭代法介绍</p><p>设$f(x)$，求当$f(x)=0$时x的值，则设初始值为$x_0（其值随意）$，则根据牛顿迭代法可得$x_{k+1}=x_k-f(x_k)/f`(x_k)$，若$x_0$在解的邻域内，则牛顿迭代法就可以找到解。</p><h3 id="Bitset"><a href="#Bitset" class="headerlink" title="Bitset"></a>Bitset</h3><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><p>此类包含用来操作数组（比如排序和搜索）的各种静态方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 【数组填充】</span></span><br><span class="line"><span class="hljs-comment"> *  fill源码是for循环</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">15</span>];</span><br><span class="line">Arrays.fill(a, <span class="hljs-number">1</span>);</span><br><span class="line">Arrays.fill(a, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 左闭右开</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 【转Collection】</span></span><br><span class="line"><span class="hljs-comment"> * Arrays.asList()</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">15</span>];</span><br><span class="line">Arrays.asList(a);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 【数组输出】</span></span><br><span class="line"><span class="hljs-comment"> *  Arrays.toString(数组)</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line">System.out.println(Arrays.toString(a));</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i : a) System.out.print(i + <span class="hljs-string">" "</span>); <span class="hljs-comment">// for-each循环</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 【数组拷贝】</span></span><br><span class="line"><span class="hljs-comment"> * Arrays.copyOf(数组, len);           // 从0开始复制返回数组对象</span></span><br><span class="line"><span class="hljs-comment"> * Arrays.copyOfRange(数组, from, to);</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125;;</span><br><span class="line"><span class="hljs-keyword">int</span> b[] = Arrays.copyOf(a, <span class="hljs-number">3</span>);</span><br><span class="line"><span class="hljs-keyword">int</span> c[] = Arrays.copyOfRange(a, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// 左闭右开拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 【数组判等】</span></span><br><span class="line"><span class="hljs-comment"> * Arrays.equals(a, b); </span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;, b[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;</span><br><span class="line">Arrays.equals(a, b);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 【二分搜索】</span></span><br><span class="line"><span class="hljs-comment"> * 需要先排序，可以为对象数组，要实现比较接口</span></span><br><span class="line"><span class="hljs-comment"> * 返回值&gt;=0时，为搜索值下标</span></span><br><span class="line"><span class="hljs-comment"> * 返回值 &lt;0时，如-3，则表明该数应该为数组第3个数</span></span><br><span class="line"><span class="hljs-comment"> */</span></span><br><span class="line"><span class="hljs-keyword">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">98</span>,<span class="hljs-number">1090</span>,<span class="hljs-number">12332</span>,<span class="hljs-number">32431231</span>&#125;;</span><br><span class="line">System.out.println(Arrays.binarySearch(a, <span class="hljs-number">111</span>));</span><br></pre></td></tr></table></figure><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>此类包含用来容器类对象（比如排序和搜索）的各种静态方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 【反转】 */</span></span><br><span class="line">Collections.reverse(容器类对象);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 【取大取小】*/</span></span><br><span class="line">Collections.max(容器类对象); <span class="hljs-comment">// 还有min</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 【无交集判断】*/</span></span><br><span class="line">Collections.disjoint(a, b); <span class="hljs-comment">// 返回boolean</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 【打乱】 */</span></span><br><span class="line">Collections.shuffle(容器类对象);   </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 【二分】 */</span></span><br><span class="line"><span class="hljs-keyword">int</span> i1 = Collections.binarySearch(buy, m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ...等</span></span><br></pre></td></tr></table></figure><h3 id="Java-容器架构"><a href="#Java-容器架构" class="headerlink" title="Java 容器架构"></a>Java 容器架构</h3><p>Java 容器主要可划分为 4 个部分：List 列表、Map 映射、Set 集合、工具类 (Iterator迭代器、Enumeration枚举类、Arrays和Collections)</p><p><img src="1567154272941.png" alt="1567154272941"></p><p>上图为 Java 容器的框架图，主干部分有两个：</p><ul><li>Collection，高度抽象的接口，定义了一个集合的基本操作和属性，分为 List 和 Set 两大分支<ul><li>List，有序列表，每个元素都有其索引。有具体的实现类如 ArrayList、LinkedList、Vector、Stack</li><li>Set，不重复集，每个元素是特殊唯一的。有具体的实现类如 HastSet、TreeSet</li></ul></li><li>Map，抽象的映射容器接口，即 <code>&lt;key, value&gt;</code> 键值对的集合。有具体的实现类如 HashMap，TreeMap，WeakHashMap</li></ul><p>有了 Java 中的多态特性，在具体使用中都建议不直接声明接口的具体实现类，而是用接口接收声明的具体的实现类（形如 <code>List list=new ArrayList()</code>），面向接口编程思想，规范使用，易于扩展。</p><h3 id="Collection-容器"><a href="#Collection-容器" class="headerlink" title="Collection 容器"></a>Collection 容器</h3><p>主要先介绍两个 List 的实现类：ArrayList 和 LinkedList。ArrayList 是可随机访问的变长数组，对应 C++ 中的 Vector。LinkedList 是众多接口例如 List、Queue、Deque 等的实现类。</p><h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><p>Iterator 是一个接口，它是集合的迭代器。集合可以通过 Iterator 去遍历集合中的元素。Iterator 提供的 API 接口，包括：是否存在下一个元素、获取下一个元素、删除当前元素。</p><p>注意：Iterator 遍历 Collection 时，是 fail-fast 机制的。但是由于 ACM 的单线程，故不介绍。</p><p>迭代器不是根据索引定义的，而是根据调用<code>next()</code>或<code>previous()</code>所返回的最后一个元素操作定义的。</p><p>它的位置可以这样理解 <code>^ element(0) ^ element(1) ^ element(2) ^ element(3) ^ element(4) ^</code>，”^”号表示迭代器当前位置。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* Iterator */</span></span><br><span class="line">Iterator&lt;E&gt; it = ...;   <span class="hljs-comment">// 声明好的迭代器</span></span><br><span class="line"><span class="hljs-keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());   <span class="hljs-comment">// 输出当前元素</span></span><br><span class="line">&#125;</span><br><span class="line">it.remove();                         <span class="hljs-comment">// 移除当前元素, 比起循环过程中间remove掉某个元素造成整个集合变化，使用迭代器进行遍历过程中的remove是可行的</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* ListIterator */</span></span><br><span class="line">ListIterator&lt;E&gt; it = ...;   <span class="hljs-comment">// 声明好的队列迭代器</span></span><br><span class="line">hasNext();                  <span class="hljs-comment">// 迭代器是否处于末尾</span></span><br><span class="line">hasPrevious();              <span class="hljs-comment">// 迭代器是否处于首部</span></span><br><span class="line">nextIndex();                <span class="hljs-comment">// 后个元素下标</span></span><br><span class="line">previousIndex();            <span class="hljs-comment">// 前个元素下标</span></span><br><span class="line">previous();                 <span class="hljs-comment">// 返回前个元素并移动迭代器</span></span><br><span class="line">next();                     <span class="hljs-comment">// 返回后个元素并移动迭代器</span></span><br><span class="line">remove();                   <span class="hljs-comment">// 删除上一次next()或previous()操作返回的元素, 没有则异常</span></span><br><span class="line"><span class="hljs-built_in">set</span>(E);                     <span class="hljs-comment">// 设置上一次next()或previous()操作返回的元素为E, 没有则异常</span></span><br></pre></td></tr></table></figure><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList，实现了有序序列接口 List，用户可对列表中每个元素的插入位置进行精确地控制，可根据元素的整数索引访问元素。尽管支持使用迭代器 Iterator 进行顺序访问。但由于又实现了 RandomAccess 接口，比起 Iterator，直接使用索引访问会更快。</p><p>ArrayList 与 Vector 一样是可变数组，与 Vector 不同的有：</p><ol><li>ArrayList 是<strong>不同步</strong>的，在多线程模式下有安全问题，而 Vector 是同步的，同一时刻只有一个线程能访问 Vector，故带来了时耗，ACM 中选择 ArrayList，本文不介绍 Vector</li><li>ArrayList 的内存拓展策略是 50% + 1，Vector 是直接加倍，故提前指定数组大小是较明智的</li></ol><p><img src="1566567956896.png" alt="1566567956896"></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* ArrayList声明 */</span></span><br><span class="line">ArrayList&lt;Integer&gt; a = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-comment">// 新建初始容量为10的空列表</span></span><br><span class="line">ArrayList&lt;Integer&gt; a = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">100</span>);<span class="hljs-comment">// 新建初始容量为100的空列表</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 调整容量 (ArrayList实现类特有方法) */</span></span><br><span class="line">a.ensureCapacity(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 调整容量为2000</span></span><br><span class="line">a.trimToSize();         <span class="hljs-comment">// 调整容量至当前数组大小，释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// ------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 接口接收实现类声明 */</span></span><br><span class="line">List&lt;Integer&gt; a = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();   <span class="hljs-comment">// 新建初始容量为10的空列表</span></span><br><span class="line">List&lt;Integer&gt; a = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">100</span>);<span class="hljs-comment">// 新建初始容量为100的空列表</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 添加 */</span></span><br><span class="line">a.add(<span class="hljs-number">10</span>);             <span class="hljs-comment">// 末尾加10</span></span><br><span class="line">a.add(<span class="hljs-number">0</span>,<span class="hljs-number">19</span>);           <span class="hljs-comment">// 在第0位置放上元素19, 注意下标不要超过数组范围！</span></span><br><span class="line">a.set(<span class="hljs-number">0</span>,<span class="hljs-number">22</span>);           <span class="hljs-comment">// 当第0位置的元素更改为22, 注意要当前元素存在</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 访问 */</span></span><br><span class="line">a.get(<span class="hljs-number">0</span>);               <span class="hljs-comment">// 获得索引为0的元素</span></span><br><span class="line">a.indexOf(<span class="hljs-number">10</span>);          <span class="hljs-comment">// 获得元素10首次出现的位置</span></span><br><span class="line">a.lastIndexOf(<span class="hljs-number">10</span>);      <span class="hljs-comment">// 获得元素10最后一次出现的位置</span></span><br><span class="line">a.contains(<span class="hljs-number">10</span>);         <span class="hljs-comment">// 返回a是否包含元素10</span></span><br><span class="line"><span class="hljs-keyword">for</span>(Integer x : a)</span><br><span class="line">	System.out.print(x);<span class="hljs-comment">// 遍历ArrayList</span></span><br><span class="line">System.out.print(a);    <span class="hljs-comment">// 直接输出ArrayList，形如[1,3,45]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* lambda 与 foreach*/</span></span><br><span class="line">a.forEach((x) -&gt; System.out.print(x+<span class="hljs-string">" "</span>)); <span class="hljs-comment">// 遍历输出每个元素</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 删除 */</span></span><br><span class="line">a.clear();             <span class="hljs-comment">// 清空</span></span><br><span class="line">a.remove(<span class="hljs-number">2</span>);           <span class="hljs-comment">// 删除第2个元素, 参数是基本数据类型int</span></span><br><span class="line">a.remove((Integer)<span class="hljs-number">2</span>);  <span class="hljs-comment">// 删除元素2首次出现的位置, 注意泛型Integer(int的包装类)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 其他 */</span></span><br><span class="line">a.size();</span><br><span class="line">a.isEmpty();</span><br><span class="line">Object[] objects = a.toArray(); <span class="hljs-comment">// 转成Object数组</span></span><br><span class="line"><span class="hljs-comment">// 以下为转成数组的demo，注意 Integer[] as = (Integer[]) a.toArray(); 的用法是错误的</span></span><br><span class="line">Integer list[] = a.toArray(<span class="hljs-keyword">new</span> Integer[a.size()]); </span><br><span class="line">List&lt;Integer&gt; sub = a.subList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 截取下标1~2的视图，注意不是拷贝，在sub上操作会反馈回a</span></span><br></pre></td></tr></table></figure><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList，List 接口的链表实现。除此之外，此类实现 Deque 接口，add、poll 提供先进先出队列操作，可作为堆栈、队列、双端队列使用。注意，LinkedList 是不同步的。其接口方法单独作为用法讲。</p><p><img src="1567152262544.png" alt="1567152262544"></p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">LinkedList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;(); <span class="hljs-comment">// 声明空列表</span></span><br></pre></td></tr></table></figure><h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>List，可译为 “列表”或”链表”。其在 Java 中是 “列表” 的抽象接口。在此节中将其用作为 <strong>“链表”</strong>。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 接口接收实现类声明 */</span></span><br><span class="line">List&lt;Integer&gt; a = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();   <span class="hljs-comment">// 新建空链表</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 添加 */</span></span><br><span class="line">a.add(<span class="hljs-number">10</span>);             <span class="hljs-comment">// 末尾加10</span></span><br><span class="line">a.add(<span class="hljs-number">0</span>,<span class="hljs-number">19</span>);           <span class="hljs-comment">// 在第0位置放上元素19, 注意下标不要超过数组范围！复杂度是O(n/2)</span></span><br><span class="line">a.set(<span class="hljs-number">0</span>,<span class="hljs-number">22</span>);           <span class="hljs-comment">// 当第0位置的元素更改为22, 注意要当前元素存在。  复杂度是O(n/2)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 访问 */</span></span><br><span class="line">a.get(<span class="hljs-number">0</span>);               <span class="hljs-comment">// 获得索引为0的元素</span></span><br><span class="line">a.indexOf(<span class="hljs-number">10</span>);          <span class="hljs-comment">// 获得元素10首次出现的位置</span></span><br><span class="line">a.lastIndexOf(<span class="hljs-number">10</span>);      <span class="hljs-comment">// 获得元素10最后一次出现的位置</span></span><br><span class="line">a.contains(<span class="hljs-number">10</span>);         <span class="hljs-comment">// 返回a是否包含元素10</span></span><br><span class="line"><span class="hljs-keyword">for</span>(Integer x : a)</span><br><span class="line">	System.out.print(x);<span class="hljs-comment">// 遍历LinkedList</span></span><br><span class="line">System.out.print(a);    <span class="hljs-comment">// 直接输出LinkedList，形如[1,3,45]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* lambda 与 forEach */</span></span><br><span class="line">a.forEach((x) -&gt; System.out.print(x+<span class="hljs-string">" "</span>)); <span class="hljs-comment">// 遍历输出每个元素</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 删除 */</span></span><br><span class="line">a.clear();             <span class="hljs-comment">// 清空</span></span><br><span class="line">a.remove(<span class="hljs-number">2</span>);           <span class="hljs-comment">// 删除第2个元素, 参数是基本数据类型int</span></span><br><span class="line">a.remove((Integer)<span class="hljs-number">2</span>);  <span class="hljs-comment">// 删除元素2首次出现的位置, 注意泛型Integer(int的包装类)</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 迭代器 */</span></span><br><span class="line">Iterator&lt;Integer&gt; it = a.iterator();           <span class="hljs-comment">// 迭代器</span></span><br><span class="line">Iterator&lt;Integer&gt; it = list.listIterator();    <span class="hljs-comment">// 链表(双向)迭代器</span></span><br><span class="line">Iterator&lt;Integer&gt; it = list.listIterator(<span class="hljs-number">3</span>);   <span class="hljs-comment">// 从下标3开始的链表得带器</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 其他 */</span></span><br><span class="line">a.size();</span><br><span class="line">a.isEmpty();</span><br><span class="line">Object[] objects = a.toArray(); <span class="hljs-comment">// 转成Object数组</span></span><br><span class="line"><span class="hljs-comment">// 以下为转成数组的demo，注意 Integer[] as = (Integer[]) a.toArray(); 的用法是错误的</span></span><br><span class="line">Integer list[] = a.toArray(<span class="hljs-keyword">new</span> Integer[a.size()]); </span><br><span class="line">List&lt;Integer&gt; sub = a.subList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 截取下标1~2的视图，注意不是拷贝，在sub上操作会反馈回a</span></span><br></pre></td></tr></table></figure><h4 id="Queue-带-PriorityQueue"><a href="#Queue-带-PriorityQueue" class="headerlink" title="Queue (带 PriorityQueue)"></a>Queue (带 PriorityQueue)</h4><p>主要介绍 Queue 的方法，还有特殊的 Queue 实现类 PriorityQueue 的使用。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  <span class="hljs-comment">// 声明空队列</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 赋值 */</span></span><br><span class="line">q.offer(<span class="hljs-number">123</span>);                           <span class="hljs-comment">// 将元素123入队</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 访问 */</span></span><br><span class="line"><span class="hljs-keyword">int</span> x = q.peek();                       <span class="hljs-comment">// 获取队列头，队列空返回null</span></span><br><span class="line"><span class="hljs-keyword">int</span> x = q.poll();                       <span class="hljs-comment">// 获取并移除队列头，队列空返回null</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 带抛出异常的操作方法 */</span></span><br><span class="line">q.add(<span class="hljs-number">123</span>);                             <span class="hljs-comment">// 将元素123入队，超出容量则异常</span></span><br><span class="line">q.remove();                             <span class="hljs-comment">// 获取并移除队列首，队列为空则异常</span></span><br><span class="line">q.element();                            <span class="hljs-comment">// 获取但不移除队列首，队列为空则异常</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 输出 */</span></span><br><span class="line">System.out.println(q);</span><br></pre></td></tr></table></figure><p>优先队列 PriorityQueue 的元素按照其<strong>自然顺序</strong>进行排序，或者根据构造队列时提供的 <code>Comparator</code> 进行排序，具体取决于所使用的构造方法。优先级队列不允许使用 <code>null</code> 元素。注意其类是不同步的。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(); <span class="hljs-comment">// 声明小根堆</span></span><br><span class="line">Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> o2 - o1;</span><br><span class="line">&#125;);                                       <span class="hljs-comment">// 声明大根堆</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 线性构造 */</span></span><br><span class="line">Integer[] Is = <span class="hljs-keyword">new</span> Integer[<span class="hljs-number">10</span>];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) Is[i] = (<span class="hljs-keyword">int</span>) (Math.random()*<span class="hljs-number">10</span>+<span class="hljs-number">1</span>); <span class="hljs-comment">// 赋值</span></span><br><span class="line">Queue&lt;Integer&gt; q = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(Arrays.asList(Is));</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 操作方法的与Queue一致</span></span><br></pre></td></tr></table></figure><h4 id="Deque-作-Stack-用"><a href="#Deque-作-Stack-用" class="headerlink" title="Deque (作 Stack 用)"></a>Deque (作 Stack 用)</h4><p>double ended queue，提供插入、移除和检查元素的方法。每种方法都存在两种形式：一种形式在操作失败时抛出异常，另一种形式返回一个特殊值（<code>null</code> 或 <code>false</code>，具体取决于操作）</p><table><thead><tr><th></th><th>第一个元素（头部）</th><th></th><th>最后一个元素（尾部）</th><th></th></tr></thead><tbody><tr><td></td><td><em>抛出异常</em></td><td><em>特殊值</em></td><td><em>抛出异常</em></td><td><em>特殊值</em></td></tr><tr><td><strong>插入</strong></td><td>addFirst(e)</td><td><strong>offerFirst(e)</strong></td><td>addLast(e)</td><td><strong>offerLast(e)</strong></td></tr><tr><td><strong>移除</strong></td><td>removeFirst()</td><td><strong>pollFirst()</strong></td><td>removeLast()</td><td><strong>pollLast()</strong></td></tr><tr><td><strong>检查</strong></td><td>getFirst()</td><td><strong>peekFirst()</strong></td><td>getLast()</td><td><strong>peekLast()</strong></td></tr></tbody></table><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">Deque&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  <span class="hljs-comment">// 声明空队列</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 赋值 */</span></span><br><span class="line">q.offerLast(<span class="hljs-number">123</span>);                       <span class="hljs-comment">// 将元素123入队尾</span></span><br><span class="line">q.offerFirst(<span class="hljs-number">123</span>);                      <span class="hljs-comment">// 将元素123入队首</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 访问 */</span></span><br><span class="line"><span class="hljs-keyword">int</span> x = q.peekFirst();                  <span class="hljs-comment">// 获取队列头，队列空返回null</span></span><br><span class="line"><span class="hljs-keyword">int</span> x = q.peekLast();                   <span class="hljs-comment">// 获取队列尾，队列空返回null</span></span><br><span class="line"><span class="hljs-keyword">int</span> x = q.pollFirst();                  <span class="hljs-comment">// 获取并移除队列头，队列空返回null</span></span><br><span class="line"><span class="hljs-keyword">int</span> x = q.pollLast();                   <span class="hljs-comment">// 获取并移除队列头，队列空返回null</span></span><br><span class="line"><span class="hljs-keyword">int</span> sz = q.size();                      <span class="hljs-comment">// 获得双端队列大小</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 迭代器 */</span></span><br><span class="line">Iterator&lt;Integer&gt; it = q.descendingIterator(); <span class="hljs-comment">// 逆向迭代器</span></span><br><span class="line">Iterator&lt;Integer&gt; it = q.iterator();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 带抛出异常的操作方法 */</span></span><br><span class="line"><span class="hljs-comment">// 略</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 特殊方法 */</span></span><br><span class="line">q.removeFirstOccurrence((Integer)<span class="hljs-number">123</span>);  <span class="hljs-comment">// 从此双端队列移除第一次出现的指定元素</span></span><br><span class="line">q.removeLastOccurrence((Integer)<span class="hljs-number">123</span>);   <span class="hljs-comment">// 从此双端队列移除第一次出现的指定元素</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 输出 */</span></span><br><span class="line">System.out.println(q);</span><br></pre></td></tr></table></figure><p>作 Stack 使用</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">Deque&lt;Integer&gt; s = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();  <span class="hljs-comment">// 声明空栈</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 赋值 */</span></span><br><span class="line">s.push(<span class="hljs-number">123</span>);                       <span class="hljs-comment">// 将元素123压入栈</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 访问 */</span></span><br><span class="line"><span class="hljs-keyword">int</span> x = s.pop();                   <span class="hljs-comment">// 获取并弹栈</span></span><br><span class="line"><span class="hljs-keyword">int</span> x = s.peek();                  <span class="hljs-comment">// 获取但不弹栈</span></span><br><span class="line"><span class="hljs-keyword">int</span> sz = q.size();                 <span class="hljs-comment">// 获得栈大小</span></span><br></pre></td></tr></table></figure><h3 id="Map-容器"><a href="#Map-容器" class="headerlink" title="Map 容器"></a>Map 容器</h3><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="1567164779330.png" alt="1567164779330"></p><p>接口：</p><ol><li>Map 是映射接口，Map中存储的内容是键值对(key-value)。</li><li>AbstractMap，继承于Map的抽象类，实现了Map中的大部分API。其它Map的实现类可以通过继承AbstractMap来减少重复编码。</li><li>SortedMap 是继承于Map的接口。SortedMap中的内容是排序的键值对，排序的方法是通过比较器(Comparator)。</li><li>NavigableMap 是继承于SortedMap的接口。相比于SortedMap，NavigableMap有一系列的导航方法；如”获取大于/等于某对象的键值对”、“获取小于/等于某对象的键值对”等等。</li></ol><p>实现类：</p><ol><li><p><strong>TreeMap</strong>，基于红黑树的 Map、SortedMap、NavigableMap 等接口的实现类，与 C++ 中的 map 对应。适合对节点大小顺序有要求的需求场景</p></li><li><p><strong>HashMap</strong>，基于 Hash 的 Map 接口实现类。理想情形下能 O(1) 查找键值对。适合数据熵较高且不关心节点顺序的需求场景。</p></li><li><p>WeakHashMap，其键是弱引用，WeakHashMap会在系统内存范围内，保存所有表项目，一旦内存不够，在GC时，没有被引用的表项很快会被清除掉，从而避免系统内存溢出。可以类比 LRU 策略，WeakHashMap 适用于小场景的缓存以提高内存命中提高查找效率。本文不做介绍。</p></li><li><p>Hashtable，线程安全的 HashMap，但其继承的接口与 HashMap 有所不同。ACM 中选择 HashMap 即可。本文不做介绍。</p></li></ol><p>注意 Java 自带容器并没有像 c++ 那样的 multimap。</p><h4 id="Map-Entry"><a href="#Map-Entry" class="headerlink" title="Map.Entry"></a>Map.Entry</h4><p>Map.Entry是Map中内部的一个接口，Map.Entry是<strong>键值对</strong>，Map 可通过 entrySet() 获取Map.Entry的键值对集合，从而通过该集合实现对键值对的操作。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getKey()</span><br><span class="line">getValue()</span><br><span class="line">setValue(V object)</span><br></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;();  <span class="hljs-comment">// 底层是红黑树的map</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();  <span class="hljs-comment">// 底层是哈希表的map</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 赋值 */</span></span><br><span class="line">map.put(<span class="hljs-string">"tt"</span>, <span class="hljs-number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 访问 */</span></span><br><span class="line">map.containsKey(<span class="hljs-string">"tt"</span>);             <span class="hljs-comment">// 是否包含此键</span></span><br><span class="line">map.containsValue(<span class="hljs-number">123</span>);            <span class="hljs-comment">// 是否包含此值 O(n)</span></span><br><span class="line"><span class="hljs-keyword">int</span> v = map.get(<span class="hljs-string">"tt"</span>);             <span class="hljs-comment">// 获取值</span></span><br><span class="line"><span class="hljs-keyword">int</span> v = map.remove(<span class="hljs-string">"tt"</span>);          <span class="hljs-comment">// 移除并返回键所对应的值, 不存在则返回null，将null自动解包到int会异常</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* java中的map计数 使用必须先删再回加 */</span></span><br><span class="line">map.put(<span class="hljs-string">"tt"</span>, map.remove(<span class="hljs-string">"tt"</span>)+<span class="hljs-number">1</span>); <span class="hljs-comment">// 注意可能异常</span></span><br><span class="line">map.put(<span class="hljs-string">"tt"</span>, (map.containsKey(<span class="hljs-string">"tt"</span>)?map.remove(<span class="hljs-string">"tt"</span>):<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-comment">/* 更高效的map计数 -&gt; 自己写一个类MutableInteger，写自增 */</span></span><br><span class="line">Map&lt;String, MutableInteger&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">MutableInteger initValue = <span class="hljs-keyword">new</span> MutableInteger(<span class="hljs-number">1</span>);</span><br><span class="line">MutableInteger oldValue = efficientCounter.put(a, initValue);</span><br><span class="line"><span class="hljs-keyword">if</span>(oldValue != <span class="hljs-keyword">null</span>) initValue.set(oldValue.get() + <span class="hljs-number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 其他 */</span></span><br><span class="line">map.size();                     <span class="hljs-comment">// map的大小</span></span><br><span class="line">map.isEmpty();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 遍历所有entry */</span></span><br><span class="line">Collection&lt;Entry&lt;String, Integer&gt;&gt; values = map.entrySet();</span><br><span class="line"><span class="hljs-comment">// foreach遍历</span></span><br><span class="line"><span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"Key = "</span> + entry.getKey() + <span class="hljs-string">", Value = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// Iterator遍历</span></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();</span><br><span class="line"><span class="hljs-keyword">while</span> (entries.hasNext()) &#123;</span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();</span><br><span class="line">    System.out.println(<span class="hljs-string">"Key = "</span> + entry.getKey() + <span class="hljs-string">", Value = "</span> + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 遍历所有keys、values */</span></span><br><span class="line">Collection&lt;Integer&gt; keys = map.keys();</span><br><span class="line">Collection&lt;Integer&gt; values = map.values();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 输出 */</span></span><br><span class="line">System.out.println(map);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 按value排序 */</span></span><br><span class="line">Map&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;Entry&lt;Integer, Integer&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.addAll(map.entrySet());</span><br><span class="line">Collections.sort(list, (o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> o1.getValue() == o2.getValue() ? o1.getKey() - o2.getKey() : o2.getValue() - o1.getValue();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="hashMap-重写-hashCode-和-equals"><a href="#hashMap-重写-hashCode-和-equals" class="headerlink" title="hashMap 重写 hashCode() 和 equals()"></a>hashMap 重写 hashCode() 和 equals()</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 【HashMap key类 重写hashCode()和equals()】 */</span></span><br><span class="line"><span class="hljs-comment">/*  hashCode()用来定位要存放的位置，equal()用来判断是否相等（有时候我们要的是逻辑上的相等）。</span></span><br><span class="line"><span class="hljs-comment">原则: </span></span><br><span class="line"><span class="hljs-comment">1.同一个对象（没有发生过修改）无论何时调用hashCode()得到的返回值必须一样。</span></span><br><span class="line"><span class="hljs-comment">    如果一个key对象在put的时候调用hashCode()决定了存放的位置，而在get的时候调用hashCode()得到了不一样的返回值，这个值映射到了一个和原来不一样的地方，那么肯定就找不到原来那个键值对了。</span></span><br><span class="line"><span class="hljs-comment">2.hashCode()的返回值相等的对象不一定相等，通过hashCode()和equals()必能唯一确定一个对象</span></span><br><span class="line"><span class="hljs-comment">    不相等的对象的hashCode()的结果可以相等。hashCode()在注意关注碰撞问题的时候，也要关注生成速度问题，完美hash不现实</span></span><br><span class="line"><span class="hljs-comment">3.一旦重写了equals()（重写equals的时候还要注意要满足自反性、对称性、传递性、一致性），就必须重写hashCode()。而且hashCode()的生成哈希值的依据应该是equals()中用来比较是否相等的字段。</span></span><br><span class="line"><span class="hljs-comment">    如果两个由equals()规定相等的对象生成的hashCode不等，对于hashMap来说，他们很可能分别映射到不同位置，没有调用equals()比较是否相等的机会，两个实际上相等的对象可能被插入不同位置，出现错误。其他一些基于哈希方法的集合类可能也会有这个问题</span></span><br><span class="line"><span class="hljs-comment"></span></span><br><span class="line"><span class="hljs-comment">方法：hashCode() 对所有对象的属性，都得到一个int散列值c，然后将变量的散列值依次 hash = hash*37 + c 合并。</span></span><br><span class="line"><span class="hljs-comment">    float          c = Float.floatToIntBits(f);</span></span><br><span class="line"><span class="hljs-comment">    double	      long l = Double.doubleToLongBits(f);       c = (int(l^(l&gt;&gt;&gt;32)))</span></span><br><span class="line"><span class="hljs-comment">    Object         c = object.hashCode();</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> result = <span class="hljs-number">17</span>;</span><br><span class="line">    result = <span class="hljs-number">37</span>*result+name.hashCode();</span><br><span class="line">    result = <span class="hljs-number">37</span>*result+age;</span><br><span class="line">    result = <span class="hljs-number">37</span>*result+(sex ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>);</span><br><span class="line">    <span class="hljs-keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-meta">@Override</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> obj <span class="hljs-keyword">instanceof</span> Student &amp;&amp;</span><br><span class="line">        <span class="hljs-keyword">this</span>.name.equals(((Student)obj).name) &amp;&amp;</span><br><span class="line">        <span class="hljs-keyword">this</span>.age ==  ((Student)obj).age &amp;&amp;</span><br><span class="line">        <span class="hljs-keyword">this</span>.sex == ((Student)obj).sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">// 当前，java的IDE一般都可以直接 Source-&gt;Generate hashCode and equals() 不用手写</span></span><br></pre></td></tr></table></figure><h4 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">SortedMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap(); </span><br><span class="line">SortedMap&lt;Integer, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap&lt;&gt;((o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> o1.compareTo(o2);</span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 较Map新增API */</span></span><br><span class="line"><span class="hljs-function">K                         <span class="hljs-title">firstKey</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function">SortedMap&lt;K, V&gt;           <span class="hljs-title">headMap</span><span class="hljs-params">(K endKey)</span></span></span><br><span class="line"><span class="hljs-function">K                         <span class="hljs-title">lastKey</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function">SortedMap&lt;K, V&gt;           <span class="hljs-title">subMap</span><span class="hljs-params">(K startKey, K endKey)</span></span></span><br><span class="line"><span class="hljs-function">SortedMap&lt;K, V&gt;           <span class="hljs-title">tailMap</span><span class="hljs-params">(K startKey)</span></span></span><br></pre></td></tr></table></figure><h4 id="NavigableMap"><a href="#NavigableMap" class="headerlink" title="NavigableMap"></a>NavigableMap</h4><p>继承于SortedMap的接口。一个可导航的键-值对集合，具有了为给定搜索目标报告最接近匹配项的导航方法。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">NavigableMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> TreeMap(); </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 提供操作&lt;键,值&gt;对的方法, 不存在则返回null */</span></span><br><span class="line"><span class="hljs-function">Entry&lt;K, V&gt;           <span class="hljs-title">lowerEntry</span><span class="hljs-params">(key)</span>   <span class="hljs-comment">// 返回小于key所对应的键值对的第一个键值对</span></span></span><br><span class="line"><span class="hljs-function">Entry&lt;K, V&gt;           <span class="hljs-title">floorEntry</span><span class="hljs-params">(key)</span>   <span class="hljs-comment">// 返回小于等于key所对应的键值对的第一个键值对</span></span></span><br><span class="line"><span class="hljs-function">Entry&lt;K, V&gt;           <span class="hljs-title">ceilingEntry</span><span class="hljs-params">(key)</span> <span class="hljs-comment">// 返回大于等于key所对应的键值对的第一个键值对</span></span></span><br><span class="line"><span class="hljs-function">Entry&lt;K, V&gt;           <span class="hljs-title">higherEntry</span><span class="hljs-params">(key)</span>  <span class="hljs-comment">// 返回大于key所对应的键值对的第一个键值对</span></span></span><br><span class="line"><span class="hljs-function"></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-title">firstEntry</span><span class="hljs-params">()</span></span>;                           <span class="hljs-comment">// 返回首个键值对 </span></span><br><span class="line">pollFirstEntry();                       <span class="hljs-comment">// 弹出首个键值对 </span></span><br><span class="line">lastEntry();                            <span class="hljs-comment">// 返回末个键值对 </span></span><br><span class="line">pollLastEntry();                        <span class="hljs-comment">// 弹出末个键值对 </span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 提供操作键的方法 */</span></span><br><span class="line"><span class="hljs-function">K           <span class="hljs-title">lowerKey</span><span class="hljs-params">(key)</span>   <span class="hljs-comment">// 返回小于key的第一个键</span></span></span><br><span class="line"><span class="hljs-function">K           <span class="hljs-title">floorKey</span><span class="hljs-params">(key)</span>   <span class="hljs-comment">// 返回小于等于key的第一个键</span></span></span><br><span class="line"><span class="hljs-function">K           <span class="hljs-title">ceilingKey</span><span class="hljs-params">(key)</span> <span class="hljs-comment">// 返回大于等于key的第一个键</span></span></span><br><span class="line"><span class="hljs-function">K           <span class="hljs-title">higherKey</span><span class="hljs-params">(key)</span>  <span class="hljs-comment">// 返回大于key的第一个键</span></span></span><br><span class="line"><span class="hljs-function"></span></span><br><span class="line"><span class="hljs-function"><span class="hljs-comment">/* 获取键集 */</span></span></span><br><span class="line"><span class="hljs-function">NavigableSet&lt;String&gt; subset </span>= map.navigableKeySet(); <span class="hljs-comment">// 获取正序的键集</span></span><br><span class="line">NavigableSet&lt;String&gt; subset = map.descendingKeySet();<span class="hljs-comment">// 获取反序的键集</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 获取当前map的逆序视图 */</span></span><br><span class="line">NavigableMap&lt;String, Integer&gt; subset = map.descendingMap();</span><br></pre></td></tr></table></figure><h3 id="Set-容器"><a href="#Set-容器" class="headerlink" title="Set 容器"></a>Set 容器</h3><h4 id="架构-1"><a href="#架构-1" class="headerlink" title="架构"></a>架构</h4><p>Map 同样继承于 Collection 接口，但在本文将其单独拿出来讲述。Set的实现类都是基于Map来实现</p><p><img src="1567231051893.png" alt="1567231051893"></p><p>接口：</p><ol><li>Set 是继承于Collection的接口。它是一个不允许有重复元素的集合。</li><li>AbstractSet 是一个抽象类，它继承于AbstractCollection，AbstractCollection实现了 Set中的绝大部分函数，其它Set的实现类可以通过继承AbstractSet 来减少重复编码。</li><li>SortedSet、NavigableSet 可以类比 Map</li></ol><p>实现类：</p><ol><li><strong>TreeSet</strong>，依赖于 TreeMap，底层同样是红黑树。元素有序。</li><li><strong>HashSet</strong>，依赖于 HashMap，底层是拉链法的哈希。元素无序。</li></ol><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;(); <span class="hljs-comment">// 底层是红黑树</span></span><br><span class="line">Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(); <span class="hljs-comment">// 底层是哈希</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 赋值 */</span></span><br><span class="line">set.add(<span class="hljs-number">123</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 删除 */</span></span><br><span class="line">set.remove(<span class="hljs-number">123</span>);</span><br><span class="line">set.clear();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 访问 */</span></span><br><span class="line">set.contains(<span class="hljs-number">123</span>);</span><br><span class="line"><span class="hljs-keyword">for</span>(Integer x : set) &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br><span class="line">set.forEach(x -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 其他 */</span></span><br><span class="line">set.size();</span><br><span class="line">set.isEmpty();</span><br><span class="line">Object[] objects = set.toArray(); <span class="hljs-comment">// 转成Object数组</span></span><br><span class="line"><span class="hljs-comment">// 以下为转成数组的demo，注意 Integer[] as = (Integer[]) a.toArray(); 的用法是错误的</span></span><br><span class="line">Integer list[] = set.toArray(<span class="hljs-keyword">new</span> Integer[set.size()]); </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 输出 */</span></span><br><span class="line">System.out.println(set);</span><br></pre></td></tr></table></figure><h4 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">SortedSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();    <span class="hljs-comment">// 从小到大排序</span></span><br><span class="line">SortedSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;((o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> o2 - o1;</span><br><span class="line">&#125;);  <span class="hljs-comment">// 从大到小排序</span></span><br><span class="line">SortedSet&lt;String&gt; set2 = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();    <span class="hljs-comment">// 从小到大排序</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 较Set新增API */</span></span><br><span class="line">set.first();                <span class="hljs-comment">// 最低元素</span></span><br><span class="line">set.last();                 <span class="hljs-comment">// 最高元素</span></span><br><span class="line">set.tailSet(<span class="hljs-number">123</span>);           <span class="hljs-comment">// 返回set的部分视图，其元素大于等于123</span></span><br><span class="line">set.subSet(<span class="hljs-number">123</span>, <span class="hljs-number">126</span>);       <span class="hljs-comment">// 返回set的部分视图，其元素[123,126)间</span></span><br><span class="line">set2.subSet(low, high+<span class="hljs-string">"\0"</span>);<span class="hljs-comment">// 返回set2的部分视图，其元素[low,high]间</span></span><br><span class="line">set2.subSet(low+<span class="hljs-string">"\0"</span>, high);<span class="hljs-comment">// 返回set2的部分视图，其元素(low,high)间</span></span><br></pre></td></tr></table></figure><h4 id="NavigableSet"><a href="#NavigableSet" class="headerlink" title="NavigableSet"></a>NavigableSet</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 声明 */</span></span><br><span class="line">NavigableSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();    <span class="hljs-comment">// 从小到大排序</span></span><br><span class="line">NavigableSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;((o1, o2) -&gt; &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> o2 - o1;</span><br><span class="line">&#125;);  <span class="hljs-comment">// 从大到小排序</span></span><br><span class="line">NavigableSet&lt;String&gt; set2 = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();    <span class="hljs-comment">// 从小到大排序</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 较NavigableSet新增API */</span></span><br><span class="line">set.ceiling(<span class="hljs-number">123</span>);             <span class="hljs-comment">// 返回大于等于123的第一个元素，不存在返回null</span></span><br><span class="line">set.floor(<span class="hljs-number">123</span>);               <span class="hljs-comment">// 返回小于等于123的第一个元素，不存在返回null</span></span><br><span class="line">set.lower(<span class="hljs-number">123</span>);               <span class="hljs-comment">// 返回小于123的第一个元素，不存在返回null</span></span><br><span class="line">set.higher(<span class="hljs-number">123</span>);              <span class="hljs-comment">// 返回小于123的第一个元素，不存在返回null</span></span><br><span class="line">set.headSet(<span class="hljs-number">123</span>);             <span class="hljs-comment">// 返回set的部分视图，其元素小于123</span></span><br><span class="line">set.headSet(<span class="hljs-number">123</span>, <span class="hljs-keyword">true</span>);       <span class="hljs-comment">// 返回set的部分视图，其元素小于等于123</span></span><br><span class="line">set.pollFirst();              <span class="hljs-comment">// 获取并移除最低元素，set为空返回null</span></span><br><span class="line">set.pollLast();               <span class="hljs-comment">// 获取并移除最高元素，set为空返回null</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 其他 */</span></span><br><span class="line">descendingIterator();         <span class="hljs-comment">// 逆序迭代器</span></span><br><span class="line">descendingSet();              <span class="hljs-comment">// 逆序视图</span></span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>排序大多是针对数组、容器类对象施展的，同样依靠Arrays、Collections，单独提取出来总结。</p><ul><li>Arrays.sort() 对[原生数组]操作</li><li>Collections.sort() 对[容器类对象]操作</li></ul><h4 id="实现Comparable接口类的排序"><a href="#实现Comparable接口类的排序" class="headerlink" title="实现Comparable接口类的排序"></a>实现Comparable接口类的排序</h4><p>可比较接口，实现后类的实例可以直接用compareTo比较。</p><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 原生数组 */</span></span><br><span class="line">Student[] ss = <span class="hljs-keyword">new</span> Student[<span class="hljs-number">10</span>];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)  ss[i] = <span class="hljs-keyword">new</span> Student(i);</span><br><span class="line">Arrays.sort(ss); </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 容器类对象 */</span></span><br><span class="line">List&lt;Student&gt; ss = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) ss.add(<span class="hljs-keyword">new</span> Student(i));</span><br><span class="line">Collections.sort(ss);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* student类的定义 */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Student</span>&gt; // 要求实现<span class="hljs-title">Comparable</span></span></span><br><span class="line"><span class="hljs-class"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Student o)</span> </span>&#123; <span class="hljs-keyword">return</span> age-o.age; &#125; <span class="hljs-comment">// 年龄升序</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123; <span class="hljs-keyword">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="借由Comparator接口类的排序"><a href="#借由Comparator接口类的排序" class="headerlink" title="借由Comparator接口类的排序"></a>借由Comparator接口类的排序</h4><p>比较器类，帮助对象进行比较，作排序传参。</p><figure class="highlight c++ hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 原生数组 */</span></span><br><span class="line">Student[] ss = <span class="hljs-keyword">new</span> Student[<span class="hljs-number">10</span>];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)  ss[i] = <span class="hljs-keyword">new</span> Student(i);</span><br><span class="line">Arrays.sort(ss, <span class="hljs-keyword">new</span> StudentCompartor()); </span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 容器类对象 */</span></span><br><span class="line">List&lt;Student&gt; ss = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) ss.add(<span class="hljs-keyword">new</span> Student(i));</span><br><span class="line">Collections.sort(ss, <span class="hljs-keyword">new</span> StudentCompartor());</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* student类的定义 */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    <span class="hljs-keyword">int</span> age = <span class="hljs-number">0</span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age)</span> </span>&#123; <span class="hljs-keyword">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* studentCompartor类的定义 */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentCompartor</span> <span class="hljs-title">implements</span> <span class="hljs-title">Comparator</span>&lt;Student&gt;</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">    @Override</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Student o1, Student o2)</span> </span>&#123; <span class="hljs-keyword">return</span> o1.age-o2.age; &#125; <span class="hljs-comment">// 年龄升序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类实现的排序"><a href="#匿名内部类实现的排序" class="headerlink" title="匿名内部类实现的排序"></a>匿名内部类实现的排序</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 原生数组 */</span></span><br><span class="line">P[] ps = <span class="hljs-keyword">new</span> P[<span class="hljs-number">10</span>];</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)  ps[i] = <span class="hljs-keyword">new</span> P(i);</span><br><span class="line">Arrays.sort(ps, <span class="hljs-keyword">new</span> Comparator&lt;P&gt;() &#123; <span class="hljs-comment">// 第1关键字升序第2关键字降序</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(P o1, P o2)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(o1.a != o2.a) <span class="hljs-keyword">return</span> o1.a-o2.a;</span><br><span class="line">        <span class="hljs-keyword">return</span> o2.b-o1.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 容器类对象 */</span></span><br><span class="line">List&lt;P&gt; ps = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)  ps.add(<span class="hljs-keyword">new</span> P(i,<span class="hljs-number">10</span>-i));</span><br><span class="line">Collections.sort(ps, <span class="hljs-keyword">new</span> Comparator&lt;P&gt;() &#123; <span class="hljs-comment">// 第1关键字升序第2关键字降序</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(P o1, P o2)</span></span></span><br><span class="line"><span class="hljs-function">    </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span>(o1.a != o2.a) <span class="hljs-keyword">return</span> o1.a-o2.a;</span><br><span class="line">        <span class="hljs-keyword">return</span> o2.b-o1.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* P类的定义 */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span></span></span><br><span class="line"><span class="hljs-class"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> a, b;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">this</span>.a = a;<span class="hljs-keyword">this</span>.b = b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><p>java8 新增了对Lambda表达式的支持。</p><h4 id="简化多关键字排序"><a href="#简化多关键字排序" class="headerlink" title="简化多关键字排序"></a>简化多关键字排序</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 原生数组 */</span></span><br><span class="line">Arrays.sort(ps, (o1, o2)-&gt;(o1.a!=o2.a ? o1.a-o2.a : o2.b-o2.a));</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* 容器类对象 */</span></span><br><span class="line">Collections.sort(ps, (o1, o2)-&gt;(o1.a!=o2.a ? o1.a-o2.a : o2.b-o2.a));</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">/* P类的定义 */</span></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">P</span></span></span><br><span class="line"><span class="hljs-class"></span>&#123;</span><br><span class="line">    <span class="hljs-keyword">int</span> a, b;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123; <span class="hljs-keyword">this</span>.a = a;<span class="hljs-keyword">this</span>.b = b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">replace(oldS, newS); // 非正则表达式的全部替换</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>特别字符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>$</td><td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或‘\r’。要匹配 $ 字符本身，请使用 $。</td></tr><tr><td>( )</td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。</td></tr><tr><td>*</td><td>匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。</td></tr><tr><td>+</td><td>匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。</td></tr><tr><td>.</td><td>匹配除换行符 \n之外的任何单字符。要匹配 .，请使用 \。</td></tr><tr><td>[ ]</td><td>标记一个中括号表达式的开始。要匹配 [，请使用 [。</td></tr><tr><td>?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。</td></tr><tr><td>\</td><td>将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(”。</td></tr><tr><td>^</td><td>匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。</td></tr><tr><td>{ }</td><td>标记限定符表达式的开始。要匹配 {，请使用 {。</td></tr><tr><td>|</td><td>指明两项之间的一个选择。要匹配 |，请使用 |。</td></tr></tbody></table><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;单引号。要匹配’，请使用\&apos;。      &quot;双引号。要匹配“，请使用\&quot;。</span><br></pre></td></tr></table></figure><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><h3 id="Regex"><a href="#Regex" class="headerlink" title="Regex"></a>Regex</h3><p>java.util.regex.*中有正则表达式的方法，除此之外String自带方法也支持正则表达式。</p><p>正则表达式主要关注：匹配、替换、提取、切割。</p><h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 注意在java里匹配\需要输入\\\\，因为\\是java语言本身对\的转义，而到了正则引擎还会经过一层转义。 也可直接使用下面转义</span></span><br><span class="line"></span><br><span class="line">Matcher.quoteReplacement(<span class="hljs-string">"\\"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">static</span> String <span class="hljs-title">escapeExprSpecialWord</span><span class="hljs-params">(String keyword)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">final</span> String[] fbsArr = &#123; <span class="hljs-string">"\\"</span>, <span class="hljs-string">"$"</span>, <span class="hljs-string">"("</span>, <span class="hljs-string">")"</span>, <span class="hljs-string">"*"</span>, <span class="hljs-string">"+"</span>, <span class="hljs-string">"."</span>, <span class="hljs-string">"["</span>, <span class="hljs-string">"]"</span>, <span class="hljs-string">"?"</span>, <span class="hljs-string">"^"</span>, <span class="hljs-string">"&#123;"</span>, <span class="hljs-string">"&#125;"</span>, <span class="hljs-string">"|"</span> &#125;;</span><br><span class="line">    <span class="hljs-keyword">for</span> (String key : fbsArr) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (keyword.contains(key)) &#123;</span><br><span class="line">            keyword = keyword.replace(key, <span class="hljs-string">"\\"</span> + key);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> keyword;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="hljs-string">"189893"</span>;</span><br><span class="line"><span class="hljs-keyword">if</span>(s.matches(<span class="hljs-string">"1.*?3"</span>)) System.out.println(<span class="hljs-string">"yes"</span>);</span><br></pre></td></tr></table></figure><h4 id="切割"><a href="#切割" class="headerlink" title="切割"></a>切割</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="hljs-string">"ads1dasd2dasd3dasd4as"</span>;</span><br><span class="line">String[] ss = s.split(<span class="hljs-string">"[0-9]"</span>);</span><br></pre></td></tr></table></figure><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="hljs-string">"&lt;html class=123&gt; &lt;a href=2333&gt;"</span>;</span><br><span class="line">String ss = s.replaceAll(<span class="hljs-string">"&lt;.*? ([^&gt;]*)&gt;"</span>, <span class="hljs-string">"&lt;div $1&gt;"</span>); <span class="hljs-comment">// 将标签都换为div</span></span><br></pre></td></tr></table></figure><h4 id="提取"><a href="#提取" class="headerlink" title="提取"></a>提取</h4><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">String testStr = <span class="hljs-string">"Java is one of my favorite programming language!"</span>;</span><br><span class="line">Pattern re = Pattern.compile(<span class="hljs-string">"[a-zA-Z]+"</span>);</span><br><span class="line">Matcher m = re.matcher(testStr);</span><br><span class="line"><span class="hljs-keyword">while</span>(m.find())</span><br><span class="line">    System.out.println(<span class="hljs-string">"testStr["</span>+m.start()+<span class="hljs-string">", "</span>+m.end()+<span class="hljs-string">"]: "</span>+m.group());</span><br><span class="line"><span class="hljs-comment">// 输出各个单词</span></span><br><span class="line"></span><br><span class="line">String s = <span class="hljs-string">"&lt;html class=123&gt; &lt;a href=2333&gt; &lt;div sss=asd&gt;"</span>;</span><br><span class="line">Pattern re = Pattern.compile(<span class="hljs-string">"&lt;.*? [^&gt;]*=([^&gt;]*)&gt;"</span>);</span><br><span class="line">Matcher m = re.matcher(s);</span><br><span class="line"><span class="hljs-keyword">while</span>(m.find())</span><br><span class="line">&#123;</span><br><span class="line">    System.out.println(<span class="hljs-string">"匹配串："</span> + m.group(<span class="hljs-number">0</span>));</span><br><span class="line">    System.out.print(<span class="hljs-string">"匹配部分："</span>);</span><br><span class="line">    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>;i&lt;=m.groupCount();i++)</span><br><span class="line">        System.out.print(m.group(i) + <span class="hljs-string">" "</span>);</span><br><span class="line">    System.out.println(<span class="hljs-string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-comment">/* 输出标签参数内容：</span></span><br><span class="line"><span class="hljs-comment">匹配串：&lt;html class=123&gt;</span></span><br><span class="line"><span class="hljs-comment">匹配部分：123</span></span><br><span class="line"><span class="hljs-comment">匹配串：&lt;a href=2333&gt;</span></span><br><span class="line"><span class="hljs-comment">匹配部分：2333</span></span><br><span class="line"><span class="hljs-comment">匹配串：&lt;div sss=asd&gt;</span></span><br><span class="line"><span class="hljs-comment">匹配部分：asd</span></span><br><span class="line"><span class="hljs-comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Eclipse使用"><a href="#Eclipse使用" class="headerlink" title="Eclipse使用"></a>Eclipse使用</h3><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0.【主题更改】：</span><br><span class="line">    Window-&gt;Preferences-&gt;General-&gt;Appearance</span><br><span class="line">1.【代码提示功能强化】：</span><br><span class="line">    Window-&gt;Preferences-&gt;Java-&gt;Editor-&gt;Content Assist-&gt;[Auto Activation].[Auto activation triggers for Java]，把&quot;.abcd...xyz&quot;全按上，意思是是按哪些键自动触发代码提示功能。</span><br><span class="line">2.【代码提示功能之防空格防等号补全】：</span><br><span class="line">    Window-&gt;Preferences-&gt;Java-&gt;Editor-&gt;Content Assist-&gt;[Disable insertion triggers except&apos;Enter&apos;]√</span><br><span class="line">3.【字体大小】</span><br><span class="line">    Ctrl+加号/减号</span><br></pre></td></tr></table></figure></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="https://zhangt.top/ACM/ACMLife-0_2-Java-Summarize/">ACMLife-0_2-Java总结</a></li><li><strong>本文作者：</strong><a href="https://zhangt.top">ZhangT</a></li><li><strong>本文链接：</strong><a href="https://zhangt.top/ACM/ACMLife-0_2-Java-Summarize/">https://zhangt.top/ACM/ACMLife-0_2-Java-Summarize/</a></li><li><strong>发布时间：</strong>2019-01-01</li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><hr style="height:1px;margin:1rem 0"><div class="level is-size-7 is-uppercase"><div class="level-start"><div class="level-item"><i class="fas fa-tags has-text-grey"></i>&nbsp; <a class="has-link-grey -link" href="/tags/ACM/">ACM</a>,&nbsp;<a class="has-link-grey -link" href="/tags/Java/">Java</a>,&nbsp;<a class="has-link-grey -link" href="/tags/Language/">Language</a></div></div></div></div></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？投喂一下吧！ヾ(●´∀｀●)</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i> </span><span>支付宝</span><div class="qrcode"><img src="/images/alipay.jpg" alt="支付宝"></div></a></div></div></div><div class="card card-transparent"><div class="level post-navigation is-flex-wrap is-mobile"><div class="level-start"><a class="level level-item has-link-grey article-nav-prev" href="/CS/Computer-Network-Study-Notes/"><i class="level-item fas fa-chevron-left"></i> <span class="level-item">计算机网络-学习笔记</span></a></div><div class="level-end"><a class="level level-item has-link-grey article-nav-next" href="/ACM/ACMLife-0_1-Cpp-Summarize/"><span class="level-item">ACMLife-0_1-cpp总结</span> <i class="level-item fas fa-chevron-right"></i></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5 has-text-weight-normal">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.4.1/dist/gitalk.min.js"></script><script>var gitalk=new Gitalk({clientID:"91f36240e98756fc091e",clientSecret:"20de2f4dadd54bc04ad8db6c1090fb00a9477ac4",id:"6e4d112bd1164b0a19ea50132eaff129",repo:"zhangt2333.github.io",owner:"zhangt2333",admin:"zhangt2333",createIssueManually:!1,distractionFreeMode:!1});gitalk.render("comment-container")</script></div></div></div><div class="column is-4-tablet is-4-desktop is-3-widescreen has-order-1 column-left"><div class="card widget"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered"><div><img class="image is-96x96 has-mb-6" src="/images/avatar.png" alt="Zhang T"><p class="is-size-4 is-block">Zhang T</p><p class="is-size-6 is-block">感受我的感受</p><p class="is-size-6 is-flex is-flex-center has-text-grey"><i class="fas fa-map-marker-alt has-mr-7"></i> <span>Nanjing &lt;- Qingdao, China</span></p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><div class="level-item has-text-centered is-marginless"><a href="/archives/"><p class="heading">文章</p><p class="title has-text-weight-normal">19</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/categories/"><p class="heading">分类</p><p class="title has-text-weight-normal">5</p></a></div><div class="level-item has-text-centered is-marginless"><a href="/tags/"><p class="heading">标签</p><p class="title has-text-weight-normal">21</p></a></div></nav><div class="level"><a class="level-item button is-link is-rounded" href="https://github.com/zhangt2333" target="_blank"><i class="fab fa-github"></i>&nbsp;&nbsp;关注我</a></div></div></div><div class="card widget column-left is-sticky" id="toc"><div class="card-content"><div class="menu" style="max-height:750px;overflow:auto"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex" href="#序言"><span class="has-mr-6">1</span> <span>序言</span></a></li><li><a class="is-flex" href="#IO"><span class="has-mr-6">2</span> <span>IO</span></a><ul class="menu-list"><li><a class="is-flex" href="#标准输入输出"><span class="has-mr-6">2.1</span> <span>标准输入输出</span></a></li><li><a class="is-flex" href="#格式化输出"><span class="has-mr-6">2.2</span> <span>格式化输出</span></a></li><li><a class="is-flex" href="#快速IO"><span class="has-mr-6">2.3</span> <span>快速IO</span></a></li><li><a class="is-flex" href="#重定向IO"><span class="has-mr-6">2.4</span> <span>重定向IO</span></a></li></ul></li><li><a class="is-flex" href="#Integer"><span class="has-mr-6">3</span> <span>Integer</span></a><ul class="menu-list"><li><a class="is-flex" href="#进制相关"><span class="has-mr-6">3.1</span> <span>进制相关</span></a></li><li><a class="is-flex" href="#类型转换"><span class="has-mr-6">3.2</span> <span>类型转换</span></a></li></ul></li><li><a class="is-flex" href="#Character"><span class="has-mr-6">4</span> <span>Character</span></a></li><li><a class="is-flex" href="#Math"><span class="has-mr-6">5</span> <span>Math</span></a></li><li><a class="is-flex" href="#Random"><span class="has-mr-6">6</span> <span>Random</span></a></li><li><a class="is-flex" href="#BigInteger"><span class="has-mr-6">7</span> <span>BigInteger</span></a></li><li><a class="is-flex" href="#BigDecimal"><span class="has-mr-6">8</span> <span>BigDecimal</span></a></li><li><a class="is-flex" href="#Bitset"><span class="has-mr-6">9</span> <span>Bitset</span></a></li><li><a class="is-flex" href="#Arrays"><span class="has-mr-6">10</span> <span>Arrays</span></a></li><li><a class="is-flex" href="#Collections"><span class="has-mr-6">11</span> <span>Collections</span></a></li><li><a class="is-flex" href="#Java-容器架构"><span class="has-mr-6">12</span> <span>Java 容器架构</span></a></li><li><a class="is-flex" href="#Collection-容器"><span class="has-mr-6">13</span> <span>Collection 容器</span></a><ul class="menu-list"><li><a class="is-flex" href="#Iterator"><span class="has-mr-6">13.1</span> <span>Iterator</span></a></li><li><a class="is-flex" href="#ArrayList"><span class="has-mr-6">13.2</span> <span>ArrayList</span></a></li><li><a class="is-flex" href="#LinkedList"><span class="has-mr-6">13.3</span> <span>LinkedList</span></a></li><li><a class="is-flex" href="#List"><span class="has-mr-6">13.4</span> <span>List</span></a></li><li><a class="is-flex" href="#Queue-带-PriorityQueue"><span class="has-mr-6">13.5</span> <span>Queue (带 PriorityQueue)</span></a></li><li><a class="is-flex" href="#Deque-作-Stack-用"><span class="has-mr-6">13.6</span> <span>Deque (作 Stack 用)</span></a></li></ul></li><li><a class="is-flex" href="#Map-容器"><span class="has-mr-6">14</span> <span>Map 容器</span></a><ul class="menu-list"><li><a class="is-flex" href="#架构"><span class="has-mr-6">14.1</span> <span>架构</span></a></li><li><a class="is-flex" href="#Map-Entry"><span class="has-mr-6">14.2</span> <span>Map.Entry</span></a></li><li><a class="is-flex" href="#Map"><span class="has-mr-6">14.3</span> <span>Map</span></a></li><li><a class="is-flex" href="#hashMap-重写-hashCode-和-equals"><span class="has-mr-6">14.4</span> <span>hashMap 重写 hashCode() 和 equals()</span></a></li><li><a class="is-flex" href="#SortedMap"><span class="has-mr-6">14.5</span> <span>SortedMap</span></a></li><li><a class="is-flex" href="#NavigableMap"><span class="has-mr-6">14.6</span> <span>NavigableMap</span></a></li></ul></li><li><a class="is-flex" href="#Set-容器"><span class="has-mr-6">15</span> <span>Set 容器</span></a><ul class="menu-list"><li><a class="is-flex" href="#架构-1"><span class="has-mr-6">15.1</span> <span>架构</span></a></li><li><a class="is-flex" href="#Set"><span class="has-mr-6">15.2</span> <span>Set</span></a></li><li><a class="is-flex" href="#SortedSet"><span class="has-mr-6">15.3</span> <span>SortedSet</span></a></li><li><a class="is-flex" href="#NavigableSet"><span class="has-mr-6">15.4</span> <span>NavigableSet</span></a></li></ul></li><li><a class="is-flex" href="#排序"><span class="has-mr-6">16</span> <span>排序</span></a><ul class="menu-list"><li><a class="is-flex" href="#实现Comparable接口类的排序"><span class="has-mr-6">16.1</span> <span>实现Comparable接口类的排序</span></a></li><li><a class="is-flex" href="#借由Comparator接口类的排序"><span class="has-mr-6">16.2</span> <span>借由Comparator接口类的排序</span></a></li><li><a class="is-flex" href="#匿名内部类实现的排序"><span class="has-mr-6">16.3</span> <span>匿名内部类实现的排序</span></a></li></ul></li><li><a class="is-flex" href="#Lambda"><span class="has-mr-6">17</span> <span>Lambda</span></a><ul class="menu-list"><li><a class="is-flex" href="#简化多关键字排序"><span class="has-mr-6">17.1</span> <span>简化多关键字排序</span></a></li></ul></li><li><a class="is-flex" href="#String"><span class="has-mr-6">18</span> <span>String</span></a></li><li><a class="is-flex" href="#StringBuilder"><span class="has-mr-6">19</span> <span>StringBuilder</span></a></li><li><a class="is-flex" href="#Regex"><span class="has-mr-6">20</span> <span>Regex</span></a><ul class="menu-list"><li><a class="is-flex" href="#转义"><span class="has-mr-6">20.1</span> <span>转义</span></a></li><li><a class="is-flex" href="#匹配"><span class="has-mr-6">20.2</span> <span>匹配</span></a></li><li><a class="is-flex" href="#切割"><span class="has-mr-6">20.3</span> <span>切割</span></a></li><li><a class="is-flex" href="#替换"><span class="has-mr-6">20.4</span> <span>替换</span></a></li><li><a class="is-flex" href="#提取"><span class="has-mr-6">20.5</span> <span>提取</span></a></li></ul></li><li><a class="is-flex" href="#Eclipse使用"><span class="has-mr-6">21</span> <span>Eclipse使用</span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start has-text-centered-mobile"><a class="footer-logo is-block has-mb-6" href="/">TTTT&#39;s Blog</a><p class="is-size-7">&copy; 2021 ZhangT&nbsp; Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle"><p class="control"><a class="button is-white is-large" target="_blank" title="GitHub" href="https://github.com/zhangt2333"><i class="fab fa-github"></i></a></p><p class="control"><a class="button is-white is-large" target="_blank" title="E-mail" href="mailto:zhangt2333@gmail.com"><i class="fa fa-envelope-open"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("zh-CN")</script><script>var IcarusThemeSettings={article:{highlight:{clipboard:!0,fold:"unfolded"}}}</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="/js/gallery.js" defer></script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update my browser now</a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>document.addEventListener("DOMContentLoaded",function(){outdatedBrowser({bgColor:"#f25648",color:"#ffffff",lowerThan:"flex"})})</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><script>document.addEventListener("DOMContentLoaded",function(){MathJax.Hub.Config({"HTML-CSS":{matchFontHeight:!1},SVG:{matchFontHeight:!1},CommonHTML:{matchFontHeight:!1},skipTags:["script","noscript","style","textarea","pre","code"],processEscapes:!0,tex2jax:{inlineMath:[["$","$"]]}})})</script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back-to-top.js" defer></script><script src="/js/main.js" defer></script><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..."> <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>window.INSIGHT_CONFIG={TRANSLATION:{POSTS:"文章",PAGES:"页面",CATEGORIES:"分类",TAGS:"标签",UNTITLED:"(无标题)"},CONTENT_URL:"/content.json"}</script><script src="/js/insight.js" defer></script><link rel="stylesheet" href="/css/search.css"><link rel="stylesheet" href="/css/insight.css"><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>